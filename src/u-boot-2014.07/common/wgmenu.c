#include <common.h>
#ifndef DO_DEPS_ONLY
#include "generated/version_autogenerated.h"
#include "generated/timestamp_autogenerated.h"
#endif
#include <wgmenu.h>

#define WG_VERSION_STRING ("WatchGuard " U_BOOT_VERSION " - " U_BOOT_DATE " " U_BOOT_TIME)
#define ANSI_CLEAR		"\e[2J"
#define ANSI_REVERSE		"\e[7m"
#define	ANSI_NORMAL		"\e[m"
#define ANSI_GOTOYX		"\e[%d;%dH"

#define SCREEN_HIGH		24
#define SCREEN_WIDTH		80
#define MAX_MENU_ITEMS		10

#define FIRST_LINE_Y		2
#define FIRST_LINE_X_FUN(len)	((SCREEN_WIDTH - len)/2)
#define FIRST_LINE_X		FIRST_LINE_X_FUN(58)

#define TABLE_START_Y		4
#define TABLE_START_X		2 
#define TABLE_LENGHT		(SCREEN_WIDTH - 6)
#define TABLE_HIGH		(SCREEN_HIGH/2)

#define	TOP_ROW			(TABLE_START_X + 1)
#define	MENU_0_ROW		(TABLE_START_Y + 1)

struct __wgmenu_option {
	const char *label;		// WG:BH - We really only use the label...
	void (*fn)(void *user);		// but we could add functionality to add dynamically generated menu items.
	void *user;			// <<< this one is the argument to fn.
};

static struct __wgmenu_option wg_options[MAX_MENU_ITEMS];
static int __wgmenu_max_width = TABLE_LENGHT - 4;
static int __wgmenu_num_options = 0;
static int __wgmenu_option_pos = 0;
static int __wgmenu_boot_menu = 1;

static void __wgmenu_print_option(const struct __wgmenu_option *opt, int reverse)
{
	int n = (opt - wg_options);
	char format[10] = {'\0'};

	printf(ANSI_GOTOYX, MENU_0_ROW+n, TABLE_START_X + 1);
	if (reverse) {
		printf(ANSI_REVERSE);
	}

	sprintf(format, "%%-%ds", __wgmenu_max_width);
	printf(format, opt->label);

	if (reverse) {
		printf(ANSI_NORMAL);
	}

	printf(ANSI_GOTOYX ,SCREEN_HIGH + 2 , 1); 
}

static void __wgmenu_show_bootmenu_table(void)
{
	int i = 0,j = 0 ;

	printf(ANSI_CLEAR ANSI_GOTOYX "%s", FIRST_LINE_Y,
			(int)FIRST_LINE_X_FUN((strlen(WG_VERSION_STRING))), WG_VERSION_STRING);

	for (i = 0 ; i < TABLE_LENGHT ; i++) {	//the above horizontal line
		printf(ANSI_GOTOYX "-", TABLE_START_Y, TABLE_START_X + i);
	}
	for (j = 0 ; j < TABLE_HIGH ; j++) {	//the left line
		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X);
	}
	for (j = 0 ; j < TABLE_HIGH ; j++) {	// the right line
		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X + TABLE_LENGHT);
	}
	for (i = 1 ; i < TABLE_LENGHT ; i++) {	//the below horizontal line
		printf(ANSI_GOTOYX "-", TABLE_START_Y + TABLE_HIGH, TABLE_START_X + i);
	}

	printf(ANSI_GOTOYX "+",TABLE_START_Y, TABLE_START_X);
	printf(ANSI_GOTOYX "+",TABLE_START_Y , TABLE_START_X + TABLE_LENGHT); 
	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X);
	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X + TABLE_LENGHT);

	printf(ANSI_GOTOYX "Use the ^ and v keys to select which entry is highlighted.",
			TABLE_START_Y + TABLE_HIGH + 2, 7);
	printf(ANSI_GOTOYX "Press enter to boot the selected OS.",
			TABLE_START_Y + TABLE_HIGH + 3, 7);

	printf(ANSI_GOTOYX , SCREEN_HIGH + 2, 1);
}

static void __wgmenu_show_bootmenu(void)
{
	const struct __wgmenu_option *opt = {NULL};

	__wgmenu_show_bootmenu_table();

	for (opt = wg_options; opt != (wg_options + __wgmenu_num_options); opt++) {
		__wgmenu_print_option(opt, opt == wg_options);
	}
}

static int __wgmenu_wg_display_menu(int key)
{
	static struct __wgmenu_option *opt = wg_options;

	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 0);

	switch (key) {
		case 65: //up
			if(__wgmenu_option_pos > 0)
				__wgmenu_option_pos--;
			break; 
		case 66: //down
			if(__wgmenu_option_pos < (__wgmenu_num_options - 1))
				__wgmenu_option_pos++;
			break; 
		case 13:
		default:
			break;
	}

	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 1);

	return opt - wg_options ;
}

int wgmenu_hook(int key)
{
	static const struct __wgmenu_option *opt = wg_options;
	int hooked = 0;

	if ((key == 65 || key == 66) && opt && __wgmenu_num_options) {
		hooked = 1;
		__wgmenu_wg_display_menu(key);
	}

	return hooked;
}


void wgmenu_add(const char *label, void (*fn)(void *user), void *user)
{
	int len;

	wg_options[__wgmenu_num_options].label = label;
	wg_options[__wgmenu_num_options].fn = fn;
	wg_options[__wgmenu_num_options].user = user;
	__wgmenu_num_options++;

	len = strlen(label);

	if (len > __wgmenu_max_width)
		__wgmenu_max_width = len;
}


void wgmenu_show(void)
{
	wgmenu_add("WatchGuard (SYSA)", NULL, NULL);
	wgmenu_add("WatchGuard (SYSB)", NULL, NULL);
	wgmenu_add("WatchGuard (SAFE MODE)", NULL, NULL);
	wgmenu_add("WatchGuard (SYSA BOOTDRIVE)", NULL, NULL);
	__wgmenu_show_bootmenu();
}

int wgmenu_selected(void)
{
	return __wgmenu_option_pos;
}

int wgmenu_inmenu(void)
{
	return __wgmenu_boot_menu;
}

void wgmenu_exit(void)
{
	__wgmenu_boot_menu = 0;
}
