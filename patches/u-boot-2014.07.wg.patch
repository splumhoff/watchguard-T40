WatchGuard patches to sources for u-boot-2014.07 as of
Mon May  9 14:06:59 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- u-boot-2014.07/Makefile.orig	2022-05-09 14:06:20.977240614 -0700
+++ u-boot-2014.07/Makefile	2022-05-09 14:06:22.589175416 -0700
@@ -940,15 +940,22 @@
 #concatenated with u-boot binary. It is need by PowerPC SoC having
 #internal SRAM <= 512KB.
 MKIMAGEFLAGS_u-boot-spl.pbl = -n $(srctree)/$(CONFIG_SYS_FSL_PBL_RCW:"%"=%) \
-		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage
+		-R $(srctree)/$(CONFIG_SYS_FSL_PBL_PBI:"%"=%) -T pblimage \
+		-A $(ARCH) -a $(CONFIG_SPL_TEXT_BASE)
 
 spl/u-boot-spl.pbl: spl/u-boot-spl.bin FORCE
 	$(call if_changed,mkimage)
 
+ifeq ($(ARCH),arm)
+UBOOT_BINLOAD := u-boot.img
+else
+UBOOT_BINLOAD := u-boot.bin
+endif
+
 OBJCOPYFLAGS_u-boot-with-spl-pbl.bin = -I binary -O binary --pad-to=$(CONFIG_SPL_PAD_TO) \
 			  --gap-fill=0xff
 
-u-boot-with-spl-pbl.bin: spl/u-boot-spl.pbl u-boot.bin FORCE
+u-boot-with-spl-pbl.bin: spl/u-boot-spl.pbl $(UBOOT_BINLOAD) FORCE
 	$(call if_changed,pad_cat)
 
 # PPC4xx needs the SPL at the end of the image, since the reset vector
--- u-boot-2014.07/common/usb_hub.c.orig	2022-05-09 14:06:21.945201463 -0700
+++ u-boot-2014.07/common/usb_hub.c	2022-05-09 14:06:23.617133838 -0700
@@ -86,12 +86,16 @@
 	int i;
 	struct usb_device *dev;
 	unsigned pgood_delay = hub->desc.bPwrOn2PwrGood * 2;
+
+#ifdef CONFIG_USB_XHCI
 	ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1);
 	unsigned short portstatus;
 	int ret;
+#endif
 
 	dev = hub->pusb_dev;
 
+#ifdef CONFIG_USB_XHCI
 	/*
 	 * Enable power to the ports:
 	 * Here we Power-cycle the ports: aka,
@@ -128,6 +132,7 @@
 			continue;
 		}
 	}
+#endif
 
 	for (i = 0; i < dev->maxchild; i++) {
 		usb_set_port_feature(dev, i + 1, USB_PORT_FEAT_POWER);
--- u-boot-2014.07/common/usb.c.orig	2022-05-09 14:06:21.945201463 -0700
+++ u-boot-2014.07/common/usb.c	2022-05-09 14:06:23.617133838 -0700
@@ -193,6 +193,9 @@
 	      request, requesttype, value, index, size);
 	dev->status = USB_ST_NOT_PROC; /*not yet processed */
 
+	if (dev->parent == NULL)
+		mdelay(195);
+
 	if (submit_control_msg(dev, pipe, data, size, setup_packet) < 0)
 		return -1;
 	if (timeout == 0)
--- u-boot-2014.07/common/cmd_mem.c.orig	2022-05-09 14:06:21.921202434 -0700
+++ u-boot-2014.07/common/cmd_mem.c	2022-05-09 14:06:23.565135941 -0700
@@ -18,6 +18,10 @@
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
+#ifdef CONFIG_LANNER_BURN
+#include <random.h>
+#include <rtc.h>
+#endif /* CONFIG_LANNER_BURN */
 #include <hash.h>
 #include <watchdog.h>
 #include <asm/io.h>
@@ -1075,6 +1079,764 @@
 
 	return ret;	/* not reached */
 }
+
+#ifdef CONFIG_LANNER_BURN
+vu_long        *addr_lanner, *start_lanner, *end_lanner;
+#define SPINSZ 0x800000
+void random_init(void)
+{
+	vu_long *addr;
+	int timeout =0;
+	addr = (vu_long *)0xffe3a01c;
+	*addr = 1;
+	addr = (vu_long *)0xffe3a02c;
+	while ( (*addr & 1) == 0 && timeout < 500)
+		timeout++;
+	if(timeout >= 499 )
+		printf("random initial failed\n");
+	addr = (vu_long *)0xffe3a014;
+	*addr = 0;
+}
+
+ulong random_freescale(void)
+{
+	ulong *addr;
+	ulong random_value;
+	addr = (ulong *)0xffe3a800;
+	random_value = *addr;
+	addr = (ulong *)0xffe3a804;
+	random_value = *addr;
+	return random_value;
+}
+
+
+int movinv1(int iter,ulong p1,ulong p2)
+{
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,i;
+	pat = p1;
+	pe = end_lanner;
+	p = start_lanner;
+	while (p < pe) {
+		WATCHDOG_RESET();
+		*p = pat;
+		p++;
+	}
+	for( i =0 ;i< iter;i++)
+	{
+		pat = p1;
+		pe = end_lanner;
+		p = start_lanner;
+		for (; p < pe; p++) {
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = p2;
+		}
+		pat = p1;
+		pat = p2;
+		pe = start_lanner;
+		p = end_lanner-1;
+		do {
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = p1;
+		} while (p-- > pe);
+	}       
+	return errs;
+}
+int movinv32(int iter, ulong p1, ulong lb, ulong hb, int sval, int off)
+{
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,done=0,k;
+	ulong p3 = sval << 31;
+	pat = p1;
+	k=off;
+	pe = start_lanner;
+	p = start_lanner;
+	done =0;
+	do{
+		/* Check for overflow */
+		if ((pe + SPINSZ) > pe) {
+			pe += SPINSZ;
+		} else {
+			pe = end_lanner;
+		}
+		if (pe >= end_lanner) {
+			pe = end_lanner;
+			done++;
+		}
+		if (p == pe) {
+			break;
+		}
+		while (p < pe) {
+			WATCHDOG_RESET();
+			*p = pat;
+			if (++k >= 32) {
+				pat = lb;
+				k = 0;
+			} else {
+				pat = pat << 1;
+				pat |= sval;
+			}
+			p++;
+		}
+	}while(!done);
+	pat = p1;
+	k=off;
+	pe = start_lanner;
+	p = start_lanner;
+	done =0;
+	do{
+		/* Check for overflow */
+		if ((pe + SPINSZ) > pe) {
+			pe += SPINSZ;
+		} else {
+			pe = end_lanner;
+		}
+		if (pe >= end_lanner) {
+			pe = end_lanner;
+			done++;
+		}
+		if (p == pe) {
+			break;
+		}
+		while(p <  pe){
+			WATCHDOG_RESET();
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = ~pat ;
+			if(++k >= 32)
+                       
+			{
+				pat = lb;
+				k=0;
+			}
+			else
+			{
+				pat = pat << 1;
+				pat |= sval;
+			}
+			p++;
+		}
+	}while(!done);
+/* MOVE 32 STEP 3 */
+	pat =lb;
+	if( 0!= ( k=(k-1) &31)) 
+	{
+		pat = (pat << k);
+		if(sval)
+			pat |= ((sval << k) - 1);
+	}
+	k++;
+/* MOVE 32 STEP 4 */
+	pe = start_lanner;
+	p = end_lanner-1;
+	done = 0;
+	do{
+		WATCHDOG_RESET();
+		readback = *p;
+		if (readback != ~pat) {
+			printf ("\nMem error @ 0x%08X: "
+				"found %08lX, expected %08lX\n",
+				(uint)p, readback, ~pat);
+			errs++;
+			if (ctrlc()) {
+				putc ('\n');
+				return errs;
+			}
+		}
+		*p = pat ;
+		if(--k <= 0)
+		{
+			pat = hb;
+			k=32;
+		}
+		else
+		{
+			pat = pat >> 1;
+			pat |= p3;
+		}
+	}while( p-- > pe);
+	return errs;
+}
+int modtst(int offset, int iter, ulong p1, ulong p2)
+{
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,i,k;
+/* MOVE 32 STEP 1 */
+	pat = p1;
+	pe = end_lanner;
+	p = start_lanner + offset;
+	for (; p < pe; p += 20) {
+		*p = pat;
+	}
+	for( i =0; i < iter ;i++)
+	{
+		pat = p2;
+		pe = end_lanner;
+		p = start_lanner;
+		k=0;
+		for (; p < pe; p++) {
+			if (k != offset) {
+				*p = pat;
+			}
+			if (++k > 19) {
+				k = 0;
+			}
+		}
+	}
+	pat = p1;
+	pe = end_lanner;
+	p = start_lanner + offset;
+	for (; p < pe; p += 20)
+	{
+		readback = *p;
+		if (readback != pat) {
+			printf ("\nMem error @ 0x%08X: "
+				"found %08lX, expected %08lX\n",
+				(uint)p, readback, pat);
+			errs++;
+			if (ctrlc()) {
+				putc ('\n');
+				return errs;
+			}
+		}
+		*p = p1;
+	}
+	return errs;
+}
+
+int  movinvr(void)
+{
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,i;
+	int seed1,seed2;
+	seed1 = 521288629;
+	seed2 = 362436069;
+	rand_seed(seed1, seed2);
+	pe = end_lanner;
+	p = start_lanner;
+	for (; p < pe; p++) {
+		WATCHDOG_RESET();
+		*p = rand_test();
+	}
+/*     puts("Testing..."); */
+	for( i =0 ; i < 2 ;i++)
+	{
+		rand_seed(seed1, seed2);
+		pe = end_lanner;
+		p = start_lanner;
+		for (; p < pe; p++) {
+			pat = rand_test();
+			if (i) {
+				pat = ~pat;
+			}
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = ~pat;
+		}
+	}
+	return errs;
+}
+
+int block_move(int iter)
+{
+	vu_long *pe,*pp,*p;
+	ulong   errs = 0;
+	ulong   readback;
+	ulong   p2;
+	int count ;
+	int i;
+	int len;
+	count = (( end_lanner - start_lanner ) / 64 );
+	addr_lanner=start_lanner;
+	int done =0;
+	pe = start_lanner;
+	p = start_lanner;
+	done = 0;
+	do {
+		/* Check for overflow */
+		if ((pe + 0x8000000) > pe) {
+			pe += 0x8000000;
+		} else {
+			pe = end_lanner;
+		}
+		if (pe >= end_lanner) {
+			pe = end_lanner;
+			done++;
+		}
+		if (p == pe) {
+			break;
+		}
+		count  = ((ulong)pe - (ulong)p) / 64;
+		int tmp_edx;
+		int tmp_eax=1;
+		do {
+			tmp_edx = ~tmp_eax;
+			for ( i=0; i < 16; i++) {
+				switch(i) {
+				case 4:
+				case 5:
+				case 10:
+				case 11:
+				case 14:
+				case 15:
+					*p++ = tmp_edx;
+					break;
+				default:
+					*p++ = tmp_eax;
+					break;
+				}
+			}
+			tmp_eax = (tmp_eax << 1) | (( tmp_eax >>31)&0x01);
+		}while (--count >0);
+	} while (!done);
+/*     puts ("Moving..."); */
+	pe = start_lanner;
+	p = start_lanner;
+	done = 0;
+	do {
+		/* Check for overflow */
+		if ((pe + 0x8000000) > pe) {
+			pe += 0x8000000;
+		} else {
+			pe = end_lanner;
+		}
+		if (pe >= end_lanner) {
+			pe = end_lanner;
+			done++;
+		}
+		if (p == pe) {
+			break;
+		}
+		pp = p + ((pe - p) / 2);
+		len  = ((ulong)pe -(ulong) p) / 8;
+		for( i =0 ;i< iter ;i++)
+		{
+			memcpy((ulong *)pp,(ulong *) p, len);
+			memcpy((ulong *)(p+8), (ulong *)pp, (len-8));
+			memcpy((ulong *)p,(ulong *)(pp+(len-8)), 8);
+		}
+	p = pe;
+	} while (!done);
+	pe = start_lanner;
+	p = start_lanner;
+	done = 0;
+	do {
+		/* Check for overflow */
+		if ((pe + 0x8000000) > pe) {
+			pe += 0x8000000;
+		} else {
+			pe = end_lanner;
+		}
+		if (pe >= end_lanner) {
+			pe = end_lanner;
+			done++;
+		}
+		if (p == pe) {
+			break;
+		}
+		while (p < pe) {
+			readback = *p;
+			p2 = *(++p);
+			if (readback != p2) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, p2);
+				errs++;
+			}
+			p++;
+		}
+	} while (!done);
+/*     printf("\n"); */
+       return errs;
+}
+
+void wait_time(int time)
+{
+	int i;
+	for ( i = 0 ; i < time ; i++ )
+	{
+		udelay(1000000);
+	}
+}
+
+int bit_fade(void)/* default 90Min */
+{
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	struct rtc_time tm1;
+	int errs=0;
+	pat = 0;
+	while(1)
+	{
+		pe = end_lanner;
+		p = start_lanner;
+		while (p < pe) {
+			WATCHDOG_RESET();
+			*p = pat;
+			p++;
+		}
+		wait_time( 15 * 60 );
+		wait_time( 15 * 60 );
+		wait_time( 15 * 60 );
+		wait_time( 15 * 60 );
+		wait_time( 15 * 60 );
+		wait_time( 15 * 60 );
+		pe = end_lanner;
+		p = start_lanner;
+		do {
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+		} while (p-- > pe);
+		if(pat == 0)
+			pat = -1;
+		else{
+			break;
+		}
+	}
+	return errs;
+}
+
+static ulong roundup_memtest(ulong value, ulong mask)
+{
+	return (value + mask) & ~mask;
+}
+
+
+int addr_tst1(void)
+{
+	int i, j, k;
+	vu_long *pt,*end,*p;
+	ulong mask, bank,p1,readback;
+	int errs=0;
+	/* Test the global address bits */
+	for (p1=0, j=0; j<2; j++) {
+		/* Set pattern in our lowest multiple of 0x20000 */
+		p = (ulong *)roundup_memtest((ulong)start_lanner, 0x1ffff);
+		*p = p1;
+		/* Now write pattern compliment */
+		p1 = ~p1;
+		end = end_lanner;
+		for (i=0; i<100; i++) {
+			mask = 4;
+			do {
+				pt = (ulong *)((ulong)p | mask);
+				if ((uintptr_t)pt == (uintptr_t)p) {
+					mask = mask << 1;
+					continue;
+				}
+				if ((uintptr_t)pt >= (uintptr_t)end) {
+					break;
+				}
+				*pt = p1;
+				readback = *p;
+				if (readback != ~p1) {
+					printf ("\nMem error @ 0x%08X: "
+						"found %08lX, expected %08lX\n",
+						(uint)p, readback, p1);
+					errs++;
+					i = 1000;
+					if (ctrlc()) {
+						putc ('\n');
+						return errs;
+					}
+				}
+				mask = mask << 1;
+			} while(mask);
+		}
+	}
+	bank =0x40000;
+	if((end_lanner -start_lanner ) > 0x100000 )
+		bank =0x100000;
+	for (p1=0, k=0; k<2; k++) {
+		p = start_lanner;
+		/* Force start address to be a multiple of 256k */
+		p = (ulong *)roundup_memtest((ulong)p, bank - 1);
+		end = end_lanner;
+		while ((uintptr_t)p < (uintptr_t)end) {
+			*p = p1;
+			p1 = ~p1;
+			for (i=0; i<200; i++) {
+				mask = 4;
+				do {
+					pt = (ulong *)((ulong)p | mask);
+					if ((uintptr_t)pt == (uintptr_t)p) {
+						mask = mask << 1;
+						continue;
+					}
+					if ((uintptr_t)pt >= (uintptr_t)end) {
+						break;
+					}
+					*pt = p1;
+					readback = *p;
+					if (readback != ~p1) {
+						printf ("\nMem error @ 0x%08X: "
+							"found %08lX, expected %08lX\n",
+							(uint)p, readback, ~p1);
+						errs++;
+						i = 200;
+						if (ctrlc()) {
+							putc ('\n');
+							return errs;
+						}
+					}
+					mask = mask << 1;
+				} while(mask);
+			}
+			if ((uintptr_t)(p + bank/4) > (uintptr_t)p) {
+				p += bank/4;
+			} else {
+				p = end;
+			}
+			p1 = ~p1;
+		}
+		p1 = ~p1;
+	}
+	return errs;
+}
+int addr_tst2(void)
+{
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0;
+	pe = end_lanner;
+	p = start_lanner;
+	while (p < pe) {
+		WATCHDOG_RESET();
+		*p =(ulong)p;
+		p++;
+	}
+	pe = end_lanner;
+	p = start_lanner;
+	for (; p < pe; p++) {
+		readback = *p;
+		pat = (ulong)p;                
+		if (readback != pat) {
+			printf ("\nMem error @ 0x%08X: "
+				"found %08lX, expected %08lX\n",
+				(uint)p, readback, pat);
+			errs++;
+			if (ctrlc()) {
+				putc ('\n');
+				return errs;
+			}
+		}
+	}
+	return errs;
+}
+/*
+ * Perform a memory test. A more complete alternative test can be
+ * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
+ * interrupted by ctrl-c or by a failure of one of the sub-tests.
+ */
+extern int testlog (int offset, unsigned char data);
+int do_ram_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong   errs = 0;
+	int iterations = 1;
+	int iteration_limit;
+	int i;
+	int count=0;
+	int error_count =0;
+	ulong   pattern;
+	if (argc > 1)
+		start_lanner = (ulong *)simple_strtoul(argv[1], NULL, 16);
+	else
+		start_lanner = (ulong *)0x1000;
+	if (argc > 2)
+		end_lanner = (ulong *)simple_strtoul(argv[2], NULL, 16);
+	else
+		end_lanner = (ulong *)0x7fae0000;
+
+	if (argc > 3)
+		iteration_limit = (ulong)simple_strtoul(argv[3], NULL, 16);
+	else
+		iteration_limit = 1;
+	printf("RAM Test:\n");
+	printf("iteration_limit =%d \n",iteration_limit);
+	if (iteration_limit && iterations > iteration_limit) {
+		printf("Tested %d iteration(s) with %lu errors.\n",
+			iterations-1, errs);
+		return errs != 0;
+	}
+	testlog(20,0);
+	/* Address test, walking ones */
+	printf("Test 0 [Address test, own address]              :");
+	count = addr_tst1();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Address test, own address */
+	printf("Test 1 [Address test, own address]              :");
+	count = addr_tst2();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Moving inversions, ones & zeros */
+	printf("TEST 2 [Moving inversions, ones & zeros]        :");
+	pattern = 0 ;
+	count =  movinv1(iteration_limit,pattern,~pattern);
+	count +=  movinv1(iteration_limit,~pattern,pattern);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Moving inversions, 8 bit pattern */
+	printf("Test 3 [Moving inversions, 8 bit pattern]       :");
+	pattern = 0x80808080 ;
+	count =  movinv1(iteration_limit,pattern,~pattern);
+	count +=  movinv1(iteration_limit,~pattern,pattern);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Moving inversions, random pattern */
+	printf("Test 4 [Moving inversions, random pattern]      :");
+	pattern = get_ticks();
+	count = movinv1(iteration_limit,pattern,~pattern);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Block move, 64 moves */
+	printf("Test 5 [Block move, 64 moves]                   :");
+	count += block_move(iteration_limit);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Moving inversions, 32 bit pattern */
+	printf("Test 6 [Moving inversions, 32 bit pattern]      :");
+	for( i = 0 ,pattern =1 ; pattern; pattern=pattern<<1,i++)
+	{
+		count = (movinv32(iteration_limit,pattern, 1, 0x80000000, 0, i));
+		count += (movinv32(iteration_limit,~pattern, 0xfffffffe, 0x7fffffff, 1, i));
+	}
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Random number sequence */
+	printf("Test 7 [Random number sequence]                 :");
+	count = movinvr();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Modulo 20, ones & zeros */
+	printf("Test 8 [Modulo 20, ones & zeros]                :");
+	pattern = 0;
+	for(i=0 ;i< 20 ;i++)
+	{
+		count = modtst(i ,iteration_limit,pattern,~pattern);
+		count += modtst(i ,iteration_limit,~pattern,pattern);
+	}
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+	/* Bit fade test, 90 min, 2 patterns */
+#if 1
+	printf("Test 9 [Bit fade test, 90 min, 2 patterns]      :");
+	count = bit_fade();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+		testlog(20,error_count);
+	}
+	else
+#endif
+	{
+		printf("PASS\n");
+		testlog(20,99);
+	}
+	return 0;
+}
+#endif /* CONFIG_LANNER_BURN */
+
+
+
+
 #endif	/* CONFIG_CMD_MEMTEST */
 
 /* Modify memory.
@@ -1363,6 +2125,14 @@
 	"simple RAM read/write test",
 	"[start [end [pattern [iterations]]]]"
 );
+#ifdef CONFIG_LANNER_BURN
+U_BOOT_CMD(
+	ram_test,       4,      1,      do_ram_test,
+	"simple test",
+	"[start [end [iterations]]]"
+);
+#endif /* CONFIG_LANNER_BURN */
+
 #endif	/* CONFIG_CMD_MEMTEST */
 
 #ifdef CONFIG_MX_CYCLIC
--- u-boot-2014.07/common/main.c.orig	2022-05-09 14:06:21.941201624 -0700
+++ u-boot-2014.07/common/main.c	2022-05-09 14:06:23.585135132 -0700
@@ -12,6 +12,8 @@
 #include <cli.h>
 #include <version.h>
 
+#include <miiphy.h>
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /*
@@ -53,11 +55,79 @@
 #endif /* CONFIG_PREBOOT */
 }
 
+
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+
+#define BUTTON_RESET			(25)
+
+/*
+* Read button status by given gpio number
+*/
+int read_btn_status(unsigned int btn)
+{
+	unsigned int reg_val;
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	reg_val = pgpio->gpdat;
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+	/* Low active */
+	if (reg_val & (1 << (31 - btn)) )
+		return 0;
+	else
+		return 1;
+#elif CONFIG_NEWPLATFORM
+	/* return 1 if keypresse detected
+	 * else return 0.
+	 */
+	return 0;
+#else
+	return 0;
+#endif
+
+}
+
+unsigned char detect_SYSB_keypress(void)
+{
+	int status = 0;
+	int i;
+	for(i = 0; i < 3; i++) {
+
+	        if (read_btn_status(BUTTON_RESET)) {
+			printf("booting into SYSB ... \n");
+			status = 1;
+			break;
+		}
+        	udelay(1000);
+	}
+
+	return status;
+}
+#endif /* end of CONFIG_M200 or CONFIG_M300 */
+
 /* We come here after U-Boot is initialised and ready to process commands */
 void main_loop(void)
 {
 	const char *s;
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+       unsigned char sysbReq;
+#endif
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	const char	*devname;
+	setenv("ethact", "eTSEC3");
+	devname = miiphy_get_current_dev();
+	miiphy_write(devname, 0, 0x16, 0x12);
+	miiphy_write(devname, 0, 0x14, 0x8001);
+	miiphy_write(devname, 0, 0x16, 0x0);
 
+
+	setenv("ethact", "eTSEC2");
+	devname = miiphy_get_current_dev();
+	miiphy_write(devname, 1, 0x16, 0x12);
+	miiphy_write(devname, 1, 0x14, 0x8001);
+	miiphy_write(devname, 1, 0x16, 0x0);
+	setenv("ethact", "eTSEC1");
+
+#endif
 	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");
 
 #ifndef CONFIG_SYS_GENERIC_BOARD
@@ -83,6 +153,22 @@
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
 
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+	sysbReq = detect_SYSB_keypress();
+	if(sysbReq == 1) {
+		if(getenv("Burn_In_Time") != NULL) {
+			 /* Assuming that mfgsys is the only user of "Burn_In_Time" */
+			setenv("bootcmd", "run wgBootSercomm");
+		} else {
+			setenv("bootcmd", "run wgBootSysB");
+		}
+
+		s = getenv ("bootcmd");
+		printf("string = %s\n", s);
+		run_command (s, 0);
+	}
+#endif /* endof CONFIG_M200 or CONFIG_M300 */
+
 	autoboot_command(s);
 
 	cli_loop();
--- u-boot-2014.07/common/miiphyutil.c.orig	2022-05-09 14:06:21.941201624 -0700
+++ u-boot-2014.07/common/miiphyutil.c	2022-05-09 14:06:23.585135132 -0700
@@ -127,6 +127,8 @@
 
 	debug("miiphy_register: added '%s', read=0x%08lx, write=0x%08lx\n",
 	       new_dev->name, ldev->read, ldev->write);
+	printf("miiphy_register: added '%s', read=%p, write=%p\n",
+	       new_dev->name, ldev->read, ldev->write);
 
 	/* add it to the list */
 	list_add_tail(&new_dev->link, &mii_devs);
@@ -163,6 +165,9 @@
 		return -1;
 	}
 
+	printf("mdio_register: added '%s', read=%p, write=%p\n",
+	       bus->name, bus->read, bus->write);
+
 	/* add it to the list */
 	list_add_tail(&bus->link, &mii_devs);
 
@@ -582,3 +587,109 @@
 	}
 }
 #endif
+
+
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+unsigned int RubyPhyReadReg (unsigned int interSMIaddr, unsigned int phyAddr,
+				unsigned int phyReg, unsigned int *retVal)
+{
+	uint16_t regData;
+	int ix;
+	const char      *devname;
+	devname = miiphy_get_current_dev();
+	for(ix = 0 ; ix < SMI_TIMEOUT ; ix++)
+	{
+		miiphy_read(devname,  phyAddr, R_mSMI_REG0, &regData);
+		if(!(regData & R_SMI_BUSY))     /* xgi: until mSMI not busy, break to use mSMI port*/
+			break;
+	}
+	if(ix == SMI_TIMEOUT)
+	{
+		printf("TimeOut Passed, mSMI stil in busy\n");
+		return 0;
+	}
+	regData =( ((interSMIaddr&=0x1f)) << 5 | (phyReg &=0x1f) | R_SMI_READ_OPCODE | R_SMI_22mode |R_SMI_go );
+	miiphy_write(devname,phyAddr, R_mSMI_REG0, regData);
+//	printf("R reg=%x ",regData);
+	for(ix = 0 ; ix < SMI_TIMEOUT ; ix++)
+	{
+		miiphy_read(devname, phyAddr, R_mSMI_REG0, &regData);
+		if(!(regData & R_SMI_READ_VALID))       /* xgi: readvalid, so, break */
+			break;
+	}
+	if(ix == SMI_TIMEOUT)
+	{
+		printf("TimeOut. mSMI Readvalid is not valid\n");
+		return 0;
+	}
+	miiphy_read(devname, phyAddr, R_mSMI_REG1, &regData);
+	*retVal = 0xffff & regData;
+//	printf("  data =%x \n",regData);
+	return 1;
+}
+int RubyPhyWriteReg (unsigned int interSMIaddr, unsigned int phyAddr,
+		unsigned int phyReg, unsigned int Val)
+{
+	uint16_t  regData, ix;
+	const char      *devname;
+	devname = miiphy_get_current_dev();
+	for(ix = 0 ; ix < SMI_TIMEOUT ; ix++)
+	{
+		miiphy_read(devname,  phyAddr, R_mSMI_REG0, &regData);
+		if(!(regData & R_SMI_BUSY))     /* xgi: until mSMI not busy, break to use mSMI port*/
+			break;
+	}
+	if(ix == SMI_TIMEOUT)
+	{
+		printf("TimeOut Passed Phy is busy\n");
+		return 0;
+	}
+	Val&=0xffff;
+	miiphy_write(devname,phyAddr, R_mSMI_REG1, Val);
+	regData =( ((interSMIaddr&=0x1f)) << 5 | (phyReg &=0x1f) | R_SMI_WRITE_OPCODE | R_SMI_22mode|R_SMI_go );
+	miiphy_write(devname,phyAddr, R_mSMI_REG0, regData);
+//	printf("W reg=%16x data=%16x\n",regData,Val);
+	return 1;
+}
+unsigned int SMIRW(
+	int rw,                                 /* 0:read,   1:write */
+	int DevSMIAddr,   /* not used for 1112 type */
+	int Reg,                        /* for all */
+	int Val,
+	int MACchipSmiAddr,
+	int MasterSmiNum,
+	int PortSmiAddr,
+	uint16_t * readVal
+	)
+{
+	int  retSta;
+	int  retVal,retBuf = 0;
+#if 0
+	if ((0<= PortSmiAddr) && (PortSmiAddr<=0xf)) { /* opal PHY */
+	        
+		retBuf=retVal;
+		retSta= RubyPhyWriteReg (0x1b, DevSMIAddr, 4, (retBuf&0xBFFF)); /* clear bit 14 */
+	}
+#endif
+	udelay(100);
+	if (rw==0){
+		retSta= RubyPhyReadReg (PortSmiAddr, DevSMIAddr, Reg, (uint *)&retVal);
+	}else {
+		retSta= RubyPhyWriteReg (PortSmiAddr, DevSMIAddr, Reg, Val);
+	}
+	if ((0<=PortSmiAddr) & (PortSmiAddr<=0xf)) { /* recovey ppu for opal PHY */
+		retSta= RubyPhyWriteReg (0x1b,DevSMIAddr, 4, retBuf);/* recovery */
+	}
+	if (retSta == 1 ) {
+		if (rw==0){
+			*readVal=retVal;
+		}
+		else {
+			;/* printf (" access ok\n" );  */
+		}
+		return 0;
+	}
+}
+#endif /* CONFIG_M200/B */
+
+
--- u-boot-2014.07/common/cmd_date.c.orig	2022-05-09 14:06:21.913202757 -0700
+++ u-boot-2014.07/common/cmd_date.c	2022-05-09 14:06:23.557136264 -0700
@@ -31,7 +31,7 @@
 {
 	struct rtc_time tm;
 	int rcode = 0;
-	int old_bus;
+	int old_bus =0;
 
 	/* switch to correct I2C bus */
 #ifdef CONFIG_SYS_I2C
@@ -95,6 +95,83 @@
 	return rcode;
 }
 
+#ifdef CONFIG_LANNER_BURN
+extern int testlog (int offset, unsigned char data);
+int do_rtc_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct rtc_time tm1;
+	struct rtc_time tm2;
+	int rcode = 0;
+	int test_time = 1 ;
+	int current = 0;
+	test_time  = simple_strtoul(argv[1], NULL, 10);
+	printf("RTC Test:\n");
+	testlog(2,0);
+	if(test_time < 0  && test_time >= 60)
+	{
+		testlog(2,1);
+		printf("Test time error\n");
+		return 1;
+	}
+	/* switch to correct I2C bus */
+	I2C_SET_BUS(CONFIG_SYS_RTC_BUS_NUM);
+	rcode = rtc_get (&tm1);
+	if (rcode) {
+		puts("## Get date failed\n");
+		return 1;
+	}
+	printf ("Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d\n",
+		tm1.tm_year, tm1.tm_mon, tm1.tm_mday,
+		(tm1.tm_wday<0 || tm1.tm_wday>6) ?
+		"unknown " : RELOC(weekdays[tm1.tm_wday]),
+		tm1.tm_hour, tm1.tm_min, tm1.tm_sec);
+	//system wait time
+	udelay(1000000*test_time);
+	rcode = rtc_get (&tm2);
+	if (rcode) {
+		puts("## Get date failed\n");
+		return 1;
+	}
+	printf ("Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d\n",
+		tm2.tm_year, tm2.tm_mon, tm2.tm_mday,
+		(tm2.tm_wday<0 || tm2.tm_wday>6) ?
+		"unknown " : RELOC(weekdays[tm2.tm_wday]),
+		tm2.tm_hour, tm2.tm_min, tm2.tm_sec);
+	if((tm1.tm_sec + test_time) < 60 )
+	{
+		if((tm1.tm_sec + test_time) == tm2.tm_sec)
+			current = 1;
+	}
+	else
+	{
+		if((tm1.tm_min + 1) == 60 )
+		{
+			if(tm2.tm_min == 0 )
+			{
+				if(((tm1.tm_sec + test_time)-60 ) == tm2.tm_sec)
+					current = 1;
+			}
+		}
+		else if((tm1.tm_min + 1) == tm2.tm_min)
+		{
+			if(((tm1.tm_sec + test_time)-60 ) == tm2.tm_sec)
+				current = 1;
+		}
+	}
+	if(current  == 1 )
+	{
+		printf("PASS\n");
+		testlog(2,99);
+	}
+	else
+	{
+		printf("FAIL\n");
+		testlog(2,2);
+	}
+	return 0;
+}
+#endif /* CONFIG_LANNER_BURN */
+
 /*
  * simple conversion of two-digit string with error checking
  */
@@ -216,3 +293,12 @@
 	"  - with numeric argument: set the system date & time\n"
 	"  - with 'reset' argument: reset the RTC"
 );
+
+#ifdef CONFIG_LANNER_BURN
+U_BOOT_CMD(
+	rtc_test,       2,      1,      do_rtc_test,
+	"simple rtc read test for second",
+	"waittime\n"
+);
+#endif /* CONFIG_LANNER_BURN */
+
--- u-boot-2014.07/common/board_f.c.orig	2022-05-09 14:06:21.905203081 -0700
+++ u-boot-2014.07/common/board_f.c	2022-05-09 14:06:23.549136588 -0700
@@ -54,6 +54,9 @@
 #endif
 #include <linux/compiler.h>
 
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
 /*
  * Pointer to initial global data area
  *
@@ -884,6 +887,9 @@
 #if defined(CONFIG_MIPS) || defined(CONFIG_PPC)
 	init_func_ram,
 #endif
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	fsl_dp_resume,
+#endif
 #ifdef CONFIG_POST
 	post_init_f,
 #endif
@@ -983,6 +989,10 @@
 	gd->flags = boot_flags;
 	gd->have_console = 0;
 
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot())
+		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+#endif
 	if (initcall_run_list(init_sequence_f))
 		hang();
 
--- u-boot-2014.07/common/autoboot.c.orig	2022-05-09 14:06:21.905203081 -0700
+++ u-boot-2014.07/common/autoboot.c	2022-05-09 14:06:23.545136750 -0700
@@ -12,6 +12,11 @@
 #include <menu.h>
 #include <post.h>
 
+#ifdef CONFIG_WG_BOOTMENU
+#include <wgmenu.h>
+#include <u-boot/sha1.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define MAX_DELAY_STOP_STR 32
@@ -146,11 +151,20 @@
 	int abort = 0;
 	unsigned long ts;
 
+#ifdef CONFIG_WG_BOOTMENU
+	wgmenu_show();
+	int wg_break = 0;
+	int wg_keypress = 0;
+	int wg_selected = 0;
+	const char wg_pw_hash[] = { 0xe5, 0x97, 0x30, 0x1a, 0x1d, 0x89, 0xff, 0x3f, 0x6d, 0x31, 0x8d, 0xbf, 0x4d, 0xba, 0x0a, 0x5a, 0xbc, 0x5e, 0xcb, 0xea};
+	char wg_csum_output[20];
+#endif
+
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
 #else
 	if (bootdelay >= 0)
-		printf("Hit any key to stop autoboot: %2d ", bootdelay);
+		printf("Hit any key to stop autoboot (except ENTER): %2d ", bootdelay);
 #endif
 
 #if defined CONFIG_ZERO_BOOTDELAY_CHECK
@@ -173,6 +187,54 @@
 		ts = get_timer(0);
 		do {
 			if (tstc()) {	/* we got a key press	*/
+# ifdef CONFIG_WG_BOOTMENU
+				/* Carriage return breaks us out of while() */
+				while (wg_keypress != 13) {
+					wg_keypress = getc();
+					wgmenu_hook(wg_keypress);
+					wg_selected = wgmenu_selected();
+					if (wg_keypress == 3) {	// CTRL+C
+						int wg_pw_len = 0;
+						wgmenu_exit();
+						printf("\x0D"); // go to the beginning of the line
+						printf("\e[2K"); // clear the line
+						wg_pw_len = cli_readline("password> ");
+						/* This if statement will not break from while if
+						 * we type a carriage return. */
+						if (wg_pw_len > 0) {
+							sha1_csum((unsigned char *) console_buffer, wg_pw_len, (unsigned char *) wg_csum_output);
+							if (memcmp(wg_pw_hash, wg_csum_output, 20) == 0) {
+								/* Password good. Assert abort and break
+								 * to prompt. */
+								abort = 1;
+								bootdelay = 0;
+								wg_break = 1;
+								break;
+							} else {
+								/* Bad password. */
+								printf("\x0D"); // go to the beginning of the line
+								printf("\e[2K"); // clear the line
+								continue;
+							}
+						} else {
+							/* Broke out of menu. Start the menu over.
+							 * Tell me how you got here, becuase this shouldn't happen. */
+							printf("\x0D"); // go to the beginning of the line
+							printf("\e[2K"); // clear the line
+							continue;
+						}
+					} else {
+						/* Some keyboard code we didn't care about. Start
+						 * the menu over. */
+						continue;
+					}
+					udelay(10000);
+				}
+				bootdelay = 0;
+				wg_break = 1;
+				wgmenu_exit();
+				break;
+# else /* !CONFIG_WG_BOOTMENU */
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
 # ifdef CONFIG_MENUKEY
@@ -180,12 +242,46 @@
 # else
 				(void) getc();  /* consume input	*/
 # endif
+# endif /* CONFIG_WG_BOOTMENU */
 				break;
 			}
 			udelay(10000);
 		} while (!abort && get_timer(ts) < 1000);
 
+#ifdef CONFIG_WG_BOOTMENU
+		if (!wg_break) {
+#endif /* CONFIG_WG_BOOTMENU */
 		printf("\b\b\b%2d ", bootdelay);
+#ifdef CONFIG_WG_BOOTMENU
+		}
+		if(getenv("Burn_In_Time") == NULL) {
+			if ((bootdelay == 0) && (abort != 1)) {
+				if (wg_selected >= 0) {
+					printf("\x0D"); // go to the beginning of the line
+					printf("\e[2K"); // clear the line
+					switch (wg_selected) {
+						case 1:
+							setenv("bootcmd", "run wgBootSysB");
+							printf("Booting SYSB");
+							break;
+						case 2:
+							setenv("bootcmd", "run wgBootRecovery");
+							printf("Booting Recovery");
+							break;
+						case 3:
+							setenv("bootcmd", "run wgBootBoot");
+							printf("Booting SYSA BOOT");
+							break;
+						case 0:
+						default:
+							setenv("bootcmd", "run wgBootSysA");
+							printf("Booting SYSA");
+							break;
+					}
+				}
+			}
+		}
+#endif /* CONFIG_WG_BOOTMENU */
 	}
 
 	putc('\n');
--- u-boot-2014.07/common/cmd_flash.c.orig	2022-05-09 14:06:21.913202757 -0700
+++ u-boot-2014.07/common/cmd_flash.c	2022-05-09 14:06:23.561136103 -0700
@@ -10,6 +10,10 @@
  */
 #include <common.h>
 #include <command.h>
+#ifdef CONFIG_LANNER_BURN
+#include <random.h>
+#endif /* CONFIG_LANNER_BURN */
+
 
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
@@ -667,6 +671,106 @@
 #endif /* CONFIG_SYS_NO_FLASH */
 
 
+#ifdef CONFIG_LANNER_BURN
+int testlog (int offset, unsigned char data)
+{
+	int rcode = 0;
+	char log[25];
+	ulong flash_start,flash_end;
+	flash_start = 0xefc10000;
+	flash_end = 0xefc1ffff;
+	if( flash_sect_protect (0, flash_start, flash_end) != 0 )
+	{
+		printf("\nFAIL\n");
+		return 1;
+	}
+	memcpy(log,(void *)(unsigned)flash_start,sizeof(log));
+	log[offset] = data;
+	rcode = flash_sect_erase(flash_start, flash_end);
+	rcode = flash_write (log,flash_start, sizeof(log));
+	return rcode;
+}
+
+
+int do_flash_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	flash_info_t *info;
+	int i, n, sect_first, sect_last;
+	int rcode = 0;
+	char *datbuf;
+	int size;
+	int rc;
+	printf("NOR Flash Test:\n");
+	testlog(7,0);
+	if ((n = abbrev_spec(argv[1], &info, &sect_first, &sect_last)) != 0) {
+		if (n < 0) {
+			printf("\nFAIL\n");
+			testlog(7,1);
+			return 1;
+		}
+		printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
+			"Un-", sect_first, sect_last,
+			(info-flash_info)+1);
+		for (i = sect_first; i <= sect_last; i++) {
+			info->protect[i] = 0;
+		}
+	}
+	if (addr_spec(argv[1], argv[2], (ulong *)&sect_first,(ulong *)&sect_last) < 0){
+		printf("\nFAIL\n");
+		testlog(7,2);
+		return 1;
+	}
+	if (sect_first >= sect_last) {
+		printf("\nFAIL\n");
+		testlog(7,3);
+		return 1;
+	}
+	if( flash_sect_protect (0, sect_first, sect_last) != 0 )
+	{
+		printf("\nFAIL\n");
+		testlog(7,4);
+		return 1;
+	}
+	rcode = flash_sect_erase(sect_first, sect_last);
+	if(rcode < 0 )
+	{
+		printf("\nFAIL\n");
+		testlog(7,5);
+		return rcode;
+	}
+	size = sect_last - sect_first + 1;
+	datbuf = malloc(size);
+	for( i = 0 ;i< size ;i++)
+		datbuf[i] = (char)rand_test();
+	rc = flash_write ((char *)datbuf, sect_first, size);
+	if( rc != 0 )
+	{
+		printf("\nFAIL\n");
+		testlog(7,6);
+		free(datbuf);
+		return 1;
+	}
+	for(i= 0;i< size;i++)
+	{
+		if(datbuf[i] != *(u_char *)sect_first)
+		{
+			printf("Address %x diff buf = %x data =%x ",sect_first,datbuf[i],*(u_char *)sect_first);
+			printf("\nFAIL\n");
+			testlog(7,7);
+			free(datbuf);
+			return 1;
+		}
+		sect_first++;
+	}
+	printf("\n PASS\n");
+	testlog(7,99);
+	free(datbuf);
+	return 0;
+}
+#endif /* CONFIG_LANNER_BURN */
+
+
+
 /**************************************************/
 #if defined(CONFIG_CMD_MTDPARTS)
 # define TMP_ERASE	"erase <part-id>\n    - erase partition\n"
@@ -723,6 +827,14 @@
 	TMP_PROT_OFF
 	"protect off all\n    - make all FLASH banks writable"
 );
+#ifdef CONFIG_LANNER_BURN
+U_BOOT_CMD(
+	flash_test,   3,   0,  do_flash_test,
+	"simple flash test",
+	"start end\n"
+);
+#endif /* CONFIG_LANNER_BURN */
+
 
 #undef	TMP_ERASE
 #undef	TMP_PROT_ON
--- u-boot-2014.07/common/cmd_pci.c.orig	2022-05-09 14:06:21.925202272 -0700
+++ u-boot-2014.07/common/cmd_pci.c	2022-05-09 14:06:23.569135779 -0700
@@ -490,3 +490,36 @@
 	pci,	5,	1,	do_pci,
 	"list and access PCI Configuration Space", pci_help_text
 );
+
+#ifdef CONFIG_LANNER_BURN
+int do_pci_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int Device;
+	int Function=0;
+	unsigned char HeaderType;
+	unsigned short VendorID;
+	unsigned short deviceID;
+	int bus;
+	pci_dev_t dev;
+	printf("PCI Device Detection: \n");
+	for (bus = 0 ; bus < 2 ;bus++)
+	{
+		for (Device = 0; Device < PCI_MAX_PCI_DEVICES; Device++) {
+			HeaderType = 0;
+			VendorID = 0;
+			dev = PCI_BDF(bus, Device, Function);
+			pci_read_config_word(dev, PCI_VENDOR_ID, &VendorID);
+			if ((VendorID == 0xFFFF) || (VendorID == 0x0000))
+				continue;
+			pci_read_config_word(dev, PCI_DEVICE_ID, &deviceID);
+			printf("PCIe Device ID =0x%04x ,Vendor = 0x%04x \n",VendorID,deviceID);
+		}
+	}
+	return 0;
+}
+U_BOOT_CMD(
+	pci_test,       1,      1,      do_pci_test,
+	"PCI Device Detection:",
+	"pci_test "
+);
+#endif /* CONFIG_LANNER_BURN */
--- u-boot-2014.07/common/Makefile.orig	2022-05-09 14:06:21.905203081 -0700
+++ u-boot-2014.07/common/Makefile	2022-05-09 14:06:23.533137235 -0700
@@ -8,22 +8,13 @@
 # core
 ifndef CONFIG_SPL_BUILD
 obj-y += main.o
-obj-y += command.o
+obj-$(CONFIG_WG_BOOTMENU) += wgmenu.o
 obj-y += exports.o
 obj-y += hash.o
 ifdef CONFIG_SYS_HUSH_PARSER
 obj-y += cli_hush.o
 endif
 
-# We always have this since drivers/ddr/fs/interactive.c needs it
-obj-y += cli_simple.o
-
-obj-y += cli.o
-obj-y += cli_readline.o
-obj-y += s_record.o
-obj-y += xyzModem.o
-obj-y += cmd_disk.o
-
 # This option is not just y/n - it can have a numeric value
 ifdef CONFIG_BOOTDELAY
 obj-y += autoboot.o
@@ -43,6 +34,7 @@
 obj-$(CONFIG_CMD_BOOTM) += cmd_bootm.o bootm.o bootm_os.o
 obj-y += cmd_help.o
 obj-y += cmd_version.o
+obj-$(CONFIG_LANNER_BURN) += random.o
 
 # environment
 obj-y += env_attr.o
@@ -265,5 +257,16 @@
 obj-$(CONFIG_IO_TRACE) += iotrace.o
 obj-y += memsize.o
 obj-y += stdio.o
+obj-$(CONFIG_PPC_MONROE) += cmd_show.o
+
+# We always have this since drivers/ddr/fs/interactive.c needs it
+obj-y += cli_simple.o
+
+obj-y += cli.o
+obj-y += cli_readline.o
+obj-y += command.o
+obj-y += s_record.o
+obj-y += xyzModem.o
+obj-y += cmd_disk.o
 
 CFLAGS_env_embedded.o := -Wa,--no-warn -DENV_CRC=$(shell tools/envcrc 2>/dev/null)
--- u-boot-2014.07/README.orig	2022-05-09 14:06:20.981240452 -0700
+++ u-boot-2014.07/README	2022-05-09 14:06:22.597175092 -0700
@@ -409,6 +409,10 @@
 		Enables a workaround for IFC erratum A003399. It is only
 		requred during NOR boot.
 
+		CONFIG_A008044_WORKAROUND
+		Enables a workaround for T1040/T1042 erratum A008044. It is only
+		requred during NAND boot and valid for Rev 1.0 SoC revision
+
 		CONFIG_SYS_FSL_CORENET_SNOOPVEC_COREONLY
 
 		This is the value to write into CCSR offset 0x18600
@@ -438,7 +442,7 @@
 		This CONFIG is defined when the CPC is configured as SRAM at the
 		time of U-boot entry and is required to be re-initialized.
 
-		CONFIG_DEEP_SLEEP
+		CONFIG_FSL_DEEP_SLEEP
 		Inidcates this SoC supports deep sleep feature. If deep sleep is
 		supported, core will start to execute uboot when wakes up.
 
--- u-boot-2014.07/boards.cfg.orig	2022-05-09 14:06:21.905203081 -0700
+++ u-boot-2014.07/boards.cfg	2022-05-09 14:06:23.533137235 -0700
@@ -301,6 +301,17 @@
 Active  arm         armv7          exynos      samsung         universal_c210      s5pc210_universal                     -                                                                                                                                 Przemyslaw Marczak <p.marczak@samsung.com>
 Active  arm         armv7          highbank    -               highbank            highbank                              -                                                                                                                                 Rob Herring <robh@kernel.org>
 Active  arm         armv7          keystone    ti              k2hk_evm            k2hk_evm                              -                                                                                                                                 Vitaly Andrianov <vitalya@ti.com>
+Active  arm         armv7          ls102xa     freescale       ls1021aqds          ls1021aqds_nor                        ls1021aqds                                                                                                                        Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7          ls102xa     freescale       ls1021aqds          ls1021aqds_nor_secboot                        ls1021aqds:SECURE_BOOT                                                                                                                        Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7          ls102xa     freescale       ls1021aqds          ls1021aqds_sdcard                     ls1021aqds:RAMBOOT_PBL,SPL_FSL_PBL,SD_BOOT                                                                                        Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7          ls102xa     freescale       ls1021aqds          ls1021aqds_nand                       ls1021aqds:RAMBOOT_PBL,SPL_FSL_PBL,NAND_BOOT                                                                                      Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7          ls102xa     freescale       ls1021aqds          ls1021aqds_qspi                       ls1021aqds:QSPI_BOOT                                                                                                              Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7	   ls102xa     freescale       ls1021aqds          ls1021aqds_lpuart                     ls1021aqds:LPUART                                                                                                                 -
+Active  arm         armv7          ls102xa     freescale       ls1021atwr          ls1021atwr_nor                        ls1021atwr                                                                                                                        Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7          ls102xa     freescale       ls1021atwr          ls1021atwr_nor_secboot                        ls1021atwr:SECURE_BOOT                                                                                                                        Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7          ls102xa     freescale       ls1021atwr          ls1021atwr_sdcard                     ls1021atwr:RAMBOOT_PBL,SPL_FSL_PBL,SD_BOOT                                                                                        Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7          ls102xa     freescale       ls1021atwr          ls1021atwr_qspi                       ls1021atwr:QSPI_BOOT                                                                                                              Alison Wang <alison.wang@freescale.com>
+Active  arm         armv7	   ls102xa     freescale       ls1021atwr          ls1021atwr_lpuart                     ls1021atwr:LPUART                                                                                                                 -
 Active  arm         armv7          mx5         denx            m53evk              m53evk                                m53evk:IMX_CONFIG=board/denx/m53evk/imximage.cfg                                                                                  Marek Vasut <marek.vasut@gmail.com>
 Active  arm         armv7          mx5         esg             ima3-mx53           ima3-mx53                             ima3-mx53:IMX_CONFIG=board/esg/ima3-mx53/imximage.cfg                                                                             -
 Active  arm         armv7          mx5         freescale       mx51evk             mx51evk                               mx51evk:IMX_CONFIG=board/freescale/mx51evk/imximage.cfg                                                                           Stefano Babic <sbabic@denx.de>
@@ -759,6 +770,8 @@
 Active  powerpc     mpc85xx        -           freescale       c29xpcie            C29XPCIE                              C29XPCIE:C29XPCIE,36BIT                                                                                                           Po Liu <po.liu@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       c29xpcie            C29XPCIE_NAND                         C29XPCIE:C29XPCIE,36BIT,NAND                                                                                                      Po Liu <po.liu@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       c29xpcie            C29XPCIE_SPIFLASH                     C29XPCIE:C29XPCIE,36BIT,SPIFLASH                                                                                                  Po Liu <po.liu@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       c29xpcie            C29XPCIE_SECBOOT                          C29XPCIE:C29XPCIE,36BIT,SECURE_BOOT                                                                       Po Liu <po.liu@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       c29xpcie            C29XPCIE_SPIFLASH_SECBOOT                C29XPCIE:C29XPCIE,36BIT,SPIFLASH,SECURE_BOOT                                                              Po Liu <po.liu@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       corenet_ds          P3041DS                               -                                                                                                                                 -
 Active  powerpc     mpc85xx        -           freescale       corenet_ds          P3041DS_NAND                          P3041DS:RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF40000                                                                                 -
 Active  powerpc     mpc85xx        -           freescale       corenet_ds          P3041DS_SDCARD                        P3041DS:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF40000                                                                               -
@@ -780,6 +793,7 @@
 Active  powerpc     mpc85xx        -           freescale       corenet_ds          P5040DS_NAND                          P5040DS:RAMBOOT_PBL,NAND,SYS_TEXT_BASE=0xFFF40000                                                                                 -
 Active  powerpc     mpc85xx        -           freescale       corenet_ds          P5040DS_SDCARD                        P5040DS:RAMBOOT_PBL,SDCARD,SYS_TEXT_BASE=0xFFF40000                                                                               -
 Active  powerpc     mpc85xx        -           freescale       corenet_ds          P5040DS_SPIFLASH                      P5040DS:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF40000                                                                             -
+Active  powerpc     mpc85xx        -           freescale       corenet_ds          P5040DS_SECURE_BOOT                   P5040DS:SECURE_BOOT                                                                                                               -
 Active  powerpc     mpc85xx        -           freescale       mpc8536ds           MPC8536DS                             -                                                                                                                                 -
 Active  powerpc     mpc85xx        -           freescale       mpc8536ds           MPC8536DS_36BIT                       MPC8536DS:36BIT                                                                                                                   -
 Active  powerpc     mpc85xx        -           freescale       mpc8536ds           MPC8536DS_SDCARD                      MPC8536DS:SDCARD                                                                                                                  -
@@ -838,7 +852,11 @@
 Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1011RDB_NAND                         P1_P2_RDB:P1011RDB,NAND                                                                                                           -
 Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1011RDB_SDCARD                       P1_P2_RDB:P1011RDB,SDCARD                                                                                                         -
 Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1011RDB_SPIFLASH                     P1_P2_RDB:P1011RDB,SPIFLASH                                                                                                       -
-Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1020RDB                              P1_P2_RDB:P1020RDB                                                                                                                -
+Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1020RDB                              P1_P2_RDB:P1020RDB,WGXTM_BOREN_TESTER,WGXTM_T50_BOREN                                                                                                -
+Active  powerpc     mpc85xx        -           freescale       wgxtm_boren         WGXTM_T50_BOREN                       WGXTM_BOREN:WGXTM_BOREN,WGXTM_T50_BOREN                                                                                                -
+Active  powerpc     mpc85xx        -           freescale       wgxtm_boren         WGXTM_T50_BOREN_SDCARD                WGXTM_BOREN:WGXTM_BOREN,WGXTM_T50_BOREN,SDCARD,WGXTM_BOREN_TESTER                                                                                             -
+Active  powerpc     mpc85xx        -           freescale       wgxtm_boren         WGXTM_T30_BOREN                       WGXTM_BOREN:WGXTM_BOREN,WGXTM_T30_BOREN,WGXTM_BOREN_TESTER                                                                                             -
+Active  powerpc     mpc85xx        -           freescale       wgxtm_boren         WGXTM_T30_BOREN_SDCARD                WGXTM_BOREN:WGXTM_BOREN,WGXTM_T30_BOREN,SDCARD,WGXTM_BOREN_TESTER                                                                                             -
 Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1020RDB_36BIT                        P1_P2_RDB:P1020RDB,36BIT                                                                                                          -
 Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1020RDB_36BIT_SDCARD                 P1_P2_RDB:P1020RDB,36BIT,SDCARD                                                                                                   -
 Active  powerpc     mpc85xx        -           freescale       p1_p2_rdb           P1020RDB_36BIT_SPIFLASH               P1_P2_RDB:P1020RDB,36BIT,SPIFLASH                                                                                                 -
@@ -920,6 +938,18 @@
 Active  powerpc     mpc85xx        -           freescale       p2041rdb            P2041RDB_SPIFLASH                     P2041RDB:RAMBOOT_PBL,SPIFLASH,SYS_TEXT_BASE=0xFFF40000                                                                            -
 Active  powerpc     mpc85xx        -           freescale       p2041rdb            P2041RDB_SRIO_PCIE_BOOT               P2041RDB:SRIO_PCIE_BOOT_SLAVE,SYS_TEXT_BASE=0xFFF40000                                                                            -
 Active  powerpc     mpc85xx        -           freescale       qemu-ppce500        qemu-ppce500                          -                                                                                                                                 Alexander Graf <agraf@suse.de>
+Active  powerpc     mpc85xx        -           freescale       t102xqds            T1024QDS           T102xQDS:PPC_T1024
+Active  powerpc     mpc85xx        -           freescale       t102xqds            T1024QDS_D4        T102xQDS:PPC_T1024,SYS_FSL_DDR4
+Active  powerpc     mpc85xx        -           freescale       t102xqds            T1024QDS_NAND      T102xQDS:PPC_T1024,RAMBOOT_PBL,SPL_FSL_PBL,NAND
+Active  powerpc     mpc85xx        -           freescale       t102xqds            T1024QDS_SDCARD    T102xQDS:PPC_T1024,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD
+Active  powerpc     mpc85xx        -           freescale       t102xqds            T1024QDS_SPIFLASH  T102xQDS:PPC_T1024,RAMBOOT_PBL,SPL_FSL_PBL,SPIFLASH
+Active  powerpc     mpc85xx        -           freescale       t102xqds            T1024QDS_SECURE_BOOT    T102xQDS:PPC_T1024,SECURE_BOOT
+Active  powerpc     mpc85xx        -           freescale       t102xqds            T1024QDS_D4_SECURE_BOOT T102xQDS:PPC_T1024,SYS_FSL_DDR4,SECURE_BOOT
+Active  powerpc     mpc85xx        -           freescale       t102xrdb            T1024RDB           T102xRDB:PPC_T1024
+Active  powerpc     mpc85xx        -           freescale       t102xrdb            T1024RDB_NAND      T102xRDB:PPC_T1024,RAMBOOT_PBL,SPL_FSL_PBL,NAND
+Active  powerpc     mpc85xx        -           freescale       t102xrdb            T1024RDB_SDCARD    T102xRDB:PPC_T1024,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD
+Active  powerpc     mpc85xx        -           freescale       t102xrdb            T1024RDB_SPIFLASH  T102xRDB:PPC_T1024,RAMBOOT_PBL,SPL_FSL_PBL,SPIFLASH
+Active  powerpc     mpc85xx        -           freescale       t102xrdb            T1024RDB_SECURE_BOOT    T102xRDB:PPC_T1024,SECURE_BOOT
 Active  powerpc     mpc85xx        -           freescale       t1040qds            T1040QDS                              T1040QDS:PPC_T1040                                                                                                                Poonam Aggrwal <poonam.aggrwal@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t1040qds            T1040QDS_D4                           T1040QDS:PPC_T1040,SYS_FSL_DDR4                                                                                                   Poonam Aggrwal <poonam.aggrwal@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t1040qds            T1040QDS_SECURE_BOOT                  T1040QDS:PPC_T1040,SECURE_BOOT                                                                                                    Aneesh Bansal <aneesh.bansal@freescale.com>
@@ -928,10 +958,15 @@
 Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1040RDB_SDCARD                       T104xRDB:PPC_T1040,T1040RDB,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD                                                                        -
 Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1040RDB_SECURE_BOOT                  T104xRDB:PPC_T1040,SECURE_BOOT,T1040RDB                                                                                           Aneesh Bansal  <aneesh.bansal@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1040RDB_SPIFLASH                     T104xRDB:PPC_T1040,T1040RDB,RAMBOOT_PBL,SPL_FSL_PBL,SPIFLASH                                                                      Priyanka Jain  <Priyanka.Jain@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1042RDB                              T104xRDB:PPC_T1042,T1042RDB                                                                                                            Priyanka Jain  <Priyanka.Jain@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1042RDB_PI                           T104xRDB:PPC_T1042,T1042RDB_PI                                                                                                    Priyanka Jain  <Priyanka.Jain@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1042RDB_PI_SECURE_BOOT               T104xRDB:PPC_T1042,T1042RDB_PI,SECURE_BOOT                                                                                        Gaurav Kumar Rana <gaurav.rana@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1042RDB_PI_NAND                      T104xRDB:PPC_T1042,T1042RDB_PI,RAMBOOT_PBL,SPL_FSL_PBL,NAND                                                                       Priyanka Jain  <Priyanka.Jain@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1042RDB_PI_SDCARD                    T104xRDB:PPC_T1042,T1042RDB_PI,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD                                                                     -
 Active  powerpc     mpc85xx        -           freescale       t104xrdb            T1042RDB_PI_SPIFLASH                  T104xRDB:PPC_T1042,T1042RDB_PI,RAMBOOT_PBL,SPL_FSL_PBL,SPIFLASH                                                                   Priyanka Jain  <Priyanka.Jain@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       m200               M200                                 m200:PPC_M200,M200,PPC_MONROE                                                                                                            Priyanka Jain  <Priyanka.Jain@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       m200               M200_SDCARD                          m200:PPC_M200,M200,PPC_MONROE,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD                                                                             Priyanka Jain  <Priyanka.Jain@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       m200               M200_SPIFLASH                        m200:PPC_M200,M200,PPC_MONROE,RAMBOOT_PBL,SPL_FSL_PBL,SPIFLASH                                                                           Priyanka Jain  <Priyanka.Jain@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t208xqds            T2080QDS                              T208xQDS:PPC_T2080                                                                                                                -
 Active  powerpc     mpc85xx        -           freescale       t208xqds            T2080QDS_NAND                         T208xQDS:PPC_T2080,RAMBOOT_PBL,SPL_FSL_PBL,NAND                                                                                   -
 Active  powerpc     mpc85xx        -           freescale       t208xqds            T2080QDS_SDCARD                       T208xQDS:PPC_T2080,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD                                                                                 -
@@ -949,6 +984,9 @@
 Active  powerpc     mpc85xx        -           freescale       t208xrdb            T2080RDB_SECURE_BOOT                  T208xRDB:PPC_T2080,SECURE_BOOT                                                                                                    Aneesh Bansal <aneesh.bansal@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t208xrdb            T2080RDB_SPIFLASH                     T208xRDB:PPC_T2080,RAMBOOT_PBL,SPL_FSL_PBL,SPIFLASH                                                                               -
 Active  powerpc     mpc85xx        -           freescale       t208xrdb            T2080RDB_SRIO_PCIE_BOOT               T208xRDB:PPC_T2080,SRIO_PCIE_BOOT_SLAVE,SYS_TEXT_BASE=0xFFF40000                                                                  -
+Active  powerpc     mpc85xx        -           freescale       m300               M300                                 m300:PPC_M300,M300,PPC_MONROE                                                                                                            Priyanka Jain  <Priyanka.Jain@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       m300               M300_SDCARD                          m300:PPC_M300,M300,PPC_MONROE,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD                                                                             Priyanka Jain  <Priyanka.Jain@freescale.com>
+Active  powerpc     mpc85xx        -           freescale       m300               M300_SPIFLASH                        m300:PPC_M300,M300,PPC_MONROE,RAMBOOT_PBL,SPL_FSL_PBL,SPIFLASH                                                                           Priyanka Jain  <Priyanka.Jain@freescale.com>
 Active  powerpc     mpc85xx        -           freescale       t4qds               T4160QDS                              T4240QDS:PPC_T4160                                                                                                                -
 Active  powerpc     mpc85xx        -           freescale       t4qds               T4160QDS_NAND                         T4240QDS:PPC_T4160,RAMBOOT_PBL,SPL_FSL_PBL,NAND                                                                                   -
 Active  powerpc     mpc85xx        -           freescale       t4qds               T4160QDS_SDCARD                       T4240QDS:PPC_T4160,RAMBOOT_PBL,SPL_FSL_PBL,SDCARD                                                                                 -
--- u-boot-2014.07/lib/lmb.c.orig	2022-05-09 14:06:22.429181887 -0700
+++ u-boot-2014.07/lib/lmb.c	2022-05-09 14:06:24.109113938 -0700
@@ -295,7 +295,10 @@
 		if (max_addr == LMB_ALLOC_ANYWHERE)
 			base = lmb_align_down(lmbbase + lmbsize - size, align);
 		else if (lmbbase < max_addr) {
-			base = min(lmbbase + lmbsize, max_addr);
+			base = lmbbase + lmbsize;
+			if (base < lmbbase)
+				base = -1;
+			base = min(base, max_addr);
 			base = lmb_align_down(base - size, align);
 		} else
 			continue;
--- u-boot-2014.07/tools/pblimage.c.orig	2022-05-09 14:06:22.493179299 -0700
+++ u-boot-2014.07/tools/pblimage.c	2022-05-09 14:06:24.169111511 -0700
@@ -8,6 +8,10 @@
 #include "pblimage.h"
 #include "pbl_crc32.h"
 
+#define roundup(x, y)		((((x) + ((y) - 1)) / (y)) * (y))
+#define PBL_ACS_CONT_CMD	0x81000000
+#define PBL_ADDR_24BIT_MASK	0x00ffffff
+
 /*
  * Initialize to an invalid value.
  */
@@ -22,6 +26,13 @@
 static char *fname = "Unknown";
 static int lineno = -1;
 static struct pbl_header pblimage_header;
+static int uboot_size;
+static int arch_flag;
+
+static uint32_t pbl_cmd_initaddr;
+static uint32_t pbi_crc_cmd1;
+static uint32_t pbi_crc_cmd2;
+static uint32_t pbl_end_cmd[4];
 
 static union
 {
@@ -38,20 +49,6 @@
  * start offset by subtracting the size of the u-boot image from the
  * top of the allowable 24-bit range.
  */
-static void init_next_pbl_cmd(FILE *fp_uboot)
-{
-	struct stat st;
-	int fd = fileno(fp_uboot);
-
-	if (fstat(fd, &st) == -1) {
-		printf("Error: Could not determine u-boot image size. %s\n",
-			strerror(errno));
-		exit(EXIT_FAILURE);
-	}
-
-	next_pbl_cmd = 0x82000000 - st.st_size;
-}
-
 static void generate_pbl_cmd(void)
 {
 	uint32_t val = next_pbl_cmd;
@@ -66,11 +63,15 @@
 
 static void pbl_fget(size_t size, FILE *stream)
 {
-	unsigned char c;
+	unsigned char c = 0xff;
 	int c_temp;
 
-	while (size && (c_temp = fgetc(stream)) != EOF) {
-		c = (unsigned char)c_temp;
+	while (size) {
+		c_temp = fgetc(stream);
+		if (c_temp != EOF)
+			c = (unsigned char)c_temp;
+		else if ((c_temp == EOF) && (arch_flag == IH_ARCH_ARM))
+			c = 0xff;
 		*pmem_buf++ = c;
 		pbl_size++;
 		size--;
@@ -80,8 +81,8 @@
 /* load split u-boot with PBI command 81xxxxxx. */
 static void load_uboot(FILE *fp_uboot)
 {
-	init_next_pbl_cmd(fp_uboot);
-	while (next_pbl_cmd < 0x82000000) {
+	next_pbl_cmd = pbl_cmd_initaddr - uboot_size;
+	while (next_pbl_cmd < pbl_cmd_initaddr) {
 		generate_pbl_cmd();
 		pbl_fget(64, fp_uboot);
 	}
@@ -154,8 +155,6 @@
 /* write end command and crc command to memory. */
 static void add_end_cmd(void)
 {
-	uint32_t pbl_end_cmd[4] = {0x09138000, 0x00000000,
-		0x091380c0, 0x00000000};
 	uint32_t crc32_pbl;
 	int i;
 	unsigned char *p = (unsigned char *)&pbl_end_cmd;
@@ -172,8 +171,8 @@
 
 	/* Add PBI CRC command. */
 	*pmem_buf++ = 0x08;
-	*pmem_buf++ = 0x13;
-	*pmem_buf++ = 0x80;
+	*pmem_buf++ = pbi_crc_cmd1;
+	*pmem_buf++ = pbi_crc_cmd2;
 	*pmem_buf++ = 0x40;
 	pbl_size += 4;
 
@@ -184,17 +183,6 @@
 	*pmem_buf++ = (crc32_pbl >> 8) & 0xff;
 	*pmem_buf++ = (crc32_pbl) & 0xff;
 	pbl_size += 4;
-
-	if ((pbl_size % 16) != 0) {
-		for (i = 0; i < 8; i++) {
-			*pmem_buf++ = 0x0;
-			pbl_size++;
-		}
-	}
-	if ((pbl_size % 16 != 0)) {
-		printf("Error: Bad size of image file\n");
-		exit(EXIT_FAILURE);
-	}
 }
 
 void pbl_load_uboot(int ifd, struct image_tool_params *params)
@@ -268,12 +256,64 @@
 	/*nothing need to do, pbl_load_uboot takes care of whole file. */
 }
 
+int pblimage_check_params(struct image_tool_params *params)
+{
+	FILE *fp_uboot;
+	int fd;
+	struct stat st;
+
+	if (!params)
+		return EXIT_FAILURE;
+
+	fp_uboot = fopen(params->datafile, "r");
+	if (fp_uboot == NULL) {
+		printf("Error: %s open failed\n", params->datafile);
+		exit(EXIT_FAILURE);
+	}
+	fd = fileno(fp_uboot);
+
+	if (fstat(fd, &st) == -1) {
+		printf("Error: Could not determine u-boot image size. %s\n",
+		       strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	/* For the variable size, we need to pad it to 64 byte boundary */
+	uboot_size = roundup(st.st_size, 64);
+
+	if (params->arch == IH_ARCH_ARM) {
+		arch_flag = IH_ARCH_ARM;
+		pbi_crc_cmd1 = 0x61;
+		pbi_crc_cmd2 = 0;
+		pbl_cmd_initaddr = params->addr & PBL_ADDR_24BIT_MASK;
+		pbl_cmd_initaddr |= PBL_ACS_CONT_CMD;
+		pbl_cmd_initaddr |= uboot_size;
+		pbl_end_cmd[0] = 0x09610000;
+		pbl_end_cmd[1] = 0x00000000;
+		pbl_end_cmd[2] = 0x096100c0;
+		pbl_end_cmd[3] = 0x00000000;
+	} else if (params->arch == IH_ARCH_PPC) {
+		arch_flag = IH_ARCH_PPC;
+		pbi_crc_cmd1 = 0x13;
+		pbi_crc_cmd2 = 0x80;
+		pbl_cmd_initaddr = 0x82000000;
+		pbl_end_cmd[0] = 0x09138000;
+		pbl_end_cmd[1] = 0x00000000;
+		pbl_end_cmd[2] = 0x091380c0;
+		pbl_end_cmd[3] = 0x00000000;
+	}
+
+	next_pbl_cmd = pbl_cmd_initaddr;
+	return 0;
+};
+
 /* pblimage parameters */
 static struct image_type_params pblimage_params = {
 	.name		= "Freescale PBL Boot Image support",
 	.header_size	= sizeof(struct pbl_header),
 	.hdr		= (void *)&pblimage_header,
 	.check_image_type = pblimage_check_image_types,
+	.check_params	= pblimage_check_params,
 	.verify_header	= pblimage_verify_header,
 	.print_header	= pblimage_print_header,
 	.set_header	= pblimage_set_header,
--- u-boot-2014.07/board/freescale/b4860qds/b4860qds.c.orig	2022-05-09 14:06:21.609215052 -0700
+++ u-boot-2014.07/board/freescale/b4860qds/b4860qds.c	2022-05-09 14:06:23.281147427 -0700
@@ -19,6 +19,7 @@
 #include <asm/fsl_portals.h>
 #include <asm/fsl_liodn.h>
 #include <fm_eth.h>
+#include <hwconfig.h>
 
 #include "../common/qixis.h"
 #include "../common/vsc3316_3308.h"
@@ -333,6 +334,8 @@
 	unsigned int num_vsc16_con, num_vsc08_con;
 	u32 serdes1_prtcl, serdes2_prtcl;
 	int ret;
+	char buffer[HWCONFIG_BUFFER_SIZE];
+	char *buf = NULL;
 
 	serdes1_prtcl = in_be32(&gur->rcwsr[4]) &
 			FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
@@ -385,15 +388,18 @@
 		}
 		break;
 
+	case 0x01:
 	case 0x02:
 	case 0x04:
 	case 0x05:
 	case 0x06:
+	case 0x07:
 	case 0x08:
 	case 0x09:
 	case 0x0A:
 	case 0x0B:
 	case 0x0C:
+	case 0x2F:
 	case 0x30:
 	case 0x32:
 	case 0x33:
@@ -487,6 +493,9 @@
 		return -1;
 	}
 
+	num_vsc08_con = NUM_CON_VSC3308;
+	/* Configure VSC3308 crossbar switch */
+	ret = select_i2c_ch_pca(I2C_CH_VSC3308);
 	switch (serdes2_prtcl) {
 #ifdef CONFIG_PPC_B4420
 	case 0x9d:
@@ -494,14 +503,11 @@
 	case 0x9E:
 	case 0x9A:
 	case 0x98:
-	case 0xb2:
+	case 0x48:
 	case 0x49:
 	case 0x4E:
-	case 0x8D:
+	case 0x79:
 	case 0x7A:
-		num_vsc08_con = NUM_CON_VSC3308;
-		/* Configure VSC3308 crossbar switch */
-		ret = select_i2c_ch_pca(I2C_CH_VSC3308);
 		if (!ret) {
 			ret = vsc3308_config(VSC3308_TX_ADDRESS,
 					vsc08_tx_amc, num_vsc08_con);
@@ -515,6 +521,71 @@
 			return ret;
 		}
 		break;
+	case 0x80:
+	case 0x81:
+	case 0x82:
+	case 0x83:
+	case 0x84:
+	case 0x85:
+	case 0x86:
+	case 0x87:
+	case 0x88:
+	case 0x89:
+	case 0x8a:
+	case 0x8b:
+	case 0x8c:
+	case 0x8d:
+	case 0x8e:
+	case 0xb1:
+	case 0xb2:
+		if (!ret) {
+			/*
+			 * Extract hwconfig from environment since environment
+			 * is not setup properly yet
+			 */
+			getenv_f("hwconfig", buffer, sizeof(buffer));
+			buf = buffer;
+
+			if (hwconfig_subarg_cmp_f("fsl_b4860_serdes2",
+						  "sfp_amc", "sfp", buf)) {
+#ifdef CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+				/* change default VSC3308 for XFI erratum */
+				ret = vsc3308_config_adjust(VSC3308_TX_ADDRESS,
+						vsc08_tx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+
+				ret = vsc3308_config_adjust(VSC3308_RX_ADDRESS,
+						vsc08_rx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+#else
+				ret = vsc3308_config(VSC3308_TX_ADDRESS,
+						vsc08_tx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+
+				ret = vsc3308_config(VSC3308_RX_ADDRESS,
+						vsc08_rx_sfp, num_vsc08_con);
+				if (ret)
+					return ret;
+#endif
+			} else {
+				ret = vsc3308_config(VSC3308_TX_ADDRESS,
+						vsc08_tx_amc, num_vsc08_con);
+				if (ret)
+					return ret;
+
+				ret = vsc3308_config(VSC3308_RX_ADDRESS,
+						vsc08_rx_amc, num_vsc08_con);
+				if (ret)
+					return ret;
+			}
+
+		} else {
+			return ret;
+		}
+		break;
 	default:
 		printf("WARNING:VSC crossbars programming not supported for: %x"
 					" SerDes2 Protocol.\n", serdes2_prtcl);
@@ -730,19 +801,23 @@
 	 * to 122.88MHz
 	 */
 	switch (serdes1_prtcl) {
+	case 0x29:
 	case 0x2A:
 	case 0x2C:
 	case 0x2D:
 	case 0x2E:
+	case 0x01:
 	case 0x02:
 	case 0x04:
 	case 0x05:
 	case 0x06:
+	case 0x07:
 	case 0x08:
 	case 0x09:
 	case 0x0A:
 	case 0x0B:
 	case 0x0C:
+	case 0x2F:
 	case 0x30:
 	case 0x32:
 	case 0x33:
@@ -860,6 +935,8 @@
 #endif
 	case 0x9E:
 	case 0x9A:
+		/* fallthrough */
+	case 0xb1:
 	case 0xb2:
 		debug("Configuring IDT for PCIe SATA for srds_prctl:%x\n",
 			serdes2_prtcl);
@@ -915,6 +992,14 @@
 	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
 	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
 	int ret;
+	u32 svr = SVR_SOC_VER(get_svr());
+
+	/* Create law for MAPLE only for personalities having MAPLE */
+	if ((svr == SVR_B4860) || (svr == SVR_B4440) ||
+	    (svr == SVR_B4420) || (svr == SVR_B4220)) {
+		set_next_law(CONFIG_SYS_MAPLE_MEM_PHYS, LAW_SIZE_16M,
+			     LAW_TRGT_IF_MAPLE);
+	}
 
 	/*
 	 * Remap Boot flash + PROMJET region to caching-inhibited
--- u-boot-2014.07/board/freescale/b4860qds/eth_b4860qds.c.orig	2022-05-09 14:06:21.613214890 -0700
+++ u-boot-2014.07/board/freescale/b4860qds/eth_b4860qds.c	2022-05-09 14:06:23.281147427 -0700
@@ -112,7 +112,10 @@
 		 * Lanes: A,B,C,D: PCI
 		 * Lanes: E,F,G,H: XAUI2
 		 */
+	case 0xb1:
 	case 0xb2:
+	case 0x8c:
+	case 0x8d:
 		/*
 		 * Configuration:
 		 * SERDES: 2
@@ -195,34 +198,34 @@
 	 * all SGMII. RGMII is not supported on this board. Setting SGMII 5 and
 	 * 6 to on board SGMII phys
 	 */
-	fm_info_set_phy_address(FM1_DTSEC5, CONFIG_SYS_FM1_DTSEC5_PHY_ADDR);
-	fm_info_set_phy_address(FM1_DTSEC6, CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC5, CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC6, CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
 
 	switch (serdes1_prtcl) {
 	case 0x29:
 	case 0x2a:
 		/* Serdes 1: A-B SGMII, Configuring DTSEC 5 and 6 */
-		debug("Setting phy addresses for FM1_DTSEC5: %x and"
-			"FM1_DTSEC6: %x\n", CONFIG_SYS_FM1_DTSEC5_PHY_ADDR,
-			CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+		debug("Set phy addresses for FM1_DTSEC5:%x, FM1_DTSEC6:%x\n",
+		      CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR,
+		      CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC5,
-				CONFIG_SYS_FM1_DTSEC5_PHY_ADDR);
+				CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC6,
-				CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+				CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
 		break;
 #ifdef CONFIG_PPC_B4420
 	case 0x17:
 	case 0x18:
 		/* Serdes 1: A-D SGMII, Configuring on board dual SGMII Phy */
-		debug("Setting phy addresses for FM1_DTSEC3: %x and"
-			"FM1_DTSEC4: %x\n", CONFIG_SYS_FM1_DTSEC5_PHY_ADDR,
-			CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+		debug("Set phy addresses for FM1_DTSEC3:%x, FM1_DTSEC4:%x\n",
+		      CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR,
+		      CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
 		/* Fixing Serdes clock by programming FPGA register */
 		QIXIS_WRITE(brdcfg[4], QIXIS_SRDS1CLK_125);
 		fm_info_set_phy_address(FM1_DTSEC3,
-				CONFIG_SYS_FM1_DTSEC5_PHY_ADDR);
+				CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC4,
-				CONFIG_SYS_FM1_DTSEC6_PHY_ADDR);
+				CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR);
 		break;
 #endif
 	default:
@@ -233,8 +236,8 @@
 	switch (serdes2_prtcl) {
 	case 0x17:
 	case 0x18:
-		debug("Setting phy addresses on SGMII Riser card for"
-				"FM1_DTSEC ports: \n");
+		debug("Set phy address on SGMII Riser for FM1_DTSEC1:%x\n",
+		      CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC1,
 				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC2,
@@ -246,8 +249,8 @@
 		break;
 	case 0x48:
 	case 0x49:
-		debug("Setting phy addresses on SGMII Riser card for"
-				"FM1_DTSEC ports: \n");
+		debug("Set phy address on SGMII Riser for FM1_DTSEC1:%x\n",
+		      CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC1,
 				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC2,
@@ -255,29 +258,37 @@
 		fm_info_set_phy_address(FM1_DTSEC3,
 				CONFIG_SYS_FM1_DTSEC3_RISER_PHY_ADDR);
 		break;
-	case 0x8d:
+	case 0xb1:
 	case 0xb2:
-		debug("Setting phy addresses on SGMII Riser card for"
-				"FM1_DTSEC ports: \n");
+	case 0x8c:
+	case 0x8d:
+		debug("Set phy addresses on SGMII Riser for FM1_DTSEC1:%x\n",
+		      CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC3,
 				CONFIG_SYS_FM1_DTSEC1_RISER_PHY_ADDR);
 		fm_info_set_phy_address(FM1_DTSEC4,
 				CONFIG_SYS_FM1_DTSEC2_RISER_PHY_ADDR);
+		/*
+		 * XFI does not need a PHY to work, but to make U-boot
+		 * happy, assign a fake PHY address for a XFI port.
+		 */
+		fm_info_set_phy_address(FM1_10GEC1, 0);
+		fm_info_set_phy_address(FM1_10GEC2, 1);
 		break;
 	case 0x98:
 		/* XAUI in Slot1 and Slot2 */
-		debug("Setting phy addresses on B4860 QDS AMC2PEX-2S for FM1_10GEC1: %x\n",
+		debug("Set phy address of AMC2PEX-2S for FM1_10GEC1:%x\n",
 		      CONFIG_SYS_FM1_10GEC1_PHY_ADDR);
 		fm_info_set_phy_address(FM1_10GEC1,
 					CONFIG_SYS_FM1_10GEC1_PHY_ADDR);
-		debug("Setting phy addresses on B4860 QDS AMC2PEX-2S for FM1_10GEC2: %x\n",
+		debug("Set phy address of AMC2PEX-2S for FM1_10GEC2:%x\n",
 		      CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
 		fm_info_set_phy_address(FM1_10GEC2,
 					CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
 		break;
 	case 0x9E:
 		/* XAUI in Slot2 */
-		debug("Setting phy addresses on B4860 QDS AMC2PEX-2S for FM1_10GEC2: %x\n",
+		debug("Sett phy address of AMC2PEX-2S for FM1_10GEC2:%x\n",
 		      CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
 		fm_info_set_phy_address(FM1_10GEC2,
 					CONFIG_SYS_FM1_10GEC2_PHY_ADDR);
@@ -329,17 +340,20 @@
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_XGMII:
 			fm_info_set_mdio(i,
-					 miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME));
+					 miiphy_get_dev_by_name
+					 (DEFAULT_FM_TGEC_MDIO_NAME));
+			break;
+		case PHY_INTERFACE_MODE_NONE:
+			fm_info_set_phy_address(i, 0);
 			break;
 		default:
-			printf("Fman1: 10GSEC%u set to unknown interface %i\n",
+			printf("Fman1: TGEC%u set to unknown interface %i\n",
 			       idx + 1, fm_info_get_enet_if(i));
 			fm_info_set_phy_address(i, 0);
 			break;
 		}
 	}
 
-
 	cpu_eth_init(bis);
 #endif
 
@@ -351,21 +365,82 @@
 {
 	int phy;
 	char alias[32];
+	struct fixed_link f_link;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 prtcl2 = in_be32(&gur->rcwsr[4]) & FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+
+	prtcl2 >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
 
 	if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_SGMII) {
 		phy = fm_info_get_phy_address(port);
 
 		sprintf(alias, "phy_sgmii_%x", phy);
 		fdt_set_phy_handle(fdt, compat, addr, alias);
+		fdt_status_okay_by_alias(fdt, alias);
+	} else if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_XGMII) {
+		/* check if it's XFI interface for 10g */
+		switch (prtcl2) {
+		case 0x80:
+		case 0x81:
+		case 0x82:
+		case 0x83:
+		case 0x84:
+		case 0x85:
+		case 0x86:
+		case 0x87:
+		case 0x88:
+		case 0x89:
+		case 0x8a:
+		case 0x8b:
+		case 0x8c:
+		case 0x8d:
+		case 0x8e:
+		case 0xb1:
+		case 0xb2:
+			f_link.phy_id = port;
+			f_link.duplex = 1;
+			f_link.link_speed = 10000;
+			f_link.pause = 0;
+			f_link.asym_pause = 0;
+
+			fdt_delprop(fdt, offset, "phy-handle");
+			fdt_setprop(fdt, offset, "fixed-link", &f_link,
+				    sizeof(f_link));
+			break;
+		case 0x98: /* XAUI interface */
+			sprintf(alias, "phy_xaui_slot1");
+			fdt_status_okay_by_alias(fdt, alias);
+
+			sprintf(alias, "phy_xaui_slot2");
+			fdt_status_okay_by_alias(fdt, alias);
+			break;
+		case 0x9e: /* XAUI interface */
+		case 0x9a:
+		case 0x93:
+		case 0x91:
+			sprintf(alias, "phy_xaui_slot1");
+			fdt_status_okay_by_alias(fdt, alias);
+			break;
+		case 0x97: /* XAUI interface */
+		case 0xc3:
+			sprintf(alias, "phy_xaui_slot2");
+			fdt_status_okay_by_alias(fdt, alias);
+			break;
+		default:
+			break;
+		}
 	}
 }
 
+/*
+ * Set status to disabled for unused ethernet node
+ */
 void fdt_fixup_board_enet(void *fdt)
 {
 	int i;
 	char alias[32];
 
-	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+	for (i = FM1_DTSEC1; i <= FM1_10GEC2; i++) {
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_NONE:
 			sprintf(alias, "ethernet%u", i);
--- u-boot-2014.07/board/freescale/b4860qds/law.c.orig	2022-05-09 14:06:21.613214890 -0700
+++ u-boot-2014.07/board/freescale/b4860qds/law.c	2022-05-09 14:06:23.281147427 -0700
@@ -17,9 +17,6 @@
 	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
 #endif
 	SET_LAW(QIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
-#ifdef CONFIG_SYS_MAPLE_MEM_PHYS
-	SET_LAW(CONFIG_SYS_MAPLE_MEM_PHYS, LAW_SIZE_16M, LAW_TRGT_IF_MAPLE),
-#endif
 #ifdef CONFIG_SYS_DCSRBAR_PHYS
 	/* Limit DCSR to 32M to access NPC Trace Buffer */
 	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_DCSR),
--- u-boot-2014.07/board/freescale/t4qds/eth.c.orig	2022-05-09 14:06:21.677212302 -0700
+++ u-boot-2014.07/board/freescale/t4qds/eth.c	2022-05-09 14:06:23.357144353 -0700
@@ -23,6 +23,7 @@
 #include <phy.h>
 #include <asm/fsl_dtsec.h>
 #include <asm/fsl_serdes.h>
+#include <hwconfig.h>
 #include "../common/qixis.h"
 #include "../common/fman.h"
 
@@ -173,6 +174,10 @@
 				enum fm_port port, int offset)
 {
 	int interface = fm_info_get_enet_if(port);
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 prtcl2 = in_be32(&gur->rcwsr[4]) & FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+
+	prtcl2 >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
 
 	if (interface == PHY_INTERFACE_MODE_SGMII ||
 	    interface == PHY_INTERFACE_MODE_QSGMII) {
@@ -262,6 +267,60 @@
 		default:
 			break;
 		}
+	} else if (interface == PHY_INTERFACE_MODE_XGMII &&
+		  ((prtcl2 == 55) || (prtcl2 == 57))) {
+		/*
+		 * if the 10G is XFI, check hwconfig to see what is the
+		 * media type, there are two types, fiber or copper,
+		 * fix the dtb accordingly.
+		 */
+		int media_type = 0;
+		struct fixed_link f_link;
+
+		switch (port) {
+		case FM1_10GEC1:
+			if (hwconfig_sub("fsl_10gkr_copper", "fm1_10g1")) {
+				media_type = 1;
+				fdt_set_phy_handle(blob, prop, pa,
+						   "phy_xfi1");
+			}
+			break;
+		case FM1_10GEC2:
+			if (hwconfig_sub("fsl_10gkr_copper", "fm1_10g2")) {
+				media_type = 1;
+				fdt_set_phy_handle(blob, prop, pa,
+						   "phy_xfi2");
+			}
+			break;
+		case FM2_10GEC1:
+			if (hwconfig_sub("fsl_10gkr_copper", "fm2_10g1")) {
+				media_type = 1;
+				fdt_set_phy_handle(blob, prop, pa,
+						   "phy_xfi3");
+			}
+			break;
+		case FM2_10GEC2:
+			if (hwconfig_sub("fsl_10gkr_copper", "fm2_10g2")) {
+				media_type = 1;
+				fdt_set_phy_handle(blob, prop, pa,
+						   "phy_xfi4");
+			}
+			break;
+		default:
+			break;
+		}
+
+		if (!media_type) {
+			/* fixed-link is used for XFI fiber cable */
+			fdt_delprop(blob, offset, "phy-handle");
+			f_link.phy_id = port;
+			f_link.duplex = 1;
+			f_link.link_speed = 10000;
+			f_link.pause = 0;
+			f_link.asym_pause = 0;
+			fdt_setprop(blob, offset, "fixed-link", &f_link,
+				    sizeof(f_link));
+		}
 	}
 }
 
@@ -295,8 +354,23 @@
 			break;
 		case PHY_INTERFACE_MODE_XGMII:
 			/* check if it's XFI interface for 10g */
-			if ((prtcl2 == 56) || (prtcl2 == 57)) {
-				fdt_status_okay_by_alias(fdt, "emi2_xfislot3");
+			if ((prtcl2 == 55) || (prtcl2 == 57)) {
+				if (i == FM1_10GEC1 && hwconfig_sub(
+					"fsl_10gkr_copper", "fm1_10g1"))
+					fdt_status_okay_by_alias(
+					fdt, "xfi_pcs_mdio1");
+				if (i == FM1_10GEC2 && hwconfig_sub(
+					"fsl_10gkr_copper", "fm1_10g2"))
+					fdt_status_okay_by_alias(
+					fdt, "xfi_pcs_mdio2");
+				if (i == FM2_10GEC1 && hwconfig_sub(
+					"fsl_10gkr_copper", "fm2_10g1"))
+					fdt_status_okay_by_alias(
+					fdt, "xfi_pcs_mdio3");
+				if (i == FM2_10GEC2 && hwconfig_sub(
+					"fsl_10gkr_copper", "fm2_10g2"))
+					fdt_status_okay_by_alias(
+					fdt, "xfi_pcs_mdio4");
 				break;
 			}
 			switch (i) {
@@ -460,7 +534,7 @@
 		fm_info_set_phy_address(FM1_DTSEC4, slot_qsgmii_phyaddr[2][3]);
 		fm_info_set_phy_address(FM1_DTSEC5, slot_qsgmii_phyaddr[1][0]);
 		fm_info_set_phy_address(FM1_DTSEC6, slot_qsgmii_phyaddr[1][1]);
-		if ((srds_prtcl_s2 != 56) && (srds_prtcl_s2 != 57)) {
+		if ((srds_prtcl_s2 != 55) && (srds_prtcl_s2 != 57)) {
 			fm_info_set_phy_address(FM1_DTSEC9,
 						slot_qsgmii_phyaddr[1][3]);
 			fm_info_set_phy_address(FM1_DTSEC10,
@@ -475,7 +549,7 @@
 		fm_info_set_phy_address(FM1_DTSEC4, slot_qsgmii_phyaddr[2][3]);
 		fm_info_set_phy_address(FM1_DTSEC5, slot_qsgmii_phyaddr[1][0]);
 		fm_info_set_phy_address(FM1_DTSEC6, slot_qsgmii_phyaddr[1][1]);
-		if ((srds_prtcl_s2 != 56) && (srds_prtcl_s2 != 57)) {
+		if ((srds_prtcl_s2 != 55) && (srds_prtcl_s2 != 57)) {
 			fm_info_set_phy_address(FM1_DTSEC9,
 						slot_qsgmii_phyaddr[1][2]);
 			fm_info_set_phy_address(FM1_DTSEC10,
@@ -490,7 +564,7 @@
 	case 48:
 		fm_info_set_phy_address(FM1_DTSEC5, slot_qsgmii_phyaddr[1][0]);
 		fm_info_set_phy_address(FM1_DTSEC6, slot_qsgmii_phyaddr[1][1]);
-		if ((srds_prtcl_s2 != 56) && (srds_prtcl_s2 != 57)) {
+		if ((srds_prtcl_s2 != 55) && (srds_prtcl_s2 != 57)) {
 			fm_info_set_phy_address(FM1_DTSEC10,
 						slot_qsgmii_phyaddr[1][2]);
 			fm_info_set_phy_address(FM1_DTSEC9,
@@ -567,13 +641,18 @@
 		idx = i - FM1_10GEC1;
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_XGMII:
-			lane = serdes_get_first_lane(FSL_SRDS_1,
+			if ((srds_prtcl_s2 == 55) || (srds_prtcl_s2 == 57)) {
+				/* A fake PHY address to make U-boot happy */
+				fm_info_set_phy_address(i, i);
+			} else {
+				lane = serdes_get_first_lane(FSL_SRDS_1,
 						XAUI_FM1_MAC9 + idx);
-			if (lane < 0)
-				break;
-			slot = lane_to_slot_fsm1[lane];
-			if (QIXIS_READ(present2) & (1 << (slot - 1)))
-				fm_disable_port(i);
+				if (lane < 0)
+					break;
+				slot = lane_to_slot_fsm1[lane];
+				if (QIXIS_READ(present2) & (1 << (slot - 1)))
+					fm_disable_port(i);
+			}
 			mdio_mux[i] = EMI2;
 			fm_info_set_mdio(i, mii_dev_for_muxval(mdio_mux[i]));
 			break;
@@ -666,7 +745,7 @@
 		fm_info_set_phy_address(FM2_DTSEC3, slot_qsgmii_phyaddr[4][2]);
 		fm_info_set_phy_address(FM2_DTSEC4, slot_qsgmii_phyaddr[4][3]);
 		break;
-	case 56:
+	case 55:
 	case 57:
 		/* XFI in Slot3, SGMII in Slot4 */
 		fm_info_set_phy_address(FM2_DTSEC1, slot_qsgmii_phyaddr[4][0]);
@@ -743,13 +822,18 @@
 		idx = i - FM2_10GEC1;
 		switch (fm_info_get_enet_if(i)) {
 		case PHY_INTERFACE_MODE_XGMII:
-			lane = serdes_get_first_lane(FSL_SRDS_2,
+			if ((srds_prtcl_s2 == 55) || (srds_prtcl_s2 == 57)) {
+				/* A fake PHY address to make U-boot happy */
+				fm_info_set_phy_address(i, i);
+			} else {
+				lane = serdes_get_first_lane(FSL_SRDS_2,
 						XAUI_FM2_MAC9 + idx);
-			if (lane < 0)
-				break;
-			slot = lane_to_slot_fsm2[lane];
-			if (QIXIS_READ(present2) & (1 << (slot - 1)))
-				fm_disable_port(i);
+				if (lane < 0)
+					break;
+				slot = lane_to_slot_fsm2[lane];
+				if (QIXIS_READ(present2) & (1 << (slot - 1)))
+					fm_disable_port(i);
+			}
 			mdio_mux[i] = EMI2;
 			fm_info_set_mdio(i, mii_dev_for_muxval(mdio_mux[i]));
 			break;
--- u-boot-2014.07/board/freescale/t104xrdb/Makefile.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t104xrdb/Makefile	2022-05-09 14:06:23.353144515 -0700
@@ -11,6 +11,7 @@
 obj-y	+= cpld.o
 obj-y	+= eth.o
 obj-$(CONFIG_PCI)	+= pci.o
+obj-$(CONFIG_FSL_DIU_FB)+= diu.o
 endif
 obj-y	+= ddr.o
 obj-y	+= law.o
--- u-boot-2014.07/board/freescale/t104xrdb/README.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t104xrdb/README	2022-05-09 14:06:23.353144515 -0700
@@ -4,10 +4,23 @@
 (and variants). Variants inclued T1042 presonality of T1040, in which
 case T1040RDB can also be called T1042RDB.
 
+The T1042RDB is a Freescale reference board that hosts the T1042 SoC
+(and variants). The board is similar to T1040RDB, T1040 is a reduced
+personality of T1040 SoC without Integrated 8-port Gigabit(L2 Switch).
+
 The T1042RDB_PI is a Freescale reference board that hosts the T1042 SoC.
 (a personality of T1040 SoC). The board is similar to T1040RDB but is
 designed specially with low power features targeted for Printing Image Market.
 
+Basic difference's among T1040RDB, T1042RDB_PI, T1042RDB
+-------------------------------------------------------------------------
+Board		Si		Protocol		Targeted Market
+-------------------------------------------------------------------------
+T1040RDB	T1040		0x66                    Networking
+T1040RDB	T1042		0x86                    Networking
+T1042RDB_PI	T1042		0x06                    Printing & Imaging
+
+
 T1040 SoC Overview
 ------------------
 The QorIQ T1040/T1042 processor support four integrated 64-bit e5500 PA
@@ -194,10 +207,10 @@
    Commands for switching to alternate bank.
 
 	1. To change from vbank0 to vbank4
-		=> qixis_reset altbank (it will boot using vbank4)
+		=> cpld reset altbank (it will boot using vbank4)
 
 	2.To change from vbank4 to vbank0
-		=> qixis reset (it will boot using vbank0)
+		=> cpld reset (it will boot using vbank0)
 
 NAND boot with 2 Stage boot loader
 ----------------------------------
@@ -259,15 +272,15 @@
 ===============
 NAND boot SW setting:
 SW1: 10001000
-SW2: 00111001
+SW2: 00111011
 SW3: 11110001
 
 SPI boot SW setting:
 SW1: 00100010
-SW2: 10111001
+SW2: 10111011
 SW3: 11100001
 
 SD boot SW setting:
 SW1: 00100000
-SW2: 00111001
+SW2: 00111011
 SW3: 11100001
--- u-boot-2014.07/board/freescale/t104xrdb/t104xrdb.c.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t104xrdb/t104xrdb.c	2022-05-09 14:06:23.357144353 -0700
@@ -106,8 +106,20 @@
 #endif
 }
 
-#ifdef CONFIG_DEEP_SLEEP
-void board_mem_sleep_setup(void)
+#ifdef CONFIG_FSL_DEEP_SLEEP
+/* determine if it is a warm boot */
+bool is_warm_boot(void)
+{
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	if (in_be32(&gur->scrtsr[0]) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_mem_setup(void)
 {
 	/* does not provide HW signals for power management */
 	CPLD_WRITE(misc_ctl_status, (CPLD_READ(misc_ctl_status) & ~0x40));
@@ -115,4 +127,50 @@
 	gpio_set_value(2, 0);
 	udelay(1);
 }
+
+void fsl_dp_ddr_restore(void)
+{
+#define DDR_BUFF_LEN	128
+	volatile u64 *src, *dst;
+	int i;
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	if (!is_warm_boot())
+		return;
+
+	/* get the address of ddr date from SPARECR3 */
+	src = (u64 *)in_be32(&scfg->sparecr[2]);
+	dst = (u64 *)CONFIG_SYS_SDRAM_BASE;
+
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst++ = *src++;
+
+	flush_dcache();
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	if (!is_warm_boot())
+		return 0;
+
+	fsl_dp_ddr_restore();
+
+	l2cache_init();
+#if defined(CONFIG_RAMBOOT_PBL)
+	disable_cpc_sram();
+#endif
+	enable_cpc();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_be32(&scfg->sparecr[1]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	kernel_resume();
+
+	return 0;
+}
 #endif
--- u-boot-2014.07/board/freescale/t104xrdb/eth.c.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t104xrdb/eth.c	2022-05-09 14:06:23.353144515 -0700
@@ -43,6 +43,16 @@
 						CONFIG_SYS_SGMII1_PHY_ADDR);
 			break;
 #endif
+#ifdef CONFIG_T1042RDB
+		case PHY_INTERFACE_MODE_SGMII:
+			/* T1042RDB doesn't supports SGMII on DTSEC1 & DTSEC2 */
+			if ((FM1_DTSEC1 == i) || (FM1_DTSEC2 == i))
+				fm_info_set_phy_address(i, 0);
+			/* T1042RDB only supports SGMII on DTSEC3 */
+			fm_info_set_phy_address(FM1_DTSEC3,
+						CONFIG_SYS_SGMII1_PHY_ADDR);
+			break;
+#endif
 		case PHY_INTERFACE_MODE_RGMII:
 			if (FM1_DTSEC4 == i)
 				phy_addr = CONFIG_SYS_RGMII1_PHY_ADDR;
--- u-boot-2014.07/board/freescale/t104xrdb/t104x_pbi.cfg.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t104xrdb/t104x_pbi.cfg	2022-05-09 14:06:23.357144353 -0700
@@ -1,4 +1,14 @@
 #PBI commands
+#Software Workaround for errata A-007662 to train PCIe2 controller in Gen2 speed
+09250100 00000400
+09250108 00002000
+#Software Workaround for errata A-008007 to reset PVR register
+09000010 0000000b
+09000014 c0000000
+09000018 81d00017
+89020400 a1000000
+091380c0 000f0000
+89020400 00000000
 #Initialize CPC1
 09010000 00200400
 09138000 00000000
--- u-boot-2014.07/board/freescale/t104xrdb/ddr.c.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t104xrdb/ddr.c	2022-05-09 14:06:23.353144515 -0700
@@ -105,8 +105,8 @@
 	popts->zq_en = 1;
 
 	/* DHC_EN =1, ODT = 75 Ohm */
-	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_OFF);
-	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_OFF);
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
 }
 
 phys_size_t initdram(int board_type)
--- u-boot-2014.07/board/freescale/t104xrdb/spl.c.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t104xrdb/spl.c	2022-05-09 14:06:23.353144515 -0700
@@ -11,9 +11,34 @@
 #include <mmc.h>
 #include <fsl_esdhc.h>
 #include <spi_flash.h>
+#include <asm/mpc85xx_gpio.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_FSL_DEEP_SLEEP
+bool is_warm_boot(void)
+{
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	if (in_be32(&gur->scrtsr[0]) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_mem_setup(void)
+{
+	void __iomem *cpld_base = (void *)CONFIG_SYS_CPLD_BASE;
+
+	/* does not provide HW signals for power management */
+	clrbits_8(cpld_base + 0x17, 0x40);
+	/* Disable MCKE isolation */
+	gpio_set_value(2, 0);
+	udelay(1);
+}
+#endif
+
 phys_size_t get_effective_memsize(void)
 {
 	return CONFIG_SYS_L3_SIZE;
@@ -33,20 +58,26 @@
 void board_init_f(ulong bootflag)
 {
 	u32 plat_ratio, sys_clk, uart_clk;
-#ifdef CONFIG_SPL_NAND_BOOT
+#if defined(CONFIG_SPL_NAND_BOOT) && defined(CONFIG_A008044_WORKAROUND)
 	u32 porsr1, pinctl;
+	u32 svr = get_svr();
 #endif
 	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
 
-#ifdef CONFIG_SPL_NAND_BOOT
-	/*
-	 * There is T1040 SoC issue where NOR, FPGA are inaccessible during
-	 * NAND boot because IFC signals > IFC_AD7 are not enabled.
-	 * This workaround changes RCW source to make all signals enabled.
-	 */
-	porsr1 = in_be32(&gur->porsr1);
-	pinctl = ((porsr1 & ~(FSL_CORENET_CCSR_PORSR1_RCW_MASK)) | 0x24800000);
-	out_be32((unsigned int *)(CONFIG_SYS_DCSRBAR + 0x20000), pinctl);
+#if defined(CONFIG_SPL_NAND_BOOT) && defined(CONFIG_A008044_WORKAROUND)
+	if (IS_SVR_REV(svr, 1, 0)) {
+		/*
+		 * There is T1040 SoC issue where NOR, FPGA are inaccessible
+		 * during NAND boot because IFC signals > IFC_AD7 are not
+		 * enabled. This workaround changes RCW source to make all
+		 * signals enabled.
+		 */
+		porsr1 = in_be32(&gur->porsr1);
+		pinctl = ((porsr1 & ~(FSL_CORENET_CCSR_PORSR1_RCW_MASK))
+			  | 0x24800000);
+		out_be32((unsigned int *)(CONFIG_SYS_DCSRBAR + 0x20000),
+			 pinctl);
+	}
 #endif
 
 	/* Memcpy existing GD at CONFIG_SPL_GD_ADDR */
@@ -55,6 +86,11 @@
 	/* Update GD pointer */
 	gd = (gd_t *)(CONFIG_SPL_GD_ADDR);
 
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	/* disable the console if boot from deep sleep */
+	if (is_warm_boot())
+		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+#endif
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("" : : : "memory");
 
--- u-boot-2014.07/board/freescale/t208xqds/ddr.h.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t208xqds/ddr.h	2022-05-09 14:06:23.357144353 -0700
@@ -28,17 +28,16 @@
 	 *   num|  hi| rank|  clk| wrlvl | wrlvl | wrlvl |
 	 * ranks| mhz| GB  |adjst| start | ctl2  | ctl3  |
 	 */
-	{2,  1200,  0,  5,  7,  0x0808090a,  0x0b0c0c0a},
-	{2,  1500,  0,  5,  6,  0x07070809,  0x0a0b0b09},
-	{2,  1600,  0,  5,  8,  0x090b0b0d,  0x0d0e0f0b},
-	{2,  1700,  0,  4,  7,  0x080a0a0c,  0x0c0d0e0a},
-	{2,  1900,  0,  5,  9,  0x0a0b0c0e,  0x0f10120c},
-	{2,  2140,  0,  4,  8,  0x090a0b0d,  0x0e0f110b},
+	{2,  1200,  0,  5,  7,  0x0708090a,  0x0b0c0d09},
+	{2,  1400,  0,  5,  7,  0x08090a0c,  0x0d0e0f0a},
+	{2,  1700,  0,  5,  8,  0x090a0b0c,  0x0e10110c},
+	{2,  1900,  0,  5,  8,  0x090b0c0f,  0x1012130d},
+	{2,  2140,  0,  5,  8,  0x090b0c0f,  0x1012130d},
 	{1,  1200,  0,  5,  7,  0x0808090a,  0x0b0c0c0a},
 	{1,  1500,  0,  5,  6,  0x07070809,  0x0a0b0b09},
 	{1,  1600,  0,  5,  8,  0x090b0b0d,  0x0d0e0f0b},
-	{1,  1700,  0,  4,  7,  0x080a0a0c,  0x0c0d0e0a},
-	{1,  1900,  0,  5,  9,  0x0a0b0c0e,  0x0f10120c},
+	{1,  1700,  0,  4,  8,  0x080a0a0c,  0x0c0d0e0a},
+	{1,  1900,  0,  5,  8,  0x090a0c0d,  0x0e0f110c},
 	{1,  2140,  0,  4,  8,  0x090a0b0d,  0x0e0f110b},
 	{}
 };
--- u-boot-2014.07/board/freescale/t208xqds/t208xqds.c.orig	2022-05-09 14:06:21.673212464 -0700
+++ u-boot-2014.07/board/freescale/t208xqds/t208xqds.c	2022-05-09 14:06:23.357144353 -0700
@@ -20,6 +20,7 @@
 
 #include "../common/qixis.h"
 #include "../common/vsc3316_3308.h"
+#include "../common/vid.h"
 #include "t208xqds.h"
 #include "t208xqds_qixis.h"
 
@@ -86,6 +87,11 @@
 	return 0;
 }
 
+int i2c_multiplexer_select_vid_channel(u8 channel)
+{
+	return select_i2c_ch_pca9547(channel);
+}
+
 int brd_mux_lane_to_slot(void)
 {
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
@@ -352,6 +358,13 @@
 	/* Disable remote I2C connection to qixis fpga */
 	QIXIS_WRITE(brdcfg[5], QIXIS_READ(brdcfg[5]) & ~BRDCFG5_IRE);
 
+	/*
+	 * Adjust core voltage according to voltage ID
+	 * This function changes I2C mux to channel 2.
+	 */
+	if (adjust_vdd(0))
+		printf("Warning: Adjusting core voltage failed.\n");
+
 	brd_mux_lane_to_slot();
 	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
 
--- u-boot-2014.07/board/freescale/t208xqds/t2080_rcw.cfg.orig	2022-05-09 14:06:21.673212464 -0700
+++ u-boot-2014.07/board/freescale/t208xqds/t2080_rcw.cfg	2022-05-09 14:06:23.357144353 -0700
@@ -1,8 +1,16 @@
 #PBL preamble and RCW header
 aa55aa55 010e0100
-#SerDes Protocol: 0x66_0x16
-#Core/DDR: 1533Mhz/2133MT/s
-12100017 15000000 00000000 00000000
-66150002 00008400 e8104000 c1000000
+
+#For T2080 v1.0
+#SerDes=0x66_0x16, Core=1533MHz, DDR=2133MT/s
+#12100017 15000000 00000000 00000000
+#66150002 00008400 e8104000 c1000000
+#00000000 00000000 00000000 000307fc
+#00000000 00000000 00000000 00000004
+
+#For T2080 v1.1
+#SerDes=0x66_0x15, Core=1800MHz, DDR=1867MT/s
+0c070012 0e000000 00000000 00000000
+66150002 00000000 e8104000 c1000000
 00000000 00000000 00000000 000307fc
 00000000 00000000 00000000 00000004
--- u-boot-2014.07/board/freescale/corenet_ds/eth_hydra.c.orig	2022-05-09 14:06:21.621214567 -0700
+++ u-boot-2014.07/board/freescale/corenet_ds/eth_hydra.c	2022-05-09 14:06:23.289147104 -0700
@@ -62,7 +62,7 @@
 
 #ifdef CONFIG_FMAN_ENET
 
-#define BRDCFG1_EMI1_SEL_MASK	0x70
+#define BRDCFG1_EMI1_SEL_MASK	0x78
 #define BRDCFG1_EMI1_SEL_SLOT1	0x10
 #define BRDCFG1_EMI1_SEL_SLOT2	0x20
 #define BRDCFG1_EMI1_SEL_SLOT5	0x30
@@ -202,6 +202,8 @@
 	if (!path)
 		path = alias;
 
+	do_fixup_by_path(fdt, path, "reg",
+			 &mux, sizeof(mux), 1);
 	do_fixup_by_path(fdt, path, "fsl,hydra-mdio-muxval",
 			 &mux, sizeof(mux), 1);
 }
@@ -250,11 +252,12 @@
 		return;
 	}
 
-	if (mux == BRDCFG1_EMI1_SEL_RGMII) {
+	if (mux == (BRDCFG1_EMI1_SEL_RGMII | BRDCFG1_EMI1_EN)) {
 		/* RGMII */
 		/* The RGMII PHY is identified by the MAC connected to it */
 		sprintf(phy, "phy_rgmii_%u", port == FM1_DTSEC4 ? 0 : 1);
 		fdt_set_phy_handle(fdt, compat, addr, phy);
+		return;
 	}
 
 	/* If it's not RGMII or XGMII, it must be SGMII */
--- u-boot-2014.07/board/freescale/t4rdb/eth.c.orig	2022-05-09 14:06:21.677212302 -0700
+++ u-boot-2014.07/board/freescale/t4rdb/eth.c	2022-05-09 14:06:23.361144192 -0700
@@ -101,7 +101,7 @@
 	}
 
 #if (CONFIG_SYS_NUM_FMAN == 2)
-	if (srds_prtcl_s2 == 56) {
+	if ((srds_prtcl_s2 == 56) || (srds_prtcl_s2 == 55)) {
 		/* SGMII && XFI */
 		fm_info_set_phy_address(FM2_DTSEC1, SGMII_PHY_ADDR5);
 		fm_info_set_phy_address(FM2_DTSEC2, SGMII_PHY_ADDR6);
--- u-boot-2014.07/board/freescale/t4rdb/t4240rdb.c.orig	2022-05-09 14:06:21.677212302 -0700
+++ u-boot-2014.07/board/freescale/t4rdb/t4240rdb.c	2022-05-09 14:06:23.361144192 -0700
@@ -20,14 +20,26 @@
 #include <fm_eth.h>
 
 #include "t4rdb.h"
+#include "cpld.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
 int checkboard(void)
 {
 	struct cpu_type *cpu = gd->arch.cpu;
+	u8 sw;
 
 	printf("Board: %sRDB, ", cpu->name);
+	printf("Board rev: 0x%02x CPLD ver: 0x%02x%02x, ",
+	       CPLD_READ(hw_ver), CPLD_READ(sw_maj_ver), CPLD_READ(sw_min_ver));
+
+	sw = CPLD_READ(vbank);
+	sw = sw & CPLD_BANK_SEL_MASK;
+
+	if (sw <= 7)
+		printf("vBank: %d\n", sw);
+	else
+		printf("Unsupported Bank=%x\n", sw);
 
 	puts("SERDES Reference Clocks:\n");
 	printf("       SERDES1=100MHz SERDES2=156.25MHz\n"
--- u-boot-2014.07/board/freescale/t4rdb/tlb.c.orig	2022-05-09 14:06:21.677212302 -0700
+++ u-boot-2014.07/board/freescale/t4rdb/tlb.c	2022-05-09 14:06:23.361144192 -0700
@@ -106,6 +106,11 @@
 		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 		      0, 16, BOOKE_PAGESZ_64K, 1),
 #endif
+#ifdef CONFIG_SYS_CPLD_BASE
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE_PHYS,
+		      MAS3_SW|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 17, BOOKE_PAGESZ_4K, 1),
+#endif
 };
 
 int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2014.07/board/freescale/t4rdb/law.c.orig	2022-05-09 14:06:21.677212302 -0700
+++ u-boot-2014.07/board/freescale/t4rdb/law.c	2022-05-09 14:06:23.361144192 -0700
@@ -16,6 +16,9 @@
 #ifdef CONFIG_SYS_QMAN_MEM_PHYS
 	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
 #endif
+#ifdef CONFIG_SYS_CPLD_BASE_PHYS
+	SET_LAW(CONFIG_SYS_CPLD_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+#endif
 #ifdef CONFIG_SYS_DCSRBAR_PHYS
 	/* Limit DCSR to 32M to access NPC Trace Buffer */
 	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_DCSR),
--- u-boot-2014.07/board/freescale/t4rdb/t4_rcw.cfg.orig	2022-05-09 14:06:21.677212302 -0700
+++ u-boot-2014.07/board/freescale/t4rdb/t4_rcw.cfg	2022-05-09 14:06:23.361144192 -0700
@@ -1,7 +1,7 @@
 #PBL preamble and RCW header
 aa55aa55 010e0100
-#serdes protocol  27_56_1_9
+#serdes protocol  27_55_1_9
 16070019 18101916 00000000 00000000
-6c700848 00448c00 6c020000 f5000000
+6c6e0848 00448c00 6c020000 f5000000
 00000000 ee0000ee 00000000 000287fc
 00000000 50000000 00000000 00000028
--- u-boot-2014.07/board/freescale/t4rdb/Makefile.orig	2022-05-09 14:06:21.677212302 -0700
+++ u-boot-2014.07/board/freescale/t4rdb/Makefile	2022-05-09 14:06:23.361144192 -0700
@@ -5,6 +5,7 @@
 #
 
 obj-$(CONFIG_T4240RDB) += t4240rdb.o
+obj-y	+= cpld.o
 obj-y	+= ddr.o
 obj-y	+= eth.o
 obj-$(CONFIG_PCI)	+= pci.o
--- u-boot-2014.07/board/freescale/vf610twr/vf610twr.c.orig	2022-05-09 14:06:21.681212140 -0700
+++ u-boot-2014.07/board/freescale/vf610twr/vf610twr.c	2022-05-09 14:06:23.361144192 -0700
@@ -429,3 +429,27 @@
 
 	return 0;
 }
+
+int board_spi_find_bus(unsigned int bus, unsigned int cs)
+{
+	switch (bus) {
+	case SPI_BUS_FSL_QSPI:
+		break;
+	default:
+		return -1;
+	}
+
+	switch (bus) {
+	case SPI_BUS_FSL_QSPI:
+		if (cs == 0)
+			return 0;
+	default:
+		return -1;
+	}
+}
+
+void board_print_spi_device(void)
+{
+	printf("vf610twr spi flash info:\n");
+	printf("S25FL128S is on spi bus 0 cs 0\n");
+}
--- u-boot-2014.07/board/freescale/p1_p2_rdb/law.c.orig	2022-05-09 14:06:21.661212949 -0700
+++ u-boot-2014.07/board/freescale/p1_p2_rdb/law.c	2022-05-09 14:06:23.345144839 -0700
@@ -1,7 +1,23 @@
 /*
  * Copyright 2009-2010 Freescale Semiconductor, Inc.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <common.h>
--- u-boot-2014.07/board/freescale/p1_p2_rdb/tlb.c.orig	2022-05-09 14:06:21.661212949 -0700
+++ u-boot-2014.07/board/freescale/p1_p2_rdb/tlb.c	2022-05-09 14:06:23.345144839 -0700
@@ -1,7 +1,23 @@
 /*
  * Copyright 2011 Freescale Semiconductor, Inc.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <common.h>
@@ -37,7 +53,6 @@
 			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 			0, 1, BOOKE_PAGESZ_1M, 1),
 
-#ifndef CONFIG_SPL_BUILD
 	/* W**G* - Flash/promjet, localbus */
 	/* This will be changed to *I*G* after relocation to RAM. */
 	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
@@ -56,7 +71,6 @@
 			0, 4, BOOKE_PAGESZ_256K, 1),
 
 #endif /* #if defined(CONFIG_PCI) */
-#endif
 	/* *I*G - NAND */
 	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
 			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
@@ -67,21 +81,7 @@
 			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
 			0, 6, BOOKE_PAGESZ_1M, 1),
 
-#ifdef CONFIG_SYS_INIT_L2_ADDR
-	/* *I*G - L2SRAM */
-	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L2_ADDR, CONFIG_SYS_INIT_L2_ADDR_PHYS,
-		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_G,
-		      0, 11, BOOKE_PAGESZ_256K, 1),
-#if CONFIG_SYS_L2_SIZE >= (256 << 10)
-	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L2_ADDR + 0x40000,
-		      CONFIG_SYS_INIT_L2_ADDR_PHYS + 0x40000,
-		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
-		      0, 12, BOOKE_PAGESZ_256K, 1),
-#endif
-#endif
-
-#if defined(CONFIG_SYS_RAMBOOT) || \
-	(defined(CONFIG_SPL) && !defined(CONFIG_SPL_COMMON_INIT_DDR))
+#if defined(CONFIG_SYS_RAMBOOT)
 	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
 			MAS3_SX|MAS3_SW|MAS3_SR, 0,
 			0, 7, BOOKE_PAGESZ_1G, 1)
--- u-boot-2014.07/board/freescale/p1_p2_rdb/pci.c.orig	2022-05-09 14:06:21.661212949 -0700
+++ u-boot-2014.07/board/freescale/p1_p2_rdb/pci.c	2022-05-09 14:06:23.345144839 -0700
@@ -1,7 +1,23 @@
 /*
  * Copyright 2009-2010 Freescale Semiconductor, Inc.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <common.h>
--- u-boot-2014.07/board/freescale/p1_p2_rdb/ddr.c.orig	2022-05-09 14:06:21.661212949 -0700
+++ u-boot-2014.07/board/freescale/p1_p2_rdb/ddr.c	2022-05-09 14:06:23.345144839 -0700
@@ -1,7 +1,23 @@
 /*
  * Copyright 2009, 2011 Freescale Semiconductor, Inc.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <common.h>
@@ -14,6 +30,115 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_WGXTM_BOREN_TESTER /* DDR Settings for  */
+#if defined(CONFIG_WGXTM_T50_BOREN)
+/* DDR setup for T50: DDR size = 2048M */
+/* P1020 w/ 2G DDR3 */
+#define CONFIG_SYS_DDR_CS0_BNDS			0x0000007F
+#define CONFIG_SYS_DDR_CS0_CONFIG		0x80014402
+#define CONFIG_SYS_DDR_CS0_CONFIG_2		0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR		0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL		0x00000000 
+#define CONFIG_SYS_DDR_ZQ_CONTROL		0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655F607
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xC70C0008	/* Type = DDR3*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401010
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x02401400
+
+#define CONFIG_SYS_DDR_TIMING_3_400	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_400	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_400	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_400	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_400	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_400	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_400	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_400	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_533	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_533	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_533	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_533	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_533	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_533	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_533	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_533	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00070000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x6f6b0644
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0FA8910c/* tFAW as 17 clks */
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00061220
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0A280000//0x0A28028A
+
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6F6D8644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA890CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_800	0x00061420
+#define CONFIG_SYS_DDR_MODE_2_800	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0C300000//0x0C30030C
+#elif defined(CONFIG_WGXTM_T30_BOREN)	/* P1011, DDR setup for T30: DDR size = 1024M */
+/* P1020 w/ 1G DDR3 */
+#define CONFIG_SYS_DDR_CS0_BNDS			0x0000003F
+#define CONFIG_SYS_DDR_CS0_CONFIG		0x80014302
+#define CONFIG_SYS_DDR_CS0_CONFIG_2		0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR		0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL		0x00000000 
+#define CONFIG_SYS_DDR_ZQ_CONTROL		0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655F607
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xC70C0008	/* Type = DDR3*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401010
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x02401400
+
+#define CONFIG_SYS_DDR_TIMING_3_400	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_400	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_400	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_400	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_400	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_400	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_400	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_400	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_533	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_533	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_533	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_533	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_533	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_533	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_533	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_533	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x5D5BD544
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0FA890D1/* tFAW as 17 clks */
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00061220
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0A280000//0x0A28028A
+
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6F6D8644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA890CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_800	0x00061420
+#define CONFIG_SYS_DDR_MODE_2_800	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0C300000//0x0C30030C
+#else //(_SC_DRAM_SIZE_ == 512)
 #define CONFIG_SYS_DDR_CS0_BNDS		0x0000003F
 #define CONFIG_SYS_DDR_CS0_CONFIG	0x80014202
 #define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
@@ -65,6 +190,8 @@
 #define CONFIG_SYS_DDR_MODE_1_800	0x00040852
 #define CONFIG_SYS_DDR_MODE_2_800	0x00000000
 #define CONFIG_SYS_DDR_INTERVAL_800	0x0c300100
+#endif
+#endif /* END_OF_AP331IB */
 
 fsl_ddr_cfg_regs_t ddr_cfg_regs_400 = {
 	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
@@ -180,6 +307,7 @@
 
 phys_size_t fixed_sdram (void)
 {
+	char buf[32];
 	fsl_ddr_cfg_regs_t ddr_cfg_regs;
 	size_t ddr_size;
 	struct cpu_type *cpu;
@@ -195,7 +323,8 @@
 	ddr_freq = get_ddr_freq(0);
 	ddr_freq_mhz = ddr_freq / 1000000;
 
-	printf("Configuring DDR for %ld T/s data rate\n", ddr_freq);
+	printf("Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, ddr_freq));
 
 	if(ddr_freq_mhz <= 400)
 		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_400, sizeof(ddr_cfg_regs));
@@ -206,16 +335,25 @@
 	else if(ddr_freq_mhz <= 800)
 		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_800, sizeof(ddr_cfg_regs));
 	else
-		panic("Unsupported DDR data rate %ld T/s\n", ddr_freq);
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+					strmhz(buf, ddr_freq));
 
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+	/* disable DRAM Bus 32bit width support, we applied 16bit in AP331IB */
 	/* P1020 and it's derivatives support max 32bit DDR width */
 	if (cpu->soc_ver == SVR_P1020 || cpu->soc_ver == SVR_P1011) {
 		ddr_cfg_regs.ddr_sdram_cfg |= SDRAM_CFG_32_BE;
-		ddr_cfg_regs.cs[0].bnds = 0x0000001F;
+		//ddr_cfg_regs.cs[0].bnds = 0x0000001F;
 	}
-
+#endif /* END_OF_AP331IB */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+	ddr_cfg_regs.ddr_cdr1 = 0x80080000;//DDR_CDR1_DHC_EN;
+	ddr_cfg_regs.ddr_cdr2 = 0x00000001;//DDR_CDR1_DHC_EN;
+    printf("Set HW AUTO ODT\n");
+    //out_be32(&ddr->timing_cfg_3, regs->timing_cfg_3);
+	//ddr_cfg_regs.ddr_cdr1 |= DDR_CDR1_DHC_EN;
+#endif
 	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
-
 	set_ddr_laws(0, ddr_size, LAW_TRGT_IF_DDR_1);
 	return ddr_size;
 }
--- u-boot-2014.07/board/freescale/p1_p2_rdb/p1_p2_rdb.c.orig	2022-05-09 14:06:21.661212949 -0700
+++ u-boot-2014.07/board/freescale/p1_p2_rdb/p1_p2_rdb.c	2022-05-09 14:06:23.345144839 -0700
@@ -1,7 +1,23 @@
 /*
  * Copyright 2009-2011 Freescale Semiconductor, Inc.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 #include <common.h>
@@ -15,7 +31,6 @@
 #include <miiphy.h>
 #include <libfdt.h>
 #include <fdt_support.h>
-#include <fsl_mdio.h>
 #include <tsec.h>
 #include <vsc7385.h>
 #include <netdev.h>
@@ -52,6 +67,7 @@
 {
 	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
 	u32 val_gpdat, sysclk_gpio;
+	return SYSCLK_66;
 
 	val_gpdat = in_be32(&pgpio->gpdat);
 	sysclk_gpio = val_gpdat & SYSCLK_MASK;
@@ -78,11 +94,19 @@
 
 int checkboard (void)
 {
-	u32 val_gpdat, board_rev_gpio;
 	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+#ifdef CONFIG_WGXTM_BOREN_TESTER
+	char board_rev[] = "Boren Board";
+#else
+	u32 val_gpdat, board_rev_gpio;
 	char board_rev = 0;
+#endif
 	struct cpu_type *cpu;
 
+#ifdef CONFIG_WGXTM_BOREN_TESTER
+	cpu = gd->arch.cpu;
+	printf ("Board: %sRDB Rev[%s]\n", cpu->name, board_rev);
+#else
 	val_gpdat = in_be32(&pgpio->gpdat);
 	board_rev_gpio = val_gpdat & BOARDREV_MASK;
 	if (board_rev_gpio == BOARDREV_C)
@@ -94,6 +118,7 @@
 
 	cpu = gd->arch.cpu;
 	printf ("Board: %sRDB Rev%c\n", cpu->name, board_rev);
+#endif /* end of CONFIG_WGXTM_BOREN */
 
 	setbits_be32(&pgpio->gpdir, GPIO_DIR);
 
@@ -214,7 +239,6 @@
 	} else
 		puts("No address specified for VSC7385 microcode.\n");
 #endif
-
 	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
 	mdio_info.name = DEFAULT_MII_NAME;
 	fsl_pq_mdio_init(bis, &mdio_info);
@@ -246,9 +270,7 @@
 
 	fdt_fixup_memory(blob, (u64)base, (u64)size);
 
-#if defined(CONFIG_HAS_FSL_DR_USB)
 	fdt_fixup_dr_usb(blob, bd);
-#endif
 
 #if defined(CONFIG_SDCARD) || defined(CONFIG_SPIFLASH)
 	/* Delete eLBC node as it is muxed with USB2 controller */
--- u-boot-2014.07/board/freescale/mpc837xemds/mpc837xemds.c.orig	2022-05-09 14:06:21.637213920 -0700
+++ u-boot-2014.07/board/freescale/mpc837xemds/mpc837xemds.c	2022-05-09 14:06:23.325145648 -0700
@@ -10,7 +10,6 @@
 #include <i2c.h>
 #include <asm/io.h>
 #include <asm/fsl_mpc83xx_serdes.h>
-#include <asm/fsl_enet.h>
 #include <spd_sdram.h>
 #include <tsec.h>
 #include <libfdt.h>
--- u-boot-2014.07/board/freescale/common/sys_eeprom.c.orig	2022-05-09 14:06:21.617214729 -0700
+++ u-boot-2014.07/board/freescale/common/sys_eeprom.c	2022-05-09 14:06:23.289147104 -0700
@@ -21,7 +21,7 @@
 /* some boards with non-256-bytes EEPROM have special define */
 /* for MAX_NUM_PORTS in board-specific file */
 #ifndef MAX_NUM_PORTS
-#define MAX_NUM_PORTS	16
+#define MAX_NUM_PORTS	8
 #endif
 #define NXID_VERSION	1
 #endif
@@ -47,7 +47,11 @@
 #endif
 #ifdef CONFIG_SYS_I2C_EEPROM_NXID
 	u8 id[4];         /* 0x00 - 0x03 EEPROM Tag 'NXID' */
+#ifdef CONFIG_LANNER_BURN
+	u8 sn[16];        /* 0x04 - 0x13 LANNER Serial Number */
+#else
 	u8 sn[12];        /* 0x04 - 0x0F Serial Number */
+#endif
 	u8 errata[5];     /* 0x10 - 0x14 Errata Level */
 	u8 date[6];       /* 0x15 - 0x1a Build Date */
 	u8 res_0;         /* 0x1b        Reserved */
@@ -90,7 +94,7 @@
 	/* EEPROM tag ID, either CCID or NXID */
 #ifdef CONFIG_SYS_I2C_EEPROM_NXID
 	printf("ID: %c%c%c%c v%u\n", e.id[0], e.id[1], e.id[2], e.id[3],
-		be32_to_cpu(e.version));
+	       e.version);
 #else
 	printf("ID: %c%c%c%c\n", e.id[0], e.id[1], e.id[2], e.id[3]);
 #endif
@@ -306,21 +310,105 @@
 {
 	char *p = (char *) string;
 	unsigned int i;
+#ifdef CONFIG_LANNER_BURN
+       int j;
+       int flag =0;
+#endif
+
 
 	if ((index >= MAX_NUM_PORTS) || !string) {
+#ifdef CONFIG_LANNER_BURN
+		printf("Usage: mac <n> XXXXXXXXXXXX\n");
+#else
 		printf("Usage: mac <n> XX:XX:XX:XX:XX:XX\n");
+#endif
 		return;
 	}
 
+#ifdef CONFIG_LANNER_BURN
+	for (i = 0; *p && (i < 6); i++) {
+		e.mac[0][i] = h2i(p[i*2]) *16 + h2i(p[i*2 +1]);
+	}
+	if( index >= 1)
+	{
+		for( i = 0 ; i < index-1 ;i++)
+		{
+			flag = 0; 
+			for( j = 5 ; j >= 0 ;j-- )
+			{
+				switch(j)
+				{
+				case 5:
+					if(e.mac[i][j] == 0xff)
+					{
+						flag = flag | (1<<(j-1));
+						e.mac[i+1][j] = 0;
+					}
+					else
+					{
+						e.mac[i+1][j] = e.mac[i][j] + 1;
+					}
+					break;
+				case 4:
+				case 3: 
+				case 2:
+				case 1:
+					if(e.mac[i][j] != 0xff)
+					{
+						if((flag & (1<< j)) != 0)
+							e.mac[i+1][j] = e.mac[i][j] + 1 ;
+						else
+							e.mac[i+1][j] = e.mac[i][j];
+					} 
+					else
+					{
+						if((flag & (1<< j)) != 0)
+						{
+							flag = flag | (1<<(j-1));
+							e.mac[i+1][j] = 0;
+						}
+						else
+							e.mac[i+1][j] = e.mac[i][j];
+					}
+				break;
+				case 0:
+					e.mac[i+1][j] = e.mac[i][j];
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+#else
 	for (i = 0; *p && (i < 6); i++) {
 		e.mac[index][i] = simple_strtoul(p, &p, 16);
 		if (*p == ':')
 			p++;
 	}
+#endif
 
 	update_crc();
 }
 
+#ifdef CONFIG_LANNER_BURN
+/* clean mac address to 0xff */
+static void clean_mac_address(void)
+{      
+	unsigned int i,j;
+
+	for ( i = 0 ; i < MAX_NUM_PORTS ;i++)
+	{
+		for( j = 0 ; j < 6 ;j++ )
+		{
+			e.mac[i][j] = 0xff; 
+		}
+	}
+	update_crc();
+ }
+#endif
+
+
 int do_mac(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	char cmd;
@@ -358,6 +446,11 @@
 		case 's':	/* save */
 			prog_eeprom();
 			break;
+#ifdef CONFIG_LANNER_BURN
+		case 'c':
+			clean_mac_address();
+			break;
+#endif
 		default:
 			return cmd_usage(cmdtp);
 		}
@@ -485,7 +578,7 @@
 
 #ifdef CONFIG_SYS_I2C_EEPROM_NXID
 	printf("%c%c%c%c v%u\n", e.id[0], e.id[1], e.id[2], e.id[3],
-		be32_to_cpu(e.version));
+	       e.version);
 #else
 	printf("%c%c%c%c\n", e.id[0], e.id[1], e.id[2], e.id[3]);
 #endif
--- u-boot-2014.07/board/freescale/common/vsc3316_3308.h.orig	2022-05-09 14:06:21.617214729 -0700
+++ u-boot-2014.07/board/freescale/common/vsc3316_3308.h	2022-05-09 14:06:23.289147104 -0700
@@ -14,6 +14,10 @@
 int vsc_if_enable(unsigned int vsc_addr);
 int vsc3316_config(unsigned int vsc_addr, int8_t con_arr[][2],
 		unsigned int num_con);
+#ifdef CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+int vsc3308_config_adjust(unsigned int vsc_addr, const int8_t con_arr[][2],
+		unsigned int num_con);
+#endif
 int vsc3308_config(unsigned int vsc_addr, const int8_t con_arr[][2],
 		unsigned int num_con);
 void vsc_wp_config(unsigned int vsc_addr);
--- u-boot-2014.07/board/freescale/common/Makefile.orig	2022-05-09 14:06:21.617214729 -0700
+++ u-boot-2014.07/board/freescale/common/Makefile	2022-05-09 14:06:23.285147265 -0700
@@ -23,6 +23,7 @@
 obj-$(CONFIG_FSL_PIXIS)	+= pixis.o
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_FSL_NGPIXIS)	+= ngpixis.o
+obj-$(CONFIG_VID)		+= vid.o
 endif
 obj-$(CONFIG_FSL_QIXIS)	+= qixis.o
 obj-$(CONFIG_PQ_MDS_PIB)	+= pq-mds-pib.o
@@ -34,6 +35,10 @@
 obj-$(CONFIG_FSL_FIXED_MMC_LOCATION)	+= sdhc_boot.o
 endif
 
+obj-$(CONFIG_FSL_DCU_SII9022A)    += dcu_sii9022a.o
+
+obj-$(CONFIG_FSL_DIU_CH7301)	+= diu_ch7301.o
+
 obj-$(CONFIG_MPC8541CDS)	+= cds_pci_ft.o
 obj-$(CONFIG_MPC8548CDS)	+= cds_pci_ft.o
 obj-$(CONFIG_MPC8555CDS)	+= cds_pci_ft.o
@@ -50,10 +55,20 @@
 obj-$(CONFIG_IDT8T49N222A)	+= idt8t49n222a_serdes_clk.o
 obj-$(CONFIG_ZM7300)		+= zm7300.o
 
+obj-$(CONFIG_LS102XA_STREAM_ID)	+= ls102xa_stream_id.o
+
 # deal with common files for P-series corenet based devices
 obj-$(CONFIG_P2041RDB)	+= p_corenet/
 obj-$(CONFIG_P3041DS)	+= p_corenet/
 obj-$(CONFIG_P4080DS)	+= p_corenet/
 obj-$(CONFIG_P5020DS)	+= p_corenet/
 obj-$(CONFIG_P5040DS)	+= p_corenet/
+
+obj-$(CONFIG_LS102XA_NS_ACESS)	+= ns_access.o
+
+ifdef CONFIG_SECURE_BOOT
+obj-y += fsl_validate.o
+obj-$(CONFIG_CMD_ESBC_VALIDATE) += cmd_esbc_validate.o
+endif
+
 endif
--- u-boot-2014.07/board/freescale/common/qixis.h.orig	2022-05-09 14:06:21.617214729 -0700
+++ u-boot-2014.07/board/freescale/common/qixis.h	2022-05-09 14:06:23.289147104 -0700
@@ -100,8 +100,15 @@
 void qixis_write_i2c(unsigned int reg, u8 value);
 #endif
 
+#if defined(CONFIG_QIXIS_I2C_ACCESS) && defined(CONFIG_SYS_I2C_FPGA_ADDR)
+#define QIXIS_READ(reg) qixis_read_i2c(offsetof(struct qixis, reg))
+#define QIXIS_WRITE(reg, value) \
+	qixis_write_i2c(offsetof(struct qixis, reg), value)
+#else
 #define QIXIS_READ(reg) qixis_read(offsetof(struct qixis, reg))
 #define QIXIS_WRITE(reg, value) qixis_write(offsetof(struct qixis, reg), value)
+#endif
+
 #ifdef CONFIG_SYS_I2C_FPGA_ADDR
 #define QIXIS_READ_I2C(reg) qixis_read_i2c(offsetof(struct qixis, reg))
 #define QIXIS_WRITE_I2C(reg, value) \
--- u-boot-2014.07/board/freescale/common/vsc3316_3308.c.orig	2022-05-09 14:06:21.617214729 -0700
+++ u-boot-2014.07/board/freescale/common/vsc3316_3308.c	2022-05-09 14:06:23.289147104 -0700
@@ -13,7 +13,12 @@
 #define INPUT_STATE_REG		0x13
 #define GLOBAL_INPUT_ISE1		0x51
 #define GLOBAL_INPUT_ISE2		0x52
+#define GLOBAL_INPUT_GAIN		0x53
 #define GLOBAL_INPUT_LOS		0x55
+#define GLOBAL_OUTPUT_PE1		0x56
+#define GLOBAL_OUTPUT_PE2		0x57
+#define GLOBAL_OUTPUT_LEVEL		0x58
+#define GLOBAL_OUTPUT_TERMINATION	0x5A
 #define GLOBAL_CORE_CNTRL		0x5D
 #define OUTPUT_MODE_PAGE		0x23
 #define CORE_CONTROL_PAGE		0x25
@@ -92,6 +97,109 @@
 	return 0;
 }
 
+#ifdef CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+int vsc3308_config_adjust(unsigned int vsc_addr, const int8_t con_arr[][2],
+		unsigned int num_con)
+{
+	unsigned int i;
+	u8 rev_id = 0;
+	int ret;
+
+	debug("VSC:Initializing VSC3308 at I2C address 0x%x for Tx\n",
+	      vsc_addr);
+
+	ret = i2c_read(vsc_addr, REVISION_ID_REG, 1, &rev_id, 1);
+	if (ret < 0) {
+		printf("VSC:0x%x could not read REV_ID from device.\n",
+		       vsc_addr);
+		return ret;
+	}
+
+	if (rev_id != 0xab) {
+		printf("VSC: device at address 0x%x is not VSC3316/3308.\n",
+		       vsc_addr);
+		return -ENODEV;
+	}
+
+	ret = vsc_if_enable(vsc_addr);
+	if (ret) {
+		printf("VSC:0x%x could not configured for 2-wire I/F.\n",
+		       vsc_addr);
+		return ret;
+	}
+
+	/* config connections - page 0x00 */
+	i2c_reg_write(vsc_addr, CURRENT_PAGE_REGISTER, CONNECTION_CONFIG_PAGE);
+
+	/* Configure Global Input ISE */
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_ISE1, 0);
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_ISE2, 0);
+
+	/* Configure Tx/Rx Global Output PE1 */
+	i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_PE1, 0);
+
+	/* Configure Tx/Rx Global Output PE2 */
+	i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_PE2, 0);
+
+	/* Configure Tx/Rx Global Input GAIN */
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_GAIN, 0x3F);
+
+	/* Setting Global Input LOS threshold value */
+	i2c_reg_write(vsc_addr, GLOBAL_INPUT_LOS, 0xE0);
+
+	/* Setting Global output termination */
+	i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_TERMINATION, 0);
+
+	/* Configure Tx/Rx Global Output level */
+	if (vsc_addr == VSC3308_TX_ADDRESS)
+		i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_LEVEL, 4);
+	else
+		i2c_reg_write(vsc_addr, GLOBAL_OUTPUT_LEVEL, 2);
+
+	/* Making crosspoint connections, by connecting required
+	 * input to output */
+	for (i = 0; i < num_con ; i++)
+		i2c_reg_write(vsc_addr, con_arr[i][1], con_arr[i][0]);
+
+	/* input state - page 0x13 */
+	i2c_reg_write(vsc_addr, CURRENT_PAGE_REGISTER, INPUT_STATE_REG);
+	/* Turning off all the required input of the switch */
+	for (i = 0; i < num_con; i++)
+		i2c_reg_write(vsc_addr, con_arr[i][0], 1);
+
+	/* only turn on specific Tx/Rx requested by the XFI erratum */
+	if (vsc_addr == VSC3308_TX_ADDRESS) {
+		i2c_reg_write(vsc_addr, 2, 0);
+		i2c_reg_write(vsc_addr, 3, 0);
+	} else {
+		i2c_reg_write(vsc_addr, 0, 0);
+		i2c_reg_write(vsc_addr, 1, 0);
+	}
+
+	/* config output mode - page 0x23 */
+	i2c_reg_write(vsc_addr, CURRENT_PAGE_REGISTER, OUTPUT_MODE_PAGE);
+	/* Turn off the Output driver correspond to required output*/
+	for (i = 0; i < num_con ; i++)
+		i2c_reg_write(vsc_addr,  con_arr[i][1], 1);
+
+	/* only turn on specific Tx/Rx requested by the XFI erratum */
+	if (vsc_addr == VSC3308_TX_ADDRESS) {
+		i2c_reg_write(vsc_addr, 0, 0);
+		i2c_reg_write(vsc_addr, 1, 0);
+	} else {
+		i2c_reg_write(vsc_addr, 3, 0);
+		i2c_reg_write(vsc_addr, 4, 0);
+	}
+
+	/* configure global core control register, Turn on Global core power */
+	i2c_reg_write(vsc_addr, GLOBAL_CORE_CNTRL, 0);
+
+	vsc_wp_config(vsc_addr);
+
+	return 0;
+}
+#endif
+
 int vsc3308_config(unsigned int vsc_addr, const int8_t con_arr[][2],
 		unsigned int num_con)
 {
--- u-boot-2014.07/board/freescale/mpc8360emds/mpc8360emds.c.orig	2022-05-09 14:06:21.637213920 -0700
+++ u-boot-2014.07/board/freescale/mpc8360emds/mpc8360emds.c	2022-05-09 14:06:23.325145648 -0700
@@ -11,13 +11,13 @@
 #include <i2c.h>
 #include <miiphy.h>
 #include <phy.h>
+#include <fsl_mdio.h>
 #if defined(CONFIG_PCI)
 #include <pci.h>
 #endif
 #include <spd_sdram.h>
 #include <asm/mmu.h>
 #include <asm/io.h>
-#include <asm/fsl_enet.h>
 #include <asm/mmu.h>
 #if defined(CONFIG_OF_LIBFDT)
 #include <libfdt.h>
--- u-boot-2014.07/board/freescale/t208xrdb/t2080_rcw.cfg.orig	2022-05-09 14:06:21.673212464 -0700
+++ u-boot-2014.07/board/freescale/t208xrdb/t2080_rcw.cfg	2022-05-09 14:06:23.357144353 -0700
@@ -1,8 +1,16 @@
-#PBL preamble and RCW header for T2080RDB
+#PBL preamble and RCW header
 aa55aa55 010e0100
-#SerDes Protocol: 0x66_0x16
-#Core/DDR: 1533Mhz/1600MT/s
-120c0017 15000000 00000000 00000000
-66150002 00008400 ec104000 c1000000
-00000000 00000000 00000000 000307fc
+
+#For T2080 v1.0
+#SerDes=0x66_0x16, Core=1533MHz, DDR=1600MT/s
+#120c0017 15000000 00000000 00000000
+#66150002 00008400 ec104000 c1000000
+#00000000 00000000 00000000 000307fc
+#00000000 00000000 00000000 00000004
+
+#For T2080 v1.1
+#SerDes=0x66_0x15, Core:1800MHz, DDR:1600MT/s
+1206001b 15000000 00000000 00000000
+66150002 00000000 e8104000 c1000000
+00800000 00000000 00000000 000307fc
 00000000 00000000 00000000 00000004
--- u-boot-2014.07/board/freescale/t1040qds/t1040qds_qixis.h.orig	2022-05-09 14:06:21.669212625 -0700
+++ u-boot-2014.07/board/freescale/t1040qds/t1040qds_qixis.h	2022-05-09 14:06:23.353144515 -0700
@@ -17,6 +17,10 @@
 #define BRDCFG5_IMX_MASK		0xC0
 #define BRDCFG5_IMX_DIU			0x80
 
+/* BRDCFG9[2] controls EPHY2 Clock */
+#define BRDCFG9_EPHY2_MASK              0x20
+#define BRDCFG9_EPHY2_VAL               0x00
+
 /* BRDCFG15[3] controls LCD Panel Powerdown*/
 #define BRDCFG15_LCDPD_MASK		0x10
 #define BRDCFG15_LCDPD_ENABLED		0x00
--- u-boot-2014.07/board/freescale/t1040qds/eth.c.orig	2022-05-09 14:06:21.665212788 -0700
+++ u-boot-2014.07/board/freescale/t1040qds/eth.c	2022-05-09 14:06:23.353144515 -0700
@@ -241,6 +241,8 @@
 		break;
 	case 0xA7:
 		lane_to_slot[1] = 7;
+		lane_to_slot[2] = 6;
+		lane_to_slot[3] = 5;
 		lane_to_slot[7] = 7;
 		break;
 	case 0xAA:
@@ -355,7 +357,9 @@
 {
 	u8 brdcfg9;
 	brdcfg9 = QIXIS_READ(brdcfg[9]);
-	brdcfg9 |= (1 << 5);
+/* Initializing EPHY2 clock to RGMII mode */
+	brdcfg9 &= ~(BRDCFG9_EPHY2_MASK);
+	brdcfg9 |= (BRDCFG9_EPHY2_VAL);
 	QIXIS_WRITE(brdcfg[9], brdcfg9);
 }
 
@@ -408,6 +412,8 @@
 			fm_info_set_phy_address(i, riser_phy_addr[1]);
 		if (FM1_DTSEC3 == i)
 			fm_info_set_phy_address(i, riser_phy_addr[2]);
+		if (FM1_DTSEC5 == i)
+			fm_info_set_phy_address(i, riser_phy_addr[3]);
 
 		mdio_mux[i] = EMI1_SLOT7;
 		fm_info_set_mdio(i, mii_dev_for_muxval(mdio_mux[i]));
--- u-boot-2014.07/drivers/qe/uec_phy.c.orig	2022-05-09 14:06:22.093195477 -0700
+++ u-boot-2014.07/drivers/qe/uec_phy.c	2022-05-09 14:06:23.753128337 -0700
@@ -14,7 +14,7 @@
 #include "net.h"
 #include "malloc.h"
 #include "asm/errno.h"
-#include "asm/immap_qe.h"
+#include "linux/immap_qe.h"
 #include "asm/io.h"
 #include "qe.h"
 #include "uccf.h"
--- u-boot-2014.07/drivers/qe/uec.c.orig	2022-05-09 14:06:22.093195477 -0700
+++ u-boot-2014.07/drivers/qe/uec.c	2022-05-09 14:06:23.753128337 -0700
@@ -11,7 +11,7 @@
 #include "malloc.h"
 #include "asm/errno.h"
 #include "asm/io.h"
-#include "asm/immap_qe.h"
+#include "linux/immap_qe.h"
 #include "qe.h"
 #include "uccf.h"
 #include "uec.h"
--- u-boot-2014.07/drivers/qe/uccf.h.orig	2022-05-09 14:06:22.089195639 -0700
+++ u-boot-2014.07/drivers/qe/uccf.h	2022-05-09 14:06:23.753128337 -0700
@@ -12,7 +12,7 @@
 
 #include "common.h"
 #include "qe.h"
-#include "asm/immap_qe.h"
+#include "linux/immap_qe.h"
 
 /* Fast or Giga ethernet
 */
--- u-boot-2014.07/drivers/qe/qe.h.orig	2022-05-09 14:06:22.089195639 -0700
+++ u-boot-2014.07/drivers/qe/qe.h	2022-05-09 14:06:23.753128337 -0700
@@ -11,6 +11,9 @@
 #define __QE_H__
 
 #include "common.h"
+#ifdef CONFIG_U_QE
+#include <linux/immap_qe.h>
+#endif
 
 #define QE_NUM_OF_BRGS	16
 #define UCC_MAX_NUM	8
@@ -284,5 +287,11 @@
 void ft_qe_setup(void *blob);
 void qe_init(uint qe_base);
 void qe_reset(void);
-
+#ifdef CONFIG_U_QE
+void u_qe_init(void);
+int u_qe_upload_firmware(const struct qe_firmware *firmware);
+void u_qe_resume(void);
+int u_qe_firmware_resume(const struct qe_firmware *firmware,
+			 qe_map_t *qe_immrr);
+#endif
 #endif /* __QE_H__ */
--- u-boot-2014.07/drivers/qe/uec.h.orig	2022-05-09 14:06:22.093195477 -0700
+++ u-boot-2014.07/drivers/qe/uec.h	2022-05-09 14:06:23.753128337 -0700
@@ -13,7 +13,6 @@
 #include "qe.h"
 #include "uccf.h"
 #include <phy.h>
-#include <asm/fsl_enet.h>
 
 #define MAX_TX_THREADS				8
 #define MAX_RX_THREADS				8
--- u-boot-2014.07/drivers/qe/Makefile.orig	2022-05-09 14:06:22.089195639 -0700
+++ u-boot-2014.07/drivers/qe/Makefile	2022-05-09 14:06:23.749128499 -0700
@@ -4,5 +4,6 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-obj-y := qe.o uccf.o uec.o uec_phy.o
+obj-$(CONFIG_QE) += qe.o uccf.o uec.o uec_phy.o
+obj-$(CONFIG_U_QE) += qe.o
 obj-$(CONFIG_OF_LIBFDT) += fdt.o
--- u-boot-2014.07/drivers/qe/qe.c.orig	2022-05-09 14:06:22.089195639 -0700
+++ u-boot-2014.07/drivers/qe/qe.c	2022-05-09 14:06:23.753128337 -0700
@@ -9,12 +9,15 @@
 
 #include "common.h"
 #include <command.h>
+#ifdef CONFIG_LS102XA
+#include <asm/arch/immap_ls102xa.h>
+#endif
 #include "asm/errno.h"
 #include "asm/io.h"
-#include "asm/immap_qe.h"
+#include "linux/immap_qe.h"
 #include "qe.h"
 
-#define MPC85xx_DEVDISR_QE_DISABLE	0x1
+#define DEVDISR_QE_DISABLE	0x1
 
 qe_map_t		*qe_immr = NULL;
 static qe_snum_t	snums[QE_NUM_OF_SNUM];
@@ -40,6 +43,7 @@
 	return;
 }
 
+#ifdef CONFIG_QE
 uint qe_muram_alloc(uint size, uint align)
 {
 	uint	retloc;
@@ -70,6 +74,7 @@
 
 	return retloc;
 }
+#endif
 
 void *qe_muram_addr(uint offset)
 {
@@ -180,6 +185,29 @@
 	qe_snums_init();
 }
 
+#ifdef CONFIG_U_QE
+void u_qe_init(void)
+{
+	uint qe_base = CONFIG_SYS_IMMR + 0x01400000; /* QE immr base */
+	qe_immr = (qe_map_t *)qe_base;
+
+	u_qe_upload_firmware((const void *)CONFIG_SYS_QE_FW_ADDR);
+	out_be32(&qe_immr->iram.iready, QE_IRAM_READY);
+}
+#endif
+
+#ifdef CONFIG_U_QE
+void u_qe_resume(void)
+{
+	qe_map_t __iomem *qe_immrr;
+	uint qe_base = CONFIG_SYS_IMMR + 0x01400000; /* QE immr base */
+	qe_immrr = (qe_map_t *)qe_base;
+
+	u_qe_firmware_resume((const void *)CONFIG_SYS_QE_FW_ADDR, qe_immrr);
+	out_be32(&qe_immrr->iram.iready, QE_IRAM_READY);
+}
+#endif
+
 void qe_reset(void)
 {
 	qe_issue_cmd(QE_RESET, QE_CR_SUBBLOCK_INVALID,
@@ -212,6 +240,7 @@
 
 #define BRG_CLK		(gd->arch.brg_clk)
 
+#ifdef CONFIG_QE
 int qe_set_brg(uint brg, uint rate)
 {
 	volatile uint	*bp;
@@ -239,6 +268,7 @@
 
 	return 0;
 }
+#endif
 
 /* Set ethernet MII clock master
 */
@@ -319,7 +349,7 @@
 	size_t calc_size = sizeof(struct qe_firmware);
 	size_t length;
 	const struct qe_header *hdr;
-#ifdef CONFIG_DEEP_SLEEP
+#if defined(CONFIG_FSL_DEEP_SLEEP) && defined(CONFIG_QE)
 	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
 #endif
 	if (!firmware) {
@@ -334,8 +364,8 @@
 	if ((hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
 	    (hdr->magic[2] != 'F')) {
 		printf("Not a microcode\n");
-#ifdef CONFIG_DEEP_SLEEP
-		setbits_be32(&gur->devdisr, MPC85xx_DEVDISR_QE_DISABLE);
+#if defined(CONFIG_FSL_DEEP_SLEEP) && defined(CONFIG_QE)
+		setbits_be32(&gur->devdisr, DEVDISR_QE_DISABLE);
 #endif
 		return -EPERM;
 	}
@@ -429,6 +459,205 @@
 	return 0;
 }
 
+#ifdef CONFIG_U_QE
+/*
+ * Upload a microcode to the I-RAM at a specific address.
+ *
+ * See docs/README.qe_firmware for information on QE microcode uploading.
+ *
+ * Currently, only version 1 is supported, so the 'version' field must be
+ * set to 1.
+ *
+ * The SOC model and revision are not validated, they are only displayed for
+ * informational purposes.
+ *
+ * 'calc_size' is the calculated size, in bytes, of the firmware structure and
+ * all of the microcode structures, minus the CRC.
+ *
+ * 'length' is the size that the structure says it is, including the CRC.
+ */
+int u_qe_upload_firmware(const struct qe_firmware *firmware)
+{
+	unsigned int i;
+	unsigned int j;
+	u32 crc;
+	size_t calc_size = sizeof(struct qe_firmware);
+	size_t length;
+	const struct qe_header *hdr;
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#ifdef CONFIG_LS102XA
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+#else
+	ccsr_gur_t __iomem *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#endif
+#endif
+	if (!firmware) {
+		printf("Invalid address\n");
+		return -EINVAL;
+	}
+
+	hdr = &firmware->header;
+	length = be32_to_cpu(hdr->length);
+
+	/* Check the magic */
+	if ((hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
+	    (hdr->magic[2] != 'F')) {
+		printf("Not a microcode\n");
+#ifdef CONFIG_FSL_DEEP_SLEEP
+		setbits_be32(&gur->devdisr, DEVDISR_QE_DISABLE);
+#endif
+		return -EPERM;
+	}
+
+	/* Check the version */
+	if (hdr->version != 1) {
+		printf("Unsupported version\n");
+		return -EPERM;
+	}
+
+	/* Validate some of the fields */
+	if ((firmware->count < 1) || (firmware->count > MAX_QE_RISC)) {
+		printf("Invalid data\n");
+		return -EINVAL;
+	}
+
+	/* Validate the length and check if there's a CRC */
+	calc_size += (firmware->count - 1) * sizeof(struct qe_microcode);
+
+	for (i = 0; i < firmware->count; i++)
+		/*
+		 * For situations where the second RISC uses the same microcode
+		 * as the first, the 'code_offset' and 'count' fields will be
+		 * zero, so it's okay to add those.
+		 */
+		calc_size += sizeof(u32) *
+			be32_to_cpu(firmware->microcode[i].count);
+
+	/* Validate the length */
+	if (length != calc_size + sizeof(u32)) {
+		printf("Invalid length\n");
+		return -EPERM;
+	}
+
+	/*
+	 * Validate the CRC.  We would normally call crc32_no_comp(), but that
+	 * function isn't available unless you turn on JFFS support.
+	 */
+	crc = be32_to_cpu(*(u32 *)((void *)firmware + calc_size));
+	if (crc != (crc32(-1, (const void *)firmware, calc_size) ^ -1)) {
+		printf("Firmware CRC is invalid\n");
+		return -EIO;
+	}
+
+	/*
+	 * If the microcode calls for it, split the I-RAM.
+	 */
+	if (!firmware->split) {
+		out_be16(&qe_immr->cp.cercr,
+			 in_be16(&qe_immr->cp.cercr) | QE_CP_CERCR_CIR);
+	}
+
+	if (firmware->soc.model)
+		printf("Firmware '%s' for %u V%u.%u\n",
+		       firmware->id, be16_to_cpu(firmware->soc.model),
+		       firmware->soc.major, firmware->soc.minor);
+	else
+		printf("Firmware '%s'\n", firmware->id);
+
+	/* Loop through each microcode. */
+	for (i = 0; i < firmware->count; i++) {
+		const struct qe_microcode *ucode = &firmware->microcode[i];
+
+		/* Upload a microcode if it's present */
+		if (ucode->code_offset)
+			qe_upload_microcode(firmware, ucode);
+
+		/* Program the traps for this processor */
+		for (j = 0; j < 16; j++) {
+			u32 trap = be32_to_cpu(ucode->traps[j]);
+
+			if (trap)
+				out_be32(&qe_immr->rsp[i].tibcr[j], trap);
+		}
+
+		/* Enable traps */
+		out_be32(&qe_immr->rsp[i].eccr, be32_to_cpu(ucode->eccr));
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_U_QE
+int u_qe_firmware_resume(const struct qe_firmware *firmware, qe_map_t *qe_immrr)
+{
+	unsigned int i;
+	unsigned int j;
+	const struct qe_header *hdr;
+	const u32 *code;
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#ifdef CONFIG_LS102XA
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+#else
+	ccsr_gur_t __iomem *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#endif
+#endif
+
+	if (!firmware)
+		return -EINVAL;
+
+	hdr = &firmware->header;
+
+	/* Check the magic */
+	if ((hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
+	    (hdr->magic[2] != 'F')) {
+#ifdef CONFIG_FSL_DEEP_SLEEP
+		setbits_be32(&gur->devdisr, DEVDISR_QE_DISABLE);
+#endif
+		return -EPERM;
+	}
+
+	/*
+	 * If the microcode calls for it, split the I-RAM.
+	 */
+	if (!firmware->split) {
+		out_be16(&qe_immrr->cp.cercr,
+			 in_be16(&qe_immrr->cp.cercr) | QE_CP_CERCR_CIR);
+	}
+
+	/* Loop through each microcode. */
+	for (i = 0; i < firmware->count; i++) {
+		const struct qe_microcode *ucode = &firmware->microcode[i];
+
+		/* Upload a microcode if it's present */
+		if (!ucode->code_offset)
+			return 0;
+
+		code = (const void *)firmware + be32_to_cpu(ucode->code_offset);
+
+		/* Use auto-increment */
+		out_be32(&qe_immrr->iram.iadd, be32_to_cpu(ucode->iram_offset) |
+			QE_IRAM_IADD_AIE | QE_IRAM_IADD_BADDR);
+
+		for (i = 0; i < be32_to_cpu(ucode->count); i++)
+			out_be32(&qe_immrr->iram.idata, be32_to_cpu(code[i]));
+
+		/* Program the traps for this processor */
+		for (j = 0; j < 16; j++) {
+			u32 trap = be32_to_cpu(ucode->traps[j]);
+
+			if (trap)
+				out_be32(&qe_immrr->rsp[i].tibcr[j], trap);
+		}
+
+		/* Enable traps */
+		out_be32(&qe_immrr->rsp[i].eccr, be32_to_cpu(ucode->eccr));
+	}
+
+	return 0;
+}
+#endif
+
 struct qe_firmware_info *qe_get_firmware_info(void)
 {
 	return qe_firmware_uploaded ? &qe_firmware_info : NULL;
--- u-boot-2014.07/drivers/qe/uccf.c.orig	2022-05-09 14:06:22.089195639 -0700
+++ u-boot-2014.07/drivers/qe/uccf.c	2022-05-09 14:06:23.753128337 -0700
@@ -11,7 +11,7 @@
 #include "malloc.h"
 #include "asm/errno.h"
 #include "asm/io.h"
-#include "asm/immap_qe.h"
+#include "linux/immap_qe.h"
 #include "qe.h"
 #include "uccf.h"
 
--- u-boot-2014.07/drivers/qe/fdt.c.orig	2022-05-09 14:06:22.089195639 -0700
+++ u-boot-2014.07/drivers/qe/fdt.c	2022-05-09 14:06:23.749128499 -0700
@@ -12,6 +12,7 @@
 #include <fdt_support.h>
 #include "qe.h"
 
+#ifdef CONFIG_QE
 DECLARE_GLOBAL_DATA_PTR;
 
 /*
@@ -72,3 +73,4 @@
 		"clock-frequency", gd->arch.qe_clk / 2, 1);
 	fdt_fixup_qe_firmware(blob);
 }
+#endif
--- u-boot-2014.07/drivers/net/tsec.c.orig	2022-05-09 14:06:22.081195962 -0700
+++ u-boot-2014.07/drivers/net/tsec.c	2022-05-09 14:06:23.741128822 -0700
@@ -20,6 +20,7 @@
 #include <fsl_mdio.h>
 #include <asm/errno.h>
 #include <asm/processor.h>
+#include <asm/io.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -188,6 +189,7 @@
 	struct tsec __iomem *regs = priv->regs;
 	u32 ecntrl, maccfg2;
 
+	printf("link:speed:duplex = %d:%d:%d\n",phydev->link,phydev->speed,phydev->duplex);
 	if (!phydev->link) {
 		printf("%s: No link.\n", phydev->dev->name);
 		return;
@@ -270,6 +272,9 @@
 	out_be32(&regs->tstat, TSTAT_CLEAR_THALT);
 	out_be32(&regs->rstat, RSTAT_CLEAR_RHALT);
 	clrbits_be32(&regs->dmactrl, DMACTRL_GRS | DMACTRL_GTS);
+#ifdef CONFIG_LS102XA
+	setbits_be32(&regs->dmactrl, DMACTRL_LE);
+#endif
 
 	do {
 		uint16_t status;
@@ -366,6 +371,9 @@
 	out_be32(&regs->tstat, TSTAT_CLEAR_THALT);
 	out_be32(&regs->rstat, RSTAT_CLEAR_RHALT);
 	clrbits_be32(&regs->dmactrl, DMACTRL_GRS | DMACTRL_GTS);
+#ifdef CONFIG_LS102XA
+	setbits_be32(&regs->dmactrl, DMACTRL_LE);
+#endif
 }
 
 /* This returns the status bits of the device.	The return value
@@ -563,6 +571,21 @@
 	return PHY_INTERFACE_MODE_MII;
 }
 
+#ifdef CONFIG_DEBUG_BOREN
+void dump_tsec_private_struct(struct tsec_private *priv)
+{
+	printf("<%s>: dump_tsec_private_struct starts\n",__FUNCTION__);
+	printf("<%s>: regs = %p\n",__FUNCTION__, priv->regs);
+	printf("<%s>: phyregs_sgmii = %p\n",__FUNCTION__, priv->phyregs_sgmii);
+	printf("<%s>: phydev = %p\n",__FUNCTION__, priv->phydev);
+	printf("<%s>: interface = %d\n",__FUNCTION__, priv->interface);
+	printf("<%s>: bus = %p\n",__FUNCTION__, priv->bus);
+	printf("<%s>: phyaddr = %u\n",__FUNCTION__, priv->phyaddr);
+	// printf("<%s>: mii_devname = %s\n",__FUNCTION__, priv->mii_devname);
+	printf("<%s>: flags = 0%0x\n",__FUNCTION__, priv->flags);
+	printf("<%s>: dump_tsec_private_struct ends\n",__FUNCTION__);
+}
+#endif
 
 /* Discover which PHY is attached to the device, and configure it
  * properly.  If the PHY is not recognized, then return 0
@@ -573,6 +596,10 @@
 	struct tsec_private *priv = (struct tsec_private *)dev->priv;
 	struct phy_device *phydev;
 	struct tsec __iomem *regs = priv->regs;
+
+#ifdef CONFIG_DEBUG_BOREN
+	dump_tsec_private_struct(priv);
+#endif
 	u32 supported = (SUPPORTED_10baseT_Half |
 			SUPPORTED_10baseT_Full |
 			SUPPORTED_100baseT_Half |
@@ -589,6 +616,13 @@
 	if (priv->interface == PHY_INTERFACE_MODE_SGMII)
 		tsec_configure_serdes(priv);
 
+	if(priv->bus == NULL)
+	{
+		/* Expect we will never be here again */
+		printf("Known WG Boren BUG: fixed. line us %d,func is %s\n",__LINE__,__func__);	
+		return 1;
+	}
+	
 	phydev = phy_connect(priv->bus, priv->phyaddr, dev, priv->interface);
 
 	phydev->supported &= supported;
@@ -601,6 +635,21 @@
 	return 1;
 }
 
+#ifdef CONFIG_DEBUG_BOREN
+void dump_tsec_info_struct(struct tsec_info_struct *priv)
+{
+	printf("<%s>: dump_tsec_info_struct starts\n",__FUNCTION__);
+	printf("<%s>: regs = %p\n",__FUNCTION__, priv->regs);
+	printf("<%s>: miiregs_sgmii = %p\n",__FUNCTION__, priv->miiregs_sgmii);
+	printf("<%s>: devname = %s\n",__FUNCTION__, priv->devname);
+	printf("<%s>: mii_devname = %s\n",__FUNCTION__, priv->mii_devname);
+	printf("<%s>: interface = %d\n",__FUNCTION__, priv->interface);
+	printf("<%s>: phyaddr = %u\n",__FUNCTION__, priv->phyaddr);
+	printf("<%s>: flags = 0%0x\n",__FUNCTION__, priv->flags);
+	printf("<%s>: dump_tsec_info_struct ends\n",__FUNCTION__);
+}
+#endif
+
 /* Initialize device structure. Returns success if PHY
  * initialization succeeded (i.e. if it recognizes the PHY)
  */
@@ -610,6 +659,9 @@
 	int i;
 	struct tsec_private *priv;
 
+#ifdef CONFIG_DEBUG_BOREN
+	dump_tsec_info_struct(tsec_info);
+#endif
 	dev = (struct eth_device *)malloc(sizeof *dev);
 
 	if (NULL == dev)
--- u-boot-2014.07/drivers/net/fsl_mdio.c.orig	2022-05-09 14:06:22.069196447 -0700
+++ u-boot-2014.07/drivers/net/fsl_mdio.c	2022-05-09 14:06:23.729129308 -0700
@@ -11,7 +11,6 @@
 #include <fsl_mdio.h>
 #include <asm/io.h>
 #include <asm/errno.h>
-#include <asm/fsl_enet.h>
 
 void tsec_local_mdio_write(struct tsec_mii_mng __iomem *phyregs, int port_addr,
 		int dev_addr, int regnum, int value)
@@ -20,7 +19,8 @@
 
 	out_be32(&phyregs->miimadd, (port_addr << 8) | (regnum & 0x1f));
 	out_be32(&phyregs->miimcon, value);
-	asm("sync");
+	/* Memory barrier */
+	mb();
 
 	while ((in_be32(&phyregs->miimind) & MIIMIND_BUSY) && timeout--)
 		;
@@ -38,11 +38,13 @@
 
 	/* Clear the command register, and wait */
 	out_be32(&phyregs->miimcom, 0);
-	asm("sync");
+	/* Memory barrier */
+	mb();
 
 	/* Initiate a read command, and wait */
 	out_be32(&phyregs->miimcom, MIIMCOM_READ_CYCLE);
-	asm("sync");
+	/* Memory barrier */
+	mb();
 
 	/* Wait for the the indication that the read is done */
 	while ((in_be32(&phyregs->miimind) & (MIIMIND_NOTVALID | MIIMIND_BUSY))
--- u-boot-2014.07/drivers/net/phy/vitesse.c.orig	2022-05-09 14:06:22.077196124 -0700
+++ u-boot-2014.07/drivers/net/phy/vitesse.c	2022-05-09 14:06:23.737128984 -0700
@@ -1,8 +1,8 @@
 /*
  * Vitesse PHY drivers
  *
- * Copyright 2010-2012 Freescale Semiconductor, Inc.
- * Author: Andy Fleming
+ * Copyright 2010-2014 Freescale Semiconductor, Inc.
+ * Original Author: Andy Fleming
  * Add vsc8662 phy support - Priyanka Jain
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -50,6 +50,7 @@
 #define MIIM_VSC8574_18G_CMDSTAT	0x8000
 
 /* Vitesse VSC8514 control register */
+#define MIIM_VSC8514_MAC_SERDES_CON     0x10
 #define MIIM_VSC8514_GENERAL18		0x12
 #define MIIM_VSC8514_GENERAL19		0x13
 #define MIIM_VSC8514_GENERAL23		0x17
@@ -247,6 +248,14 @@
 	val = (val & 0xf8ff);
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_VSC8514_GENERAL23, val);
 
+	/* Enable Serdes Auto-negotiation */
+	phy_write(phydev, MDIO_DEVAD_NONE, PHY_EXT_PAGE_ACCESS,
+		  PHY_EXT_PAGE_ACCESS_EXTENDED3);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_VSC8514_MAC_SERDES_CON);
+	val = val | MIIM_VSC8574_MAC_SERDES_ANEG;
+	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_VSC8514_MAC_SERDES_CON, val);
+	phy_write(phydev, MDIO_DEVAD_NONE, PHY_EXT_PAGE_ACCESS, 0);
+
 	genphy_config_aneg(phydev);
 
 	return 0;
--- u-boot-2014.07/drivers/net/phy/broadcom.c.orig	2022-05-09 14:06:22.073196286 -0700
+++ u-boot-2014.07/drivers/net/phy/broadcom.c	2022-05-09 14:06:23.737128984 -0700
@@ -73,7 +73,6 @@
 		phydev->speed = SPEED_1000;
 		break;
 	default:
-		printf("Auto-neg error, defaulting to 10BT/HD\n");
 		phydev->duplex = DUPLEX_HALF;
 		phydev->speed = SPEED_10;
 		break;
@@ -264,11 +263,25 @@
 	.shutdown = &genphy_shutdown,
 };
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+/* add PHYID support for AP331IB's BCM54616S GE PHY */
+static struct phy_driver BCM54616S_driver = {
+	.name = "BCM 54616S",
+	.uid = 0x3625d10,
+	.mask = 0xffffff0,
+	.features = PHY_GBIT_FEATURES,
+	.config = &bcm5461_config,
+	.startup = &bcm54xx_startup,
+	.shutdown = &genphy_shutdown,
+};
+#endif
+
 int phy_broadcom_init(void)
 {
 	phy_register(&BCM5482S_driver);
 	phy_register(&BCM5464S_driver);
 	phy_register(&BCM5461S_driver);
+	phy_register(&BCM54616S_driver);
 
 	return 0;
 }
--- u-boot-2014.07/drivers/net/phy/mv88e61xx.c.orig	2022-05-09 14:06:22.077196124 -0700
+++ u-boot-2014.07/drivers/net/phy/mv88e61xx.c	2022-05-09 14:06:23.737128984 -0700
@@ -44,16 +44,24 @@
 	return 0;
 }
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+void mv88e61xx_switch_write(char *name, u32 phy_adr, u32 reg_ofs, u16 data)
+#else
 static void mv88e61xx_switch_write(char *name, u32 phy_adr,
 	u32 reg_ofs, u16 data)
+#endif
 {
 	u16 mii_dev_addr;
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	mii_dev_addr = SC_MII_DEV_ADDR;
+#else
 	/* command to read PHY dev address */
 	if (miiphy_read(name, 0xEE, 0xEE, &mii_dev_addr)) {
 		printf("Error..could not read PHY dev address\n");
 		return;
 	}
+#endif	
 	mv88e61xx_busychk_multic(name, mii_dev_addr);
 	/* Write data to Switch indirect data register */
 	miiphy_write(name, mii_dev_addr, 0x1, data);
@@ -63,16 +71,24 @@
 									 15));
 }
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+void mv88e61xx_switch_read(char *name, u32 phy_adr, u32 reg_ofs, u16 * data)
+#else
 static void mv88e61xx_switch_read(char *name, u32 phy_adr,
 	u32 reg_ofs, u16 *data)
+#endif
 {
 	u16 mii_dev_addr;
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	mii_dev_addr = SC_MII_DEV_ADDR;
+#else
 	/* command to read PHY dev address */
 	if (miiphy_read(name, 0xEE, 0xEE, &mii_dev_addr)) {
 		printf("Error..could not read PHY dev address\n");
 		return;
 	}
+#endif	
 	mv88e61xx_busychk_multic(name, mii_dev_addr);
 	/* Write command to Switch indirect command register (read) */
 	miiphy_write(name, mii_dev_addr, 0x0,
@@ -209,6 +225,9 @@
 
 static void mv88e61xx_port_vlan_config(struct mv88e61xx_config *swconfig)
 {
+	char *name = swconfig->name;
+
+#ifndef CONFIG_BOREN_ETHNET_SETUP
 	u32 prt;
 	u16 reg;
 	char *name = swconfig->name;
@@ -231,6 +250,15 @@
 				MV88E61XX_PRT_VMAP_REG, reg);
 		}
 	}
+#else	// defined (CONFIG_BOREN_ETHNET_SETUP)
+	WR_SWITCH_PORT_REG(name, 0,  MV88E61XX_PRT_VMAP_REG, 0x4e);
+	WR_SWITCH_PORT_REG(name, 1,  MV88E61XX_PRT_VMAP_REG, 0x4d);
+	WR_SWITCH_PORT_REG(name, 2,  MV88E61XX_PRT_VMAP_REG, 0x4b);
+	WR_SWITCH_PORT_REG(name, 3,  MV88E61XX_PRT_VMAP_REG, 0x47);
+	WR_SWITCH_PORT_REG(name, 4,  MV88E61XX_PRT_VMAP_REG, 0x20);
+	WR_SWITCH_PORT_REG(name, 5,  MV88E61XX_PRT_VMAP_REG, 0x10);
+	WR_SWITCH_PORT_REG(name, 6,  MV88E61XX_PRT_VMAP_REG, 0x0f);
+#endif
 }
 
 /*
@@ -269,6 +297,7 @@
  */
 static int mv88361xx_led_init(struct mv88e61xx_config *swconfig, u32 phy)
 {
+#ifndef CONFIG_BOREN_ETHNET_SETUP /* tony close it now */	
 	char *name = swconfig->name;
 
 	if (swconfig->led_init != MV88E61XX_LED_INIT_EN)
@@ -288,10 +317,12 @@
 	/* set page address to 0 */
 	if (WR_SWITCH_PHY_REG(name, phy, 0x16, 0x0000))
 		return -1;
-
+#endif
 	return 0;
 }
 
+#if 0
+/* UNUSED code */
 /*
  * Reverse Transmit polarity for Media Dependent Interface
  * Pins (MDIP) bits in Copper Specific Control Register 3
@@ -314,6 +345,7 @@
 
 	return 0;
 }
+#endif
 
 /*
  * Marvell 88E61XX Switch initialization
@@ -324,17 +356,34 @@
 	u16 reg;
 	char *idstr;
 	char *name = swconfig->name;
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	u32 sc_cpuport = 0;
+	u16 sc_reg;
+#endif	
 	int time;
 
 	if (miiphy_set_current_dev(name)) {
 		printf("%s failed\n", __FUNCTION__);
 		return -1;
 	}
-
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	//if (!(swconfig->cpuport & ((1 << 5) | (1 << 6)))) {
+	if (!(swconfig->cpuport &  (1 << 6))) {
+		swconfig->cpuport = (1 << 6);
+		printf("Invalid cpu port config, using default port6\n");
+		sc_cpuport = 6;
+	}	
+	
+	if (swconfig->cpuport & (1 << 5))
+		sc_cpuport = 5;
+	else if (swconfig->cpuport & (1 << 6))
+		sc_cpuport = 6;
+#else 
 	if (!(swconfig->cpuport & ((1 << 4) | (1 << 5)))) {
 		swconfig->cpuport = (1 << 5);
 		printf("Invalid cpu port config, using default port5\n");
 	}
+#endif
 
 	RD_SWITCH_PORT_REG(name, 0, MII_PHYSID2, &reg);
 	switch (reg &= 0xfff0) {
@@ -349,6 +398,11 @@
 		/* ports 2,3,4 not available */
 		swconfig->ports_enabled &= 0x023;
 		break;
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	case 0x1710:
+		idstr = "88E6171(R)";
+		break;
+#endif
 	default:
 		/* Could not detect switch id */
 		idstr = "88E61??";
@@ -384,9 +438,33 @@
 	/* Port based VLANs configuration */
 	mv88e61xx_port_vlan_config(swconfig);
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP
 	if (swconfig->rgmii_delay == MV88E61XX_RGMII_DELAY_EN) {
 		/*
 		 * Enable RGMII delay on Tx and Rx for CPU port
+		 */
+                rd_switch_reg(name, MV88E61XX_PRT_OFST + SC_eTSEC1_PORT,
+                                MV88E61XX_PORT_PHYCTRL_REG, &sc_reg);
+
+                sc_reg |= (1 << MV88E61XX_PORT_PHYCTRL_REG_RXDELAY_BIT);
+                sc_reg |= (1 << MV88E61XX_PORT_PHYCTRL_REG_TXDELAY_BIT);
+
+                wr_switch_reg(name, MV88E61XX_PRT_OFST + SC_eTSEC1_PORT,
+                                MV88E61XX_PORT_PHYCTRL_REG, sc_reg);
+
+		rd_switch_reg(name, MV88E61XX_PRT_OFST + SC_eTSEC3_PORT, 
+				MV88E61XX_PORT_PHYCTRL_REG, &sc_reg);		
+			
+		sc_reg |= (1 << MV88E61XX_PORT_PHYCTRL_REG_RXDELAY_BIT);
+		sc_reg |= (1 << MV88E61XX_PORT_PHYCTRL_REG_TXDELAY_BIT);	
+ 
+		wr_switch_reg(name, MV88E61XX_PRT_OFST + SC_eTSEC3_PORT, 
+				MV88E61XX_PORT_PHYCTRL_REG, sc_reg);
+	}
+#else
+ 	if (swconfig->rgmii_delay == MV88E61XX_RGMII_DELAY_EN) {
+		/*
+		 * Enable RGMII delay on Tx and Rx for CPU port
 		 * Ref: sec 9.5 of chip datasheet-02
 		 */
 		/*Force port link down */
@@ -404,6 +482,7 @@
 		WR_SWITCH_PORT_REG(name, 5, MV88E61XX_PCS_CTRL_REG, 0x1e);
 		WR_SWITCH_PORT_REG(name, 5, MV88E61XX_PCS_CTRL_REG, 0x3e);
 	}
+#endif
 
 	for (prt = 0; prt < MV88E61XX_MAX_PORTS_NUM; prt++) {
 
@@ -413,8 +492,10 @@
 			int phy = (prt == 4) ? 6 : prt;
 			if (mv88361xx_powerup(swconfig, phy))
 				return -1;
+#ifndef CONFIG_BOREN_ETHNET_SETUP
 			if (mv88361xx_reverse_mdipn(swconfig, phy))
 				return -1;
+#endif
 			if (mv88361xx_led_init(swconfig, phy))
 				return -1;
 		}
@@ -437,10 +518,167 @@
 
 	}
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP	/* close switch interrupt */
+	mv88e61xx_switch_write(name, 0x1B, 0x4, 0x4000);
+#endif
+
 	printf("%s Initialized on %s\n", idstr, name);
 	return 0;
 }
 
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+extern int miiphy_read(const char *devname, unsigned char addr, unsigned char reg,
+        unsigned short *value);
+extern int miiphy_write(const char *devname, unsigned char addr, unsigned char reg,
+		  unsigned short value);
+extern const char *miiphy_get_current_dev(void);
+
+/*read phy data*/
+int sc_phy_read(int phy_id,int page,int reg)
+{
+	unsigned short	data;
+	const char	*devname;
+
+	devname = miiphy_get_current_dev();
+	data = 0xffff;
+
+	if(page != 0)
+		miiphy_write(devname,phy_id,0x16,page);//when page is not 0 ,must write page to 0x16 resigned
+
+	if (miiphy_read (devname, phy_id, reg, &data) != 0) {
+		printf("Error reading from the PHY id=%02x reg=%02x\n",
+			phy_id, reg);
+	} else {
+		printf("addr=0x%02x page=0x%02x reg=0x%02x data=0x",
+			(uint)phy_id,(uint)page, (uint)reg);
+		printf("%04X\n", data & 0x0000FFFF);
+	}
+
+	if(page != 0)
+		miiphy_write(devname,phy_id,0x16,0);
+
+	return data;
+} 
+
+/*write data to phy*/
+int sc_phy_write(int phy_id,int page,int reg,int data)
+{
+	const char	*devname;
+	devname = miiphy_get_current_dev();
+	if(page != 0)
+		//when page is not 0 ,must write page to 0x16 resigned
+		miiphy_write(devname,phy_id,0x16,page);
+
+	if (miiphy_write (devname, phy_id, reg, data) != 0) 
+	{
+		printf("Error writing to the PHY id=%02x reg=%02x\n",
+			phy_id, reg);
+	}
+
+	if(page != 0)
+		miiphy_write(devname,phy_id,0x16,0);
+
+	return 0;
+}
+#endif /* end of CONFIG_BOREN_ETHNET_SETUP */
+
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+#ifdef CONFIG_MV88E61XX_SWITCH
+#define RGMII_PHY_RST_SET	13	
+//#define PHY_RST	9	
+//#define USB_PHY2_RST	10
+//#define USB_PHY1_RST	12	
+void reset_phy(void)
+{
+	/* H/W reset switch chip */
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+	unsigned int gpio_val, gpio_dir;
+	
+	/* current gpio data & dir */
+	gpio_dir = pgpio->gpdir;
+	/* set output */
+	gpio_dir |= (1 << (31 - RGMII_PHY_RST_SET));
+	pgpio->gpdir = gpio_dir;
+	udelay(20000);	
+	
+	gpio_val = pgpio->gpdat;	
+	gpio_val &= ~(1 << (31 - RGMII_PHY_RST_SET));
+	pgpio->gpdat = gpio_val;
+	udelay(20000);	
+	/* */
+	gpio_val = pgpio->gpdat;		
+	gpio_val |= (1 << (31 - RGMII_PHY_RST_SET));
+	pgpio->gpdat = gpio_val;
+	udelay(20000);	
+	
+	gpio_val = pgpio->gpdat;	
+	gpio_val &= ~(1 << (31 - RGMII_PHY_RST_SET));
+	pgpio->gpdat = gpio_val;
+	udelay(20000);	
+
+	gpio_val = pgpio->gpdat;		
+	gpio_val |= (1 << (31 - RGMII_PHY_RST_SET));
+	pgpio->gpdat = gpio_val;
+	udelay(20000);		
+#if 0	
+	gpio_dir = pgpio->gpdir;
+	/* set output */
+	gpio_dir |= (1 << (31 - PHY_RST));
+	pgpio->gpdir = gpio_dir;
+	udelay(100000);	
+	
+	/* */
+	
+	gpio_val = pgpio->gpdat;	
+	gpio_val &= ~(1 << (31 - PHY_RST));
+	pgpio->gpdat = gpio_val;
+	udelay(100000);	
+
+	gpio_val = pgpio->gpdat;		
+	gpio_val |= (1 << (31 - PHY_RST));
+	pgpio->gpdat = gpio_val;
+	udelay(100000);		
+    	
+	gpio_val = pgpio->gpdat;	
+	gpio_val &= ~(1 << (31 - PHY_RST));
+	pgpio->gpdat = gpio_val;
+	udelay(100000);	
+	
+    gpio_dir = pgpio->gpdir;
+	/* set output */
+	gpio_dir |= (1 << (31 - USB_PHY1_RST) | (1 << (31 - USB_PHY2_RST)));
+	pgpio->gpdir = gpio_dir;
+	udelay(100000);	
+    
+	gpio_val = pgpio->gpdat;	
+	gpio_val &= ~((1 << (31 - USB_PHY1_RST)) | (1 << (31 - USB_PHY2_RST))) ;
+	pgpio->gpdat = gpio_val;
+	udelay(100000);	
+#endif
+	/* configure and initialize switch */
+	struct mv88e61xx_config swcfg = {
+		.name = "FSL_MDIO", /* "FSL_MDIO"=DEFAULT_MII_NAME; previously was "eTSEC1" */
+		.vlancfg = MV88E61XX_VLANCFG_ROUTER,
+		.rgmii_delay = MV88E61XX_RGMII_DELAY_EN,
+		.led_init = MV88E61XX_LED_INIT_EN,
+		.mdip = MV88E61XX_MDIP_REVERSE,
+		.portstate = MV88E61XX_PORTSTT_FORWARDING,
+		.cpuport = (1 << 6),
+		.ports_enabled = 0x7f
+	};
+
+	mv88e61xx_switch_initialize(&swcfg);
+	/* wait 1s for switch stable(link up) */
+
+	udelay(1000000);
+	sc_phy_write(0,0x3,0x10,0x1771);
+	sc_phy_write(0,0x3,0x11,0x4415);
+	sc_phy_write(1,0x3,0x10,0x1771);
+	sc_phy_write(1,0x3,0x11,0x4415);
+}
+#endif /* CONFIG_MV88E61XX_SWITCH */
+#endif
+
 #ifdef CONFIG_MV88E61XX_CMD
 static int
 do_switch(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
--- u-boot-2014.07/drivers/net/phy/Makefile.orig	2022-05-09 14:06:22.073196286 -0700
+++ u-boot-2014.07/drivers/net/phy/Makefile	2022-05-09 14:06:23.733129146 -0700
@@ -13,11 +13,13 @@
 obj-$(CONFIG_PHYLIB_10G) += generic_10g.o
 obj-$(CONFIG_PHY_ATHEROS) += atheros.o
 obj-$(CONFIG_PHY_BROADCOM) += broadcom.o
+obj-$(CONFIG_PHY_CORTINA) += cortina.o
 obj-$(CONFIG_PHY_DAVICOM) += davicom.o
 obj-$(CONFIG_PHY_ET1011C) += et1011c.o
 obj-$(CONFIG_PHY_ICPLUS) += icplus.o
 obj-$(CONFIG_PHY_LXT) += lxt.o
 obj-$(CONFIG_PHY_MARVELL) += marvell.o
+obj-y += marvell_sw.o
 obj-$(CONFIG_PHY_MICREL) += micrel.o
 obj-$(CONFIG_PHY_NATSEMI) += natsemi.o
 obj-$(CONFIG_PHY_REALTEK) += realtek.o
--- u-boot-2014.07/drivers/net/phy/phy.c.orig	2022-05-09 14:06:22.077196124 -0700
+++ u-boot-2014.07/drivers/net/phy/phy.c	2022-05-09 14:06:23.737128984 -0700
@@ -448,6 +448,9 @@
 #ifdef CONFIG_PHY_BROADCOM
 	phy_broadcom_init();
 #endif
+#ifdef CONFIG_PHY_CORTINA
+	phy_cortina_init();
+#endif
 #ifdef CONFIG_PHY_DAVICOM
 	phy_davicom_init();
 #endif
@@ -463,6 +466,9 @@
 #ifdef CONFIG_PHY_MARVELL
 	phy_marvell_init();
 #endif
+#if defined(CONFIG_M200) || defined(CONFIG_M300) || defined(CONFIG_BOREN_ETHNET_SETUP)
+	phy_marvell_sw_init();
+#endif
 #ifdef CONFIG_PHY_MICREL
 	phy_micrel_init();
 #endif
@@ -582,6 +588,22 @@
 {
 	int phy_reg;
 
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+	if(( addr ==  0x4 )  || ( addr == 0x10 ))
+	{
+		*phy_id = 0x12345678;
+		return 0;
+	}
+#endif
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	if(( addr ==  0x2))
+	{
+		*phy_id = 0x12345678;
+		return 0;
+	}
+#endif
+
+
 	/* Grab the bits from PHYIR1, and put them
 	 * in the upper half */
 	phy_reg = bus->read(bus, addr, devad, MII_PHYSID1);
@@ -675,6 +697,20 @@
 	int timeout = 500;
 	int devad = MDIO_DEVAD_NONE;
 
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+	if(( phydev->addr ==  0x4 )  || ( phydev->addr == 0x10 ))
+	{
+		return 0;
+	}
+#endif
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	if(( phydev->addr ==  0x2))
+	{
+		return 0;
+	}
+#endif
+
+
 #ifdef CONFIG_PHYLIB_10G
 	/* If it's 10G, we need to issue reset through one of the MMDs */
 	if (is_10g_interface(phydev->interface)) {
@@ -700,6 +736,9 @@
 
 #ifdef CONFIG_PHY_RESET_DELAY
 	udelay(CONFIG_PHY_RESET_DELAY);	/* Intel LXT971A needs this */
+#else
+#define CONFIG_PHY_RESET_DELAY 1000
+	udelay(CONFIG_PHY_RESET_DELAY);	/* Intel LXT971A needs this */
 #endif
 	/*
 	 * Poll the control register for the reset bit to go to 0 (it is
--- u-boot-2014.07/drivers/net/phy/mv88e61xx.h.orig	2022-05-09 14:06:22.077196124 -0700
+++ u-boot-2014.07/drivers/net/phy/mv88e61xx.h	2022-05-09 14:06:23.737128984 -0700
@@ -12,8 +12,24 @@
 #include <miiphy.h>
 
 #define MV88E61XX_CPU_PORT		0x5
-
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+#ifndef MV88E61XX_MAX_PORTS_NUM
+ #define MV88E61XX_MAX_PORTS_NUM	0x7		/* 88E6171R has 7 ports */
+#endif
+#define SC_MII_DEV_ADDR			0x10		/* Set by HW */
+#define MV88E61XX_PHY_TIMEOUT		10
+#define MV88E61XX_PORT_PHYCTRL_REG		0x1
+#define MV88E61XX_PORT_PHYCTRL_REG_RXDELAY_BIT	15
+#define MV88E61XX_PORT_PHYCTRL_REG_TXDELAY_BIT	14
+#define SC_GPIO_SW_RST			13
+#define SC_eTSEC1_PORT			6
+#define SC_eTSEC3_PORT			5
+#else
+#ifndef MV88E61XX_MAX_PORTS_NUM
+ #define MV88E61XX_MAX_PORTS_NUM	0x6
+#endif
 #define MV88E61XX_PHY_TIMEOUT		100000
+#endif
 
 /* port dev-addr (= port + 0x10) */
 #define MV88E61XX_PRT_OFST		0x10
@@ -46,10 +62,17 @@
 
 #ifdef CONFIG_MV88E61XX_MULTICHIP_ADRMODE
 static int mv88e61xx_busychk_multic(char *name, u32 devaddr);
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+void mv88e61xx_switch_write(char *name, u32 phy_adr,
+	u32 reg_ofs, u16 data);
+void mv88e61xx_switch_read(char *name, u32 phy_adr,
+	u32 reg_ofs, u16 *data);
+#else
 static void mv88e61xx_switch_write(char *name, u32 phy_adr,
 	u32 reg_ofs, u16 data);
 static void mv88e61xx_switch_read(char *name, u32 phy_adr,
 	u32 reg_ofs, u16 *data);
+#endif
 #define wr_switch_reg mv88e61xx_switch_write
 #define rd_switch_reg mv88e61xx_switch_read
 #else
--- u-boot-2014.07/drivers/net/phy/marvell.c.orig	2022-05-09 14:06:22.077196124 -0700
+++ u-boot-2014.07/drivers/net/phy/marvell.c	2022-05-09 14:06:23.737128984 -0700
@@ -156,7 +156,7 @@
 		phydev->speed = SPEED_10;
 		break;
 	}
-
+ 
 	return 0;
 }
 
@@ -259,7 +259,11 @@
 
 	/* soft reset */
 	timeout = 1000;
+#ifdef CONFIG_LANNER_BURN
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, 0x9140);
+#else
 	phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);
+#endif
 	udelay(1000);
 	reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
 	while ((reg & BMCR_RESET) && --timeout) {
@@ -373,14 +377,21 @@
 /* Marvell 88E1149S */
 static int m88e1149_config(struct phy_device *phydev)
 {
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x00, 0x00009140);
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1149_PHY_PAGE, 0x1f);
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x200c);
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1149_PHY_PAGE, 0x5);
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x0);
 	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
 
-	genphy_config_aneg(phydev);
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x09, 0xe00);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x04, 0x1e1);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x00, 0x00009140);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x00, 0x00001140);
+#endif
 
+	genphy_config_aneg(phydev);
 	phy_reset(phydev);
 
 	return 0;
@@ -438,6 +449,16 @@
 	.shutdown = &genphy_shutdown,
 };
 
+static struct phy_driver M88E1543_driver = {
+	.name = "Marvell 88E1543",
+	.uid = 0x1410ea0,
+	.mask = 0xffffff0,
+	.features = PHY_GBIT_FEATURES,
+	.config = &m88e1111s_config,
+	.startup = &m88e1011s_startup,
+	.shutdown = &genphy_shutdown,
+};
+
 static struct phy_driver M88E1118_driver = {
 	.name = "Marvell 88E1118",
 	.uid = 0x1410e10,
@@ -488,6 +509,7 @@
 	.shutdown = &genphy_shutdown,
 };
 
+#if 0
 static struct phy_driver M88E1518_driver = {
 	.name = "Marvell 88E1518",
 	.uid = 0x1410dd1,
@@ -497,6 +519,7 @@
 	.startup = &m88e1011s_startup,
 	.shutdown = &genphy_shutdown,
 };
+#endif
 
 static struct phy_driver M88E1310_driver = {
 	.name = "Marvell 88E1310",
@@ -508,6 +531,20 @@
 	.shutdown = &genphy_shutdown,
 };
 
+
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+/* add PHYID support for Aruba_k2's marvell88e1512 GE PHY */
+static struct phy_driver M88E1512_driver = {
+	.name = "Marvell 88E1512",
+	.uid = 0x1410dd0,
+	.mask = 0xffffff0,
+	.features = PHY_GBIT_FEATURES,
+	.config = &m88e1149_config,
+	.startup = &m88e1011s_startup,
+	.shutdown = &genphy_shutdown,
+};
+#endif
+
 int phy_marvell_init(void)
 {
 	phy_register(&M88E1310_driver);
@@ -517,8 +554,13 @@
 	phy_register(&M88E1118_driver);
 	phy_register(&M88E1118R_driver);
 	phy_register(&M88E1111S_driver);
+	phy_register(&M88E1543_driver);
 	phy_register(&M88E1011S_driver);
+#if 0
 	phy_register(&M88E1518_driver);
-
+#endif
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+	phy_register(&M88E1512_driver);
+#endif
 	return 0;
 }
--- u-boot-2014.07/drivers/net/fm/b4860.c.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/b4860.c	2022-05-09 14:06:23.725129469 -0700
@@ -10,6 +10,7 @@
 #include <asm/io.h>
 #include <asm/immap_85xx.h>
 #include <asm/fsl_serdes.h>
+#include <hwconfig.h>
 
 u32 port_to_devdisr[] = {
 	[FM1_DTSEC1] = FSL_CORENET_DEVDISR2_DTSEC1_1,
@@ -46,15 +47,76 @@
 
 phy_interface_t fman_port_enet_if(enum fm_port port)
 {
+#if defined(CONFIG_B4860QDS)
+	u32 serdes2_prtcl;
+	char buffer[HWCONFIG_BUFFER_SIZE];
+	char *buf = NULL;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+#endif
+
 	if (is_device_disabled(port))
 		return PHY_INTERFACE_MODE_NONE;
 
 	/*B4860 has two 10Gig Mac*/
 	if ((port == FM1_10GEC1 || port == FM1_10GEC2)	&&
 	    ((is_serdes_configured(XAUI_FM1_MAC9))	||
-	    (is_serdes_configured(XAUI_FM1_MAC10))))
+	     #if !defined(CONFIG_B4860QDS)
+	     (is_serdes_configured(XFI_FM1_MAC9))	||
+	     (is_serdes_configured(XFI_FM1_MAC10))	||
+	     #endif
+	     (is_serdes_configured(XAUI_FM1_MAC10))
+	     ))
 		return PHY_INTERFACE_MODE_XGMII;
 
+#if defined(CONFIG_B4860QDS)
+	serdes2_prtcl = in_be32(&gur->rcwsr[4]) &
+			FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+
+	if (serdes2_prtcl) {
+		serdes2_prtcl >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+		switch (serdes2_prtcl) {
+		case 0x80:
+		case 0x81:
+		case 0x82:
+		case 0x83:
+		case 0x84:
+		case 0x85:
+		case 0x86:
+		case 0x87:
+		case 0x88:
+		case 0x89:
+		case 0x8a:
+		case 0x8b:
+		case 0x8c:
+		case 0x8d:
+		case 0x8e:
+		case 0xb1:
+		case 0xb2:
+			/*
+			 * Extract hwconfig from environment since environment
+			 * is not setup yet
+			 */
+			getenv_f("hwconfig", buffer, sizeof(buffer));
+			buf = buffer;
+
+			/* check if XFI interface enable in hwconfig for 10g */
+			if (hwconfig_subarg_cmp_f("fsl_b4860_serdes2",
+						  "sfp_amc", "sfp", buf)) {
+				if ((port == FM1_10GEC1 ||
+				     port == FM1_10GEC2) &&
+				    ((is_serdes_configured(XFI_FM1_MAC9)) ||
+				    (is_serdes_configured(XFI_FM1_MAC10))))
+					return PHY_INTERFACE_MODE_XGMII;
+				else if ((port == FM1_DTSEC1) ||
+					 (port == FM1_DTSEC2) ||
+					 (port == FM1_DTSEC3) ||
+					 (port == FM1_DTSEC4))
+					return PHY_INTERFACE_MODE_NONE;
+			}
+		}
+	}
+#endif
+
 	/* Fix me need to handle RGMII here first */
 
 	switch (port) {
--- u-boot-2014.07/drivers/net/fm/memac.c.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/memac.c	2022-05-09 14:06:23.725129469 -0700
@@ -12,7 +12,6 @@
 #include <phy.h>
 #include <asm/types.h>
 #include <asm/io.h>
-#include <asm/fsl_enet.h>
 #include <asm/fsl_memac.h>
 
 #include "fm.h"
@@ -38,7 +37,8 @@
 {
 	struct memac *regs = mac->base;
 
-	setbits_be32(&regs->command_config, MEMAC_CMD_CFG_RXTX_EN);
+	setbits_be32(&regs->command_config,
+		     MEMAC_CMD_CFG_RXTX_EN | MEMAC_CMD_CFG_NO_LEN_CHK);
 }
 
 static void memac_disable_mac(struct fsl_enet_mac *mac)
@@ -94,11 +94,16 @@
 		if_mode &= ~IF_MODE_MASK;
 		if_mode |= (IF_MODE_GMII);
 		break;
+	case PHY_INTERFACE_MODE_XGMII:
+		if_mode &= ~IF_MODE_MASK;
+		if_mode |= IF_MODE_XGMII;
+		break;
 	default:
 		break;
 	}
-	/* Enable automatic speed selection */
-	if_mode |= IF_MODE_EN_AUTO;
+	/* Enable automatic speed selection for Non-XGMII */
+	if (type != PHY_INTERFACE_MODE_XGMII)
+		if_mode |= IF_MODE_EN_AUTO;
 
 	if (type == PHY_INTERFACE_MODE_RGMII) {
 		if_mode &= ~IF_MODE_EN_AUTO;
--- u-boot-2014.07/drivers/net/fm/init.c.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/init.c	2022-05-09 14:06:23.725129469 -0700
@@ -6,6 +6,7 @@
 #include <common.h>
 #include <asm/io.h>
 #include <asm/fsl_serdes.h>
+#include <fsl_mdio.h>
 
 #include "fm.h"
 
@@ -147,6 +148,9 @@
 {
 	int i = fm_port_to_index(port);
 
+	if (i == -1)
+		return;
+
 	fm_info[i].enabled = 0;
 	fman_disable_port(port);
 }
@@ -155,6 +159,9 @@
 {
 	int i = fm_port_to_index(port);
 
+	if (i == -1)
+		return;
+
 	fm_info[i].enabled = 1;
 	fman_enable_port(port);
 }
@@ -240,10 +247,12 @@
 	}
 
 #ifdef CONFIG_SYS_FMAN_V3
+#ifndef CONFIG_FSL_FM_10GEC_REGULAR_NOTATION
 	/*
-	 * Physically FM1_DTSEC9 and FM1_10GEC1 use the same dual-role MAC, when
-	 * FM1_10GEC1 is enabled and  FM1_DTSEC9 is disabled, ensure that the
-	 * dual-role MAC is not disabled, ditto for other dual-role MACs.
+	 * On T2/T4 SoCs, physically FM1_DTSEC9 and FM1_10GEC1 use the same
+	 * dual-role MAC, when FM1_10GEC1 is enabled and  FM1_DTSEC9
+	 * is disabled, ensure that the dual-role MAC is not disabled,
+	 * ditto for other dual-role MACs.
 	 */
 	if (((info->port == FM1_DTSEC9) && (PORT_IS_ENABLED(FM1_10GEC1)))  ||
 	    ((info->port == FM1_DTSEC10) && (PORT_IS_ENABLED(FM1_10GEC2))) ||
@@ -260,6 +269,17 @@
 	    ((info->port == FM2_10GEC1) && (PORT_IS_ENABLED(FM2_DTSEC9)))	||
 	    ((info->port == FM2_10GEC2) && (PORT_IS_ENABLED(FM2_DTSEC10)))
 #endif
+#else
+	/* FM1_DTSECx and FM1_10GECx use the same dual-role MAC */
+	if (((info->port == FM1_DTSEC1) && (PORT_IS_ENABLED(FM1_10GEC1)))  ||
+	    ((info->port == FM1_DTSEC2) && (PORT_IS_ENABLED(FM1_10GEC2)))  ||
+	    ((info->port == FM1_DTSEC3) && (PORT_IS_ENABLED(FM1_10GEC3)))  ||
+	    ((info->port == FM1_DTSEC4) && (PORT_IS_ENABLED(FM1_10GEC4)))  ||
+	    ((info->port == FM1_10GEC1) && (PORT_IS_ENABLED(FM1_DTSEC1)))  ||
+	    ((info->port == FM1_10GEC2) && (PORT_IS_ENABLED(FM1_DTSEC2)))  ||
+	    ((info->port == FM1_10GEC3) && (PORT_IS_ENABLED(FM1_DTSEC3)))  ||
+	    ((info->port == FM1_10GEC4) && (PORT_IS_ENABLED(FM1_DTSEC4)))
+#endif
 	)
 		return;
 #endif
--- u-boot-2014.07/drivers/net/fm/t4240.c.orig	2022-05-09 14:06:22.069196447 -0700
+++ u-boot-2014.07/drivers/net/fm/t4240.c	2022-05-09 14:06:23.725129469 -0700
@@ -71,6 +71,11 @@
 	     (is_serdes_configured(XFI_FM1_MAC10))))
 		return PHY_INTERFACE_MODE_XGMII;
 
+	if ((port == FM1_DTSEC9 || port == FM1_DTSEC10) &&
+	    ((is_serdes_configured(XFI_FM1_MAC9)) ||
+	     (is_serdes_configured(XFI_FM1_MAC10))))
+		return PHY_INTERFACE_MODE_XGMII;
+
 	if ((port == FM2_10GEC1 || port == FM2_10GEC2) &&
 	    ((is_serdes_configured(XAUI_FM2_MAC9))	||
 	     (is_serdes_configured(XAUI_FM2_MAC10))	||
--- u-boot-2014.07/drivers/net/fm/memac_phy.c.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/memac_phy.c	2022-05-09 14:06:23.725129469 -0700
@@ -71,6 +71,8 @@
 	u32 c45 = 1;
 
 	if (dev_addr == MDIO_DEVAD_NONE) {
+		if (!strcmp(bus->name, DEFAULT_FM_TGEC_MDIO_NAME))
+			return 0xffff;
 		c45 = 0; /* clause 22 */
 		dev_addr = regnum & 0x1f;
 		clrbits_be32(&regs->mdio_stat, MDIO_STAT_ENC);
--- u-boot-2014.07/drivers/net/fm/fm.h.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/fm.h	2022-05-09 14:06:23.725129469 -0700
@@ -8,8 +8,8 @@
 #define __FM_H__
 
 #include <common.h>
+#include <phy.h>
 #include <fm_eth.h>
-#include <asm/fsl_enet.h>
 #include <asm/fsl_fman.h>
 
 /* Port ID */
@@ -143,6 +143,7 @@
 #define MAX_RXBUF_LOG2		11
 #define MAX_RXBUF_LEN		(1 << MAX_RXBUF_LOG2)
 
-#define PORT_IS_ENABLED(port)	fm_info[fm_port_to_index(port)].enabled
+#define PORT_IS_ENABLED(port)	(fm_port_to_index(port) == -1 ? \
+	0 : fm_info[fm_port_to_index(port)].enabled)
 
 #endif /* __FM_H__ */
--- u-boot-2014.07/drivers/net/fm/eth.c.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/eth.c	2022-05-09 14:06:23.725129469 -0700
@@ -39,9 +39,14 @@
 	u32 value;
 	struct mii_dev bus;
 	bus.priv = priv->mac->phyregs;
+	bool sgmii_2500 = (priv->enet_if ==
+			PHY_INTERFACE_MODE_SGMII_2500) ? true : false;
+
+	/* SGMII IF mode + AN enable only for 1G SGMII, not for 2.5G */
+	value = PHY_SGMII_IF_MODE_SGMII;
+	if (!sgmii_2500)
+		value |= PHY_SGMII_IF_MODE_AN;
 
-	/* SGMII IF mode + AN enable */
-	value = PHY_SGMII_IF_MODE_AN | PHY_SGMII_IF_MODE_SGMII;
 	memac_mdio_write(&bus, 0, MDIO_DEVAD_NONE, 0x14, value);
 
 	/* Dev ability according to SGMII specification */
@@ -54,7 +59,9 @@
 	memac_mdio_write(&bus, 0, MDIO_DEVAD_NONE, 0x12, 0xd40);
 
 	/* Restart AN */
-	value = PHY_SGMII_CR_DEF_VAL | PHY_SGMII_CR_RESET_AN;
+	value = PHY_SGMII_CR_DEF_VAL;
+	if (!sgmii_2500)
+		value |= PHY_SGMII_CR_RESET_AN;
 	memac_mdio_write(&bus, 0, MDIO_DEVAD_NONE, 0, value);
 #else
 	struct dtsec *regs = priv->mac->base;
@@ -83,7 +90,8 @@
 	out_be32(&regs->tbipa, CONFIG_SYS_TBIPA_VALUE);
 #endif
 
-	if (fm_eth->enet_if == PHY_INTERFACE_MODE_SGMII)
+	if (fm_eth->enet_if == PHY_INTERFACE_MODE_SGMII ||
+	    fm_eth->enet_if == PHY_INTERFACE_MODE_SGMII_2500)
 		dtsec_configure_serdes(fm_eth);
 }
 
@@ -557,9 +565,11 @@
 	num = fm_eth->num;
 
 #ifdef CONFIG_SYS_FMAN_V3
+#ifndef CONFIG_FSL_FM_10GEC_REGULAR_NOTATION
 	if (fm_eth->type == FM_ETH_10G_E) {
-		/* 10GEC1/10GEC2 use mEMAC9/mEMAC10
-		 * 10GEC3/10GEC4 use mEMAC1/mEMAC2
+		/* 10GEC1/10GEC2 use mEMAC9/mEMAC10 on T2080/T4240.
+		 * 10GEC3/10GEC4 use mEMAC1/mEMAC2 on T2080.
+		 * 10GEC1 uses mEMAC1 on T1024.
 		 * so it needs to change the num.
 		 */
 		if (fm_eth->num >= 2)
@@ -567,6 +577,7 @@
 		else
 			num += 8;
 	}
+#endif
 	base = &reg->memac[num].fm_memac;
 	phyregs = &reg->memac[num].fm_memac_mdio;
 #else
--- u-boot-2014.07/drivers/net/fm/tgec.c.orig	2022-05-09 14:06:22.069196447 -0700
+++ u-boot-2014.07/drivers/net/fm/tgec.c	2022-05-09 14:06:23.729129308 -0700
@@ -12,7 +12,6 @@
 #include <phy.h>
 #include <asm/types.h>
 #include <asm/io.h>
-#include <asm/fsl_enet.h>
 #include <asm/fsl_tgec.h>
 
 #include "fm.h"
--- u-boot-2014.07/drivers/net/fm/dtsec.c.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/dtsec.c	2022-05-09 14:06:23.725129469 -0700
@@ -7,7 +7,6 @@
 #include <common.h>
 #include <asm/types.h>
 #include <asm/io.h>
-#include <asm/fsl_enet.h>
 #include <asm/fsl_dtsec.h>
 #include <fsl_mdio.h>
 #include <phy.h>
--- u-boot-2014.07/drivers/net/fm/Makefile.orig	2022-05-09 14:06:22.065196609 -0700
+++ u-boot-2014.07/drivers/net/fm/Makefile	2022-05-09 14:06:23.725129469 -0700
@@ -28,8 +28,12 @@
 obj-$(CONFIG_PPC_T1042)	+= t1040.o
 obj-$(CONFIG_PPC_T1020)	+= t1040.o
 obj-$(CONFIG_PPC_T1022)	+= t1040.o
+obj-$(CONFIG_PPC_M200)	+= t1040.o
+obj-$(CONFIG_PPC_T1023) += t1024.o
+obj-$(CONFIG_PPC_T1024) += t1024.o
 obj-$(CONFIG_PPC_T2080) += t2080.o
 obj-$(CONFIG_PPC_T2081) += t2080.o
+obj-$(CONFIG_PPC_M300) += t2080.o
 obj-$(CONFIG_PPC_T4240) += t4240.o
 obj-$(CONFIG_PPC_T4160) += t4240.o
 obj-$(CONFIG_PPC_T4080) += t4240.o
--- u-boot-2014.07/drivers/net/fm/t1040.c.orig	2022-05-09 14:06:22.069196447 -0700
+++ u-boot-2014.07/drivers/net/fm/t1040.c	2022-05-09 14:06:23.725129469 -0700
@@ -49,8 +49,6 @@
 		else if ((rcwsr13 & FSL_CORENET_RCWSR13_EC2) ==
 				FSL_CORENET_RCWSR13_EC2_FM1_DTSEC5_MII)
 			return PHY_INTERFACE_MODE_MII;
-		else
-			return PHY_INTERFACE_MODE_NONE;
 	}
 
 	switch (port) {
--- u-boot-2014.07/drivers/mmc/fsl_esdhc.c.orig	2022-05-09 14:06:22.033197904 -0700
+++ u-boot-2014.07/drivers/mmc/fsl_esdhc.c	2022-05-09 14:06:23.689130926 -0700
@@ -96,7 +96,7 @@
 	else if (cmd->resp_type & MMC_RSP_PRESENT)
 		xfertyp |= XFERTYP_RSPTYP_48;
 
-#if defined(CONFIG_MX53) || defined(CONFIG_PPC_T4240)
+#if defined(CONFIG_MX53) || defined(CONFIG_PPC_T4240) || defined(CONFIG_LS102XA)
 	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
 		xfertyp |= XFERTYP_CMDTYP_ABORT;
 #endif
@@ -561,7 +561,7 @@
 	memset(&cfg->cfg, 0, sizeof(cfg->cfg));
 
 	voltage_caps = 0;
-	caps = regs->hostcapblt;
+	caps = esdhc_read32(&regs->hostcapblt);
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_ESDHC135
 	caps = caps & ~(ESDHC_HOSTCAPBLT_SRS |
--- u-boot-2014.07/drivers/pci/Makefile.orig	2022-05-09 14:06:22.081195962 -0700
+++ u-boot-2014.07/drivers/pci/Makefile	2022-05-09 14:06:23.745128661 -0700
@@ -17,3 +17,4 @@
 obj-$(CONFIG_SH7780_PCI) +=pci_sh7780.o
 obj-$(CONFIG_TSI108_PCI) += tsi108_pci.o
 obj-$(CONFIG_WINBOND_83C553) += w83c553f.o
+obj-$(CONFIG_PCIE_LAYERSCAPE) += pcie_layerscape.o
--- u-boot-2014.07/drivers/serial/serial_lpuart.c.orig	2022-05-09 14:06:22.101195153 -0700
+++ u-boot-2014.07/drivers/serial/serial_lpuart.c	2022-05-09 14:06:23.761128014 -0700
@@ -17,10 +17,34 @@
 #define UC2_TE          (1 << 3)
 #define UC2_RE          (1 << 2)
 
+#define STAT_LBKDIF	(1 << 31)
+#define STAT_RXEDGIF	(1 << 30)
+#define STAT_TDRE	(1 << 23)
+#define STAT_RDRF	(1 << 21)
+#define STAT_IDLE	(1 << 20)
+#define STAT_OR		(1 << 19)
+#define STAT_NF		(1 << 18)
+#define STAT_FE		(1 << 17)
+#define STAT_PF		(1 << 16)
+#define STAT_MA1F	(1 << 15)
+#define STAT_MA2F	(1 << 14)
+#define STAT_FLAGS	(STAT_LBKDIF | STAT_RXEDGIF | STAT_IDLE | STAT_OR | \
+			STAT_NF | STAT_FE | STAT_PF | STAT_MA1F | STAT_MA2F)
+
+#define CTRL_TE		(1 << 19)
+#define CTRL_RE		(1 << 18)
+
+#define FIFO_TXFE		0x80
+#define FIFO_RXFE		0x40
+
+#define WATER_TXWATER_OFF	1
+#define WATER_RXWATER_OFF	16
+
 DECLARE_GLOBAL_DATA_PTR;
 
 struct lpuart_fsl *base = (struct lpuart_fsl *)LPUART_BASE;
 
+#ifndef CONFIG_LPUART_32B_REG
 static void lpuart_serial_setbrg(void)
 {
 	u32 clk = mxc_get_clock(MXC_UART_CLK);
@@ -107,13 +131,107 @@
 	.getc = lpuart_serial_getc,
 	.tstc = lpuart_serial_tstc,
 };
+#else
+static void lpuart32_serial_setbrg(void)
+{
+	u32 clk = CONFIG_SYS_CLK_FREQ;
+	u32 sbr;
+
+	if (!gd->baudrate)
+		gd->baudrate = CONFIG_BAUDRATE;
+
+	sbr = (clk / (16 * gd->baudrate));
+	/* place adjustment later - n/32 BRFA */
+
+	out_be32(&base->baud, sbr);
+}
+
+static int lpuart32_serial_getc(void)
+{
+	u32 stat;
+
+	while (((stat = in_be32(&base->stat)) & STAT_RDRF) == 0) {
+		out_be32(&base->stat, STAT_FLAGS);
+		WATCHDOG_RESET();
+	}
+
+	return in_be32(&base->data) & 0x3ff;
+}
+
+static void lpuart32_serial_putc(const char c)
+{
+	if (c == '\n')
+		serial_putc('\r');
+
+	while (!(in_be32(&base->stat) & STAT_TDRE))
+		WATCHDOG_RESET();
+
+	out_be32(&base->data, c);
+}
+
+/*
+ * Test whether a character is in the RX buffer
+ */
+static int lpuart32_serial_tstc(void)
+{
+	if ((in_be32(&base->water) >> 24) == 0)
+		return 0;
+
+	return 1;
+}
+
+/*
+ * Initialise the serial port with the given baudrate. The settings
+ * are always 8 data bits, no parity, 1 stop bit, no start bits.
+ */
+static int lpuart32_serial_init(void)
+{
+	u8 ctrl;
+
+	ctrl = in_be32(&base->ctrl);
+	ctrl &= ~CTRL_RE;
+	ctrl &= ~CTRL_TE;
+	out_be32(&base->ctrl, ctrl);
+
+	out_be32(&base->modir, 0);
+	out_be32(&base->fifo, ~(FIFO_TXFE | FIFO_RXFE));
+
+	out_be32(&base->match, 0);
+	/* provide data bits, parity, stop bit, etc */
+
+	serial_setbrg();
+
+	out_be32(&base->ctrl, CTRL_RE | CTRL_TE);
+
+	return 0;
+}
+
+static struct serial_device lpuart32_serial_drv = {
+	.name = "lpuart32_serial",
+	.start = lpuart32_serial_init,
+	.stop = NULL,
+	.setbrg = lpuart32_serial_setbrg,
+	.putc = lpuart32_serial_putc,
+	.puts = default_serial_puts,
+	.getc = lpuart32_serial_getc,
+	.tstc = lpuart32_serial_tstc,
+};
+#endif
 
 void lpuart_serial_initialize(void)
 {
+#ifdef CONFIG_LPUART_32B_REG
+	serial_register(&lpuart32_serial_drv);
+#else
 	serial_register(&lpuart_serial_drv);
+#endif
 }
 
 __weak struct serial_device *default_serial_console(void)
 {
+#ifdef CONFIG_LPUART_32B_REG
+	return &lpuart32_serial_drv;
+#else
 	return &lpuart_serial_drv;
+#endif
 }
--- u-boot-2014.07/drivers/usb/host/Makefile.orig	2022-05-09 14:06:22.125194182 -0700
+++ u-boot-2014.07/drivers/usb/host/Makefile	2022-05-09 14:06:23.785127043 -0700
@@ -23,6 +23,7 @@
 obj-$(CONFIG_USB_EHCI_FSL) += ehci-mpc512x.o
 else
 obj-$(CONFIG_USB_EHCI_FSL) += ehci-fsl.o
+obj-$(CONFIG_USB_XHCI_FSL) += xhci-fsl.o
 endif
 obj-$(CONFIG_USB_EHCI_FARADAY) += ehci-faraday.o
 obj-$(CONFIG_USB_EHCI_EXYNOS) += ehci-exynos.o
--- u-boot-2014.07/drivers/usb/host/ehci-fsl.c.orig	2022-05-09 14:06:22.129194021 -0700
+++ u-boot-2014.07/drivers/usb/host/ehci-fsl.c	2022-05-09 14:06:23.785127043 -0700
@@ -14,10 +14,15 @@
 #include <asm/io.h>
 #include <usb/ehci-fsl.h>
 #include <hwconfig.h>
-#include <asm/fsl_errata.h>
+#include <fsl_usb.h>
+#include <fdt_support.h>
 
 #include "ehci.h"
 
+#ifndef CONFIG_USB_MAX_CONTROLLER_COUNT
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+#endif
+
 static void set_txfifothresh(struct usb_ehci *, u32);
 
 /* Check USB PHY clock valid */
@@ -130,10 +135,19 @@
 
 	in_le32(&ehci->usbmode);
 
-	if (SVR_SOC_VER(get_svr()) == SVR_T4240 &&
-	    IS_SVR_REV(get_svr(), 2, 0))
+	if (has_erratum_a007798())
 		set_txfifothresh(ehci, TXFIFOTHRESH);
 
+	if (has_erratum_a004477()) {
+		/*
+		 * When reset is issued while any ULPI transaction is ongoing
+		 * then it may result to corruption of ULPI Function Control
+		 * Register which eventually causes phy clock to enter low
+		 * power mode which stops the clock. Thus delay is required
+		 * before reset to let ongoing ULPI transaction complete.
+		 */
+		udelay(1);
+	}
 	return 0;
 }
 
@@ -159,3 +173,198 @@
 	cmd |= TXFIFO_THRESH(txfifo_thresh);
 	ehci_writel(&ehci->txfilltuning, cmd);
 }
+
+#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)
+static int fdt_fixup_usb_mode_phy_type(void *blob, const char *mode,
+				       const char *phy_type, int start_offset)
+{
+	const char *compat_dr = "fsl-usb2-dr";
+	const char *compat_mph = "fsl-usb2-mph";
+	const char *prop_mode = "dr_mode";
+	const char *prop_type = "phy_type";
+	const char *node_type = NULL;
+	int node_offset;
+	int err;
+
+	node_offset = fdt_node_offset_by_compatible(blob,
+						    start_offset, compat_mph);
+	if (node_offset < 0) {
+		node_offset = fdt_node_offset_by_compatible(blob,
+							    start_offset,
+							    compat_dr);
+		if (node_offset < 0) {
+			printf("WARNING: could not find compatible node: %s",
+			       fdt_strerror(node_offset));
+			return -1;
+		}
+		node_type = compat_dr;
+	} else {
+		node_type = compat_mph;
+	}
+
+	if (mode) {
+		err = fdt_setprop(blob, node_offset, prop_mode, mode,
+				  strlen(mode) + 1);
+		if (err < 0)
+			printf("WARNING: could not set %s for %s: %s.\n",
+			       prop_mode, node_type, fdt_strerror(err));
+	}
+
+	if (phy_type) {
+		err = fdt_setprop(blob, node_offset, prop_type, phy_type,
+				  strlen(phy_type) + 1);
+		if (err < 0)
+			printf("WARNING: could not set %s for %s: %s.\n",
+			       prop_type, node_type, fdt_strerror(err));
+	}
+
+	return node_offset;
+}
+
+static const char *fdt_usb_get_node_type(void *blob, int start_offset,
+					 int *node_offset)
+{
+	const char *compat_dr = "fsl-usb2-dr";
+	const char *compat_mph = "fsl-usb2-mph";
+	const char *node_type = NULL;
+
+	*node_offset = fdt_node_offset_by_compatible(blob, start_offset,
+						     compat_mph);
+	if (*node_offset < 0) {
+		*node_offset = fdt_node_offset_by_compatible(blob,
+							     start_offset,
+							     compat_dr);
+		if (*node_offset < 0) {
+			printf("ERROR: could not find compatible node: %s\n",
+			       fdt_strerror(*node_offset));
+		} else {
+			node_type = compat_dr;
+		}
+	} else {
+		node_type = compat_mph;
+	}
+
+	return node_type;
+}
+
+static int fdt_fixup_usb_erratum(void *blob, const char *prop_erratum,
+				 int start_offset)
+{
+	int node_offset, err;
+	const char *node_type = NULL;
+
+	node_type = fdt_usb_get_node_type(blob, start_offset, &node_offset);
+	if (!node_type)
+		return -1;
+
+	err = fdt_setprop(blob, node_offset, prop_erratum, NULL, 0);
+	if (err < 0) {
+		printf("ERROR: could not set %s for %s: %s.\n",
+		       prop_erratum, node_type, fdt_strerror(err));
+	}
+
+	return node_offset;
+}
+
+void fdt_fixup_dr_usb(void *blob, bd_t *bd)
+{
+	static const char * const modes[] = { "host", "peripheral", "otg" };
+	static const char * const phys[] = { "ulpi", "utmi", "utmi_dual" };
+	int usb_erratum_a006261_off = -1;
+	int usb_erratum_a007075_off = -1;
+	int usb_erratum_a007792_off = -1;
+	int usb_erratum_a005697_off = -1;
+	int usb_mode_off = -1;
+	int usb_phy_off = -1;
+	char str[5];
+	int i, j;
+
+	for (i = 1; i <= CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
+		const char *dr_mode_type = NULL;
+		const char *dr_phy_type = NULL;
+		int mode_idx = -1, phy_idx = -1;
+
+		snprintf(str, 5, "%s%d", "usb", i);
+		if (hwconfig(str)) {
+			for (j = 0; j < ARRAY_SIZE(modes); j++) {
+				if (hwconfig_subarg_cmp(str, "dr_mode",
+							modes[j])) {
+					mode_idx = j;
+					break;
+				}
+			}
+
+			for (j = 0; j < ARRAY_SIZE(phys); j++) {
+				if (hwconfig_subarg_cmp(str, "phy_type",
+							phys[j])) {
+					phy_idx = j;
+					break;
+				}
+			}
+
+			if (mode_idx < 0 && phy_idx < 0) {
+				printf("WARNING: invalid phy or mode\n");
+				return;
+			}
+
+			if (mode_idx > -1)
+				dr_mode_type = modes[mode_idx];
+
+			if (phy_idx > -1)
+				dr_phy_type = phys[phy_idx];
+		}
+
+		if (has_dual_phy())
+			dr_phy_type = phys[2];
+
+		usb_mode_off = fdt_fixup_usb_mode_phy_type(blob,
+							   dr_mode_type, NULL,
+							   usb_mode_off);
+
+		if (usb_mode_off < 0)
+			return;
+
+		usb_phy_off = fdt_fixup_usb_mode_phy_type(blob,
+							  NULL, dr_phy_type,
+							  usb_phy_off);
+
+		if (usb_phy_off < 0)
+			return;
+
+		if (has_erratum_a006261()) {
+			usb_erratum_a006261_off =  fdt_fixup_usb_erratum
+						   (blob,
+						    "fsl,usb-erratum-a006261",
+						    usb_erratum_a006261_off);
+			if (usb_erratum_a006261_off < 0)
+				return;
+		}
+
+		if (has_erratum_a007075()) {
+			usb_erratum_a007075_off =  fdt_fixup_usb_erratum
+						   (blob,
+						    "fsl,usb-erratum-a007075",
+						    usb_erratum_a007075_off);
+			if (usb_erratum_a007075_off < 0)
+				return;
+		}
+
+		if (has_erratum_a007792()) {
+			usb_erratum_a007792_off =  fdt_fixup_usb_erratum
+						   (blob,
+						    "fsl,usb-erratum-a007792",
+						    usb_erratum_a007792_off);
+			if (usb_erratum_a007792_off < 0)
+				return;
+		}
+		if (has_erratum_a005697()) {
+			usb_erratum_a005697_off =  fdt_fixup_usb_erratum
+						   (blob,
+						    "fsl,usb-erratum-a005697",
+						    usb_erratum_a005697_off);
+			if (usb_erratum_a005697_off < 0)
+				return;
+		}
+	}
+}
+#endif
--- u-boot-2014.07/drivers/mtd/nand/fsl_ifc_nand.c.orig	2022-05-09 14:06:22.041197580 -0700
+++ u-boot-2014.07/drivers/mtd/nand/fsl_ifc_nand.c	2022-05-09 14:06:23.697130602 -0700
@@ -290,7 +290,7 @@
 	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
 	struct fsl_ifc *ifc = ctrl->regs;
 	long long end_tick;
-	u32 eccstat[4];
+	u32 eccstat[4] = {0};
 	int i;
 
 	/* set the chip select for NAND Transaction */
--- u-boot-2014.07/drivers/mtd/nand/fsl_ifc_spl.c.orig	2022-05-09 14:06:22.041197580 -0700
+++ u-boot-2014.07/drivers/mtd/nand/fsl_ifc_spl.c	2022-05-09 14:06:23.697130602 -0700
@@ -250,3 +250,13 @@
 	uboot = (void *)CONFIG_SYS_NAND_U_BOOT_START;
 	uboot();
 }
+
+#ifndef CONFIG_SPL_NAND_INIT
+void nand_init(void)
+{
+}
+
+void nand_deselect(void)
+{
+}
+#endif
--- u-boot-2014.07/drivers/mtd/spi/sf_params.c.orig	2022-05-09 14:06:22.049197257 -0700
+++ u-boot-2014.07/drivers/mtd/spi/sf_params.c	2022-05-09 14:06:23.709130117 -0700
@@ -15,7 +15,7 @@
 const struct spi_flash_params spi_flash_params_table[] = {
 #ifdef CONFIG_SPI_FLASH_ATMEL		/* ATMEL */
 	{"AT45DB011D",	   0x1f2200, 0x0,	64 * 1024,     4,	0,		    SECT_4K},
-	{"AT45DB021D",	   0x1f2300, 0x0,	64 * 1024,     8,	0,		    SECT_4K},
+	{"AT45DB021D", 0x1f2300, 0x0, 32 * 1024, 8, 0, SECT_2K},
 	{"AT45DB041D",	   0x1f2400, 0x0,	64 * 1024,     8,	0,		    SECT_4K},
 	{"AT45DB081D",	   0x1f2500, 0x0,	64 * 1024,    16,	0,		    SECT_4K},
 	{"AT45DB161D",	   0x1f2600, 0x0,	64 * 1024,    32,	0,		    SECT_4K},
@@ -94,6 +94,7 @@
 	{"SST25WF010",	   0xbf2502, 0x0,	64 * 1024,     2,       0,          SECT_4K | SST_WP},
 	{"SST25WF020",	   0xbf2503, 0x0,	64 * 1024,     4,       0,	    SECT_4K | SST_WP},
 	{"SST25WF040",	   0xbf2504, 0x0,	64 * 1024,     8,       0,	    SECT_4K | SST_WP},
+	{"SST25WF040B",    0x621613, 0x0,       64 * 1024,     8,       0,          SECT_4K | SST_WP},
 	{"SST25WF080",	   0xbf2505, 0x0,	64 * 1024,    16,       0,	    SECT_4K | SST_WP},
 #endif
 #ifdef CONFIG_SPI_FLASH_WINBOND		/* WINBOND */
--- u-boot-2014.07/drivers/mtd/spi/sf_internal.h.orig	2022-05-09 14:06:22.049197257 -0700
+++ u-boot-2014.07/drivers/mtd/spi/sf_internal.h	2022-05-09 14:06:23.709130117 -0700
@@ -21,6 +21,7 @@
 #define SPI_FLASH_CFI_MFR_WINBOND	0xef
 
 /* Erase commands */
+#define CMD_ERASE_2K			0x50
 #define CMD_ERASE_4K			0x20
 #define CMD_ERASE_32K			0x52
 #define CMD_ERASE_CHIP			0xc7
@@ -36,6 +37,11 @@
 #define CMD_WRITE_ENABLE		0x06
 #define CMD_READ_CONFIG			0x35
 #define CMD_FLAG_STATUS			0x70
+#define CMD_CLEAR_FLAG_STATUS		0x50
+
+/* Used for Macronix and Winbond flashes */
+#define	CMD_ENTER_4B_ADDR		0xB7
+#define	CMD_EXIT_4B_ADDR		0xE9
 
 /* Read commands */
 #define CMD_READ_ARRAY_SLOW		0x03
@@ -46,6 +52,12 @@
 #define CMD_READ_QUAD_IO_FAST		0xeb
 #define CMD_READ_ID			0x9f
 
+/* ATMEL dataflash commands*/
+#define CMD_ATMEL_PAGE_PROGRAM		0x82
+#define CMD_ATMEL_READ_STATUS		0xd7
+#define CMD_ATMEL_FLAG_STATUS		0xd7
+#define CMD_ATMEL_ERASE_32K		0x7c
+
 /* Bank addr access commands */
 #ifdef CONFIG_SPI_FLASH_BAR
 # define CMD_BANKADDR_BRWR		0x17
@@ -59,6 +71,8 @@
 #define STATUS_QEB_WINSPAN		(1 << 1)
 #define STATUS_QEB_MXIC			(1 << 6)
 #define STATUS_PEC			(1 << 7)
+#define STATUS_PROT			(1 << 1)
+#define STATUS_ERASE			(1 << 5)
 
 /* Flash timeout values */
 #define SPI_FLASH_PROG_TIMEOUT		(2 * CONFIG_SYS_HZ)
@@ -75,6 +89,10 @@
 		const void *buf);
 #endif
 
+#ifdef CONFIG_SF_DATAFLASH
+int board_spi_is_dataflash(unsigned int bus, unsigned int cs);
+#endif
+
 /* Send a single-byte command to the device and read the response */
 int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
 
@@ -120,6 +138,12 @@
 	return spi_flash_cmd(flash->spi, CMD_WRITE_DISABLE, NULL, 0);
 }
 
+/* Clear flag status register */
+static inline int spi_flash_cmd_clear_flag_status(struct spi_flash *flash)
+{
+	return spi_flash_cmd(flash->spi, CMD_CLEAR_FLAG_STATUS, NULL, 0);
+}
+
 /*
  * Send the read status command to the device and wait for the wip
  * (write-in-progress) bit to clear itself.
@@ -156,4 +180,8 @@
 int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		size_t len, void *data);
 
+#if defined(CONFIG_SPI_FLASH_STMICRO)
+int spi_flash_cmd_4B_addr_switch(struct spi_flash *flash, int enable);
+#endif
+
 #endif /* _SF_INTERNAL_H_ */
--- u-boot-2014.07/drivers/mtd/spi/sf_ops.c.orig	2022-05-09 14:06:22.049197257 -0700
+++ u-boot-2014.07/drivers/mtd/spi/sf_ops.c	2022-05-09 14:06:23.709130117 -0700
@@ -93,6 +93,30 @@
 }
 #endif
 
+#if defined(CONFIG_SPI_FLASH_STMICRO)
+int spi_flash_cmd_4B_addr_switch(struct spi_flash *flash, int enable)
+{
+	int ret;
+	u8 cmd;
+
+	cmd = enable ? CMD_ENTER_4B_ADDR : CMD_EXIT_4B_ADDR;
+
+	ret = spi_claim_bus(flash->spi);
+	if (ret) {
+		debug("SF: unable to claim SPI bus\n");
+		return ret;
+	}
+
+	ret = spi_flash_cmd_write_enable(flash);
+	if (ret < 0) {
+		debug("SF: enabling write failed\n");
+		return ret;
+	}
+
+	return spi_flash_cmd(flash->spi, cmd, NULL, 0);
+}
+#endif
+
 #ifdef CONFIG_SPI_FLASH_BAR
 static int spi_flash_cmd_bankaddr_write(struct spi_flash *flash, u8 bank_sel)
 {
@@ -160,12 +184,13 @@
 	unsigned long timebase;
 	unsigned long flags = SPI_XFER_BEGIN;
 	int ret;
+	int out_of_time = 1;
 	u8 status;
 	u8 check_status = 0x0;
 	u8 poll_bit = STATUS_WIP;
 	u8 cmd = flash->poll_cmd;
 
-	if (cmd == CMD_FLAG_STATUS) {
+	if (cmd == CMD_FLAG_STATUS || cmd == CMD_ATMEL_FLAG_STATUS) {
 		poll_bit = STATUS_PEC;
 		check_status = poll_bit;
 	}
@@ -186,22 +211,45 @@
 		WATCHDOG_RESET();
 
 		ret = spi_xfer(spi, 8, NULL, &status, 0);
-		if (ret)
+		if (ret) {
+			spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
 			return -1;
+		}
 
-		if ((status & poll_bit) == check_status)
+		if ((status & poll_bit) == check_status) {
+			out_of_time = 0;
 			break;
+		}
 
 	} while (get_timer(timebase) < timeout);
 
 	spi_xfer(spi, 0, NULL, NULL, SPI_XFER_END);
 
-	if ((status & poll_bit) == check_status)
-		return 0;
+	if (out_of_time) {
+		/* Timed out */
+		debug("SF: time out!\n");
+		if (cmd == CMD_FLAG_STATUS) {
+			if (spi_flash_cmd_clear_flag_status(flash) < 0)
+				debug("SF: clear flag status failed\n");
+		}
+		ret = -1;
+	}
+#ifdef CONFIG_SPI_FLASH_STMICRO
+	else if (cmd == CMD_FLAG_STATUS) {
+		if (!(status & (STATUS_PROT | STATUS_ERASE))) {
+			ret = 0;
+		} else {
+			debug("SF: flag status error");
+			ret = -1;
+		}
 
-	/* Timed out */
-	debug("SF: time out!\n");
-	return -1;
+		if (spi_flash_cmd_clear_flag_status(flash) < 0) {
+			debug("SF: clear flag status failed\n");
+			ret = -1;
+		}
+	}
+#endif
+	return ret;
 }
 
 int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
@@ -234,7 +282,7 @@
 
 	ret = spi_flash_cmd_wait_ready(flash, timeout);
 	if (ret < 0) {
-		debug("SF: write %s timed out\n",
+		debug("SF: write %s failed\n",
 		      timeout == SPI_FLASH_PROG_TIMEOUT ?
 			"program" : "page erase");
 		return ret;
--- u-boot-2014.07/drivers/mtd/spi/sf_probe.c.orig	2022-05-09 14:06:22.049197257 -0700
+++ u-boot-2014.07/drivers/mtd/spi/sf_probe.c	2022-05-09 14:06:23.709130117 -0700
@@ -169,7 +169,10 @@
 #endif
 
 	/* Compute erase sector and command */
-	if (params->flags & SECT_4K) {
+	if (params->flags & SECT_2K) {
+		flash->erase_cmd = CMD_ERASE_2K;
+		flash->erase_size = 2048 << flash->shift;
+	} else if (params->flags & SECT_4K) {
 		flash->erase_cmd = CMD_ERASE_4K;
 		flash->erase_size = 4096 << flash->shift;
 	} else if (params->flags & SECT_32K) {
@@ -221,8 +224,21 @@
 #ifdef CONFIG_SPI_FLASH_STMICRO
 	if (params->flags & E_FSR)
 		flash->poll_cmd = CMD_FLAG_STATUS;
+
+	if (flash->size > SPI_FLASH_16MB_BOUN) {
+		if (spi_flash_cmd_4B_addr_switch(flash, 0) < 0)
+			debug("SF: enter 3B address mode failed\n");
+	}
 #endif
 
+#ifdef CONFIG_SF_DATAFLASH
+	if (board_spi_is_dataflash(spi->bus, spi->cs)) {
+		flash->poll_cmd = CMD_ATMEL_READ_STATUS;
+		flash->write_cmd = CMD_ATMEL_PAGE_PROGRAM;
+		if (params->flags & SECT_32K)
+			flash->erase_cmd = CMD_ATMEL_ERASE_32K;
+	}
+#endif
 	/* Configure the BAR - discover bank cmds and read current bank */
 #ifdef CONFIG_SPI_FLASH_BAR
 	u8 curr_bank = 0;
@@ -247,6 +263,10 @@
 #if defined(CONFIG_SPI_FLASH_ATMEL) || \
 	defined(CONFIG_SPI_FLASH_MACRONIX) || \
 	defined(CONFIG_SPI_FLASH_SST)
+#ifdef CONFIG_SF_DATAFLASH
+		if (!board_spi_is_dataflash(spi->bus, spi->cs))
+			return flash;
+#endif
 		spi_flash_cmd_write_status(flash, 0);
 #endif
 
--- u-boot-2014.07/drivers/video/Makefile.orig	2022-05-09 14:06:22.145193374 -0700
+++ u-boot-2014.07/drivers/video/Makefile	2022-05-09 14:06:23.801126396 -0700
@@ -15,6 +15,7 @@
 				exynos_mipi_dsi_lowlevel.o
 obj-$(CONFIG_EXYNOS_PWM_BL) += exynos_pwm_bl.o
 obj-$(CONFIG_FSL_DIU_FB) += fsl_diu_fb.o videomodes.o
+obj-$(CONFIG_FSL_DCU_FB) += fsl_dcu_fb.o videomodes.o
 obj-$(CONFIG_L5F31188) += l5f31188.o
 obj-$(CONFIG_MPC8XX_LCD) += mpc8xx_lcd.o
 obj-$(CONFIG_PXA_LCD) += pxa_lcd.o
--- u-boot-2014.07/drivers/block/sata_sil.c.orig	2022-05-09 14:06:22.001199198 -0700
+++ u-boot-2014.07/drivers/block/sata_sil.c	2022-05-09 14:06:23.657132220 -0700
@@ -519,7 +519,7 @@
 	u16 word;
 
 	if (init_done == 1 && dev < sata_info.maxport)
-		return 1;
+		return 0;
 
 	init_done = 1;
 
--- u-boot-2014.07/drivers/i2c/mxc_i2c.c.orig	2022-05-09 14:06:22.025198227 -0700
+++ u-boot-2014.07/drivers/i2c/mxc_i2c.c	2022-05-09 14:06:23.677131411 -0700
@@ -423,7 +423,7 @@
 	(void *)IMX_I2C2_BASE
 #elif defined(CONFIG_MX31) || defined(CONFIG_MX35) || \
 	defined(CONFIG_MX51) || defined(CONFIG_MX53) ||	\
-	defined(CONFIG_MX6)
+	defined(CONFIG_MX6) || defined(CONFIG_LS102XA)
 	(void *)I2C1_BASE_ADDR,
 	(void *)I2C2_BASE_ADDR,
 	(void *)I2C3_BASE_ADDR
@@ -545,7 +545,7 @@
 			 CONFIG_SYS_MXC_I2C2_SLAVE, 1)
 #if defined(CONFIG_MX31) || defined(CONFIG_MX35) ||\
 	defined(CONFIG_MX51) || defined(CONFIG_MX53) ||\
-	defined(CONFIG_MX6)
+	defined(CONFIG_MX6) || defined(CONFIG_LS102XA)
 U_BOOT_I2C_ADAP_COMPLETE(mxc2, mxc_i2c_init, mxc_i2c_probe,
 			 mxc_i2c_read, mxc_i2c_write,
 			 mxc_i2c_set_bus_speed,
--- u-boot-2014.07/drivers/i2c/fsl_i2c.c.orig	2022-05-09 14:06:22.021198389 -0700
+++ u-boot-2014.07/drivers/i2c/fsl_i2c.c	2022-05-09 14:06:23.677131411 -0700
@@ -38,7 +38,7 @@
  * generic value.
  */
 #ifndef CONFIG_I2C_TIMEOUT
-#define CONFIG_I2C_TIMEOUT	10000
+#define CONFIG_I2C_TIMEOUT	100000
 #endif
 
 #define I2C_READ_BIT  1
--- u-boot-2014.07/drivers/bootcount/bootcount.c.orig	2022-05-09 14:06:22.005199036 -0700
+++ u-boot-2014.07/drivers/bootcount/bootcount.c	2022-05-09 14:06:23.657132220 -0700
@@ -36,7 +36,7 @@
 #endif /* defined(CONFIG_MPC8260) */
 
 #if defined(CONFIG_QE)
-#include <asm/immap_qe.h>
+#include <linux/immap_qe.h>
 
 #define CONFIG_SYS_BOOTCOUNT_ADDR	(CONFIG_SYS_IMMR + 0x110000 + \
 					 QE_MURAM_SIZE - 2 * sizeof(u32))
--- u-boot-2014.07/drivers/spi/fsl_qspi.c.orig	2022-05-09 14:06:22.105194992 -0700
+++ u-boot-2014.07/drivers/spi/fsl_qspi.c	2022-05-09 14:06:23.769127690 -0700
@@ -12,6 +12,7 @@
 #include <asm/io.h>
 #include <linux/sizes.h>
 #include "fsl_qspi.h"
+#include "fsl_spi_interface.h"
 
 #define RX_BUFFER_SIZE		0x80
 #define TX_BUFFER_SIZE		0x40
@@ -51,14 +52,6 @@
 #define qspi_write32		out_be32
 #endif
 
-static unsigned long spi_bases[] = {
-	QSPI0_BASE_ADDR,
-};
-
-static unsigned long amba_bases[] = {
-	QSPI0_AMBA_BASE,
-};
-
 struct fsl_qspi {
 	struct spi_slave slave;
 	unsigned long reg_base;
@@ -176,12 +169,7 @@
 	qspi_write32(&regs->lckcr, QSPI_LCKCR_LOCK);
 }
 
-void spi_init()
-{
-	/* do nothing */
-}
-
-struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+struct spi_slave *qspi_setup_slave(unsigned int bus, unsigned int cs,
 		unsigned int max_hz, unsigned int mode)
 {
 	struct fsl_qspi *qspi;
@@ -189,15 +177,12 @@
 	u32 reg_val, smpr_val;
 	u32 total_size, seq_id;
 
-	if (bus >= ARRAY_SIZE(spi_bases))
-		return NULL;
-
 	qspi = spi_alloc_slave(struct fsl_qspi, bus, cs);
 	if (!qspi)
 		return NULL;
 
-	qspi->reg_base = spi_bases[bus];
-	qspi->amba_base = amba_bases[bus];
+	qspi->reg_base = get_spi_bus_base(bus);
+	qspi->amba_base = get_qspi_amba_base(bus);
 
 	qspi->slave.max_write_size = TX_BUFFER_SIZE;
 
@@ -232,14 +217,14 @@
 	return &qspi->slave;
 }
 
-void spi_free_slave(struct spi_slave *slave)
+void qspi_free_slave(struct spi_slave *slave)
 {
 	struct fsl_qspi *qspi = to_qspi_spi(slave);
 
 	free(qspi);
 }
 
-int spi_claim_bus(struct spi_slave *slave)
+int qspi_claim_bus(struct spi_slave *slave)
 {
 	return 0;
 }
@@ -436,7 +421,7 @@
 	qspi_write32(&regs->mcr, mcr_reg);
 }
 
-int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+int qspi_xfer(struct spi_slave *slave, unsigned int bitlen,
 		const void *dout, void *din, unsigned long flags)
 {
 	struct fsl_qspi *qspi = to_qspi_spi(slave);
@@ -476,7 +461,7 @@
 	return 0;
 }
 
-void spi_release_bus(struct spi_slave *slave)
+void qspi_release_bus(struct spi_slave *slave)
 {
 	/* Nothing to do */
 }
--- u-boot-2014.07/drivers/spi/Makefile.orig	2022-05-09 14:06:22.105194992 -0700
+++ u-boot-2014.07/drivers/spi/Makefile	2022-05-09 14:06:23.765127852 -0700
@@ -16,7 +16,7 @@
 obj-$(CONFIG_ATMEL_SPI) += atmel_spi.o
 obj-$(CONFIG_BFIN_SPI) += bfin_spi.o
 obj-$(CONFIG_BFIN_SPI6XX) += bfin_spi6xx.o
-obj-$(CONFIG_CF_SPI) += cf_spi.o
+obj-$(CONFIG_FSL_DSPI) += fsl_dspi.o
 obj-$(CONFIG_CF_QSPI) += cf_qspi.o
 obj-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
 obj-$(CONFIG_EXYNOS_SPI) += exynos_spi.o
@@ -42,3 +42,4 @@
 obj-$(CONFIG_XILINX_SPI) += xilinx_spi.o
 obj-$(CONFIG_ZYNQ_SPI) += zynq_spi.o
 obj-$(CONFIG_FSL_QSPI) += fsl_qspi.o
+obj-$(CONFIG_FSL_SPI_INTERFACE) += fsl_spi_interface.o
--- u-boot-2014.07/drivers/Makefile.orig	2022-05-09 14:06:21.989199683 -0700
+++ u-boot-2014.07/drivers/Makefile	2022-05-09 14:06:23.645132705 -0700
@@ -14,4 +14,6 @@
 obj-y += video/
 obj-y += watchdog/
 obj-$(CONFIG_QE) += qe/
+obj-$(CONFIG_U_QE) += qe/
 obj-y += memory/
+obj-y += sec/
--- u-boot-2014.07/drivers/watchdog/Makefile.orig	2022-05-09 14:06:22.153193050 -0700
+++ u-boot-2014.07/drivers/watchdog/Makefile	2022-05-09 14:06:23.813125910 -0700
@@ -7,7 +7,7 @@
 
 obj-$(CONFIG_AT91SAM9_WATCHDOG) += at91sam9_wdt.o
 obj-$(CONFIG_FTWDT010_WATCHDOG) += ftwdt010_wdt.o
-ifneq (,$(filter $(SOC), mx31 mx35 mx5 mx6 vf610))
+ifneq (,$(filter $(SOC), mx31 mx35 mx5 mx6 vf610 ls102xa))
 obj-y += imx_watchdog.o
 endif
 obj-$(CONFIG_TNETV107X_WATCHDOG) += tnetv107x_wdt.o
--- u-boot-2014.07/drivers/ddr/fsl/options.c.orig	2022-05-09 14:06:22.009198874 -0700
+++ u-boot-2014.07/drivers/ddr/fsl/options.c	2022-05-09 14:06:23.665131896 -0700
@@ -6,6 +6,7 @@
 
 #include <common.h>
 #include <hwconfig.h>
+#include <asm/processor.h>
 #include <fsl_ddr_sdram.h>
 
 #include <fsl_ddr.h>
@@ -513,6 +514,7 @@
 	const struct dynamic_odt *pdodt = odt_unknown;
 #endif
 	ulong ddr_freq;
+	__maybe_unused u32 svr;
 
 	/*
 	 * Extract hwconfig from environment since we have not properly setup
@@ -592,7 +594,20 @@
 	defined(CONFIG_SYS_FSL_DDR2) || \
 	defined(CONFIG_SYS_FSL_DDR4)
 		popts->cs_local_opts[i].odt_rd_cfg = pdodt[i].odt_rd_cfg;
+#ifdef CONFIG_M300
+		if ( i == 0 )
+		{
+		    svr = get_svr();
+		     if ((SVR_MAJ(svr) > 1) || (SVR_MIN(svr) >= 1))
+			popts->cs_local_opts[i].odt_wr_cfg = FSL_DDR_ODT_ALL;
+		     else
+			popts->cs_local_opts[i].odt_wr_cfg = FSL_DDR_ODT_CS;
+		}
+		else
+		popts->cs_local_opts[i].odt_wr_cfg = pdodt[i].odt_wr_cfg;
+#else
 		popts->cs_local_opts[i].odt_wr_cfg = pdodt[i].odt_wr_cfg;
+#endif
 		popts->cs_local_opts[i].odt_rtt_norm = pdodt[i].odt_rtt_norm;
 		popts->cs_local_opts[i].odt_rtt_wr = pdodt[i].odt_rtt_wr;
 #else
@@ -777,10 +792,6 @@
 	 */
 	popts->bstopre = 0x100;
 
-	/* Minimum CKE pulse width -- tCKE(MIN) */
-	popts->tcke_clock_pulse_width_ps
-		= mclk_to_picos(FSL_DDR_MIN_TCKE_PULSE_WIDTH_DDR);
-
 	/*
 	 * Window for four activates -- tFAW
 	 *
--- u-boot-2014.07/drivers/ddr/fsl/fsl_ddr_gen4.c.orig	2022-05-09 14:06:22.009198874 -0700
+++ u-boot-2014.07/drivers/ddr/fsl/fsl_ddr_gen4.c	2022-05-09 14:06:23.661132058 -0700
@@ -8,6 +8,7 @@
 #include <asm/io.h>
 #include <fsl_ddr_sdram.h>
 #include <asm/processor.h>
+#include <fsl_immap.h>
 #include <fsl_ddr.h>
 
 #if (CONFIG_CHIP_SELECTS_PER_CTRL > 4)
@@ -183,12 +184,14 @@
 	 * we choose the max, that is 500 us for all of case.
 	 */
 	udelay(500);
-	asm volatile("sync;isync");
+	mb();
+	isb();
 
 	/* Let the controller go */
 	temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI;
 	ddr_out32(&ddr->sdram_cfg, temp_sdram_cfg | SDRAM_CFG_MEM_EN);
-	asm volatile("sync;isync");
+	mb();
+	isb();
 
 	total_gb_size_per_controller = 0;
 	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
--- u-boot-2014.07/drivers/ddr/fsl/arm_ddr_gen3.c.orig	2022-05-09 14:06:22.009198874 -0700
+++ u-boot-2014.07/drivers/ddr/fsl/arm_ddr_gen3.c	2022-05-09 14:06:23.661132058 -0700
@@ -12,6 +12,9 @@
 #include <asm/processor.h>
 #include <fsl_immap.h>
 #include <fsl_ddr.h>
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
 
 #if (CONFIG_CHIP_SELECTS_PER_CTRL > 4)
 #error Invalid setting for CONFIG_CHIP_SELECTS_PER_CTRL
@@ -92,7 +95,6 @@
 	ddr_out32(&ddr->timing_cfg_0, regs->timing_cfg_0);
 	ddr_out32(&ddr->timing_cfg_1, regs->timing_cfg_1);
 	ddr_out32(&ddr->timing_cfg_2, regs->timing_cfg_2);
-	ddr_out32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
 	ddr_out32(&ddr->sdram_mode, regs->ddr_sdram_mode);
 	ddr_out32(&ddr->sdram_mode_2, regs->ddr_sdram_mode_2);
 	ddr_out32(&ddr->sdram_mode_3, regs->ddr_sdram_mode_3);
@@ -105,8 +107,25 @@
 	ddr_out32(&ddr->sdram_interval, regs->ddr_sdram_interval);
 	ddr_out32(&ddr->sdram_data_init, regs->ddr_data_init);
 	ddr_out32(&ddr->sdram_clk_cntl, regs->ddr_sdram_clk_cntl);
-	ddr_out32(&ddr->init_addr, regs->ddr_init_addr);
-	ddr_out32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot()) {
+		ddr_out32(&ddr->sdram_cfg_2,
+			  regs->ddr_sdram_cfg_2 & ~SDRAM_CFG2_D_INIT);
+		ddr_out32(&ddr->init_addr, CONFIG_SYS_SDRAM_BASE);
+		ddr_out32(&ddr->init_ext_addr, (1 << 31));
+
+		/* DRAM VRef will not be trained */
+		temp_sdram_cfg = ddr_in32(&ddr->ddr_cdr2);
+		temp_sdram_cfg &= ~DDR_CDR2_VREF_TRAIN_EN;
+		ddr_out32(&ddr->ddr_cdr2, temp_sdram_cfg);
+	} else
+#endif
+	{
+		ddr_out32(&ddr->sdram_cfg_2, regs->ddr_sdram_cfg_2);
+		ddr_out32(&ddr->init_addr, regs->ddr_init_addr);
+		ddr_out32(&ddr->init_ext_addr, regs->ddr_init_ext_addr);
+		ddr_out32(&ddr->ddr_cdr2, regs->ddr_cdr2);
+	}
 
 	ddr_out32(&ddr->timing_cfg_4, regs->timing_cfg_4);
 	ddr_out32(&ddr->timing_cfg_5, regs->timing_cfg_5);
@@ -128,7 +147,6 @@
 	ddr_out32(&ddr->ddr_sdram_rcw_1, regs->ddr_sdram_rcw_1);
 	ddr_out32(&ddr->ddr_sdram_rcw_2, regs->ddr_sdram_rcw_2);
 	ddr_out32(&ddr->ddr_cdr1, regs->ddr_cdr1);
-	ddr_out32(&ddr->ddr_cdr2, regs->ddr_cdr2);
 	ddr_out32(&ddr->err_disable, regs->err_disable);
 	ddr_out32(&ddr->err_int_en, regs->err_int_en);
 	for (i = 0; i < 32; i++) {
@@ -167,8 +185,20 @@
 	udelay(500);
 	asm volatile("dsb sy;isb");
 
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot()) {
+		/* enter self-refresh */
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg_2);
+		temp_sdram_cfg |= SDRAM_CFG2_FRC_SR;
+		ddr_out32(&ddr->sdram_cfg_2, temp_sdram_cfg);
+		/* do board specific memory setup */
+		fsl_dp_mem_setup();
+
+		temp_sdram_cfg = (ddr_in32(&ddr->sdram_cfg) | SDRAM_CFG_BI);
+	} else
+#endif
+		temp_sdram_cfg = (in_be32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI);
 	/* Let the controller go */
-	temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI;
 	ddr_out32(&ddr->sdram_cfg, temp_sdram_cfg | SDRAM_CFG_MEM_EN);
 	asm volatile("dsb sy;isb");
 
@@ -194,7 +224,7 @@
 	 * For example, 2GB on 666MT/s 64-bit bus takes about 402ms
 	 * Let's wait for 800ms
 	 */
-	bus_width = 3 - ((ddr->sdram_cfg & SDRAM_CFG_DBW_MASK)
+	bus_width = 3 - ((ddr_in32(&ddr->sdram_cfg) & SDRAM_CFG_DBW_MASK)
 			>> SDRAM_CFG_DBW_SHIFT);
 	timeout = ((total_gb_size_per_controller << (6 - bus_width)) * 100 /
 		(get_ddr_freq(0) >> 20)) << 1;
@@ -211,4 +241,12 @@
 
 	if (timeout <= 0)
 		printf("Waiting for D_INIT timeout. Memory may not work.\n");
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot()) {
+		/* exit self-refresh */
+		temp_sdram_cfg = ddr_in32(&ddr->sdram_cfg_2);
+		temp_sdram_cfg &= ~SDRAM_CFG2_FRC_SR;
+		ddr_out32(&ddr->sdram_cfg_2, temp_sdram_cfg);
+	}
+#endif
 }
--- u-boot-2014.07/drivers/ddr/fsl/ctrl_regs.c.orig	2022-05-09 14:06:22.009198874 -0700
+++ u-boot-2014.07/drivers/ddr/fsl/ctrl_regs.c	2022-05-09 14:06:23.661132058 -0700
@@ -253,22 +253,30 @@
 /* -3E = 667 CL5, -25 = CL6 800, -25E = CL5 800 */
 
 #if !defined(CONFIG_SYS_FSL_DDR1)
+/*
+ * Check DIMM configuration, return 2 if quad-rank or two dual-rank
+ * Return 1 if other two slots configuration. Return 0 if single slot.
+ */
 static inline int avoid_odt_overlap(const dimm_params_t *dimm_params)
 {
 #if CONFIG_DIMM_SLOTS_PER_CTLR == 1
 	if (dimm_params[0].n_ranks == 4)
-		return 1;
+		return 2;
 #endif
 
 #if CONFIG_DIMM_SLOTS_PER_CTLR == 2
 	if ((dimm_params[0].n_ranks == 2) &&
 		(dimm_params[1].n_ranks == 2))
-		return 1;
+		return 2;
 
 #ifdef CONFIG_FSL_DDR_FIRST_SLOT_QUAD_CAPABLE
 	if (dimm_params[0].n_ranks == 4)
-		return 1;
+		return 2;
 #endif
+
+	if ((dimm_params[0].n_ranks != 0) &&
+	    (dimm_params[2].n_ranks != 0))
+		return 1;
 #endif
 	return 0;
 }
@@ -297,10 +305,13 @@
 	unsigned char taxpd_mclk = 0;
 	/* Mode register set cycle time (tMRD). */
 	unsigned char tmrd_mclk;
+#if defined(CONFIG_SYS_FSL_DDR4) || defined(CONFIG_SYS_FSL_DDR3)
+	const unsigned int mclk_ps = get_memory_clk_period_ps();
+#endif
 
 #ifdef CONFIG_SYS_FSL_DDR4
 	/* tXP=max(4nCK, 6ns) */
-	int txp = max((get_memory_clk_period_ps() * 4), 6000); /* unit=ps */
+	int txp = max(mclk_ps * 4, 6000); /* unit=ps */
 	trwt_mclk = 2;
 	twrt_mclk = 1;
 	act_pd_exit_mclk = picos_to_mclk(txp);
@@ -311,27 +322,60 @@
 	 */
 	tmrd_mclk = max(24, picos_to_mclk(15000));
 #elif defined(CONFIG_SYS_FSL_DDR3)
+	unsigned int data_rate = get_ddr_freq(0);
+	int txp;
+	int odt_overlap;
+	unsigned int ip_rev;
 	/*
 	 * (tXARD and tXARDS). Empirical?
 	 * The DDR3 spec has not tXARD,
 	 * we use the tXP instead of it.
-	 * tXP=max(3nCK, 7.5ns) for DDR3.
+	 * tXP=max(3nCK, 7.5ns) for DDR3-800, 1066
+	 *     max(3nCK, 6ns) for DDR3-1333, 1600, 1866, 2133
 	 * spec has not the tAXPD, we use
 	 * tAXPD=1, need design to confirm.
 	 */
-	int txp = max((get_memory_clk_period_ps() * 3), 7500); /* unit=ps */
-	unsigned int data_rate = get_ddr_freq(0);
-	tmrd_mclk = 4;
+	txp = max(mclk_ps * 3, (mclk_ps > 1540 ? 7500 : 6000));
+
+	ip_rev = fsl_ddr_get_version();
+	if (ip_rev >= 0x40700) {
+		/*
+		 * MRS_CYC = max(tMRD, tMOD)
+		 * tMRD = 4nCK (8nCK for RDIMM)
+		 * tMOD = max(12nCK, 15ns)
+		 */
+		tmrd_mclk = max(12, picos_to_mclk(15000));
+	} else {
+		/*
+		 * MRS_CYC = tMRD
+		 * tMRD = 4nCK (8nCK for RDIMM)
+		 */
+		if (popts->registered_dimm_en)
+			tmrd_mclk = 8;
+		else
+			tmrd_mclk = 4;
+	}
+
 	/* set the turnaround time */
 
 	/*
-	 * for single quad-rank DIMM and two dual-rank DIMMs
+	 * for single quad-rank DIMM and two-slot DIMMs
 	 * to avoid ODT overlap
 	 */
-	if (avoid_odt_overlap(dimm_params)) {
+	odt_overlap = avoid_odt_overlap(dimm_params);
+	switch (odt_overlap) {
+	case 2:
 		twwt_mclk = 2;
 		trrt_mclk = 1;
+		break;
+	case 1:
+		twwt_mclk = 1;
+		trrt_mclk = 0;
+		break;
+	default:
+		break;
 	}
+
 	/* for faster clock, need more time for data setup */
 	trwt_mclk = (data_rate/1000000 > 1800) ? 2 : 1;
 
@@ -377,7 +421,7 @@
 		);
 	debug("FSLDDR: timing_cfg_0 = 0x%08x\n", ddr->timing_cfg_0);
 }
-#endif	/* defined(CONFIG_SYS_FSL_DDR2) */
+#endif	/* !defined(CONFIG_SYS_FSL_DDR1) */
 
 /* DDR SDRAM Timing Configuration 3 (TIMING_CFG_3) */
 static void set_timing_cfg_3(fsl_ddr_cfg_regs_t *ddr,
@@ -578,6 +622,9 @@
 	unsigned char cke_pls;
 	/* Window for four activates (tFAW) */
 	unsigned short four_act;
+#ifdef CONFIG_SYS_FSL_DDR3
+	const unsigned int mclk_ps = get_memory_clk_period_ps();
+#endif
 
 	/* FIXME add check that this must be less than acttorw_mclk */
 	add_lat_mclk = additive_latency;
@@ -619,10 +666,17 @@
 #ifdef CONFIG_SYS_FSL_DDR4
 	cpo = 0;
 	cke_pls = max(3, picos_to_mclk(5000));
+#elif defined(CONFIG_SYS_FSL_DDR3)
+	/*
+	 * cke pulse = max(3nCK, 7.5ns) for DDR3-800
+	 *             max(3nCK, 5.625ns) for DDR3-1066, 1333
+	 *             max(3nCK, 5ns) for DDR3-1600, 1866, 2133
+	 */
+	cke_pls = max(3, picos_to_mclk(mclk_ps > 1870 ? 7500 :
+				       (mclk_ps > 1245 ? 5625 : 5000)));
 #else
-	cke_pls = picos_to_mclk(popts->tcke_clock_pulse_width_ps);
+	cke_pls = FSL_DDR_MIN_TCKE_PULSE_WIDTH_DDR;
 #endif
-
 	four_act = picos_to_mclk(popts->tfaw_window_four_activates_ps);
 
 	ddr->timing_cfg_2 = (0
@@ -693,6 +747,7 @@
 	unsigned int x32_en = 0;	/* x32 enable */
 	unsigned int pchb8 = 0;		/* precharge bit 8 enable */
 	unsigned int hse;		/* Global half strength override */
+	unsigned int acc_ecc_en = 0;	/* Accumulated ECC enable */
 	unsigned int mem_halt = 0;	/* memory controller halt */
 	unsigned int bi = 0;		/* Bypass initialization */
 
@@ -736,6 +791,9 @@
 	ba_intlv_ctl = popts->ba_intlv_ctl;
 	hse = popts->half_strength_driver_enable;
 
+	/* set when ddr bus width < 64 */
+	acc_ecc_en = (dbw != 0 && ecc_en == 1) ? 1 : 0;
+
 	ddr->ddr_sdram_cfg = (0
 			| ((mem_en & 0x1) << 31)
 			| ((sren & 0x1) << 30)
@@ -752,6 +810,7 @@
 			| ((x32_en & 0x1) << 5)
 			| ((pchb8 & 0x1) << 4)
 			| ((hse & 0x1) << 3)
+			| ((acc_ecc_en & 0x1) << 2)
 			| ((mem_halt & 0x1) << 1)
 			| ((bi & 0x1) << 0)
 			);
@@ -2268,6 +2327,9 @@
 	if (ip_rev > 0x40400)
 		unq_mrs_en = 1;
 
+	if (ip_rev > 0x40700)
+		ddr->debug[18] = popts->cswl_override;
+
 	set_ddr_sdram_cfg_2(ddr, popts, unq_mrs_en);
 	set_ddr_sdram_mode(ddr, popts, common_dimm,
 				cas_latency, additive_latency, unq_mrs_en);
--- u-boot-2014.07/drivers/ddr/fsl/mpc85xx_ddr_gen3.c.orig	2022-05-09 14:06:22.009198874 -0700
+++ u-boot-2014.07/drivers/ddr/fsl/mpc85xx_ddr_gen3.c	2022-05-09 14:06:23.665131896 -0700
@@ -10,13 +10,14 @@
 #include <asm/io.h>
 #include <fsl_ddr_sdram.h>
 #include <asm/processor.h>
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
 
 #if (CONFIG_CHIP_SELECTS_PER_CTRL > 4)
 #error Invalid setting for CONFIG_CHIP_SELECTS_PER_CTRL
 #endif
 
-DECLARE_GLOBAL_DATA_PTR;
-
 /*
  * regs has the to-be-set values for DDR controller registers
  * ctrl_num is the DDR controller number
@@ -44,16 +45,6 @@
 	u32 save1, save2;
 #endif
 
-#ifdef CONFIG_DEEP_SLEEP
-	const ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
-	bool sleep_flag = 0;
-#endif
-
-#ifdef CONFIG_DEEP_SLEEP
-	if (in_be32(&gur->scrtsr[0]) & (1 << 3))
-		sleep_flag = 1;
-#endif
-
 	switch (ctrl_num) {
 	case 0:
 		ddr = (void *)CONFIG_SYS_FSL_DDR_ADDR;
@@ -130,8 +121,8 @@
 	out_be32(&ddr->timing_cfg_0, regs->timing_cfg_0);
 	out_be32(&ddr->timing_cfg_1, regs->timing_cfg_1);
 	out_be32(&ddr->timing_cfg_2, regs->timing_cfg_2);
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag)
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot())
 		out_be32(&ddr->sdram_cfg_2,
 			 regs->ddr_sdram_cfg_2 & ~SDRAM_CFG2_D_INIT);
 	else
@@ -149,8 +140,8 @@
 	out_be32(&ddr->sdram_interval, regs->ddr_sdram_interval);
 	out_be32(&ddr->sdram_data_init, regs->ddr_data_init);
 	out_be32(&ddr->sdram_clk_cntl, regs->ddr_sdram_clk_cntl);
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag) {
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot()) {
 		out_be32(&ddr->init_addr, 0);
 		out_be32(&ddr->init_ext_addr, (1 << 31));
 	} else
@@ -399,18 +390,18 @@
 	udelay(500);
 	asm volatile("sync;isync");
 
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag) {
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot()) {
 		/* enter self-refresh */
 		setbits_be32(&ddr->sdram_cfg_2, (1 << 31));
 		/* do board specific memory setup */
-		board_mem_sleep_setup();
+		fsl_dp_mem_setup();
 	}
 #endif
 
 	/* Let the controller go */
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag)
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot())
 		temp_sdram_cfg = (in_be32(&ddr->sdram_cfg) | SDRAM_CFG_BI);
 	else
 #endif
@@ -565,8 +556,8 @@
 		clrbits_be32(&ddr->sdram_cfg, 0x2);
 	}
 #endif /* CONFIG_SYS_FSL_ERRATUM_DDR111_DDR134 */
-#ifdef CONFIG_DEEP_SLEEP
-	if (sleep_flag)
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	if (is_warm_boot())
 		/* exit self-refresh */
 		clrbits_be32(&ddr->sdram_cfg_2, (1 << 31));
 #endif
--- u-boot-2014.07/drivers/ddr/fsl/interactive.c.orig	2022-05-09 14:06:22.009198874 -0700
+++ u-boot-2014.07/drivers/ddr/fsl/interactive.c	2022-05-09 14:06:23.661132058 -0700
@@ -511,12 +511,12 @@
 		CTRL_OPTIONS(wrlvl_override),
 		CTRL_OPTIONS(wrlvl_sample),
 		CTRL_OPTIONS(wrlvl_start),
+		CTRL_OPTIONS(cswl_override),
 		CTRL_OPTIONS(rcw_override),
 		CTRL_OPTIONS(rcw_1),
 		CTRL_OPTIONS(rcw_2),
 		CTRL_OPTIONS(ddr_cdr1),
 		CTRL_OPTIONS(ddr_cdr2),
-		CTRL_OPTIONS(tcke_clock_pulse_width_ps),
 		CTRL_OPTIONS(tfaw_window_four_activates_ps),
 		CTRL_OPTIONS(trwt_override),
 		CTRL_OPTIONS(trwt),
@@ -801,12 +801,12 @@
 		CTRL_OPTIONS(wrlvl_override),
 		CTRL_OPTIONS(wrlvl_sample),
 		CTRL_OPTIONS(wrlvl_start),
+		CTRL_OPTIONS_HEX(cswl_override),
 		CTRL_OPTIONS(rcw_override),
 		CTRL_OPTIONS(rcw_1),
 		CTRL_OPTIONS(rcw_2),
 		CTRL_OPTIONS_HEX(ddr_cdr1),
 		CTRL_OPTIONS_HEX(ddr_cdr2),
-		CTRL_OPTIONS(tcke_clock_pulse_width_ps),
 		CTRL_OPTIONS(tfaw_window_four_activates_ps),
 		CTRL_OPTIONS(trwt_override),
 		CTRL_OPTIONS(trwt),
--- u-boot-2014.07/arch/arm/cpu/u-boot-spl.lds.orig	2022-05-09 14:06:21.073236732 -0700
+++ u-boot-2014.07/arch/arm/cpu/u-boot-spl.lds	2022-05-09 14:06:22.669172180 -0700
@@ -32,6 +32,9 @@
 	}
 
 	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*_i2c_*)));
+	}
 
 	. = .;
 
--- u-boot-2014.07/arch/arm/cpu/armv7/virt-v7.c.orig	2022-05-09 14:06:21.061237217 -0700
+++ u-boot-2014.07/arch/arm/cpu/armv7/virt-v7.c	2022-05-09 14:06:22.661172504 -0700
@@ -115,6 +115,7 @@
 {
 	unsigned int reg;
 	unsigned itlinesnr, i;
+	unsigned long gic_base_addr;
 
 	/* check whether the CPU supports the security extensions */
 	reg = read_id_pfr1();
@@ -129,23 +130,24 @@
 	 * any access to it will trap.
 	 */
 
-	gic_dist_addr = get_gicd_base_address();
-	if (gic_dist_addr == -1)
+	gic_base_addr = get_gicd_base_address();
+	gic_dist_addr = gic_base_addr;
+	if (gic_base_addr == -1)
 		return -1;
 
 	/* enable the GIC distributor */
-	writel(readl(gic_dist_addr + GICD_CTLR) | 0x03,
-	       gic_dist_addr + GICD_CTLR);
+	writel(readl(gic_base_addr + GICD_CTLR) | 0x03,
+	       gic_base_addr + GICD_CTLR);
 
 	/* TYPER[4:0] contains an encoded number of available interrupts */
-	itlinesnr = readl(gic_dist_addr + GICD_TYPER) & 0x1f;
+	itlinesnr = readl(gic_base_addr + GICD_TYPER) & 0x1f;
 
 	/* set all bits in the GIC group registers to one to allow access
 	 * from non-secure state. The first 32 interrupts are private per
 	 * CPU and will be set later when enabling the GIC for each core
 	 */
 	for (i = 1; i <= itlinesnr; i++)
-		writel((unsigned)-1, gic_dist_addr + GICD_IGROUPRn + 4 * i);
+		writel((unsigned)-1, gic_base_addr + GICD_IGROUPRn + 4 * i);
 
 	smp_set_core_boot_addr((unsigned long)_smp_pen, -1);
 	smp_kick_all_cpus();
--- u-boot-2014.07/arch/arm/cpu/armv7/nonsec_virt.S.orig	2022-05-09 14:06:21.045237864 -0700
+++ u-boot-2014.07/arch/arm/cpu/armv7/nonsec_virt.S	2022-05-09 14:06:22.641173312 -0700
@@ -14,6 +14,10 @@
 .arch_extension sec
 .arch_extension virt
 
+.globl non_sec_start
+non_sec_start:
+	.word .
+
 	.align	5
 /* the vector table for secure state and HYP mode */
 _monitor_vectors:
@@ -139,11 +143,11 @@
  * we do this here instead.
  * But first check if we have the generic timer.
  */
-#ifdef CONFIG_SYS_CLK_FREQ
+#ifdef CONFIG_TIMER_CLK_FREQ
 	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
 	and	r0, r0, #CPUID_ARM_GENTIMER_MASK	@ mask arch timer bits
 	cmp	r0, #(1 << CPUID_ARM_GENTIMER_SHIFT)
-	ldreq	r1, =CONFIG_SYS_CLK_FREQ
+	ldreq	r1, =CONFIG_TIMER_CLK_FREQ
 	mcreq	p15, 0, r1, c14, c0, 0		@ write CNTFRQ
 #endif
 
@@ -173,6 +177,9 @@
 	wfi
 	ldr	r1, =CONFIG_SMP_PEN_ADDR	@ load start address
 	ldr	r1, [r1]
+#ifdef CONFIG_PEN_ADDR_BIG_ENDIAN
+	rev	r1, r1
+#endif
 	cmp	r0, r1			@ make sure we dont execute this code
 	beq	smp_waitloop		@ again (due to a spurious wakeup)
 	mov	pc, r1
@@ -190,3 +197,7 @@
 
 	bx	lr
 ENDPROC(_switch_to_hyp)
+
+.globl non_sec_end
+non_sec_end:
+	.word .
--- u-boot-2014.07/arch/arm/include/asm/arch-fsl-lsch3/config.h.orig	2022-05-09 14:06:21.101235599 -0700
+++ u-boot-2014.07/arch/arm/include/asm/arch-fsl-lsch3/config.h	2022-05-09 14:06:22.693171210 -0700
@@ -43,7 +43,11 @@
 /* DDR */
 #define CONFIG_SYS_FSL_DDR_LE
 #define CONFIG_VERY_BIG_RAM
+#ifdef CONFIG_SYS_FSL_DDR4
+#define CONFIG_SYS_FSL_DDRC_GEN4
+#else
 #define CONFIG_SYS_FSL_DDRC_ARM_GEN3	/* Enable Freescale ARM DDR3 driver */
+#endif
 #define CONFIG_SYS_FSL_DDR		/* Freescale DDR driver */
 #define CONFIG_SYS_LS2_DDR_BLOCK1_SIZE	((phys_size_t)2 << 30)
 #define CONFIG_MAX_MEM_MAPPED		CONFIG_SYS_LS2_DDR_BLOCK1_SIZE
--- u-boot-2014.07/arch/arm/include/asm/config.h.orig	2022-05-09 14:06:21.157233334 -0700
+++ u-boot-2014.07/arch/arm/include/asm/config.h	2022-05-09 14:06:22.757168621 -0700
@@ -21,4 +21,8 @@
 #include <asm/arch-fsl-lsch3/config.h>
 #endif
 
+#ifdef CONFIG_LS102XA
+#include <asm/arch/config.h>
+#endif
+
 #endif
--- u-boot-2014.07/arch/arm/include/asm/arch-vf610/imx-regs.h.orig	2022-05-09 14:06:21.153233495 -0700
+++ u-boot-2014.07/arch/arm/include/asm/arch-vf610/imx-regs.h	2022-05-09 14:06:22.757168621 -0700
@@ -45,8 +45,8 @@
 #define UART1_BASE		(AIPS0_BASE_ADDR + 0x00028000)
 #define UART2_BASE		(AIPS0_BASE_ADDR + 0x00029000)
 #define UART3_BASE		(AIPS0_BASE_ADDR + 0x0002A000)
-#define SPI0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002C000)
-#define SPI1_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002D000)
+#define DSPI1_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002C000)
+#define DSPI2_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002D000)
 #define SAI0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x0002F000)
 #define SAI1_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00030000)
 #define SAI2_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00031000)
@@ -62,7 +62,7 @@
 #define LPTMR_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00040000)
 #define RLE_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00042000)
 #define MLB_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00043000)
-#define QSPI0_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00044000)
+#define QSPI_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00044000)
 #define IOMUXC_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00048000)
 #define ANADIG_BASE_ADDR	(AIPS0_BASE_ADDR + 0x00050000)
 #define SCSCM_BASE_ADDR		(AIPS0_BASE_ADDR + 0x00052000)
@@ -87,7 +87,11 @@
 #define ENET_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00050000)
 #define ENET1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00051000)
 
-#define QSPI0_AMBA_BASE		0x20000000
+#define QSPI_AMBA_BASE		0x20000000
+
+#define SPI_BUS_FSL_QSPI	0
+#define SPI_BUS_FSL_DSPI1	1
+#define SPI_BUS_FSL_DSPI2	2
 
 /* MUX mode and PAD ctrl are in one register */
 #define CONFIG_IOMUX_SHARE_CONF_REG
--- u-boot-2014.07/arch/arm/include/asm/global_data.h.orig	2022-05-09 14:06:21.157233334 -0700
+++ u-boot-2014.07/arch/arm/include/asm/global_data.h	2022-05-09 14:06:22.757168621 -0700
@@ -17,6 +17,14 @@
 #if defined(CONFIG_FSL_ESDHC)
 	u32 sdhc_clk;
 #endif
+
+#if defined(CONFIG_U_QE)
+	u32 qe_clk;
+	u32 brg_clk;
+	uint mp_alloc_base;
+	uint mp_alloc_top;
+#endif /* CONFIG_U_QE */
+
 #ifdef CONFIG_AT91FAMILY
 	/* "static data" needed by at91's clock.c */
 	unsigned long	cpu_clk_rate_hz;
--- u-boot-2014.07/arch/arm/include/asm/io.h.orig	2022-05-09 14:06:21.161233172 -0700
+++ u-boot-2014.07/arch/arm/include/asm/io.h	2022-05-09 14:06:22.761168459 -0700
@@ -136,6 +136,7 @@
  * TODO: The kernel offers some more advanced versions of barriers, it might
  * have some advantages to use them instead of the simple one here.
  */
+#define mb()		asm volatile("dsb sy" : : : "memory")
 #define dmb()		__asm__ __volatile__ ("" : : : "memory")
 #define __iormb()	dmb()
 #define __iowmb()	dmb()
@@ -375,7 +376,12 @@
 	return retval;
 }
 
-#elif !defined(readb)
+#else
+#define memset_io(a, b, c)		memset((void *)(a), (b), (c))
+#define memcpy_fromio(a, b, c)		memcpy((a), (void *)(b), (c))
+#define memcpy_toio(a, b, c)		memcpy((void *)(a), (b), (c))
+
+#if !defined(readb)
 
 #define readb(addr)			(__readwrite_bug("readb"),0)
 #define readw(addr)			(__readwrite_bug("readw"),0)
@@ -388,6 +394,7 @@
 
 #define check_signature(io,sig,len)	(0)
 
+#endif
 #endif	/* __mem_pci */
 
 /*
--- u-boot-2014.07/arch/arm/lib/Makefile.orig	2022-05-09 14:06:21.169232848 -0700
+++ u-boot-2014.07/arch/arm/lib/Makefile	2022-05-09 14:06:22.769168135 -0700
@@ -48,6 +48,10 @@
 obj-y	+= cache-cp15.o
 endif
 
+ifneq ($(CONFIG_ARMV7_NONSEC)$(CONFIG_ARMV7_VIRT),)
+obj-y   += nonsecure.o
+endif
+
 # For EABI conformant tool chains, provide eabi_compat()
 ifneq (,$(findstring -mabi=aapcs-linux,$(PLATFORM_CPPFLAGS)))
 extra-y	+= eabi_compat.o
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/b4860_ids.c.orig	2022-05-09 14:06:21.329226377 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/b4860_ids.c	2022-05-09 14:06:22.973159885 -0700
@@ -57,10 +57,10 @@
 
 	SET_USB_LIODN(1, "fsl-usb2-mph", 553),
 
-	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
 
-	SET_DMA_LIODN(1, 147),
-	SET_DMA_LIODN(2, 227),
+	SET_DMA_LIODN(1, "fsl,elo3-dma", 147),
+	SET_DMA_LIODN(2, "fsl,elo3-dma", 227),
 
 #ifndef CONFIG_PPC_B4420
 	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/fdt.c.orig	2022-05-09 14:06:21.329226377 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/fdt.c	2022-05-09 14:06:22.977159723 -0700
@@ -134,6 +134,21 @@
 			printf("Failed to reserve memory for spin table: %s\n",
 				fdt_strerror(off));
 	}
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#ifdef CONFIG_SPL_MMC_BOOT
+	off = fdt_add_mem_rsv(blob, CONFIG_SYS_MMC_U_BOOT_START,
+		CONFIG_SYS_MMC_U_BOOT_SIZE);
+	if (off < 0)
+		printf("Failed to reserve memory for SD deep sleep: %s\n",
+		       fdt_strerror(off));
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	off = fdt_add_mem_rsv(blob, CONFIG_SYS_SPI_FLASH_U_BOOT_START,
+		CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE);
+	if (off < 0)
+		printf("Failed to reserve memory for SPI deep sleep: %s\n",
+		       fdt_strerror(off));
+#endif
+#endif
 }
 #endif
 
@@ -612,7 +627,52 @@
 #define fdt_fixup_usb(x)
 #endif
 
-#if defined(CONFIG_PPC_T1040)
+#if defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T4240) || \
+	defined(CONFIG_PPC_T4160) || defined(CONFIG_PPC_T4080) || defined(CONFIG_PPC_M300)
+void fdt_fixup_dma3(void *blob)
+{
+	/* the 3rd DMA is not functional if SRIO2 is chosen */
+	int nodeoff;
+	ccsr_gur_t __iomem *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+#define CONFIG_SYS_ELO3_DMA3 (0xffe000000 + 0x102300)
+#if defined(CONFIG_PPC_T2080) ||  defined(CONFIG_PPC_M300)
+	u32 srds_prtcl_s2 = in_be32(&gur->rcwsr[4]) &
+				    FSL_CORENET2_RCWSR4_SRDS2_PRTCL;
+	srds_prtcl_s2 >>= FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT;
+
+	switch (srds_prtcl_s2) {
+	case 0x29:
+	case 0x2d:
+	case 0x2e:
+#elif defined(CONFIG_PPC_T4240) || defined(CONFIG_PPC_T4160) || \
+	defined(CONFIG_PPC_T4080)
+	u32 srds_prtcl_s4 = in_be32(&gur->rcwsr[4]) &
+				    FSL_CORENET2_RCWSR4_SRDS4_PRTCL;
+	srds_prtcl_s4 >>= FSL_CORENET2_RCWSR4_SRDS4_PRTCL_SHIFT;
+
+	switch (srds_prtcl_s4) {
+	case 6:
+	case 8:
+	case 14:
+	case 16:
+#endif
+		nodeoff = fdt_node_offset_by_compat_reg(blob, "fsl,elo3-dma",
+							CONFIG_SYS_ELO3_DMA3);
+		if (nodeoff > 0)
+			fdt_status_disabled(blob, nodeoff);
+		else
+			printf("WARNING: unable to disable dma3\n");
+		break;
+	default:
+		break;
+	}
+}
+#else
+#define fdt_fixup_dma3(x)
+#endif
+
+#if defined(CONFIG_PPC_T1040) || defined(CONFIG_PPC_M200)
 static void fdt_fixup_l2_switch(void *blob)
 {
 	uchar l2swaddr[6];
@@ -778,6 +838,8 @@
 	fdt_fixup_usb(blob);
 
 	fdt_fixup_l2_switch(blob);
+
+	fdt_fixup_dma3(blob);
 }
 
 /*
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/cmd_errata.c.orig	2022-05-09 14:06:21.329226377 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/cmd_errata.c	2022-05-09 14:06:22.973159885 -0700
@@ -9,6 +9,7 @@
 #include <linux/compiler.h>
 #include <asm/fsl_errata.h>
 #include <asm/processor.h>
+#include <fsl_usb.h>
 #include "fsl_corenet_serdes.h"
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_A004849
@@ -270,7 +271,8 @@
 	puts("Work-around for Erratum USB14 enabled\n");
 #endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_A007186
-	puts("Work-around for Erratum A007186 enabled\n");
+	if (has_erratum_a007186())
+		puts("Work-around for Erratum A007186 enabled\n");
 #endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_A006593
 	puts("Work-around for Erratum A006593 enabled\n");
@@ -293,6 +295,14 @@
 	if (has_erratum_a007075())
 		puts("Work-around for Erratum A007075 enabled\n");
 #endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A007798
+	if (has_erratum_a007798())
+		puts("Work-around for Erratum A007798 enabled\n");
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A004477
+	if (has_erratum_a004477())
+		puts("Work-around for Erratum A004477 enabled\n");
+#endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_I2C_A004447
 	if ((SVR_SOC_VER(svr) == SVR_8548 && IS_SVR_REV(svr, 3, 1)) ||
 	    (SVR_REV(svr) <= CONFIG_SYS_FSL_A004447_SVR_REV))
@@ -308,7 +318,14 @@
 #ifdef CONFIG_SYS_FSL_ERRATUM_A005434
 	puts("Work-around for Erratum A-005434 enabled\n");
 #endif
-
+#if defined(CONFIG_SYS_FSL_ERRATUM_A008044) && \
+	defined(CONFIG_A008044_WORKAROUND)
+	if (IS_SVR_REV(svr, 1, 0))
+		puts("Work-around for Erratum A-008044 enabled\n");
+#endif
+#if defined(CONFIG_SYS_FSL_B4860QDS_XFI_ERR) && defined(CONFIG_B4860QDS)
+	puts("Work-around for Erratum XFI on B4860QDS enabled\n");
+#endif
 	return 0;
 }
 
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t2080_serdes.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t2080_serdes.c	2022-05-09 14:06:22.981159561 -0700
@@ -169,6 +169,7 @@
 	{0x01, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1, PCIE1} },
 	{0x29, {SRIO2, SRIO2, SRIO2, SRIO2, SRIO1, SRIO1, SRIO1, SRIO1} },
 	{0x2D, {SRIO2, SRIO2, SRIO2, SRIO2, SRIO1, SRIO1, SRIO1, SRIO1} },
+	{0x2E, {SRIO2, SRIO2, SRIO2, SRIO2, SRIO1, SRIO1, SRIO1, SRIO1} },
 	{0x15, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE2, PCIE2, SATA1, SATA2} },
 	{0x27, {PCIE1, PCIE1, PCIE1, PCIE1, NONE,  NONE,  SATA1, SATA2} },
 	{0x18, {PCIE1, PCIE1, PCIE1, PCIE1, AURORA, AURORA, SATA1, SATA2} },
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/portals.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/portals.c	2022-05-09 14:06:22.977159723 -0700
@@ -14,9 +14,46 @@
 #include <asm/fsl_portals.h>
 #include <asm/fsl_liodn.h>
 
+#define MAX_BPORTALS (CONFIG_SYS_BMAN_CINH_SIZE / CONFIG_SYS_BMAN_SP_CINH_SIZE)
+#define MAX_QPORTALS (CONFIG_SYS_QMAN_CINH_SIZE / CONFIG_SYS_QMAN_SP_CINH_SIZE)
+static void inhibit_portals(void __iomem *addr, int max_portals,
+			int arch_max_portals, int portal_cinh_size)
+{
+	uint32_t val;
+	int i;
+
+	/* arch_max_portals is the maximum based on memory size. This includes
+	 * the reserved memory in the SoC.  max_portals the number of physical
+	 * portals in the SoC */
+	if (max_portals > arch_max_portals) {
+		printf("ERROR: portal config error\n");
+		max_portals = arch_max_portals;
+	}
+
+	for (i = 0; i < max_portals; i++) {
+		out_be32(addr, -1);
+		val = in_be32(addr);
+		if (!val) {
+			printf("ERROR: Stopped after %d portals\n", i);
+			goto done;
+		}
+		addr += portal_cinh_size;
+	}
+#ifdef DEBUG
+	printf("Cleared %d portals\n", i);
+#endif
+done:
+
+	return;
+}
+
 void setup_portals(void)
 {
 	ccsr_qman_t *qman = (void *)CONFIG_SYS_FSL_QMAN_ADDR;
+	void __iomem *bpaddr = (void *)CONFIG_SYS_BMAN_CINH_BASE +
+				CONFIG_SYS_BMAN_SWP_ISDR_REG;
+	void __iomem *qpaddr = (void *)CONFIG_SYS_QMAN_CINH_BASE +
+				CONFIG_SYS_QMAN_SWP_ISDR_REG;
 #ifdef CONFIG_FSL_CORENET
 	int i;
 
@@ -38,6 +75,12 @@
 	out_be32(&qman->qcsp_bare, (u32)(CONFIG_SYS_QMAN_MEM_PHYS >> 32));
 #endif
 	out_be32(&qman->qcsp_bar, (u32)CONFIG_SYS_QMAN_MEM_PHYS);
+
+	/* Change default state of BMan ISDR portals to all 1s */
+	inhibit_portals(bpaddr, CONFIG_SYS_BMAN_NUM_PORTALS, MAX_BPORTALS,
+			CONFIG_SYS_BMAN_SP_CINH_SIZE);
+	inhibit_portals(qpaddr, CONFIG_SYS_QMAN_NUM_PORTALS, MAX_QPORTALS,
+			CONFIG_SYS_QMAN_SP_CINH_SIZE);
 }
 
 /* Update portal containter to match LAW setup of portal in phy map */
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p2041_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p2041_ids.c	2022-05-09 14:06:22.977159723 -0700
@@ -50,8 +50,8 @@
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 2, 194),
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 195),
 
-	SET_DMA_LIODN(1, 197),
-	SET_DMA_LIODN(2, 198),
+	SET_DMA_LIODN(1, "fsl,eloplus-dma", 197),
+	SET_DMA_LIODN(2, "fsl,eloplus-dma", 198),
 
 	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
 	SET_GUTS_LIODN(NULL, 200, rio2liodnr, 0),
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/cpu_init.c.orig	2022-05-09 14:06:21.329226377 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/cpu_init.c	2022-05-09 14:06:22.973159885 -0700
@@ -32,6 +32,15 @@
 #include <errno.h>
 #endif
 
+#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_FSL_CORENET)
+#include <asm/fsl_pamu.h>
+#endif
+#ifdef CONFIG_SECURE_BOOT
+#include <jr.h>
+#include <fsl_secboot_err.h>
+#endif
+
+
 #include "../../../../drivers/block/fsl_sata.h"
 #ifdef CONFIG_U_QE
 #include "../../../../drivers/qe/qe.h"
@@ -39,6 +48,10 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#ifdef CONFIG_SECURE_BOOT
+struct jobring jr;
+#endif
+
 #ifdef CONFIG_SYS_FSL_SINGLE_SOURCE_CLK
 /*
  * For deriving usb clock from 100MHz sysclk, reference divisor is set
@@ -200,7 +213,7 @@
 
 #ifdef CONFIG_SYS_FSL_CPC
 #if defined(CONFIG_RAMBOOT_PBL) || defined(CONFIG_SYS_CPC_REINIT_F)
-static void disable_cpc_sram(void)
+void disable_cpc_sram(void)
 {
 	int i;
 
@@ -251,15 +264,39 @@
 }
 #endif
 
-static void enable_cpc(void)
+void enable_cpc(void)
 {
 	int i;
+	int ret;
 	u32 size = 0;
-
+	u32 cpccfg0;
+	char buffer[HWCONFIG_BUFFER_SIZE];
+	char cpc_subarg[16];
+	bool have_hwconfig = false;
+	int cpc_args = 0;
 	cpc_corenet_t *cpc = (cpc_corenet_t *)CONFIG_SYS_FSL_CPC_ADDR;
 
+	/* Extract hwconfig from environment */
+	ret = getenv_f("hwconfig", buffer, sizeof(buffer));
+	if (ret > 0) {
+		/*
+		 * If "en_cpc" is not defined in hwconfig then by default all
+		 * cpcs are enable. If this config is defined then individual
+		 * cpcs which have to be enabled should also be defined.
+		 * e.g en_cpc:cpc1,cpc2;
+		 */
+		if (hwconfig_f("en_cpc", buffer))
+			have_hwconfig = true;
+	}
+
 	for (i = 0; i < CONFIG_SYS_NUM_CPC; i++, cpc++) {
-		u32 cpccfg0 = in_be32(&cpc->cpccfg0);
+		if (have_hwconfig) {
+			sprintf(cpc_subarg, "cpc%u", i + 1);
+			cpc_args = hwconfig_sub_f("en_cpc", cpc_subarg, buffer);
+			if (cpc_args == 0)
+				continue;
+		}
+		cpccfg0 = in_be32(&cpc->cpccfg0);
 		size += CPC_CFG0_SZ_K(cpccfg0);
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_CPC_A002
@@ -306,6 +343,7 @@
 #else
 #define enable_cpc()
 #define invalidate_cpc()
+#define disable_cpc_sram()
 #endif /* CONFIG_SYS_FSL_CPC */
 
 /*
@@ -465,7 +503,7 @@
 #endif
 
 #ifdef CONFIG_SYS_DCSRBAR_PHYS
-#ifdef CONFIG_DEEP_SLEEP
+#ifdef CONFIG_FSL_DEEP_SLEEP
 	/* disable the console if boot from deep sleep */
 	if (in_be32(&gur->scrtsr[0]) & (1 << 3))
 		flag = GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
@@ -520,7 +558,8 @@
 			u32 idx = (cluster >> (j*8)) & TP_CLUSTER_INIT_MASK;
 			u32 type = in_be32(&gur->tp_ityp[idx]);
 
-			if (type & TP_ITYP_AV)
+			if ((type & TP_ITYP_AV) &&
+			    TP_ITYP_TYPE(type) == TP_ITYP_TYPE_PPC)
 				cluster_valid = 1;
 		}
 
@@ -545,88 +584,15 @@
 
 /*
  * Initialize L2 as cache.
- *
- * The newer 8548, etc, parts have twice as much cache, but
- * use the same bit-encoding as the older 8555, etc, parts.
- *
  */
-int cpu_init_r(void)
+int l2cache_init(void)
 {
 	__maybe_unused u32 svr = get_svr();
-#ifdef CONFIG_SYS_LBC_LCRR
-	fsl_lbc_t *lbc = (void __iomem *)LBC_BASE_ADDR;
-#endif
 #ifdef CONFIG_L2_CACHE
 	ccsr_l2cache_t *l2cache = (void __iomem *)CONFIG_SYS_MPC85xx_L2_ADDR;
 #elif defined(CONFIG_SYS_FSL_QORIQ_CHASSIS2) && defined(CONFIG_E6500)
 	struct ccsr_cluster_l2 * l2cache = (void __iomem *)CONFIG_SYS_FSL_CLUSTER_1_L2;
 #endif
-#if defined(CONFIG_PPC_SPINTABLE_COMPATIBLE) && defined(CONFIG_MP)
-	extern int spin_table_compat;
-	const char *spin;
-#endif
-#ifdef CONFIG_SYS_FSL_ERRATUM_SEC_A003571
-	ccsr_sec_t __iomem *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
-#endif
-#if defined(CONFIG_SYS_P4080_ERRATUM_CPU22) || \
-	defined(CONFIG_SYS_FSL_ERRATUM_NMG_CPU_A011)
-	/*
-	 * CPU22 and NMG_CPU_A011 share the same workaround.
-	 * CPU22 applies to P4080 rev 1.0, 2.0, fixed in 3.0
-	 * NMG_CPU_A011 applies to P4080 rev 1.0, 2.0, fixed in 3.0
-	 * also applies to P3041 rev 1.0, 1.1, P2041 rev 1.0, 1.1, both
-	 * fixed in 2.0. NMG_CPU_A011 is activated by default and can
-	 * be disabled by hwconfig with syntax:
-	 *
-	 * fsl_cpu_a011:disable
-	 */
-	extern int enable_cpu_a011_workaround;
-#ifdef CONFIG_SYS_P4080_ERRATUM_CPU22
-	enable_cpu_a011_workaround = (SVR_MAJ(svr) < 3);
-#else
-	char buffer[HWCONFIG_BUFFER_SIZE];
-	char *buf = NULL;
-	int n, res;
-
-	n = getenv_f("hwconfig", buffer, sizeof(buffer));
-	if (n > 0)
-		buf = buffer;
-
-	res = hwconfig_arg_cmp_f("fsl_cpu_a011", "disable", buf);
-	if (res > 0)
-		enable_cpu_a011_workaround = 0;
-	else {
-		if (n >= HWCONFIG_BUFFER_SIZE) {
-			printf("fsl_cpu_a011 was not found. hwconfig variable "
-				"may be too long\n");
-		}
-		enable_cpu_a011_workaround =
-			(SVR_SOC_VER(svr) == SVR_P4080 && SVR_MAJ(svr) < 3) ||
-			(SVR_SOC_VER(svr) != SVR_P4080 && SVR_MAJ(svr) < 2);
-	}
-#endif
-	if (enable_cpu_a011_workaround) {
-		flush_dcache();
-		mtspr(L1CSR2, (mfspr(L1CSR2) | L1CSR2_DCWS));
-		sync();
-	}
-#endif
-#ifdef CONFIG_SYS_FSL_ERRATUM_A005812
-	/*
-	 * A-005812 workaround sets bit 32 of SPR 976 for SoCs running
-	 * in write shadow mode. Checking DCWS before setting SPR 976.
-	 */
-	if (mfspr(L1CSR2) & L1CSR2_DCWS)
-		mtspr(SPRN_HDBCR0, (mfspr(SPRN_HDBCR0) | 0x80000000));
-#endif
-
-#if defined(CONFIG_PPC_SPINTABLE_COMPATIBLE) && defined(CONFIG_MP)
-	spin = getenv("spin_table_compat");
-	if (spin && (*spin == 'n'))
-		spin_table_compat = 0;
-	else
-		spin_table_compat = 1;
-#endif
 
 	puts ("L2:    ");
 
@@ -751,6 +717,89 @@
 	puts("disabled\n");
 #endif
 
+	return 0;
+}
+
+/*
+ *
+ * The newer 8548, etc, parts have twice as much cache, but
+ * use the same bit-encoding as the older 8555, etc, parts.
+ *
+ */
+int cpu_init_r(void)
+{
+	__maybe_unused u32 svr = get_svr();
+#ifdef CONFIG_SYS_LBC_LCRR
+	fsl_lbc_t *lbc = (void __iomem *)LBC_BASE_ADDR;
+#endif
+#if defined(CONFIG_PPC_SPINTABLE_COMPATIBLE) && defined(CONFIG_MP)
+	extern int spin_table_compat;
+	const char *spin;
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_SEC_A003571
+	ccsr_sec_t __iomem *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+#endif
+#if defined(CONFIG_SYS_P4080_ERRATUM_CPU22) || \
+	defined(CONFIG_SYS_FSL_ERRATUM_NMG_CPU_A011)
+	/*
+	 * CPU22 and NMG_CPU_A011 share the same workaround.
+	 * CPU22 applies to P4080 rev 1.0, 2.0, fixed in 3.0
+	 * NMG_CPU_A011 applies to P4080 rev 1.0, 2.0, fixed in 3.0
+	 * also applies to P3041 rev 1.0, 1.1, P2041 rev 1.0, 1.1, both
+	 * fixed in 2.0. NMG_CPU_A011 is activated by default and can
+	 * be disabled by hwconfig with syntax:
+	 *
+	 * fsl_cpu_a011:disable
+	 */
+	extern int enable_cpu_a011_workaround;
+#ifdef CONFIG_SYS_P4080_ERRATUM_CPU22
+	enable_cpu_a011_workaround = (SVR_MAJ(svr) < 3);
+#else
+	char buffer[HWCONFIG_BUFFER_SIZE];
+	char *buf = NULL;
+	int n, res;
+
+	n = getenv_f("hwconfig", buffer, sizeof(buffer));
+	if (n > 0)
+		buf = buffer;
+
+	res = hwconfig_arg_cmp_f("fsl_cpu_a011", "disable", buf);
+	if (res > 0) {
+		enable_cpu_a011_workaround = 0;
+	} else {
+		if (n >= HWCONFIG_BUFFER_SIZE) {
+			printf("fsl_cpu_a011 was not found. hwconfig variable "
+				"may be too long\n");
+		}
+		enable_cpu_a011_workaround =
+			(SVR_SOC_VER(svr) == SVR_P4080 && SVR_MAJ(svr) < 3) ||
+			(SVR_SOC_VER(svr) != SVR_P4080 && SVR_MAJ(svr) < 2);
+	}
+#endif
+	if (enable_cpu_a011_workaround) {
+		flush_dcache();
+		mtspr(L1CSR2, (mfspr(L1CSR2) | L1CSR2_DCWS));
+		sync();
+	}
+#endif
+#ifdef CONFIG_SYS_FSL_ERRATUM_A005812
+	/*
+	 * A-005812 workaround sets bit 32 of SPR 976 for SoCs running
+	 * in write shadow mode. Checking DCWS before setting SPR 976.
+	 */
+	if (mfspr(L1CSR2) & L1CSR2_DCWS)
+		mtspr(SPRN_HDBCR0, (mfspr(SPRN_HDBCR0) | 0x80000000));
+#endif
+
+#if defined(CONFIG_PPC_SPINTABLE_COMPATIBLE) && defined(CONFIG_MP)
+	spin = getenv("spin_table_compat");
+	if (spin && (*spin == 'n'))
+		spin_table_compat = 0;
+	else
+		spin_table_compat = 1;
+#endif
+
+	l2cache_init();
 #if defined(CONFIG_RAMBOOT_PBL)
 	disable_cpc_sram();
 #endif
@@ -924,6 +973,21 @@
 		clrbits_le32(&reg->hcontrol, HCONTROL_ENTERPRISE_EN);
 	}
 #endif
+#if defined(CONFIG_SECURE_BOOT) && defined(CONFIG_FSL_CORENET)
+	if (pamu_init() < 0)
+		fsl_secboot_handle_error(ERROR_ESBC_PAMU_INIT);
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+	if (sec_init(&jr) < 0)
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_INIT);
+	if (get_rng_vid() >= 4) {
+		if (rng_init(&jr) < 0)
+			printf("CAAM:RNG init failed\n");
+	}
+#endif
+
+	return 0;
 
 	init_used_tlb_cams();
 
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/b4860_serdes.c.orig	2022-05-09 14:06:21.329226377 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/b4860_serdes.c	2022-05-09 14:06:22.973159885 -0700
@@ -18,6 +18,8 @@
 #ifdef CONFIG_PPC_B4860
 static struct serdes_config serdes1_cfg_tbl[] = {
 	/* SerDes 1 */
+	{0x01, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{0x02, {AURORA, AURORA, CPRI6, CPRI5,
 		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{0x04, {AURORA, AURORA, CPRI6, CPRI5,
@@ -26,6 +28,8 @@
 		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{0x06, {AURORA, AURORA, CPRI6, CPRI5,
 		CPRI4, CPRI3, CPRI2, CPRI1} },
+	{0x07, {AURORA, AURORA, CPRI6, CPRI5,
+		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{0x08, {AURORA, AURORA, CPRI6, CPRI5,
 		CPRI4, CPRI3, CPRI2, CPRI1} },
 	{0x09, {AURORA, AURORA, CPRI6, CPRI5,
@@ -184,12 +188,17 @@
 		CPRI4, CPRI3, NONE, NONE} },
 	{0x0F, {NONE, NONE, CPRI6, CPRI5,
 		CPRI4, CPRI3, NONE, NONE} },
+	{0x17, {NONE, NONE,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		NONE, NONE, NONE, NONE} },
 	{0x18, {NONE, NONE,
 		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
 		NONE, NONE, NONE, NONE} },
 	{0x1B, {NONE, NONE,
 		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
 		NONE, NONE, NONE, NONE} },
+	{0x1D, {NONE, NONE, AURORA, AURORA,
+		NONE, NONE, NONE, NONE} },
 	{0x1E, {NONE, NONE, AURORA, AURORA,
 		NONE, NONE, NONE, NONE} },
 	{0x21, {NONE, NONE, AURORA, AURORA,
@@ -199,19 +208,29 @@
 	{}
 };
 static struct serdes_config serdes2_cfg_tbl[] = {
+	{0x48, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		SGMII_FM1_DTSEC3, AURORA,
+		NONE, NONE, NONE, NONE} },
 	{0x49, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
 		SGMII_FM1_DTSEC3, AURORA,
 		NONE, NONE, NONE, NONE} },
 	{0x4A, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
 		SGMII_FM1_DTSEC3, AURORA,
 		NONE, NONE, NONE, NONE} },
+	{0x6E, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
+		AURORA, AURORA, NONE, NONE, NONE, NONE} },
 	{0x6F, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
 		AURORA, AURORA,	NONE, NONE, NONE, NONE} },
 	{0x70, {SGMII_FM1_DTSEC1, SGMII_FM1_DTSEC2,
 		AURORA, AURORA,	NONE, NONE, NONE, NONE} },
+	{0x99, {PCIE1, PCIE1,
+		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
+		NONE, NONE, NONE, NONE} },
 	{0x9A, {PCIE1, PCIE1,
 		SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC4,
 		NONE, NONE, NONE, NONE} },
+	{0x9D, {PCIE1, PCIE1, PCIE1, PCIE1,
+		NONE, NONE, NONE, NONE} },
 	{0x9E, {PCIE1, PCIE1, PCIE1, PCIE1,
 		NONE, NONE, NONE, NONE} },
 	{}
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t4240_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t4240_ids.c	2022-05-09 14:06:22.981159561 -0700
@@ -93,8 +93,8 @@
 	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 308),
 	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 4, 388),
 
-	SET_DMA_LIODN(1, 147),
-	SET_DMA_LIODN(2, 227),
+	SET_DMA_LIODN(1, "fsl,elo3-dma", 147),
+	SET_DMA_LIODN(2, "fsl,elo3-dma", 227),
 
 	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
 	SET_GUTS_LIODN(NULL, 200, rio2liodnr, 0),
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t1040_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t1040_ids.c	2022-05-09 14:06:22.981159561 -0700
@@ -24,12 +24,6 @@
 };
 #endif
 
-struct srio_liodn_id_table srio_liodn_tbl[] = {
-	SET_SRIO_LIODN_1(1, 307),
-	SET_SRIO_LIODN_1(2, 387),
-};
-int srio_liodn_tbl_sz = ARRAY_SIZE(srio_liodn_tbl);
-
 struct liodn_id_table liodn_tbl[] = {
 #ifdef CONFIG_SYS_DPAA_QBMAN
 	SET_QMAN_LIODN(62),
@@ -38,12 +32,21 @@
 
 	SET_SDHC_LIODN(1, 552),
 
+	SET_PME_LIODN(117),
+
 	SET_USB_LIODN(1, "fsl-usb2-mph", 553),
+	SET_USB_LIODN(2, "fsl-usb2-dr", 554),
 
-	SET_PCI_LIODN("fsl,qoriq-pcie-v2.2", 1, 148),
+	SET_SATA_LIODN(1, 555),
+	SET_SATA_LIODN(2, 556),
 
-	SET_DMA_LIODN(1, 147),
-	SET_DMA_LIODN(2, 227),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 2, 228),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 308),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 4, 388),
+
+	SET_DMA_LIODN(1, "fsl,elo3-dma", 147),
+	SET_DMA_LIODN(2, "fsl,elo3-dma", 227),
 
 	/* SET_NEXUS_LIODN(557), -- not yet implemented */
 	SET_QE_LIODN(559),
@@ -74,6 +77,12 @@
 	SET_SEC_RTIC_LIODN_ENTRY(d, 551),
 	SET_SEC_DECO_LIODN_ENTRY(0, 541, 610),
 	SET_SEC_DECO_LIODN_ENTRY(1, 542, 611),
+	SET_SEC_DECO_LIODN_ENTRY(2, 543, 612),
+	SET_SEC_DECO_LIODN_ENTRY(3, 544, 613),
+	SET_SEC_DECO_LIODN_ENTRY(4, 545, 614),
+	SET_SEC_DECO_LIODN_ENTRY(5, 546, 615),
+	SET_SEC_DECO_LIODN_ENTRY(6, 547, 616),
+	SET_SEC_DECO_LIODN_ENTRY(7, 548, 617),
 };
 int sec_liodn_tbl_sz = ARRAY_SIZE(sec_liodn_tbl);
 
@@ -82,4 +91,7 @@
 #ifdef CONFIG_SYS_DPAA_FMAN
 	[FSL_HW_PORTAL_FMAN1] = SET_LIODN_BASE_1(973),
 #endif
+#ifdef CONFIG_SYS_DPAA_PME
+	[FSL_HW_PORTAL_PME]   = SET_LIODN_BASE_2(770, 846),
+#endif
 };
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p5020_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p5020_ids.c	2022-05-09 14:06:22.977159723 -0700
@@ -51,8 +51,8 @@
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 195),
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 4, 196),
 
-	SET_DMA_LIODN(1, 197),
-	SET_DMA_LIODN(2, 198),
+	SET_DMA_LIODN(1, "fsl,eloplus-dma", 197),
+	SET_DMA_LIODN(2, "fsl,eloplus-dma", 198),
 
 	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
 	SET_GUTS_LIODN(NULL, 200, rio2liodnr, 0),
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p3041_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p3041_ids.c	2022-05-09 14:06:22.977159723 -0700
@@ -51,8 +51,8 @@
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 195),
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 4, 196),
 
-	SET_DMA_LIODN(1, 197),
-	SET_DMA_LIODN(2, 198),
+	SET_DMA_LIODN(1, "fsl,eloplus-dma", 197),
+	SET_DMA_LIODN(2, "fsl,eloplus-dma", 198),
 
 	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
 	SET_GUTS_LIODN(NULL, 200, rio2liodnr, 0),
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.c.orig	2022-05-09 14:06:21.329226377 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/fsl_corenet2_serdes.c	2022-05-09 14:06:22.977159723 -0700
@@ -11,6 +11,7 @@
 #include <asm/processor.h>
 #include <asm/fsl_law.h>
 #include <asm/errno.h>
+#include <asm/fsl_errata.h>
 #include "fsl_corenet2_serdes.h"
 
 #ifdef CONFIG_SYS_FSL_SRDS_1
@@ -208,7 +209,7 @@
 
 	sel = (sfp_spfr0 >> FUSE_VAL_SHIFT) & FUSE_VAL_MASK;
 
-	if (sel == 0x01 || sel == 0x02) {
+	if (has_erratum_a007186() && (sel == 0x01 || sel == 0x02)) {
 		for (pll_num = 0; pll_num < SRDS_MAX_BANK; pll_num++) {
 			pll_status = in_be32(&srds_regs->bank[pll_num].pllcr0);
 			debug("A007186: pll_num=%x pllcr0=%x\n",
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/speed.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/speed.c	2022-05-09 14:06:22.981159561 -0700
@@ -37,6 +37,7 @@
 #ifdef CONFIG_SYS_FSL_QORIQ_CHASSIS2
 	int cc_group[12] = CONFIG_SYS_FSL_CLUSTER_CLOCKS;
 #endif
+	__maybe_unused u32 svr;
 
 	const u8 core_cplx_PLL[16] = {
 		[ 0] = 0,	/* CC1 PPL / 1 */
@@ -122,11 +123,27 @@
 	/* T4240/T4160 Rev2.0 MEM_PLL_RAT uses a value which is half of
 	 * T4240/T4160 Rev1.0. eg. It's 12 in Rev1.0, however, for Rev2.0
 	 * it uses 6.
+	 * T2080 rev 1.1 and later also use half mem_pll comparing with rev 1.0
 	 */
 #if defined(CONFIG_PPC_T4240) || defined(CONFIG_PPC_T4160) || \
-	defined(CONFIG_PPC_T4080)
-	if (SVR_MAJ(get_svr()) >= 2)
-		mem_pll_rat *= 2;
+	defined(CONFIG_PPC_T4080) || defined(CONFIG_PPC_T2080) ||  defined(CONFIG_PPC_M300)
+	svr = get_svr();
+	switch (SVR_SOC_VER(svr)) {
+	case SVR_T4240:
+	case SVR_T4160:
+	case SVR_T4120:
+	case SVR_T4080:
+		if (SVR_MAJ(svr) >= 2)
+			mem_pll_rat *= 2;
+		break;
+	case SVR_T2080:
+	case SVR_T2081:
+		if ((SVR_MAJ(svr) > 1) || (SVR_MIN(svr) >= 1))
+			mem_pll_rat *= 2;
+		break;
+	default:
+		break;
+	}
 #endif
 	if (mem_pll_rat > 2)
 		sys_info->freq_ddrbus *= mem_pll_rat;
@@ -165,9 +182,12 @@
 			 freq_c_pll[cplx_pll] / core_cplx_pll_div[c_pll_sel];
 	}
 #if defined(CONFIG_PPC_B4860) || defined(CONFIG_PPC_B4420) || \
-	defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081)
+	defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081) || defined(CONFIG_PPC_M300)
 #define FM1_CLK_SEL	0xe0000000
 #define FM1_CLK_SHIFT	29
+#elif defined(CONFIG_PPC_T1024) || defined(CONFIG_PPC_T1023)
+#define FM1_CLK_SEL	0x00000007
+#define FM1_CLK_SHIFT	0
 #else
 #define PME_CLK_SEL	0xe0000000
 #define PME_CLK_SHIFT	29
@@ -175,8 +195,12 @@
 #define FM1_CLK_SHIFT	26
 #endif
 #if !defined(CONFIG_FM_PLAT_CLK_DIV) || !defined(CONFIG_PME_PLAT_CLK_DIV)
+#if defined(CONFIG_PPC_T1024) || defined(CONFIG_PPC_T1023)
+	rcw_tmp = in_be32(&gur->rcwsr[15]) - 4;
+#else
 	rcw_tmp = in_be32(&gur->rcwsr[7]);
 #endif
+#endif
 
 #ifdef CONFIG_SYS_DPAA_PME
 #ifndef CONFIG_PME_PLAT_CLK_DIV
@@ -213,7 +237,10 @@
 #endif
 
 #ifdef CONFIG_SYS_DPAA_QBMAN
-	sys_info->freq_qman = sys_info->freq_systembus / 2;
+#ifndef CONFIG_QBMAN_CLK_DIV
+#define CONFIG_QBMAN_CLK_DIV	2
+#endif
+	sys_info->freq_qman = sys_info->freq_systembus / CONFIG_QBMAN_CLK_DIV;
 #endif
 
 #ifdef CONFIG_SYS_DPAA_FMAN
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p4080_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p4080_ids.c	2022-05-09 14:06:22.977159723 -0700
@@ -40,8 +40,8 @@
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 2, 194),
 	SET_PCI_LIODN(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 195),
 
-	SET_DMA_LIODN(1, 196),
-	SET_DMA_LIODN(2, 197),
+	SET_DMA_LIODN(1, "fsl,eloplus-dma", 196),
+	SET_DMA_LIODN(2, "fsl,eloplus-dma", 197),
 
 	SET_GUTS_LIODN("fsl,srio-rmu", 200, rmuliodnr, 0xd3000),
 
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p5040_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/p5040_ids.c	2022-05-09 14:06:22.977159723 -0700
@@ -42,30 +42,30 @@
 	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 2, 196),
 	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 197),
 
-	SET_DMA_LIODN(1, 193),
-	SET_DMA_LIODN(2, 194),
+	SET_DMA_LIODN(1, "fsl,eloplus-dma", 193),
+	SET_DMA_LIODN(2, "fsl,eloplus-dma", 194),
 };
 int liodn_tbl_sz = ARRAY_SIZE(liodn_tbl);
 
 #ifdef CONFIG_SYS_DPAA_FMAN
 struct liodn_id_table fman1_liodn_tbl[] = {
-	SET_FMAN_RX_1G_LIODN(1, 0, 6),
-	SET_FMAN_RX_1G_LIODN(1, 1, 7),
-	SET_FMAN_RX_1G_LIODN(1, 2, 8),
-	SET_FMAN_RX_1G_LIODN(1, 3, 9),
-	SET_FMAN_RX_1G_LIODN(1, 4, 10),
-	SET_FMAN_RX_10G_LIODN(1, 0, 11),
+	SET_FMAN_RX_1G_LIODN(1, 0, 11),
+	SET_FMAN_RX_1G_LIODN(1, 1, 12),
+	SET_FMAN_RX_1G_LIODN(1, 2, 13),
+	SET_FMAN_RX_1G_LIODN(1, 3, 14),
+	SET_FMAN_RX_1G_LIODN(1, 4, 15),
+	SET_FMAN_RX_10G_LIODN(1, 0, 16),
 };
 int fman1_liodn_tbl_sz = ARRAY_SIZE(fman1_liodn_tbl);
 
 #if (CONFIG_SYS_NUM_FMAN == 2)
 struct liodn_id_table fman2_liodn_tbl[] = {
-	SET_FMAN_RX_1G_LIODN(2, 0, 12),
-	SET_FMAN_RX_1G_LIODN(2, 1, 13),
-	SET_FMAN_RX_1G_LIODN(2, 2, 14),
-	SET_FMAN_RX_1G_LIODN(2, 3, 15),
-	SET_FMAN_RX_1G_LIODN(2, 4, 16),
-	SET_FMAN_RX_10G_LIODN(2, 0, 17),
+	SET_FMAN_RX_1G_LIODN(2, 0, 17),
+	SET_FMAN_RX_1G_LIODN(2, 1, 18),
+	SET_FMAN_RX_1G_LIODN(2, 2, 19),
+	SET_FMAN_RX_1G_LIODN(2, 3, 20),
+	SET_FMAN_RX_1G_LIODN(2, 4, 21),
+	SET_FMAN_RX_10G_LIODN(2, 0, 22),
 };
 int fman2_liodn_tbl_sz = ARRAY_SIZE(fman2_liodn_tbl);
 #endif
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/Makefile.orig	2022-05-09 14:06:21.329226377 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/Makefile	2022-05-09 14:06:22.973159885 -0700
@@ -51,8 +51,12 @@
 obj-$(CONFIG_PPC_T1042)	+= t1040_ids.o
 obj-$(CONFIG_PPC_T1020)	+= t1040_ids.o
 obj-$(CONFIG_PPC_T1022)	+= t1040_ids.o
+obj-$(CONFIG_PPC_M200)	+= t1040_ids.o
+obj-$(CONFIG_PPC_T1023) += t1024_ids.o
+obj-$(CONFIG_PPC_T1024) += t1024_ids.o
 obj-$(CONFIG_PPC_T2080) += t2080_ids.o
 obj-$(CONFIG_PPC_T2081) += t2080_ids.o
+obj-$(CONFIG_PPC_M300) += t2080_ids.o
 
 
 obj-$(CONFIG_QE)	+= qe_io.o
@@ -97,8 +101,12 @@
 obj-$(CONFIG_PPC_T1042)	+= t1040_serdes.o
 obj-$(CONFIG_PPC_T1020)	+= t1040_serdes.o
 obj-$(CONFIG_PPC_T1022)	+= t1040_serdes.o
+obj-$(CONFIG_PPC_M200)	+= t1040_serdes.o
+obj-$(CONFIG_PPC_T1023) += t1024_serdes.o
+obj-$(CONFIG_PPC_T1024) += t1024_serdes.o
 obj-$(CONFIG_PPC_T2080) += t2080_serdes.o
 obj-$(CONFIG_PPC_T2081) += t2080_serdes.o
+obj-$(CONFIG_PPC_M300) += t2080_serdes.o
 
 obj-y	+= cpu.o
 obj-y	+= cpu_init.o
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t2080_ids.c.orig	2022-05-09 14:06:21.333226216 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t2080_ids.c	2022-05-09 14:06:22.981159561 -0700
@@ -63,9 +63,9 @@
 	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 308),
 	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 4, 388),
 
-	SET_DMA_LIODN(1, 147),
-	SET_DMA_LIODN(2, 227),
-	SET_DMA_LIODN(3, 226),
+	SET_DMA_LIODN(1, "fsl,elo3-dma", 147),
+	SET_DMA_LIODN(2, "fsl,elo3-dma", 227),
+	SET_DMA_LIODN(3, "fsl,elo3-dma", 226),
 
 	SET_GUTS_LIODN("fsl,rapidio-delta", 199, rio1liodnr, 0),
 	SET_GUTS_LIODN(NULL, 200, rio2liodnr, 0),
--- u-boot-2014.07/arch/powerpc/cpu/mpc83xx/fdt.c.orig	2022-05-09 14:06:21.325226539 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc83xx/fdt.c	2022-05-09 14:06:22.973159885 -0700
@@ -18,7 +18,7 @@
 
 #if defined(CONFIG_BOOTCOUNT_LIMIT) && \
 	(defined(CONFIG_QE) && !defined(CONFIG_MPC831x))
-#include <asm/immap_qe.h>
+#include <linux/immap_qe.h>
 
 void fdt_fixup_muram (void *blob)
 {
--- u-boot-2014.07/arch/powerpc/cpu/mpc83xx/cpu.c.orig	2022-05-09 14:06:21.325226539 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc83xx/cpu.c	2022-05-09 14:06:22.969160046 -0700
@@ -20,7 +20,7 @@
 #include <netdev.h>
 #include <fsl_esdhc.h>
 #if defined(CONFIG_BOOTCOUNT_LIMIT) && !defined(CONFIG_MPC831x)
-#include <asm/immap_qe.h>
+#include <linux/immap_qe.h>
 #include <asm/io.h>
 #endif
 
--- u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/fdt.c.orig	2022-05-09 14:06:21.345225730 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/fdt.c	2022-05-09 14:06:22.993159076 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2012 Freescale Semiconductor, Inc.
+ * Copyright 2009-2014 Freescale Semiconductor, Inc.
  *
  * This file is derived from arch/powerpc/cpu/mpc85xx/cpu.c and
  * arch/powerpc/cpu/mpc86xx/cpu.c. Basically this file contains
@@ -73,282 +73,6 @@
 }
 #endif /* defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx) */
 
-#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB)
-static int fdt_fixup_usb_mode_phy_type(void *blob, const char *mode,
-				const char *phy_type, int start_offset)
-{
-	const char *compat_dr = "fsl-usb2-dr";
-	const char *compat_mph = "fsl-usb2-mph";
-	const char *prop_mode = "dr_mode";
-	const char *prop_type = "phy_type";
-	const char *node_type = NULL;
-	int node_offset;
-	int err;
-
-	node_offset = fdt_node_offset_by_compatible(blob,
-			start_offset, compat_mph);
-	if (node_offset < 0) {
-		node_offset = fdt_node_offset_by_compatible(blob,
-			start_offset, compat_dr);
-		if (node_offset < 0) {
-			printf("WARNING: could not find compatible"
-				" node %s or %s: %s.\n", compat_mph,
-				compat_dr, fdt_strerror(node_offset));
-			return -1;
-		} else
-			node_type = compat_dr;
-	} else
-		node_type = compat_mph;
-
-	if (mode) {
-		err = fdt_setprop(blob, node_offset, prop_mode, mode,
-				  strlen(mode) + 1);
-		if (err < 0)
-			printf("WARNING: could not set %s for %s: %s.\n",
-			       prop_mode, node_type, fdt_strerror(err));
-	}
-
-	if (phy_type) {
-		err = fdt_setprop(blob, node_offset, prop_type, phy_type,
-				  strlen(phy_type) + 1);
-		if (err < 0)
-			printf("WARNING: could not set %s for %s: %s.\n",
-			       prop_type, node_type, fdt_strerror(err));
-	}
-
-	return node_offset;
-}
-
-void fdt_fixup_dr_usb(void *blob, bd_t *bd)
-{
-	const char *modes[] = { "host", "peripheral", "otg" };
-	const char *phys[] = { "ulpi", "utmi" };
-	const char *dr_mode_type = NULL;
-	const char *dr_phy_type = NULL;
-	int usb_mode_off = -1;
-	int usb_phy_off = -1;
-	char str[5];
-	int i, j;
-
-	for (i = 1; i <= CONFIG_USB_MAX_CONTROLLER_COUNT; i++) {
-		int mode_idx = -1, phy_idx = -1;
-		snprintf(str, 5, "%s%d", "usb", i);
-		if (hwconfig(str)) {
-			for (j = 0; j < ARRAY_SIZE(modes); j++) {
-				if (hwconfig_subarg_cmp(str, "dr_mode",
-						modes[j])) {
-					mode_idx = j;
-					break;
-				}
-			}
-
-			for (j = 0; j < ARRAY_SIZE(phys); j++) {
-				if (hwconfig_subarg_cmp(str, "phy_type",
-						phys[j])) {
-					phy_idx = j;
-					break;
-				}
-			}
-
-			if (mode_idx < 0 || phy_idx < 0) {
-				puts("ERROR: wrong usb mode/phy defined!!\n");
-				return;
-			}
-
-			dr_mode_type = modes[mode_idx];
-			dr_phy_type = phys[phy_idx];
-
-			if (mode_idx < 0 && phy_idx < 0) {
-				printf("WARNING: invalid phy or mode\n");
-				return;
-			}
-		}
-
-		usb_mode_off = fdt_fixup_usb_mode_phy_type(blob,
-			dr_mode_type, NULL, usb_mode_off);
-
-		if (usb_mode_off < 0)
-			return;
-
-		usb_phy_off = fdt_fixup_usb_mode_phy_type(blob,
-			NULL, dr_phy_type, usb_phy_off);
-
-		if (usb_phy_off < 0)
-			return;
-	}
-}
-#endif /* defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_MPH_USB) */
-
-/*
- * update crypto node properties to a specified revision of the SEC
- * called with sec_rev == 0 if not on an E processor
- */
-#if CONFIG_SYS_FSL_SEC_COMPAT == 2 /* SEC 2.x/3.x */
-void fdt_fixup_crypto_node(void *blob, int sec_rev)
-{
-	static const struct sec_rev_prop {
-		u32 sec_rev;
-		u32 num_channels;
-		u32 channel_fifo_len;
-		u32 exec_units_mask;
-		u32 descriptor_types_mask;
-	} sec_rev_prop_list [] = {
-		{ 0x0200, 4, 24, 0x07e, 0x01010ebf }, /* SEC 2.0 */
-		{ 0x0201, 4, 24, 0x0fe, 0x012b0ebf }, /* SEC 2.1 */
-		{ 0x0202, 1, 24, 0x04c, 0x0122003f }, /* SEC 2.2 */
-		{ 0x0204, 4, 24, 0x07e, 0x012b0ebf }, /* SEC 2.4 */
-		{ 0x0300, 4, 24, 0x9fe, 0x03ab0ebf }, /* SEC 3.0 */
-		{ 0x0301, 4, 24, 0xbfe, 0x03ab0ebf }, /* SEC 3.1 */
-		{ 0x0303, 4, 24, 0x97c, 0x03a30abf }, /* SEC 3.3 */
-	};
-	static char compat_strlist[ARRAY_SIZE(sec_rev_prop_list) *
-				   sizeof("fsl,secX.Y")];
-	int crypto_node, sec_idx, err;
-	char *p;
-	u32 val;
-
-	/* locate crypto node based on lowest common compatible */
-	crypto_node = fdt_node_offset_by_compatible(blob, -1, "fsl,sec2.0");
-	if (crypto_node == -FDT_ERR_NOTFOUND)
-		return;
-
-	/* delete it if not on an E-processor */
-	if (crypto_node > 0 && !sec_rev) {
-		fdt_del_node(blob, crypto_node);
-		return;
-	}
-
-	/* else we got called for possible uprev */
-	for (sec_idx = 0; sec_idx < ARRAY_SIZE(sec_rev_prop_list); sec_idx++)
-		if (sec_rev_prop_list[sec_idx].sec_rev == sec_rev)
-			break;
-
-	if (sec_idx == ARRAY_SIZE(sec_rev_prop_list)) {
-		puts("warning: unknown SEC revision number\n");
-		return;
-	}
-
-	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].num_channels);
-	err = fdt_setprop(blob, crypto_node, "fsl,num-channels", &val, 4);
-	if (err < 0)
-		printf("WARNING: could not set crypto property: %s\n",
-		       fdt_strerror(err));
-
-	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].descriptor_types_mask);
-	err = fdt_setprop(blob, crypto_node, "fsl,descriptor-types-mask", &val, 4);
-	if (err < 0)
-		printf("WARNING: could not set crypto property: %s\n",
-		       fdt_strerror(err));
-
-	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].exec_units_mask);
-	err = fdt_setprop(blob, crypto_node, "fsl,exec-units-mask", &val, 4);
-	if (err < 0)
-		printf("WARNING: could not set crypto property: %s\n",
-		       fdt_strerror(err));
-
-	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].channel_fifo_len);
-	err = fdt_setprop(blob, crypto_node, "fsl,channel-fifo-len", &val, 4);
-	if (err < 0)
-		printf("WARNING: could not set crypto property: %s\n",
-		       fdt_strerror(err));
-
-	val = 0;
-	while (sec_idx >= 0) {
-		p = compat_strlist + val;
-		val += sprintf(p, "fsl,sec%d.%d",
-			(sec_rev_prop_list[sec_idx].sec_rev & 0xff00) >> 8,
-			sec_rev_prop_list[sec_idx].sec_rev & 0x00ff) + 1;
-		sec_idx--;
-	}
-	err = fdt_setprop(blob, crypto_node, "compatible", &compat_strlist, val);
-	if (err < 0)
-		printf("WARNING: could not set crypto property: %s\n",
-		       fdt_strerror(err));
-}
-#elif CONFIG_SYS_FSL_SEC_COMPAT >= 4  /* SEC4 */
-static u8 caam_get_era(void)
-{
-	static const struct {
-		u16 ip_id;
-		u8 maj_rev;
-		u8 era;
-	} caam_eras[] = {
-		{0x0A10, 1, 1},
-		{0x0A10, 2, 2},
-		{0x0A12, 1, 3},
-		{0x0A14, 1, 3},
-		{0x0A14, 2, 4},
-		{0x0A16, 1, 4},
-		{0x0A10, 3, 4},
-		{0x0A11, 1, 4},
-		{0x0A18, 1, 4},
-		{0x0A11, 2, 5},
-		{0x0A12, 2, 5},
-		{0x0A13, 1, 5},
-		{0x0A1C, 1, 5}
-	};
-
-	ccsr_sec_t __iomem *sec = (void __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
-	u32 secvid_ms = in_be32(&sec->secvid_ms);
-	u32 ccbvid = in_be32(&sec->ccbvid);
-	u16 ip_id = (secvid_ms & SEC_SECVID_MS_IPID_MASK) >>
-				SEC_SECVID_MS_IPID_SHIFT;
-	u8 maj_rev = (secvid_ms & SEC_SECVID_MS_MAJ_REV_MASK) >>
-				SEC_SECVID_MS_MAJ_REV_SHIFT;
-	u8 era = (ccbvid & SEC_CCBVID_ERA_MASK) >> SEC_CCBVID_ERA_SHIFT;
-
-	int i;
-
-	if (era)	/* This is '0' prior to CAAM ERA-6 */
-		return era;
-
-	for (i = 0; i < ARRAY_SIZE(caam_eras); i++)
-		if (caam_eras[i].ip_id == ip_id &&
-		    caam_eras[i].maj_rev == maj_rev)
-			return caam_eras[i].era;
-
-	return 0;
-}
-
-static void fdt_fixup_crypto_era(void *blob, u32 era)
-{
-	int err;
-	int crypto_node;
-
-	crypto_node = fdt_path_offset(blob, "crypto");
-	if (crypto_node < 0) {
-		printf("WARNING: Missing crypto node\n");
-		return;
-	}
-
-	err = fdt_setprop(blob, crypto_node, "fsl,sec-era", &era,
-			  sizeof(era));
-	if (err < 0) {
-		printf("ERROR: could not set fsl,sec-era property: %s\n",
-		       fdt_strerror(err));
-	}
-}
-
-void fdt_fixup_crypto_node(void *blob, int sec_rev)
-{
-	u8 era;
-
-	if (!sec_rev) {
-		fdt_del_node_and_alias(blob, "crypto");
-		return;
-	}
-
-	/* Add SEC ERA information in compatible */
-	era = caam_get_era();
-	if (era) {
-		fdt_fixup_crypto_era(blob, era);
-	} else {
-		printf("WARNING: Unable to get ERA for CAAM rev: %d\n",
-			sec_rev);
-	}
-}
-#endif
-
 int fdt_fixup_phy_connection(void *blob, int offset, phy_interface_t phyc)
 {
 	return fdt_setprop_string(blob, offset, "phy-connection-type",
--- u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/Makefile.orig	2022-05-09 14:06:21.341225892 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/Makefile	2022-05-09 14:06:22.993159076 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright 2009-2010 Freescale Semiconductor, Inc.
+# Copyright 2009-2010, 2012 Freescale Semiconductor, Inc.
 #
 # This program is free software; you can redistribute it and/or
 # modify it under the terms of the GNU General Public License
@@ -26,5 +26,6 @@
 obj-$(CONFIG_FSL_LBC) += fsl_lbc.o
 obj-$(CONFIG_SYS_SRIO) += srio.o
 obj-$(CONFIG_FSL_LAW) += law.o
+obj-$(CONFIG_FSL_CORENET) += fsl_pamu.o pamu_table.o
 
 endif
--- u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/cpu.c.orig	2022-05-09 14:06:21.341225892 -0700
+++ u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/cpu.c	2022-05-09 14:06:22.993159076 -0700
@@ -65,7 +65,6 @@
 	CPU_TYPE_ENTRY(T4080, T4080, 4),
 	CPU_TYPE_ENTRY(B4860, B4860, 0),
 	CPU_TYPE_ENTRY(G4860, G4860, 0),
-	CPU_TYPE_ENTRY(G4060, G4060, 0),
 	CPU_TYPE_ENTRY(B4440, B4440, 0),
 	CPU_TYPE_ENTRY(B4460, B4460, 0),
 	CPU_TYPE_ENTRY(G4440, G4440, 0),
@@ -74,11 +73,17 @@
 	CPU_TYPE_ENTRY(T1040, T1040, 0),
 	CPU_TYPE_ENTRY(T1041, T1041, 0),
 	CPU_TYPE_ENTRY(T1042, T1042, 0),
+	CPU_TYPE_ENTRY(M200, T1042, 0),
 	CPU_TYPE_ENTRY(T1020, T1020, 0),
 	CPU_TYPE_ENTRY(T1021, T1021, 0),
 	CPU_TYPE_ENTRY(T1022, T1022, 0),
+	CPU_TYPE_ENTRY(T1024, T1024, 0),
+	CPU_TYPE_ENTRY(T1023, T1023, 0),
+	CPU_TYPE_ENTRY(T1014, T1014, 0),
+	CPU_TYPE_ENTRY(T1013, T1013, 0),
 	CPU_TYPE_ENTRY(T2080, T2080, 0),
 	CPU_TYPE_ENTRY(T2081, T2081, 0),
+	CPU_TYPE_ENTRY(M300, T2081, 0),
 	CPU_TYPE_ENTRY(BSC9130, 9130, 1),
 	CPU_TYPE_ENTRY(BSC9131, 9131, 1),
 	CPU_TYPE_ENTRY(BSC9132, 9132, 2),
--- u-boot-2014.07/arch/powerpc/include/asm/types.h.orig	2022-05-09 14:06:21.377224436 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/types.h	2022-05-09 14:06:23.025157781 -0700
@@ -42,7 +42,11 @@
 #define BITS_PER_LONG 32
 
 /* DMA addresses are 32-bits wide */
+#ifdef CONFIG_PHYS_64BIT
+typedef unsigned long long dma_addr_t;
+#else
 typedef u32 dma_addr_t;
+#endif
 
 #ifdef CONFIG_PHYS_64BIT
 typedef unsigned long long phys_addr_t;
--- u-boot-2014.07/arch/powerpc/include/asm/cache.h.orig	2022-05-09 14:06:21.361225083 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/cache.h	2022-05-09 14:06:23.009158429 -0700
@@ -57,6 +57,12 @@
 #endif /* CONFIG_SYS_INIT_RAM_LOCK */
 #endif /* __ASSEMBLY__ */
 
+#if defined(__KERNEL__) && !defined(__ASSEMBLY__)
+int l2cache_init(void);
+void enable_cpc(void);
+void disable_cpc_sram(void);
+#endif
+
 /* prep registers for L2 */
 #define CACHECRBA       0x80000823      /* Cache configuration register address */
 #define L2CACHE_MASK	0x03	/* Mask for 2 L2 Cache bits */
--- u-boot-2014.07/arch/powerpc/include/asm/fsl_secure_boot.h.orig	2022-05-09 14:06:21.365224921 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/fsl_secure_boot.h	2022-05-09 14:06:23.013158267 -0700
@@ -6,27 +6,81 @@
 
 #ifndef __FSL_SECURE_BOOT_H
 #define __FSL_SECURE_BOOT_H
+#include <asm/config_mpc85xx.h>
 
 #ifdef CONFIG_SECURE_BOOT
+
 #if defined(CONFIG_FSL_CORENET)
 #define CONFIG_SYS_PBI_FLASH_BASE		0xc0000000
 #elif defined(CONFIG_BSC9132QDS)
 #define CONFIG_SYS_PBI_FLASH_BASE		0xc8000000
+#elif defined(CONFIG_C29XPCIE)
+#define CONFIG_SYS_PBI_FLASH_BASE		0xcc000000
 #else
 #define CONFIG_SYS_PBI_FLASH_BASE		0xce000000
 #endif
+
 #define CONFIG_SYS_PBI_FLASH_WINDOW		0xcff80000
 
+/*
+ * Define the key hash for boot script here if public/private key pair used to
+ * sign bootscript are different from the SRK hash put in the fuse
+ * Example of defining KEY_HASH is
+ * #define CONFIG_BOOTSCRIPT_KEY_HASH \
+ *	 "41066b564c6ffcef40ccbc1e0a5d0d519604000c785d97bbefd25e4d288d1c8b"
+ */
+
 #if defined(CONFIG_B4860QDS) || \
 	defined(CONFIG_T4240QDS) || \
 	defined(CONFIG_T2080QDS) || \
 	defined(CONFIG_T2080RDB) || \
 	defined(CONFIG_T1040QDS) || \
-	defined(CONFIG_T104xRDB)
+	defined(CONFIG_T104xRDB) || \
+	defined(CONFIG_PPC_T1024) || \
+	defined(CONFIG_PPC_T1023)
 #define CONFIG_SYS_CPC_REINIT_F
+#define CONFIG_KEY_REVOCATION
 #undef CONFIG_SYS_INIT_L3_ADDR
 #define CONFIG_SYS_INIT_L3_ADDR			0xbff00000
 #endif
 
+#if defined(CONFIG_C29XPCIE)
+#define CONFIG_KEY_REVOCATION
+#endif
+
+#if defined(CONFIG_PPC_P3041)	||	\
+	defined(CONFIG_PPC_P4080) ||	\
+	defined(CONFIG_PPC_P5020) ||	\
+	defined(CONFIG_PPC_P5040) ||	\
+	defined(CONFIG_PPC_P2041)
+	#define	CONFIG_FSL_TRUST_ARCH_v1
+#endif
+
+#if defined(CONFIG_FSL_CORENET)
+/* The key used for verification of next level images
+ * is picked up from an Extension Table which has
+ * been verified by the ISBC (Internal Secure boot Code)
+ * in boot ROM of the SoC
+ */
+#define CONFIG_FSL_ISBC_KEY_EXT
+#endif
+
+/* The bootscript header address is different for B4860 because the NOR
+ * mapping is different on B4 due to reduced NOR size.
+ */
+#if defined(CONFIG_B4860QDS)
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0xecc00000
+#elif defined(CONFIG_FSL_CORENET)
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0xe8e00000
+#elif defined(CONFIG_BSC9132QDS)
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0x88020000
+#elif defined(CONFIG_C29XPCIE)
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0xec020000
+#else
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0xee020000
+#endif
+
+#include <config_fsl_secboot.h>
+
 #endif
 #endif
--- u-boot-2014.07/arch/powerpc/include/asm/immap_85xx.h.orig	2022-05-09 14:06:21.369224759 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/immap_85xx.h	2022-05-09 14:06:23.017158105 -0700
@@ -16,6 +16,8 @@
 #include <asm/fsl_dma.h>
 #include <asm/fsl_i2c.h>
 #include <fsl_ifc.h>
+#include <fsl_sec.h>
+#include <fsl_sfp.h>
 #include <asm/fsl_lbc.h>
 #include <asm/fsl_fman.h>
 #include <fsl_immap.h>
@@ -1625,10 +1627,15 @@
 #define FSL_CORENET_DEVDISR2_DTSEC1_6	0x04000000
 #define FSL_CORENET_DEVDISR2_DTSEC1_9	0x00800000
 #define FSL_CORENET_DEVDISR2_DTSEC1_10	0x00400000
+#ifdef CONFIG_FSL_FM_10GEC_REGULAR_NOTATION
+#define FSL_CORENET_DEVDISR2_10GEC1_1   0x80000000
+#define FSL_CORENET_DEVDISR2_10GEC1_2   0x40000000
+#else
 #define FSL_CORENET_DEVDISR2_10GEC1_1	0x00800000
 #define FSL_CORENET_DEVDISR2_10GEC1_2	0x00400000
 #define FSL_CORENET_DEVDISR2_10GEC1_3	0x80000000
 #define FSL_CORENET_DEVDISR2_10GEC1_4	0x40000000
+#endif
 #define FSL_CORENET_DEVDISR2_DTSEC2_1	0x00080000
 #define FSL_CORENET_DEVDISR2_DTSEC2_2	0x00040000
 #define FSL_CORENET_DEVDISR2_DTSEC2_3	0x00020000
@@ -1766,7 +1773,7 @@
 #define FSL_CORENET2_RCWSR4_SRDS2_PRTCL_SHIFT	16
 #define FSL_CORENET_RCWSR6_BOOT_LOC	0x0f800000
 #elif defined(CONFIG_PPC_T1040) || defined(CONFIG_PPC_T1042) ||\
-defined(CONFIG_PPC_T1020) || defined(CONFIG_PPC_T1022)
+defined(CONFIG_PPC_T1020) || defined(CONFIG_PPC_T1022) || defined(CONFIG_PPC_M200)
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL	0xff000000
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT	24
 #define FSL_CORENET2_RCWSR4_SRDS2_PRTCL	0x00fe0000
@@ -1786,7 +1793,23 @@
 #define PXCKEN_MASK	0x80000000
 #define PXCK_MASK	0x00FF0000
 #define PXCK_BITS_START	16
-#elif defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081)
+#elif defined(CONFIG_PPC_T1024) || defined(CONFIG_PPC_T1023) || \
+	defined(CONFIG_PPC_T1014) || defined(CONFIG_PPC_T1013)
+#define FSL_CORENET2_RCWSR4_SRDS1_PRTCL		0xff800000
+#define FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT	23
+#define FSL_CORENET_RCWSR6_BOOT_LOC		0x0f800000
+#define FSL_CORENET_RCWSR13_EC1			0x30000000 /* bits 418..419 */
+#define FSL_CORENET_RCWSR13_EC1_RGMII		0x00000000
+#define FSL_CORENET_RCWSR13_EC1_GPIO		0x10000000
+#define FSL_CORENET_RCWSR13_EC2			0x0c000000
+#define FSL_CORENET_RCWSR13_EC2_RGMII		0x08000000
+#define CONFIG_SYS_FSL_SCFG_PIXCLKCR_OFFSET	0x28
+#define CONFIG_SYS_FSL_SCFG_IODSECR1_OFFSET	0xd00
+#define PXCKEN_MASK				0x80000000
+#define PXCK_MASK				0x00FF0000
+#define PXCK_BITS_START				16
+#elif defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081) ||\
+defined(CONFIG_PPC_M300)
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL		0xff000000
 #define FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT	24
 #define FSL_CORENET2_RCWSR4_SRDS2_PRTCL		0x00ff0000
@@ -1859,7 +1882,7 @@
 #define FSL_CORENET_RCWSR13_EC2_FM1_DTSEC6_RGMII	0x08000000
 #define FSL_CORENET_RCWSR13_EC2_FM1_GPIO		0x10000000
 #endif
-#if defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081)
+#if defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081)  || defined(CONFIG_PPC_M300)
 #define FSL_CORENET_RCWSR13_EC1			0x60000000 /* bits 417..418 */
 #define FSL_CORENET_RCWSR13_EC1_DTSEC3_RGMII	0x00000000
 #define FSL_CORENET_RCWSR13_EC1_GPIO		0x40000000
@@ -2675,72 +2698,6 @@
 	FSL_SRDS_B3_LANE_D = 23,
 };
 
-/* Security Engine Block (MS = Most Sig., LS = Least Sig.) */
-#if CONFIG_SYS_FSL_SEC_COMPAT >= 4
-typedef struct ccsr_sec {
-	u32	res0;
-	u32	mcfgr;		/* Master CFG Register */
-	u8	res1[0x8];
-	struct {
-		u32	ms;	/* Job Ring LIODN Register, MS */
-		u32	ls;	/* Job Ring LIODN Register, LS */
-	} jrliodnr[4];
-	u8	res2[0x30];
-	struct {
-		u32	ms;	/* RTIC LIODN Register, MS */
-		u32	ls;	/* RTIC LIODN Register, LS */
-	} rticliodnr[4];
-	u8	res3[0x1c];
-	u32	decorr;		/* DECO Request Register */
-	struct {
-		u32	ms;	/* DECO LIODN Register, MS */
-		u32	ls;	/* DECO LIODN Register, LS */
-	} decoliodnr[8];
-	u8	res4[0x40];
-	u32	dar;		/* DECO Avail Register */
-	u32	drr;		/* DECO Reset Register */
-	u8	res5[0xe78];
-	u32	crnr_ms;	/* CHA Revision Number Register, MS */
-	u32	crnr_ls;	/* CHA Revision Number Register, LS */
-	u32	ctpr_ms;	/* Compile Time Parameters Register, MS */
-	u32	ctpr_ls;	/* Compile Time Parameters Register, LS */
-	u8	res6[0x10];
-	u32	far_ms;		/* Fault Address Register, MS */
-	u32	far_ls;		/* Fault Address Register, LS */
-	u32	falr;		/* Fault Address LIODN Register */
-	u32	fadr;		/* Fault Address Detail Register */
-	u8	res7[0x4];
-	u32	csta;		/* CAAM Status Register */
-	u8	res8[0x8];
-	u32	rvid;		/* Run Time Integrity Checking Version ID Reg.*/
-	u32	ccbvid;		/* CHA Cluster Block Version ID Register */
-	u32	chavid_ms;	/* CHA Version ID Register, MS */
-	u32	chavid_ls;	/* CHA Version ID Register, LS */
-	u32	chanum_ms;	/* CHA Number Register, MS */
-	u32	chanum_ls;	/* CHA Number Register, LS */
-	u32	secvid_ms;	/* SEC Version ID Register, MS */
-	u32	secvid_ls;	/* SEC Version ID Register, LS */
-	u8	res9[0x6020];
-	u32	qilcr_ms;	/* Queue Interface LIODN CFG Register, MS */
-	u32	qilcr_ls;	/* Queue Interface LIODN CFG Register, LS */
-	u8	res10[0x8fd8];
-} ccsr_sec_t;
-
-#define SEC_CTPR_MS_AXI_LIODN		0x08000000
-#define SEC_CTPR_MS_QI			0x02000000
-#define SEC_RVID_MA			0x0f000000
-#define SEC_CHANUM_MS_JRNUM_MASK	0xf0000000
-#define SEC_CHANUM_MS_JRNUM_SHIFT	28
-#define SEC_CHANUM_MS_DECONUM_MASK	0x0f000000
-#define SEC_CHANUM_MS_DECONUM_SHIFT	24
-#define SEC_SECVID_MS_IPID_MASK	0xffff0000
-#define SEC_SECVID_MS_IPID_SHIFT	16
-#define SEC_SECVID_MS_MAJ_REV_MASK	0x0000ff00
-#define SEC_SECVID_MS_MAJ_REV_SHIFT	8
-#define SEC_CCBVID_ERA_MASK		0xff000000
-#define SEC_CCBVID_ERA_SHIFT		24
-#endif
-
 typedef struct ccsr_qman {
 #ifdef CONFIG_SYS_FSL_QMAN_V3
 	u8	res0[0x200];
@@ -2814,6 +2771,21 @@
 	u8	res4[0x400];
 } ccsr_pme_t;
 
+struct ccsr_pamu {
+	u32 ppbah;
+	u32 ppbal;
+	u32 pplah;
+	u32 pplal;
+	u32 spbah;
+	u32 spbal;
+	u32 splah;
+	u32 splal;
+	u32 obah;
+	u32 obal;
+	u32 olah;
+	u32 olal;
+};
+
 #ifdef CONFIG_SYS_FSL_RAID_ENGINE
 struct ccsr_raide {
 	u8	res0[0x543];
@@ -2867,21 +2839,6 @@
 	u8	res_f4[0xf0c];
 };
 #endif
-#ifdef CONFIG_SYS_FSL_SFP_VER_3_0
-struct ccsr_sfp_regs {
-	u32 ospr;		/* 0x200 */
-	u32 reserved0[14];
-	u32 srk_hash[8];	/* 0x23c Super Root Key Hash */
-	u32 oem_uid;		/* 0x9c OEM Unique ID */
-	u8 reserved2[0x04];
-	u32 ovpr;			/* 0xA4  Intent To Secure */
-	u8 reserved4[0x08];
-	u32 fsl_uid;		/* 0xB0  FSL Unique ID */
-	u8 reserved5[0x04];
-	u32 fsl_spfr0;		/* Scratch Pad Fuse Register 0 */
-	u32 fsl_spfr1;		/* Scratch Pad Fuse Register 1 */
-};
-#endif
 
 #ifdef CONFIG_FSL_CORENET
 #define CONFIG_SYS_FSL_CORENET_CCM_OFFSET	0x0000
@@ -2907,6 +2864,7 @@
 #define CONFIG_SYS_FSL_CORENET_SERDES2_OFFSET	0xEB000
 #define CONFIG_SYS_FSL_CPC_OFFSET		0x10000
 #define CONFIG_SYS_FSL_SCFG_OFFSET		0xFC000
+#define CONFIG_SYS_FSL_PAMU_OFFSET		0x20000
 #define CONFIG_SYS_MPC85xx_DMA1_OFFSET		0x100000
 #define CONFIG_SYS_MPC85xx_DMA2_OFFSET		0x101000
 #define CONFIG_SYS_MPC85xx_DMA3_OFFSET		0x102000
@@ -2938,6 +2896,8 @@
 #define CONFIG_SYS_MPC85xx_SATA1_OFFSET		0x220000
 #define CONFIG_SYS_MPC85xx_SATA2_OFFSET		0x221000
 #define CONFIG_SYS_FSL_SEC_OFFSET		0x300000
+#define CONFIG_SYS_FSL_JR0_OFFSET		0x301000
+#define CONFIG_SYS_SNVS_OFFSET			0x314000
 #define CONFIG_SYS_FSL_CORENET_PME_OFFSET	0x316000
 #define CONFIG_SYS_FSL_QMAN_OFFSET		0x318000
 #define CONFIG_SYS_FSL_BMAN_OFFSET		0x31a000
@@ -2998,8 +2958,10 @@
 #define CONFIG_SYS_MPC85xx_ESDHC_OFFSET		0x2e000
 #if defined(CONFIG_PPC_C29X)
 #define CONFIG_SYS_FSL_SEC_OFFSET		0x80000
+#define CONFIG_SYS_FSL_JR0_OFFSET		0x81000
 #else
 #define CONFIG_SYS_FSL_SEC_OFFSET		0x30000
+#define CONFIG_SYS_FSL_JR0_OFFSET		0x31000
 #endif
 #define CONFIG_SYS_MPC85xx_SERDES2_OFFSET	0xE3100
 #define CONFIG_SYS_MPC85xx_SERDES1_OFFSET	0xE3000
@@ -3030,6 +2992,8 @@
 	(CONFIG_SYS_CCSRBAR + CONFIG_SYS_FSL_SCFG_OFFSET)
 #define CONFIG_SYS_FSL_SCFG_PIXCLK_ADDR	\
 	(CONFIG_SYS_FSL_SCFG_ADDR + CONFIG_SYS_FSL_SCFG_PIXCLKCR_OFFSET)
+#define CONFIG_SYS_FSL_SCFG_IODSECR1_ADDR \
+	(CONFIG_SYS_FSL_SCFG_ADDR + CONFIG_SYS_FSL_SCFG_IODSECR1_OFFSET)
 #define CONFIG_SYS_FSL_QMAN_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_QMAN_OFFSET)
 #define CONFIG_SYS_FSL_BMAN_ADDR \
@@ -3100,6 +3064,8 @@
 	(CONFIG_SYS_IMMR + CONFIG_SYS_MPC85xx_USB2_PHY_OFFSET)
 #define CONFIG_SYS_FSL_SEC_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_SEC_OFFSET)
+#define CONFIG_SYS_FSL_JR0_ADDR \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_JR0_OFFSET)
 #define CONFIG_SYS_FSL_FM1_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_FM1_OFFSET)
 #define CONFIG_SYS_FSL_FM1_DTSEC1_ADDR \
@@ -3108,6 +3074,8 @@
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_FM2_OFFSET)
 #define CONFIG_SYS_FSL_SRIO_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_SRIO_OFFSET)
+#define CONFIG_SYS_PAMU_ADDR \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_PAMU_OFFSET)
 
 #define CONFIG_SYS_PCI1_ADDR \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_MPC85xx_PCI1_OFFSET)
@@ -3124,6 +3092,8 @@
 
 #define CONFIG_SYS_SFP_ADDR  \
 	(CONFIG_SYS_IMMR + CONFIG_SYS_SFP_OFFSET)
+#define CONFIG_SYS_SNVS_ADDR  \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_SNVS_OFFSET)
 
 #define TSEC_BASE_ADDR		(CONFIG_SYS_IMMR + CONFIG_SYS_TSEC1_OFFSET)
 #define MDIO_BASE_ADDR		(CONFIG_SYS_IMMR + CONFIG_SYS_MDIO1_OFFSET)
--- u-boot-2014.07/arch/powerpc/include/asm/processor.h.orig	2022-05-09 14:06:21.373224598 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/processor.h	2022-05-09 14:06:23.025157781 -0700
@@ -1118,7 +1118,6 @@
 #define SVR_B4860	0X868000
 #define SVR_G4860	0x868001
 #define SVR_B4460	0x868003
-#define SVR_G4060	0x868003
 #define SVR_B4440	0x868100
 #define SVR_G4440	0x868101
 #define SVR_B4420	0x868102
@@ -1129,6 +1128,10 @@
 #define SVR_T1020	0x852100
 #define SVR_T1021	0x852101
 #define SVR_T1022	0x852102
+#define SVR_T1024	0x854000
+#define SVR_T1023	0x854100
+#define SVR_T1014	0x854400
+#define SVR_T1013	0x854500
 #define SVR_T2080	0x853000
 #define SVR_T2081	0x853100
 
--- u-boot-2014.07/arch/powerpc/include/asm/fsl_liodn.h.orig	2022-05-09 14:06:21.365224921 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/fsl_liodn.h	2022-05-09 14:06:23.013158267 -0700
@@ -91,8 +91,8 @@
 		CONFIG_SYS_MPC85xx_PCIE##pciNum##_OFFSET)
 
 /* reg nodes for DMA start @ 0x300 */
-#define SET_DMA_LIODN(dmaNum, liodn) \
-	SET_GUTS_LIODN("fsl,eloplus-dma", liodn, dma##dmaNum##liodnr,\
+#define SET_DMA_LIODN(dmaNum, compat, liodn) \
+	SET_GUTS_LIODN(compat, liodn, dma##dmaNum##liodnr,\
 		CONFIG_SYS_MPC85xx_DMA##dmaNum##_OFFSET + 0x300)
 
 #define SET_SDHC_LIODN(sdhcNum, liodn) \
--- u-boot-2014.07/arch/powerpc/include/asm/config_mpc85xx.h.orig	2022-05-09 14:06:21.361225083 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/config_mpc85xx.h	2022-05-09 14:06:23.009158429 -0700
@@ -24,6 +24,9 @@
 
 /* IP endianness */
 #define CONFIG_SYS_FSL_IFC_BE
+#define CONFIG_SYS_FSL_SEC_BE
+#define CONFIG_SYS_FSL_SFP_BE
+#define CONFIG_SYS_FSL_SNVS_BE
 
 /* Number of TLB CAM entries we have on FSL Book-E chips */
 #if defined(CONFIG_E500MC)
@@ -160,6 +163,7 @@
 #define CONFIG_SYS_FSL_ERRATUM_A004508
 #define CONFIG_SYS_FSL_ERRATUM_A007075
 #define CONFIG_SYS_FSL_ERRATUM_A006261
+#define CONFIG_SYS_FSL_ERRATUM_A004477
 #define CONFIG_SYS_FSL_A004447_SVR_REV	0x10
 #define CONFIG_ESDHC_HC_BLK_ADDR
 
@@ -200,7 +204,7 @@
 #elif defined(CONFIG_P1013)
 #define CONFIG_MAX_CPUS			1
 #define CONFIG_SYS_FSL_NUM_LAWS		12
-#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	1
 #define CONFIG_SYS_PPC_E500_DEBUG_TLB	2
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
@@ -284,13 +288,14 @@
 #define CONFIG_SYS_PPC_E500_DEBUG_TLB	2
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
-#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	1
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000
 #define CONFIG_SYS_FSL_ERRATUM_ELBC_A001
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
 #define CONFIG_FSL_SATA_ERRATUM_A001
 #define CONFIG_SYS_FSL_ERRATUM_A004508
 #define CONFIG_SYS_FSL_ERRATUM_A005125
+#define CONFIG_SYS_FSL_ERRATUM_A004477
 
 #elif defined(CONFIG_P1023)
 #define CONFIG_MAX_CPUS			2
@@ -371,6 +376,7 @@
 #define CONFIG_SYS_FSL_SRIO_MSG_UNIT_NUM	2
 #define CONFIG_SYS_FSL_ERRATUM_A004508
 #define CONFIG_SYS_FSL_ERRATUM_A005125
+#define CONFIG_SYS_FSL_ERRATUM_A004477
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	1
 
 #elif defined(CONFIG_PPC_P2041) /* also supports P2040 */
@@ -588,6 +594,7 @@
 #define CONFIG_NAND_FSL_IFC
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
 #define CONFIG_SYS_FSL_ERRATUM_A005125
+#define CONFIG_SYS_FSL_ERRATUM_A004477
 #define CONFIG_ESDHC_HC_BLK_ADDR
 
 #elif defined(CONFIG_BSC9132)
@@ -612,6 +619,7 @@
 #define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.2"
 #define CONFIG_SYS_FSL_ERRATUM_A005125
 #define CONFIG_SYS_FSL_ERRATUM_A005434
+#define CONFIG_SYS_FSL_ERRATUM_A004477
 #define CONFIG_SYS_FSL_ERRATUM_I2C_A004447
 #define CONFIG_SYS_FSL_A004447_SVR_REV	0x11
 #define CONFIG_ESDHC_HC_BLK_ADDR
@@ -677,6 +685,7 @@
 #define CONFIG_SYS_FSL_ERRATUM_A006379
 #define CONFIG_SYS_FSL_ERRATUM_A007186
 #define CONFIG_SYS_FSL_ERRATUM_A006593
+#define CONFIG_SYS_FSL_ERRATUM_A007798
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xfe000000
 #define CONFIG_SYS_FSL_SFP_VER_3_0
 #define CONFIG_SYS_FSL_PCI_VER_3_X
@@ -710,6 +719,7 @@
 #define CONFIG_SYS_FSL_ERRATUM_A006475
 #define CONFIG_SYS_FSL_ERRATUM_A006384
 #define CONFIG_SYS_FSL_ERRATUM_A007212
+#define CONFIG_SYS_FSL_ERRATUM_A004477
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xfe000000
 #define CONFIG_SYS_FSL_SFP_VER_3_0
 
@@ -739,7 +749,8 @@
 #endif
 
 #elif defined(CONFIG_PPC_T1040) || defined(CONFIG_PPC_T1042) ||\
-defined(CONFIG_PPC_T1020) || defined(CONFIG_PPC_T1022)
+defined(CONFIG_PPC_T1020) || defined(CONFIG_PPC_T1022) ||\
+defined(CONFIG_PPC_M200)
 #define CONFIG_E5500
 #define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
 #define CONFIG_SYS_FSL_QORIQ_CHASSIS2	/* Freescale Chassis generation 2 */
@@ -748,7 +759,8 @@
 #ifdef CONFIG_SYS_FSL_DDR4
 #define CONFIG_SYS_FSL_DDRC_GEN4
 #endif
-#if defined(CONFIG_PPC_T1040) || defined(CONFIG_PPC_T1042)
+#if defined(CONFIG_PPC_T1040) || defined(CONFIG_PPC_T1042) ||\
+ defined(CONFIG_PPC_M200)
 #define CONFIG_MAX_CPUS			4
 #elif defined(CONFIG_PPC_T1020) || defined(CONFIG_PPC_T1022)
 #define CONFIG_MAX_CPUS			2
@@ -767,6 +779,7 @@
 #define CONFIG_SYS_PME_CLK		CONFIG_PME_PLAT_CLK_DIV
 #define CONFIG_SYS_FSL_DDR_VER		FSL_DDR_VER_5_0
 #define CONFIG_SYS_FSL_IFC_BANK_COUNT	8
+#define CONFIG_SYS_FSL_ERRATUM_A008044
 #define CONFIG_SYS_FMAN_V3
 #define CONFIG_FM_PLAT_CLK_DIV	1
 #define CONFIG_SYS_FM1_CLK		CONFIG_FM_PLAT_CLK_DIV
@@ -783,8 +796,55 @@
 #define QE_MURAM_SIZE			0x6000UL
 #define MAX_QE_RISC			1
 #define QE_NUM_OF_SNUM			28
+#define CONFIG_SYS_FSL_SFP_VER_3_0
 
-#elif defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081)
+#elif defined(CONFIG_PPC_T1024) || defined(CONFIG_PPC_T1023) ||\
+defined(CONFIG_PPC_T1014) || defined(CONFIG_PPC_T1013)
+#define CONFIG_E5500
+#define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
+#define CONFIG_SYS_FSL_QORIQ_CHASSIS2	/* Freescale Chassis generation 2 */
+#define CONFIG_SYS_FSL_CORES_PER_CLUSTER 1
+#define CONFIG_SYS_FSL_QMAN_V3		/* QMAN version 3 */
+#define CONFIG_SYS_FMAN_V3
+#ifdef CONFIG_SYS_FSL_DDR4
+#define CONFIG_SYS_FSL_DDRC_GEN4
+#endif
+#if defined(CONFIG_PPC_T1024) || defined(CONFIG_PPC_T1023)
+#define CONFIG_MAX_CPUS			2
+#elif defined(CONFIG_PPC_T1014) || defined(CONFIG_PPC_T1013)
+#define CONFIG_MAX_CPUS			1
+#endif
+#define CONFIG_SYS_FSL_NUM_CC_PLL	2
+#define CONFIG_SYS_FSL_CLUSTER_CLOCKS	{ 1, 1, 1, 1 }
+#define CONFIG_SYS_SDHC_CLOCK		0
+#define CONFIG_SYS_FSL_NUM_LAWS		16
+#define CONFIG_SYS_FSL_SRDS_1
+#define CONFIG_SYS_FSL_SEC_COMPAT	5
+#define CONFIG_SYS_NUM_FMAN		1
+#define CONFIG_SYS_NUM_FM1_DTSEC	4
+#define CONFIG_SYS_NUM_FM1_10GEC	1
+#define CONFIG_FSL_FM_10GEC_REGULAR_NOTATION
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#define CONFIG_SYS_FSL_DDR_VER		FSL_DDR_VER_5_0
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT	8
+#define CONFIG_SYS_FM1_CLK		0
+#define CONFIG_QBMAN_CLK_DIV		1
+#define CONFIG_SYS_FM_MURAM_SIZE	0x30000
+#define CONFIG_SYS_FSL_SINGLE_SOURCE_CLK
+#define CONFIG_SYS_FSL_TBCLK_DIV	16
+#define CONFIG_SYS_FSL_PCIE_COMPAT	"fsl,qoriq-pcie-v2.4"
+#define CONFIG_SYS_FSL_USB_DUAL_PHY_ENABLE
+#define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xfe000000
+#define CONFIG_SYS_FSL_ERRATUM_ESDHC111
+#define ESDHCI_QUIRK_BROKEN_TIMEOUT_VALUE
+#define QE_MURAM_SIZE			0x6000UL
+#define MAX_QE_RISC			1
+#define QE_NUM_OF_SNUM			28
+#define CONFIG_SYS_FSL_SFP_VER_3_0
+
+#elif defined(CONFIG_PPC_T2080) || defined(CONFIG_PPC_T2081) || defined(CONFIG_PPC_M300)
 #define CONFIG_E6500
 #define CONFIG_SYS_PPC64		/* 64-bit core */
 #define CONFIG_FSL_CORENET		/* Freescale CoreNet platform */
@@ -810,6 +870,8 @@
 #elif defined(CONFIG_PPC_T2081)
 #define CONFIG_SYS_NUM_FM1_DTSEC	6
 #define CONFIG_SYS_NUM_FM1_10GEC	2
+#elif defined(CONFIG_PPC_M300)
+#define CONFIG_SYS_NUM_FM1_DTSEC	8
 #endif
 #define CONFIG_USB_MAX_CONTROLLER_COUNT 2
 #define CONFIG_NUM_DDR_CONTROLLERS	1
@@ -826,8 +888,6 @@
 #define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
 #define CONFIG_SYS_FSL_ERRATUM_A007212
 #define CONFIG_SYS_CCSRBAR_DEFAULT	0xfe000000
-#define CONFIG_SYS_FSL_SFP_VER_3_0
-#define CONFIG_SYS_FSL_ISBC_VER		2
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
 #define CONFIG_SYS_FSL_ERRATUM_A006261
 #define CONFIG_SYS_FSL_ERRATUM_A006593
--- u-boot-2014.07/arch/powerpc/include/asm/io.h.orig	2022-05-09 14:06:21.369224759 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/io.h	2022-05-09 14:06:23.017158105 -0700
@@ -123,6 +123,9 @@
 #define iobarrier_r()  eieio()
 #define iobarrier_w()  eieio()
 
+#define mb()	sync()
+#define isb()	isync()
+
 /*
  * Non ordered and non-swapping "raw" accessors
  */
--- u-boot-2014.07/arch/powerpc/include/asm/config.h.orig	2022-05-09 14:06:21.361225083 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/config.h	2022-05-09 14:06:23.009158429 -0700
@@ -75,6 +75,7 @@
  * SEC (crypto unit) major compatible version determination
  */
 #if defined(CONFIG_MPC83xx)
+#define CONFIG_SYS_FSL_SEC_BE
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
 #endif
 
--- u-boot-2014.07/arch/powerpc/include/asm/fsl_errata.h.orig	2022-05-09 14:06:21.361225083 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/fsl_errata.h	2022-05-09 14:06:23.013158267 -0700
@@ -26,59 +26,28 @@
 	return false;
 }
 #endif
+#endif
 
-#ifdef CONFIG_SYS_FSL_ERRATUM_A006261
-static inline bool has_erratum_a006261(void)
+#ifdef CONFIG_SYS_FSL_ERRATUM_A007186
+static inline bool has_erratum_a007186(void)
 {
 	u32 svr = get_svr();
 	u32 soc = SVR_SOC_VER(svr);
 
 	switch (soc) {
-	case SVR_P1010:
-		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
-	case SVR_P2041:
-	case SVR_P2040:
-		return IS_SVR_REV(svr, 1, 0) ||
-			IS_SVR_REV(svr, 1, 1) || IS_SVR_REV(svr, 2, 1);
-	case SVR_P3041:
-		return IS_SVR_REV(svr, 1, 0) ||
-			IS_SVR_REV(svr, 1, 1) ||
-			IS_SVR_REV(svr, 2, 0) || IS_SVR_REV(svr, 2, 1);
-	case SVR_P5010:
-	case SVR_P5020:
-	case SVR_P5021:
-		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
 	case SVR_T4240:
+		return IS_SVR_REV(svr, 2, 0);
 	case SVR_T4160:
-	case SVR_T4080:
-		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
-	case SVR_T1040:
-		return IS_SVR_REV(svr, 1, 0);
-	case SVR_T2080:
-	case SVR_T2081:
-		return IS_SVR_REV(svr, 1, 0);
-	case SVR_P5040:
-		return IS_SVR_REV(svr, 1, 0);
-	}
-
-	return false;
-}
-#endif
-
-static inline bool has_erratum_a007075(void)
-{
-	u32 svr = get_svr();
-	u32 soc = SVR_SOC_VER(svr);
-
-	switch (soc) {
+		return IS_SVR_REV(svr, 2, 0);
 	case SVR_B4860:
+		return IS_SVR_REV(svr, 2, 0);
 	case SVR_B4420:
-		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
-	case SVR_P1010:
+		return IS_SVR_REV(svr, 2, 0);
+	case SVR_T2081:
+	case SVR_T2080:
 		return IS_SVR_REV(svr, 1, 0);
-	case SVR_P4080:
-		return IS_SVR_REV(svr, 2, 0) || IS_SVR_REV(svr, 3, 0);
 	}
+
 	return false;
 }
 #endif
--- u-boot-2014.07/arch/powerpc/include/asm/fsl_memac.h.orig	2022-05-09 14:06:21.365224921 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/fsl_memac.h	2022-05-09 14:06:23.013158267 -0700
@@ -159,6 +159,7 @@
 #define MEMAC_CMD_CFG_RX_EN		0x00000002 /* MAC Rx path enable */
 #define MEMAC_CMD_CFG_TX_EN		0x00000001 /* MAC Tx path enable */
 #define MEMAC_CMD_CFG_RXTX_EN	(MEMAC_CMD_CFG_RX_EN | MEMAC_CMD_CFG_TX_EN)
+#define MEMAC_CMD_CFG_NO_LEN_CHK 0x20000 /* Payload length check disable */
 
 /* HASHTABLE_CTRL - Hashtable control register */
 #define HASHTABLE_CTRL_MCAST_EN	0x00000200 /* enable mulitcast Rx hash */
--- u-boot-2014.07/arch/powerpc/include/asm/fsl_serdes.h.orig	2022-05-09 14:06:21.365224921 -0700
+++ u-boot-2014.07/arch/powerpc/include/asm/fsl_serdes.h	2022-05-09 14:06:23.013158267 -0700
@@ -71,6 +71,22 @@
 	INTERLAKEN,
 	QSGMII_SW1_A,		/* Indicates ports on L2 Switch */
 	QSGMII_SW1_B,
+	SGMII_2500_FM1_DTSEC1,
+	SGMII_2500_FM1_DTSEC2,
+	SGMII_2500_FM1_DTSEC3,
+	SGMII_2500_FM1_DTSEC4,
+	SGMII_2500_FM1_DTSEC5,
+	SGMII_2500_FM1_DTSEC6,
+	SGMII_2500_FM1_DTSEC9,
+	SGMII_2500_FM1_DTSEC10,
+	SGMII_2500_FM2_DTSEC1,
+	SGMII_2500_FM2_DTSEC2,
+	SGMII_2500_FM2_DTSEC3,
+	SGMII_2500_FM2_DTSEC4,
+	SGMII_2500_FM2_DTSEC5,
+	SGMII_2500_FM2_DTSEC6,
+	SGMII_2500_FM2_DTSEC9,
+	SGMII_2500_FM2_DTSEC10,
 };
 
 enum srds {
--- u-boot-2014.07/arch/powerpc/lib/board.c.orig	2022-05-09 14:06:21.377224436 -0700
+++ u-boot-2014.07/arch/powerpc/lib/board.c	2022-05-09 14:06:23.029157620 -0700
@@ -113,6 +113,9 @@
 #include <bedbug/type.h>
 #endif
 
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
 /*
  * Utilities
  */
@@ -343,13 +346,6 @@
 #ifdef CONFIG_PRAM
 	ulong reg;
 #endif
-#ifdef CONFIG_DEEP_SLEEP
-	const ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
-	struct ccsr_scfg *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
-	u32 start_addr;
-	typedef void (*func_t)(void);
-	func_t kernel_resume;
-#endif
 
 	/* Pointer is writable since we allocated a register for it */
 	gd = (gd_t *) (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_GBL_DATA_OFFSET);
@@ -367,13 +363,10 @@
 		if ((*init_fnc_ptr) () != 0)
 			hang();
 
-#ifdef CONFIG_DEEP_SLEEP
+#ifdef CONFIG_FSL_DEEP_SLEEP
 	/* Jump to kernel in deep sleep case */
-	if (in_be32(&gur->scrtsr[0]) & (1 << 3)) {
-		start_addr = in_be32(&scfg->sparecr[1]);
-		kernel_resume = (func_t)start_addr;
-		kernel_resume();
-	}
+	if (is_warm_boot())
+		fsl_dp_resume();
 #endif
 
 #ifdef CONFIG_POST
--- u-boot-2014.07/arch/m68k/cpu/mcf52x2/speed.c.orig	2022-05-09 14:06:21.257229289 -0700
+++ u-boot-2014.07/arch/m68k/cpu/mcf52x2/speed.c	2022-05-09 14:06:22.853164738 -0700
@@ -83,3 +83,10 @@
 
 	return (0);
 }
+
+#ifdef CONFIG_FSL_DSPI
+int get_dspi_clk(void)
+{
+	return gd->bus_clk;
+}
+#endif
--- u-boot-2014.07/arch/m68k/cpu/mcf5227x/cpu_init.c.orig	2022-05-09 14:06:21.253229451 -0700
+++ u-boot-2014.07/arch/m68k/cpu/mcf5227x/cpu_init.c	2022-05-09 14:06:22.849164900 -0700
@@ -16,6 +16,7 @@
 #include <asm/io.h>
 #include <asm/rtc.h>
 #include <linux/compiler.h>
+#include <fsl_dspi.h>
 
 /*
  * Breath some life into the CPU...
@@ -139,7 +140,7 @@
 	}
 }
 
-#ifdef CONFIG_CF_DSPI
+#ifdef CONFIG_FSL_DSPI
 void cfspi_port_conf(void)
 {
 	gpio_t *gpio = (gpio_t *) MMAP_GPIO;
--- u-boot-2014.07/arch/m68k/cpu/mcf5227x/speed.c.orig	2022-05-09 14:06:21.253229451 -0700
+++ u-boot-2014.07/arch/m68k/cpu/mcf5227x/speed.c	2022-05-09 14:06:22.853164738 -0700
@@ -124,3 +124,10 @@
 
 	return (0);
 }
+
+#ifdef CONFIG_FSL_DSPI
+int get_dspi_clk(void)
+{
+	return gd->bus_clk;
+}
+#endif
--- u-boot-2014.07/arch/m68k/cpu/mcf5445x/cpu_init.c.orig	2022-05-09 14:06:21.257229289 -0700
+++ u-boot-2014.07/arch/m68k/cpu/mcf5445x/cpu_init.c	2022-05-09 14:06:22.853164738 -0700
@@ -16,6 +16,7 @@
 #include <asm/rtc.h>
 #include <asm/io.h>
 #include <linux/compiler.h>
+#include <fsl_dspi.h>
 
 #if defined(CONFIG_CMD_NET)
 #include <config.h>
@@ -423,7 +424,7 @@
 }
 #endif
 
-#ifdef CONFIG_CF_DSPI
+#ifdef CONFIG_FSL_DSPI
 void cfspi_port_conf(void)
 {
 	gpio_t *gpio = (gpio_t *) MMAP_GPIO;
--- u-boot-2014.07/arch/m68k/cpu/mcf5445x/speed.c.orig	2022-05-09 14:06:21.257229289 -0700
+++ u-boot-2014.07/arch/m68k/cpu/mcf5445x/speed.c	2022-05-09 14:06:22.857164576 -0700
@@ -279,3 +279,10 @@
 
 	return (0);
 }
+
+#ifdef CONFIG_FSL_DSPI
+int get_dspi_clk(void)
+{
+	return gd->bus_clk;
+}
+#endif
--- u-boot-2014.07/arch/m68k/include/asm/immap_5301x.h.orig	2022-05-09 14:06:21.265228966 -0700
+++ u-boot-2014.07/arch/m68k/include/asm/immap_5301x.h	2022-05-09 14:06:22.865164253 -0700
@@ -52,7 +52,6 @@
 #define MMAP_ESDHC	(CONFIG_SYS_MBAR + 0x000CC000)
 
 #include <asm/coldfire/crossbar.h>
-#include <asm/coldfire/dspi.h>
 #include <asm/coldfire/edma.h>
 #include <asm/coldfire/eport.h>
 #include <asm/coldfire/flexbus.h>
--- u-boot-2014.07/arch/m68k/include/asm/immap_5227x.h.orig	2022-05-09 14:06:21.261229128 -0700
+++ u-boot-2014.07/arch/m68k/include/asm/immap_5227x.h	2022-05-09 14:06:22.865164253 -0700
@@ -51,7 +51,6 @@
 #define MMAP_PLL	(CONFIG_SYS_MBAR + 0x000C0000)
 
 #include <asm/coldfire/crossbar.h>
-#include <asm/coldfire/dspi.h>
 #include <asm/coldfire/edma.h>
 #include <asm/coldfire/eport.h>
 #include <asm/coldfire/flexbus.h>
--- u-boot-2014.07/arch/m68k/include/asm/immap_547x_8x.h.orig	2022-05-09 14:06:21.265228966 -0700
+++ u-boot-2014.07/arch/m68k/include/asm/immap_547x_8x.h	2022-05-09 14:06:22.873163929 -0700
@@ -41,7 +41,6 @@
 #define MMAP_SRAMCFG	(CONFIG_SYS_MBAR + 0x0001FF00)
 #define MMAP_SEC	(CONFIG_SYS_MBAR + 0x00020000)
 
-#include <asm/coldfire/dspi.h>
 #include <asm/coldfire/eport.h>
 #include <asm/coldfire/flexbus.h>
 #include <asm/coldfire/flexcan.h>
--- u-boot-2014.07/arch/m68k/include/asm/immap_5441x.h.orig	2022-05-09 14:06:21.265228966 -0700
+++ u-boot-2014.07/arch/m68k/include/asm/immap_5441x.h	2022-05-09 14:06:22.873163929 -0700
@@ -78,7 +78,6 @@
 #define MMAP_GPIO	0xEC094000
 
 #include <asm/coldfire/crossbar.h>
-#include <asm/coldfire/dspi.h>
 #include <asm/coldfire/edma.h>
 #include <asm/coldfire/eport.h>
 #include <asm/coldfire/flexbus.h>
--- u-boot-2014.07/arch/m68k/include/asm/immap_5445x.h.orig	2022-05-09 14:06:21.265228966 -0700
+++ u-boot-2014.07/arch/m68k/include/asm/immap_5445x.h	2022-05-09 14:06:22.873163929 -0700
@@ -55,7 +55,6 @@
 
 #include <asm/coldfire/ata.h>
 #include <asm/coldfire/crossbar.h>
-#include <asm/coldfire/dspi.h>
 #include <asm/coldfire/edma.h>
 #include <asm/coldfire/eport.h>
 #include <asm/coldfire/flexbus.h>
--- u-boot-2014.07/include/usb/ehci-fsl.h.orig	2022-05-09 14:06:22.405182858 -0700
+++ u-boot-2014.07/include/usb/ehci-fsl.h	2022-05-09 14:06:24.089114747 -0700
@@ -163,6 +163,9 @@
 #elif defined(CONFIG_MPC512X)
 #define CONFIG_SYS_FSL_USB1_ADDR CONFIG_SYS_MPC512x_USB1_ADDR
 #define CONFIG_SYS_FSL_USB2_ADDR	0
+#elif defined(CONFIG_LS102XA)
+#define CONFIG_SYS_FSL_USB1_ADDR CONFIG_SYS_LS102XA_USB1_ADDR
+#define CONFIG_SYS_FSL_USB2_ADDR        0
 #endif
 
 /*
--- u-boot-2014.07/include/configs/P1023RDS.h.orig	2022-05-09 14:06:22.241189491 -0700
+++ u-boot-2014.07/include/configs/P1023RDS.h	2022-05-09 14:06:23.881123160 -0700
@@ -444,9 +444,25 @@
 #define CONFIG_SYS_QMAN_MEM_BASE	0xff000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_BMAN_MEM_BASE	0xff200000
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 
 /* For FM */
 #define CONFIG_SYS_DPAA_FMAN
--- u-boot-2014.07/include/configs/corenet_ds.h.orig	2022-05-09 14:06:22.273188197 -0700
+++ u-boot-2014.07/include/configs/corenet_ds.h	2022-05-09 14:06:23.913121866 -0700
@@ -494,6 +494,14 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
 #ifdef CONFIG_PHYS_64BIT
@@ -502,6 +510,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
--- u-boot-2014.07/include/configs/M54418TWR.h.orig	2022-05-09 14:06:22.229189976 -0700
+++ u-boot-2014.07/include/configs/M54418TWR.h	2022-05-09 14:06:23.869123645 -0700
@@ -206,8 +206,7 @@
 #define CONFIG_SYS_IMMR		CONFIG_SYS_MBAR
 
 /* DSPI and Serial Flash */
-#define CONFIG_CF_SPI
-#define CONFIG_CF_DSPI
+#define CONFIG_FSL_DSPI
 #define CONFIG_SERIAL_FLASH
 #define CONFIG_HARD_SPI
 #define CONFIG_SYS_SBFHDR_SIZE		0x7
--- u-boot-2014.07/include/configs/M54451EVB.h.orig	2022-05-09 14:06:22.229189976 -0700
+++ u-boot-2014.07/include/configs/M54451EVB.h	2022-05-09 14:06:23.869123645 -0700
@@ -148,8 +148,7 @@
 #define CONFIG_SYS_IMMR			CONFIG_SYS_MBAR
 
 /* DSPI and Serial Flash */
-#define CONFIG_CF_SPI
-#define CONFIG_CF_DSPI
+#define CONFIG_FSL_DSPI
 #define CONFIG_SERIAL_FLASH
 #define CONFIG_HARD_SPI
 #define CONFIG_SYS_SBFHDR_SIZE		0x7
--- u-boot-2014.07/include/configs/MPC837XERDB.h.orig	2022-05-09 14:06:22.233189815 -0700
+++ u-boot-2014.07/include/configs/MPC837XERDB.h	2022-05-09 14:06:23.873123484 -0700
@@ -685,6 +685,11 @@
 #define CONFIG_ENV_OVERWRITE
 
 #define CONFIG_HAS_FSL_DR_USB
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
 
 #define CONFIG_NETDEV		"eth1"
 
--- u-boot-2014.07/include/configs/P1022DS.h.orig	2022-05-09 14:06:22.241189491 -0700
+++ u-boot-2014.07/include/configs/P1022DS.h	2022-05-09 14:06:23.877123322 -0700
@@ -11,6 +11,9 @@
 
 #include "../board/freescale/common/ics307_clk.h"
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+
 #ifdef CONFIG_36BIT
 #define CONFIG_PHYS_64BIT
 #endif
--- u-boot-2014.07/include/configs/B4860QDS.h.orig	2022-05-09 14:06:22.213190623 -0700
+++ u-boot-2014.07/include/configs/B4860QDS.h	2022-05-09 14:06:23.857124131 -0700
@@ -228,6 +228,7 @@
 #endif
 
 /* EEPROM */
+#define CONFIG_ID_EEPROM
 #define CONFIG_SYS_I2C_EEPROM_NXID
 #define CONFIG_SYS_EEPROM_BUS_NUM	0
 #define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
@@ -640,6 +641,14 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE	0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE	0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE	CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE	(CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE	(CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE	(CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	25
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #ifdef CONFIG_PHYS_64BIT
@@ -648,6 +657,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 
@@ -712,8 +729,8 @@
 #endif	/* CONFIG_PCI */
 
 #ifdef CONFIG_FMAN_ENET
-#define CONFIG_SYS_FM1_DTSEC5_PHY_ADDR	0x10
-#define CONFIG_SYS_FM1_DTSEC6_PHY_ADDR	0x11
+#define CONFIG_SYS_FM1_ONBOARD_PHY1_ADDR 0x10
+#define CONFIG_SYS_FM1_ONBOARD_PHY2_ADDR 0x11
 
 /*B4860 QDS AMC2PEX-2S default PHY_ADDR */
 #define CONFIG_SYS_FM1_10GEC1_PHY_ADDR 0x7	 /*SLOT 1*/
@@ -730,6 +747,8 @@
 #define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
 #endif
 
+#define CONFIG_SYS_FSL_B4860QDS_XFI_ERR
+
 /*
  * Environment
  */
@@ -820,9 +839,16 @@
 
 #define __USB_PHY_TYPE	ulpi
 
+#ifdef CONFIG_PPC_B4860
+#define HWCONFIG	"hwconfig=fsl_ddr:ctlr_intlv=null,"	\
+			"bank_intlv=cs0_cs1;"	\
+			"en_cpc:cpc2;"
+#else
+#define	HWCONFIG	"hwconfig=fsl_ddr:ctlr_intlv=null,bank_intlv=cs0_cs1;"
+#endif
+
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
-	"hwconfig=fsl_ddr:ctlr_intlv=null,"		\
-	"bank_intlv=cs0_cs1;"					\
+	HWCONFIG						\
 	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
 	"netdev=eth0\0"						\
 	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"			\
--- u-boot-2014.07/include/configs/M54455EVB.h.orig	2022-05-09 14:06:22.229189976 -0700
+++ u-boot-2014.07/include/configs/M54455EVB.h	2022-05-09 14:06:23.869123645 -0700
@@ -181,8 +181,7 @@
 #define CONFIG_SYS_IMMR		CONFIG_SYS_MBAR
 
 /* DSPI and Serial Flash */
-#define CONFIG_CF_SPI
-#define CONFIG_CF_DSPI
+#define CONFIG_FSL_DSPI
 #define CONFIG_HARD_SPI
 #define CONFIG_SYS_SBFHDR_SIZE		0x13
 #ifdef CONFIG_CMD_SPI
--- u-boot-2014.07/include/configs/MPC837XEMDS.h.orig	2022-05-09 14:06:22.233189815 -0700
+++ u-boot-2014.07/include/configs/MPC837XEMDS.h	2022-05-09 14:06:23.873123484 -0700
@@ -387,6 +387,11 @@
 #define CONFIG_PQ_MDS_PIB	1 /* PQ MDS Platform IO Board */
 
 #define CONFIG_HAS_FSL_DR_USB	1 /* fixup device tree for the DR USB */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
 
 #define CONFIG_PCI_PNP		/* do pci plug-and-play */
 
--- u-boot-2014.07/include/configs/M52277EVB.h.orig	2022-05-09 14:06:22.225190138 -0700
+++ u-boot-2014.07/include/configs/M52277EVB.h	2022-05-09 14:06:23.865123807 -0700
@@ -137,8 +137,7 @@
 #define CONFIG_SYS_IMMR			CONFIG_SYS_MBAR
 
 /* DSPI and Serial Flash */
-#define CONFIG_CF_SPI
-#define CONFIG_CF_DSPI
+#define CONFIG_FSL_DSPI
 #define CONFIG_HARD_SPI
 #define CONFIG_SYS_SBFHDR_SIZE		0x7
 #ifdef CONFIG_CMD_SPI
--- u-boot-2014.07/include/configs/T4240EMU.h.orig	2022-05-09 14:06:22.249189168 -0700
+++ u-boot-2014.07/include/configs/T4240EMU.h	2022-05-09 14:06:23.889122837 -0700
@@ -85,10 +85,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	50
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
--- u-boot-2014.07/include/configs/T4240RDB.h.orig	2022-05-09 14:06:22.249189168 -0700
+++ u-boot-2014.07/include/configs/T4240RDB.h	2022-05-09 14:06:23.889122837 -0700
@@ -12,6 +12,8 @@
 
 #define CONFIG_T4240RDB
 #define CONFIG_PHYS_64BIT
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 
 #define CONFIG_FSL_SATA_V2
 #define CONFIG_PCIE4
@@ -513,6 +515,29 @@
 #define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
 #define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
 
+/* CPLD on IFC */
+#define CONFIG_SYS_CPLD_BASE	0xffdf0000
+#define CONFIG_SYS_CPLD_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_CPLD_BASE)
+#define CONFIG_SYS_CSPR3_EXT	(0xf)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(CONFIG_SYS_CPLD_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+
+#define CONFIG_SYS_AMASK3	IFC_AMASK(4*1024)
+#define CONFIG_SYS_CSOR3	0x0
+
+/* CPLD Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0x0e) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x8) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
 #if defined(CONFIG_RAMBOOT_PBL)
 #define CONFIG_SYS_RAMBOOT
 #endif
@@ -553,10 +578,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	50
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
@@ -597,6 +638,7 @@
 #define CONFIG_PHYLIB_10G
 #define CONFIG_PHY_VITESSE
 #define CONFIG_PHY_CORTINA
+#define CONFIG_SYS_CORTINA_FW_IN_NOR
 #define CONFIG_CORTINA_FW_ADDR		0xefe00000
 #define CONFIG_CORTINA_FW_LENGTH	0x40000
 #define CONFIG_PHY_TERANETICS
@@ -661,6 +703,7 @@
 #define CONFIG_FSL_ESDHC
 #define CONFIG_SYS_FSL_ESDHC_ADDR       CONFIG_SYS_MPC85xx_ESDHC_ADDR
 #define CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
 #define CONFIG_CMD_MMC
 #define CONFIG_GENERIC_MMC
 #define CONFIG_CMD_EXT2
--- u-boot-2014.07/include/configs/BSC9131RDB.h.orig	2022-05-09 14:06:22.217190462 -0700
+++ u-boot-2014.07/include/configs/BSC9131RDB.h	2022-05-09 14:06:23.857124131 -0700
@@ -11,6 +11,9 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+
 #ifdef CONFIG_BSC9131RDB
 #define CONFIG_BSC9131
 #define CONFIG_NAND_FSL_IFC
--- u-boot-2014.07/include/configs/vf610twr.h.orig	2022-05-09 14:06:22.333185770 -0700
+++ u-boot-2014.07/include/configs/vf610twr.h	2022-05-09 14:06:24.029117174 -0700
@@ -68,11 +68,13 @@
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_MICREL
 
+#define CONFIG_FSL_SPI_INTERFACE
+#define CONFIG_CMD_SF
+
 /* QSPI Configs*/
 #define CONFIG_FSL_QSPI
 
 #ifdef CONFIG_FSL_QSPI
-#define CONFIG_CMD_SF
 #define CONFIG_SPI_FLASH
 #define CONFIG_SPI_FLASH_SPANSION
 #define FSL_QSPI_FLASH_SIZE		(1 << 24)
--- u-boot-2014.07/include/configs/P1023RDB.h.orig	2022-05-09 14:06:22.241189491 -0700
+++ u-boot-2014.07/include/configs/P1023RDB.h	2022-05-09 14:06:23.881123160 -0700
@@ -10,6 +10,9 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+
 #ifndef CONFIG_SYS_TEXT_BASE
 #define CONFIG_SYS_TEXT_BASE	0xeff40000
 #endif
@@ -344,9 +347,25 @@
 #define CONFIG_SYS_QMAN_MEM_BASE	0xff000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_BMAN_MEM_BASE	0xff200000
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 
 /* For FM */
 #define CONFIG_SYS_DPAA_FMAN
--- u-boot-2014.07/include/configs/T208xQDS.h.orig	2022-05-09 14:06:22.249189168 -0700
+++ u-boot-2014.07/include/configs/T208xQDS.h	2022-05-09 14:06:23.885122998 -0700
@@ -11,6 +11,8 @@
 #ifndef __T208xQDS_H
 #define __T208xQDS_H
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 #define CONFIG_ICS307_REFCLK_HZ 25000000  /* ICS307 ref clk freq */
 #define CONFIG_MMC
 #define CONFIG_SPI_FLASH
@@ -232,7 +234,7 @@
 #define CONFIG_FSL_DDR_FIRST_SLOT_QUAD_CAPABLE
 #define CONFIG_DDR_SPD
 #define CONFIG_SYS_FSL_DDR3
-#undef CONFIG_FSL_DDR_INTERACTIVE
+#define CONFIG_FSL_DDR_INTERACTIVE
 #define CONFIG_SYS_SPD_BUS_NUM	0
 #define CONFIG_SYS_SDRAM_SIZE	2048	/* for fixed parameter use */
 #define SPD_EEPROM_ADDRESS1	0x51
@@ -492,6 +494,23 @@
 #define I2C_MUX_PCA_ADDR_SEC2	0x76 /* I2C bus multiplexer,secondary 2 */
 #define I2C_MUX_CH_DEFAULT	0x8
 
+#define I2C_MUX_CH_VOL_MONITOR 0xa
+
+/* Voltage monitor on channel 2*/
+#define I2C_VOL_MONITOR_ADDR           0x40
+#define I2C_VOL_MONITOR_BUS_V_OFFSET   0x2
+#define I2C_VOL_MONITOR_BUS_V_OVF      0x1
+#define I2C_VOL_MONITOR_BUS_V_SHIFT    3
+
+#define CONFIG_VID_FLS_ENV		"t208xqds_vdd_mv"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_VID
+#endif
+#define CONFIG_VOL_MONITOR_IR36021_SET
+#define CONFIG_VOL_MONITOR_IR36021_READ
+/* The lowest and highest voltage allowed for T208xQDS */
+#define VDD_MV_MIN			819
+#define VDD_MV_MAX			1212
 
 /*
  * RapidIO
@@ -537,7 +556,7 @@
 #ifdef CONFIG_SPI_FLASH
 #define CONFIG_FSL_ESPI
 #define CONFIG_SPI_FLASH_STMICRO
-#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_RAMBOOT_PBL)
+#ifndef CONFIG_SPL_BUILD
 #define CONFIG_SPI_FLASH_SST
 #define CONFIG_SPI_FLASH_EON
 #endif
@@ -615,10 +634,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	18
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
--- u-boot-2014.07/include/configs/km/kmp204x-common.h.orig	2022-05-09 14:06:22.293187388 -0700
+++ u-boot-2014.07/include/configs/km/kmp204x-common.h	2022-05-09 14:06:23.929121219 -0700
@@ -336,10 +336,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff4200000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
--- u-boot-2014.07/include/configs/C29XPCIE.h.orig	2022-05-09 14:06:22.217190462 -0700
+++ u-boot-2014.07/include/configs/C29XPCIE.h	2022-05-09 14:06:23.857124131 -0700
@@ -12,6 +12,8 @@
 #define __CONFIG_H
 
 #define CONFIG_PHYS_64BIT
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 
 #ifdef CONFIG_C29XPCIE
 #define CONFIG_PPC_C29X
@@ -574,4 +576,6 @@
 
 #define CONFIG_BOOTCOMMAND CONFIG_RAMBOOTCOMMAND
 
+#include <asm/fsl_secure_boot.h>
+
 #endif	/* __CONFIG_H */
--- u-boot-2014.07/include/configs/p1_twr.h.orig	2022-05-09 14:06:22.309186741 -0700
+++ u-boot-2014.07/include/configs/p1_twr.h	2022-05-09 14:06:23.989118792 -0700
@@ -10,6 +10,8 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define	CONFIG_SYS_GENERIC_BOARD
+#define	CONFIG_DISPLAY_BOARDINFO
 #if defined(CONFIG_TWR_P1025)
 #define CONFIG_BOARDNAME "TWR-P1025"
 #define CONFIG_P1025
--- u-boot-2014.07/include/configs/P2041RDB.h.orig	2022-05-09 14:06:22.241189491 -0700
+++ u-boot-2014.07/include/configs/P2041RDB.h	2022-05-09 14:06:23.881123160 -0700
@@ -13,6 +13,8 @@
 
 #define CONFIG_P2041RDB
 #define CONFIG_PHYS_64BIT
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 #define CONFIG_PPC_P2041
 
 #ifdef CONFIG_RAMBOOT_PBL
@@ -488,6 +490,14 @@
 #define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf4200000
 #ifdef CONFIG_PHYS_64BIT
@@ -496,6 +506,14 @@
 #define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
 #endif
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x00200000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
--- u-boot-2014.07/include/configs/T4240QDS.h.orig	2022-05-09 14:06:22.249189168 -0700
+++ u-boot-2014.07/include/configs/T4240QDS.h	2022-05-09 14:06:23.889122837 -0700
@@ -417,10 +417,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	50
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
--- u-boot-2014.07/include/configs/T104xRDB.h.orig	2022-05-09 14:06:22.245189329 -0700
+++ u-boot-2014.07/include/configs/T104xRDB.h	2022-05-09 14:06:23.885122998 -0700
@@ -12,6 +12,11 @@
  */
 #define CONFIG_T104xRDB
 #define CONFIG_PHYS_64BIT
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_E500			/* BOOKE e500 family */
+#include <asm/config_mpc85xx.h>
 
 #ifdef CONFIG_RAMBOOT_PBL
 #define CONFIG_SYS_FSL_PBL_PBI $(SRCTREE)/board/freescale/t104xrdb/t104x_pbi.cfg
@@ -33,7 +38,7 @@
 #define CONFIG_SPL_I2C_SUPPORT
 #define CONFIG_SPL_DRIVERS_MISC_SUPPORT
 #define CONFIG_FSL_LAW                 /* Use common FSL init code */
-#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SYS_TEXT_BASE		0x30001000
 #define CONFIG_SPL_TEXT_BASE		0xFFFD8000
 #define CONFIG_SPL_PAD_TO		0x40000
 #define CONFIG_SPL_MAX_SIZE		0x28000
@@ -49,21 +54,21 @@
 #ifdef CONFIG_NAND
 #define CONFIG_SPL_NAND_SUPPORT
 #define CONFIG_SYS_NAND_U_BOOT_SIZE	(768 << 10)
-#define CONFIG_SYS_NAND_U_BOOT_DST	0x00200000
-#define CONFIG_SYS_NAND_U_BOOT_START	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_DST	0x30000000
+#define CONFIG_SYS_NAND_U_BOOT_START	0x30000000
 #define CONFIG_SYS_NAND_U_BOOT_OFFS	(256 << 10)
 #define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
 #define CONFIG_SPL_NAND_BOOT
 #endif
 
 #ifdef CONFIG_SPIFLASH
-#define	CONFIG_RESET_VECTOR_ADDRESS		0x200FFC
+#define	CONFIG_RESET_VECTOR_ADDRESS		0x30000FFC
 #define CONFIG_SPL_SPI_SUPPORT
 #define CONFIG_SPL_SPI_FLASH_SUPPORT
 #define CONFIG_SPL_SPI_FLASH_MINIMAL
 #define CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE	(768 << 10)
-#define CONFIG_SYS_SPI_FLASH_U_BOOT_DST		(0x00200000)
-#define CONFIG_SYS_SPI_FLASH_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_DST		(0x30000000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_START	(0x30000000)
 #define CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS	(256 << 10)
 #define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
 #ifndef CONFIG_SPL_BUILD
@@ -73,12 +78,12 @@
 #endif
 
 #ifdef CONFIG_SDCARD
-#define	CONFIG_RESET_VECTOR_ADDRESS		0x200FFC
+#define	CONFIG_RESET_VECTOR_ADDRESS		0x30000FFC
 #define CONFIG_SPL_MMC_SUPPORT
 #define CONFIG_SPL_MMC_MINIMAL
 #define CONFIG_SYS_MMC_U_BOOT_SIZE	(768 << 10)
-#define CONFIG_SYS_MMC_U_BOOT_DST	(0x00200000)
-#define CONFIG_SYS_MMC_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_DST	(0x30000000)
+#define CONFIG_SYS_MMC_U_BOOT_START	(0x30000000)
 #define CONFIG_SYS_MMC_U_BOOT_OFFS	(260 << 10)
 #define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
 #ifndef CONFIG_SPL_BUILD
@@ -91,13 +96,12 @@
 
 /* High Level Configuration Options */
 #define CONFIG_BOOKE
-#define CONFIG_E500			/* BOOKE e500 family */
 #define CONFIG_E500MC			/* BOOKE e500mc family */
 #define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
 #define CONFIG_MP			/* support multiple processors */
 
 /* support deep sleep */
-#define CONFIG_DEEP_SLEEP
+#define CONFIG_FSL_DEEP_SLEEP
 #define CONFIG_SILENT_CONSOLE
 
 #ifndef CONFIG_SYS_TEXT_BASE
@@ -269,6 +273,9 @@
 #define CPLD_LBMAP_DFLTBANK		0x40 /* BANK OR | BANK0 */
 #define CPLD_LBMAP_RESET		0xFF
 #define CPLD_LBMAP_SHIFT		0x03
+#ifdef CONFIG_T1042RDB_PI
+#define CPLD_DIU_SEL_DFP		0x80
+#endif
 
 #define CONFIG_SYS_CPLD_BASE	0xffdf0000
 #define CONFIG_SYS_CPLD_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_CPLD_BASE)
@@ -380,6 +387,12 @@
 #define CONFIG_SYS_RAMBOOT
 #endif
 
+#ifdef CONFIG_SYS_FSL_ERRATUM_A008044
+#if defined(CONFIG_NAND)
+#define CONFIG_A008044_WORKAROUND
+#endif
+#endif
+
 #define CONFIG_BOARD_EARLY_INIT_R
 #define CONFIG_MISC_INIT_R
 
@@ -430,6 +443,24 @@
 #define CONFIG_SYS_HUSH_PARSER
 #define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
 
+#ifdef CONFIG_T1042RDB_PI
+/* Video */
+#define CONFIG_FSL_DIU_FB
+
+#ifdef CONFIG_FSL_DIU_FB
+#define CONFIG_FSL_DIU_CH7301
+#define CONFIG_SYS_DIU_ADDR	(CONFIG_SYS_CCSRBAR + 0x180000)
+#define CONFIG_VIDEO
+#define CONFIG_CMD_BMP
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_CFB_CONSOLE_ANSI
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+#endif
+
 /* pass open firmware flat tree */
 #define CONFIG_OF_LIBFDT
 #define CONFIG_OF_BOARD_SETUP
@@ -451,11 +482,15 @@
 
 /* I2C bus multiplexer */
 #define I2C_MUX_PCA_ADDR                0x70
-#ifdef CONFIG_T1040RDB
+#if defined(CONFIG_T1040RDB) || defined(CONFIG_T1042RDB)
 #define I2C_MUX_CH_DEFAULT      0x8
 #endif
 
 #ifdef CONFIG_T1042RDB_PI
+/* LDI/DVI Encoder for display */
+#define CONFIG_SYS_I2C_LDI_ADDR		0x38
+#define CONFIG_SYS_I2C_DVI_ADDR		0x75
+
 /*
  * RTC configuration
  */
@@ -473,6 +508,7 @@
 #define CONFIG_FSL_ESPI
 #define CONFIG_SPI_FLASH
 #define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_BAR
 #define CONFIG_CMD_SF
 #define CONFIG_SF_DEFAULT_SPEED         10000000
 #define CONFIG_SF_DEFAULT_MODE          0
@@ -591,19 +627,35 @@
 /* Qman/Bman */
 #ifndef CONFIG_NOBQFMAN
 #define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
-#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
-#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
 
-#ifdef CONFIG_T1040RDB
+#if defined(CONFIG_T1040RDB) || defined(CONFIG_T1042RDB)
 #define CONFIG_QE
 #define CONFIG_U_QE
 #endif
@@ -632,7 +684,7 @@
 #define CONFIG_SYS_FMAN_FW_ADDR		0xEFF00000
 #endif
 
-#ifdef CONFIG_T1040RDB
+#if defined(CONFIG_T1040RDB) || defined(CONFIG_T1042RDB)
 #if defined(CONFIG_SPIFLASH)
 #define CONFIG_SYS_QE_FW_ADDR		0x130000
 #elif defined(CONFIG_SDCARD)
@@ -656,7 +708,7 @@
 #endif
 
 #ifdef CONFIG_FMAN_ENET
-#ifdef CONFIG_T1040RDB
+#if defined(CONFIG_T1040RDB) || defined(CONFIG_T1042RDB)
 #define CONFIG_SYS_SGMII1_PHY_ADDR		0x03
 #endif
 #define CONFIG_SYS_RGMII1_PHY_ADDR		0x01
@@ -758,13 +810,20 @@
 #define CONFIG_BAUDRATE	115200
 
 #define __USB_PHY_TYPE	utmi
+#define RAMDISKFILE	"t104xrdb/ramdisk.uboot"
 
 #ifdef CONFIG_T1040RDB
 #define FDTFILE		"t1040rdb/t1040rdb.dtb"
-#define RAMDISKFILE	"t1040rdb/ramdisk.uboot"
 #elif CONFIG_T1042RDB_PI
-#define FDTFILE		"t1040rdb_pi/t1040rdb_pi.dtb"
-#define RAMDISKFILE	"t1040rdb_pi/ramdisk.uboot"
+#define FDTFILE		"t1042rdb_pi/t1042rdb_pi.dtb"
+#elif CONFIG_T1042RDB
+#define FDTFILE		"t1042rdb/t1042rdb.dtb"
+#endif
+
+#ifdef CONFIG_FSL_DIU_FB
+#define DIU_ENVIRONMENT "fslfb:1024x768-32@60,monitor=dvi"
+#else
+#define DIU_ENVIRONMENT
 #endif
 
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
@@ -772,6 +831,7 @@
 	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) ";"\
 	"usb2:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
 	"netdev=eth0\0"						\
+	"video-mode=" __stringify(DIU_ENVIRONMENT) "\0"		\
 	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
 	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"	\
 	"tftpflash=tftpboot $loadaddr $uboot && "		\
--- u-boot-2014.07/include/configs/P1010RDB.h.orig	2022-05-09 14:06:22.237189653 -0700
+++ u-boot-2014.07/include/configs/P1010RDB.h	2022-05-09 14:06:23.877123322 -0700
@@ -14,6 +14,8 @@
 #ifdef CONFIG_36BIT
 #define CONFIG_PHYS_64BIT
 #endif
+#define	CONFIG_SYS_GENERIC_BOARD
+#define	CONFIG_DISPLAY_BOARDINFO
 
 #define CONFIG_P1010
 #define CONFIG_E500			/* BOOKE e500 family */
@@ -54,7 +56,7 @@
 #ifdef CONFIG_SECURE_BOOT
 #define CONFIG_RAMBOOT_SPIFLASH
 #define CONFIG_SYS_TEXT_BASE		0x11000000
-#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#define CONFIG_RESET_VECTOR_ADDRESS	0x110bfffc
 #else
 #define CONFIG_SPL
 #define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
--- u-boot-2014.07/include/configs/P5040DS.h.orig	2022-05-09 14:06:22.241189491 -0700
+++ u-boot-2014.07/include/configs/P5040DS.h	2022-05-09 14:06:23.881123160 -0700
@@ -17,6 +17,7 @@
 #define CONFIG_MMC
 #define CONFIG_NAND_FSL_ELBC
 #define CONFIG_PCIE3
+#define CONFIG_FSL_SATA_V2
 #define CONFIG_SYS_FSL_RAID_ENGINE
 
 #define CONFIG_ICS307_REFCLK_HZ		25000000  /* ICS307 ref clk freq */
--- u-boot-2014.07/include/configs/T1040QDS.h.orig	2022-05-09 14:06:22.245189329 -0700
+++ u-boot-2014.07/include/configs/T1040QDS.h	2022-05-09 14:06:23.885122998 -0700
@@ -28,6 +28,8 @@
  */
 #define CONFIG_T1040QDS
 #define CONFIG_PHYS_64BIT
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 
 #ifdef CONFIG_RAMBOOT_PBL
 #define CONFIG_RAMBOOT_TEXT_BASE	CONFIG_SYS_TEXT_BASE
@@ -175,8 +177,8 @@
 #define CONFIG_DDR_SPD
 #ifndef CONFIG_SYS_FSL_DDR4
 #define CONFIG_SYS_FSL_DDR3
-#define CONFIG_FSL_DDR_INTERACTIVE
 #endif
+#define CONFIG_FSL_DDR_INTERACTIVE
 
 #define CONFIG_SYS_SPD_BUS_NUM	0
 #define SPD_EEPROM_ADDRESS	0x51
@@ -595,14 +597,30 @@
 /* Qman/Bman */
 #ifndef CONFIG_NOBQFMAN
 #define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
-#define CONFIG_SYS_BMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
-#define CONFIG_SYS_QMAN_NUM_PORTALS	25
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
@@ -755,8 +773,7 @@
 #define __USB_PHY_TYPE	utmi
 
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
-	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
-	"bank_intlv=cs0_cs1;"					\
+	"hwconfig=fsl_ddr:bank_intlv=auto;"			\
 	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
 	"netdev=eth0\0"						\
 	"video-mode=fslfb:1024x768-32@60,monitor=dvi\0"		\
--- u-boot-2014.07/include/configs/P1_P2_RDB.h.orig	2022-05-09 14:06:22.241189491 -0700
+++ u-boot-2014.07/include/configs/P1_P2_RDB.h	2022-05-09 14:06:23.881123160 -0700
@@ -1,7 +1,23 @@
 /*
  * Copyright 2009-2011 Freescale Semiconductor, Inc.
  *
- * SPDX-License-Identifier:	GPL-2.0+
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
  */
 
 /*
@@ -14,6 +30,25 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+/* XTM3x , error-out if WGXTM_BOREN  not in the ENV */
+#ifndef CONFIG_WGXTM_BOREN_TESTER
+#error
+#endif
+
+#ifdef CONFIG_WGXTM_BOREN_TESTER /* XTM3x , not using VSC chip, Marvell instead */
+#define CONFIG_MV88E61XX_SWITCH
+#define CONFIG_MV88E61XX_CMD
+#define CONFIG_RESET_PHY_R
+#define CONFIG_MV88E61XX_MULTICHIP_ADRMODE
+#define CONFIG_PHY_GIGE     1
+
+/* define bare minimal stuff for PHLIB and marvell phy drivers */
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MARVELL
+#else
+#error
+#endif
+
 #ifdef CONFIG_36BIT
 #define CONFIG_PHYS_64BIT
 #endif
@@ -136,7 +171,7 @@
 #endif
 
 #ifndef CONFIG_SYS_TEXT_BASE
-#define CONFIG_SYS_TEXT_BASE		0xeff40000
+#define CONFIG_SYS_TEXT_BASE		0xeff80000
 #endif
 
 #ifndef CONFIG_RESET_VECTOR_ADDRESS
@@ -144,12 +179,8 @@
 #endif
 
 #ifndef CONFIG_SYS_MONITOR_BASE
-#ifdef CONFIG_SPL_BUILD
-#define CONFIG_SYS_MONITOR_BASE	CONFIG_SPL_TEXT_BASE
-#else
 #define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
 #endif
-#endif
 
 /* High Level Configuration Options */
 #define CONFIG_BOOKE		1	/* BOOKE */
@@ -169,6 +200,9 @@
 #define CONFIG_TSEC_ENET		/* tsec ethernet support */
 #define CONFIG_ENV_OVERWRITE
 
+#define CONFIG_BOREN_ETHNET_SETUP	/* WG:MJ - All debug stuff for Boren */
+#define CONFIG_DEBUG_BOREN		/* WG:MJ - All debug stuff for Boren */
+
 #if defined(CONFIG_PCI)
 #define CONFIG_E1000		1	/*  E1000 pci Ethernet card*/
 #endif
@@ -204,48 +238,21 @@
 #define CONFIG_SYS_MEMTEST_END		0x1fffffff
 #define CONFIG_PANIC_HANG	/* do not reset board on panic */
 
-/*
- * Config the L2 Cache as L2 SRAM
-*/
-#if defined(CONFIG_SPL_BUILD)
-#if defined(CONFIG_SDCARD) || defined(CONFIG_SPIFLASH)
+ /*
+  * Config the L2 Cache as L2 SRAM
+  */
 #define CONFIG_SYS_INIT_L2_ADDR		0xf8f80000
-#define CONFIG_SYS_INIT_L2_ADDR_PHYS	CONFIG_SYS_INIT_L2_ADDR
-#define CONFIG_SYS_INIT_L2_END	(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_L2_SIZE)
-#define CONFIG_SPL_RELOC_TEXT_BASE	0xf8f81000
-#define CONFIG_SPL_GD_ADDR		(CONFIG_SYS_INIT_L2_ADDR + 112 * 1024)
-#define CONFIG_SPL_RELOC_STACK		(CONFIG_SYS_INIT_L2_ADDR + 116 * 1024)
-#define CONFIG_SPL_RELOC_STACK_SIZE	(32 << 10)
-#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SYS_INIT_L2_ADDR + 148 * 1024)
-#if defined(CONFIG_P2020RDB)
-#define CONFIG_SPL_RELOC_MALLOC_SIZE	(364 << 10)
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_L2_ADDR_PHYS	0xff8f80000ull
 #else
-#define CONFIG_SPL_RELOC_MALLOC_SIZE	(108 << 10)
-#endif
-#elif defined(CONFIG_NAND)
-#ifdef CONFIG_TPL_BUILD
-#define CONFIG_SYS_INIT_L2_ADDR		0xf8f80000
 #define CONFIG_SYS_INIT_L2_ADDR_PHYS	CONFIG_SYS_INIT_L2_ADDR
-#define CONFIG_SYS_INIT_L2_END	(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_L2_SIZE)
-#define CONFIG_SPL_RELOC_TEXT_BASE	0xf8f81000
-#define CONFIG_SPL_RELOC_STACK		(CONFIG_SYS_INIT_L2_ADDR + 192 * 1024)
-#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SYS_INIT_L2_ADDR + 208 * 1024)
-#define CONFIG_SPL_RELOC_MALLOC_SIZE	(48 << 10)
-#define CONFIG_SPL_GD_ADDR		(CONFIG_SYS_INIT_L2_ADDR + 176 * 1024)
-#else
-#define CONFIG_SYS_INIT_L2_ADDR		0xf8f80000
-#define CONFIG_SYS_INIT_L2_ADDR_PHYS	CONFIG_SYS_INIT_L2_ADDR
-#define CONFIG_SYS_INIT_L2_END	(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_L2_SIZE)
-#define CONFIG_SPL_RELOC_TEXT_BASE	(CONFIG_SYS_INIT_L2_END - 0x2000)
-#define CONFIG_SPL_RELOC_STACK		((CONFIG_SYS_INIT_L2_END - 1) & ~0xF)
-#endif /* CONFIG_TPL_BUILD */
-#endif
 #endif
 
-#ifdef CONFIG_SPL_BUILD
-#define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
-#endif
+#define CONFIG_SYS_INIT_L2_END		(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_L2_SIZE)
 
+							/* CCSRBAR */
+#define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses */
+							/* CONFIG_SYS_IMMR */
 /* DDR Setup */
 #define CONFIG_SYS_FSL_DDR2
 #undef CONFIG_FSL_DDR_INTERACTIVE
@@ -253,15 +260,13 @@
 
 #define CONFIG_MEM_INIT_VALUE	0xDeadBeef
 
-#if defined(CONFIG_P1011RDB) || defined(CONFIG_P1020RDB)
-/*
- * P1020 and it's derivatives support max 32bit DDR width
- * So Reduce available DDR size
-*/
-#define CONFIG_SYS_SDRAM_SIZE	512
+#ifdef CONFIG_WGXTM_T30_BOREN /* Is it a T30 unit, DDR size is 1024 */
+#define CONFIG_SYS_SDRAM_SIZE	1024 	/* DDR size on AP331IB */
+#elif CONFIG_WGXTM_T50_BOREN /* Is it a T50 unit, DDR size is 2048 */
+#define CONFIG_SYS_SDRAM_SIZE	2048 	/* DDR size on AP331IB */
 #else
-#define CONFIG_SYS_SDRAM_SIZE	1024
-#endif
+#define CONFIG_SYS_SDRAM_SIZE	1024 	/* DDR size : Fallback */
+#endif /* END_OF CONFIG_WGXTM_T*_BOREN */
 #define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
 #define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
 
@@ -294,9 +299,12 @@
 /*
  * Local Bus Definitions
  */
-#define CONFIG_SYS_FLASH_BASE		0xef000000	/* start of FLASH 16M */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_FLASH_BASE		0xefc00000	/* start of FLASH 4M */
+#endif
 
 #ifdef CONFIG_PHYS_64BIT
+#error
 #define CONFIG_SYS_FLASH_BASE_PHYS	0xfef000000ull
 #else
 #define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
@@ -304,18 +312,35 @@
 
 #define CONFIG_FLASH_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
 					BR_PS_16 | BR_V)
-#define CONFIG_FLASH_OR_PRELIM		0xff000ff7
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_FLASH_OR_PRELIM		0xffc00831//4MB to check cpu datasheet table12-7
+#else
+#error
+#define CONFIG_FLASH_OR_PRELIM		0xff000ff7 //16MB
+#endif
 
 #define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS}
 #define CONFIG_SYS_FLASH_QUIET_TEST
 #define CONFIG_FLASH_SHOW_PROGRESS 45 /* count down from 45/5: 9..1 */
 
 #define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_MAX_FLASH_SECT	256	/* sectors per device */
+#else
 #define CONFIG_SYS_MAX_FLASH_SECT	128	/* sectors per device */
+#endif
 #undef	CONFIG_SYS_FLASH_CHECKSUM
 #define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
 #define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
 
+#if defined(CONFIG_RAMBOOT_NAND) || defined(CONFIG_RAMBOOT_SDCARD) || \
+    defined(CONFIG_RAMBOOT_SPIFLASH)
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#else
+#undef CONFIG_SYS_RAMBOOT
+#endif
+
 #define CONFIG_FLASH_CFI_DRIVER
 #define CONFIG_SYS_FLASH_CFI
 #define CONFIG_SYS_FLASH_EMPTY_INFO
@@ -345,77 +370,126 @@
 						- GENERATED_GBL_DATA_SIZE)
 #define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
 
-#define CONFIG_SYS_MONITOR_LEN		(768 * 1024)
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon*/
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_MALLOC_LEN		(8 * 1024 * 1024)	/* Reserved for malloc*/
+#else
 #define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc*/
-
-#define CONFIG_SYS_NAND_BASE		0xff800000
+#endif
+#ifndef CONFIG_NAND_SPL
+#define CONFIG_SYS_NAND_BASE		0xffa00000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfffa00000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+#else
+#define CONFIG_SYS_NAND_BASE		0xfff00000
 #ifdef CONFIG_PHYS_64BIT
-#define CONFIG_SYS_NAND_BASE_PHYS	0xfff800000ull
+#define CONFIG_SYS_NAND_BASE_PHYS	0xffff00000ull
 #else
 #define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
 #endif
+#endif
 
-#define CONFIG_CMD_NAND
 #define CONFIG_SYS_NAND_BASE_LIST	{CONFIG_SYS_NAND_BASE}
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS			1
 #define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND			1
 #define CONFIG_NAND_FSL_ELBC		1
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+#else
 #define CONFIG_SYS_NAND_BLOCK_SIZE	(16 * 1024)
+#endif
+
+/* NAND boot: 4K NAND loader config */
+#define CONFIG_SYS_NAND_SPL_SIZE	0x1000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	((512 << 10) - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(CONFIG_SYS_INIT_L2_ADDR)
+#define CONFIG_SYS_NAND_U_BOOT_START	(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_NAND_SPL_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(0)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC	(CONFIG_SYS_INIT_L2_END - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC_SP		((CONFIG_SYS_INIT_L2_END - 1) & ~0xF)
 
 /* NAND flash config */
-#define CONFIG_SYS_NAND_BR_PRELIM (BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+#define CONFIG_NAND_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
 				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
 				| BR_PS_8	/* Port Size = 8 bit */ \
 				| BR_MS_FCM		/* MSEL = FCM */ \
 				| BR_V)			/* valid */
 
-#define CONFIG_SYS_NAND_OR_PRELIM	(0xFFF80000	/* length 32K */ \
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
 				| OR_FCM_CSCT \
 				| OR_FCM_CST \
 				| OR_FCM_CHT \
 				| OR_FCM_SCY_1 \
 				| OR_FCM_TRLX \
 				| OR_FCM_EHTR)
-
-#ifdef CONFIG_NAND
-#define CONFIG_SYS_BR0_PRELIM  CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
-#define CONFIG_SYS_OR0_PRELIM  CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#else
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_PGS /* for big page */\
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+#endif
+#ifdef CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
 #define CONFIG_SYS_BR1_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
 #define CONFIG_SYS_OR1_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
 #else
 #define CONFIG_SYS_BR0_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
 #define CONFIG_SYS_OR0_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
-#define CONFIG_SYS_BR1_PRELIM  CONFIG_SYS_NAND_BR_PRELIM /* NAND Base Address */
-#define CONFIG_SYS_OR1_PRELIM  CONFIG_SYS_NAND_OR_PRELIM /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
 #endif
 
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
 #define CONFIG_SYS_VSC7385_BASE	0xffb00000
 
-#ifdef CONFIG_PHYS_64BIT
-#define CONFIG_SYS_VSC7385_BASE_PHYS	0xfffb00000ull
-#else
-#define CONFIG_SYS_VSC7385_BASE_PHYS	CONFIG_SYS_VSC7385_BASE
-#endif
+	#ifdef CONFIG_PHYS_64BIT
+	#define CONFIG_SYS_VSC7385_BASE_PHYS	0xfffb00000ull
+	#else
+	#define CONFIG_SYS_VSC7385_BASE_PHYS	CONFIG_SYS_VSC7385_BASE
+	#endif
 
 #define CONFIG_SYS_BR2_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_VSC7385_BASE) \
 							| BR_PS_8 | BR_V)
 #define CONFIG_SYS_OR2_PRELIM	(OR_AM_128KB | OR_GPCM_CSNT | OR_GPCM_XACS | \
 				OR_GPCM_SCY_15 | OR_GPCM_SETA | OR_GPCM_TRLX | \
 				OR_GPCM_EHTR | OR_GPCM_EAD)
+#endif /* END_OF CONFIG_WGXTM_T*_BOREN */
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN) /* eTSEC1's clk source register */
+#define CONFIG_GUT_PMUXCR_OFFSET    (0xE0060)
+#define CONFIG_GUT_PMUXCR           (CONFIG_SYS_CCSRBAR + CONFIG_GUT_PMUXCR_OFFSET)
+#endif /* END_OF CONFIG_WGXTM_T*_BOREN */
 
 /* Serial Port - controlled on board with jumper J8
  * open - index 2
  * shorted - index 1
  */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_CONS_INDEX	1//colin test
+#else
 #define CONFIG_CONS_INDEX	1
+#endif /* END_OF CONFIG_WGXTM_T*0_BOREN */
 #define CONFIG_SYS_NS16550
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_SYS_NS16550_REG_SIZE	1
 #define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
-#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_INIT_MINIMAL)
+#ifdef CONFIG_NAND_SPL
 #define CONFIG_NS16550_MIN_FUNCTIONS
 #endif
 
+#define CONFIG_SERIAL_MULTI	1 /* Enable both serial ports */
 #define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
 
 #define CONFIG_SYS_BAUDRATE_TABLE	\
@@ -425,7 +499,12 @@
 #define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
 
 /* Use the HUSH parser */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
 #define CONFIG_SYS_HUSH_PARSER
+#endif
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
 
 /*
  * Pass open firmware flat tree
@@ -456,7 +535,7 @@
 #ifdef CONFIG_ID_EEPROM
 #define CONFIG_SYS_I2C_EEPROM_NXID
 #endif
-#define CONFIG_SYS_I2C_EEPROM_ADDR	0x52
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0xac
 #define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
 #define CONFIG_SYS_EEPROM_BUS_NUM	1
 
@@ -469,7 +548,10 @@
 /* eSPI - Enhanced SPI */
 #define CONFIG_FSL_ESPI
 #define CONFIG_SPI_FLASH
+#if 0
 #define CONFIG_SPI_FLASH_SPANSION
+#endif
+/* #define CONFIG_SPI_FLASH_MACRONIX */
 #define CONFIG_CMD_SF
 #define CONFIG_SF_DEFAULT_SPEED		10000000
 #define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
@@ -479,8 +561,8 @@
  * Memory space is mapped 1-1, but I/O space must start from 0.
  */
 
-#if defined(CONFIG_PCI)
 /* controller 2, Slot 2, tgtid 2, Base address 9000 */
+#if defined(CONFIG_PCI)
 #define CONFIG_SYS_PCIE2_NAME		"Slot 1"
 #define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
 #ifdef CONFIG_PHYS_64BIT
@@ -493,12 +575,12 @@
 #define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
 #define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
 #define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
 #ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE2_IO_PHYS	0xfffc10000ull
 #else
 #define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
 #endif
-#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
 
 /* controller 1, Slot 1, tgtid 1, Base address a000 */
 #define CONFIG_SYS_PCIE1_NAME		"Slot 2"
@@ -513,12 +595,12 @@
 #define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
 #define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
 #define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
 #ifdef CONFIG_PHYS_64BIT
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc00000ull
 #else
 #define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
 #endif
-#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
 
 #define CONFIG_PCI_PNP			/* do pci plug-and-play */
 
@@ -538,10 +620,14 @@
 
 #endif	/* CONFIG_PCI */
 
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN) /* TONY_FOR_AP331IB */
+#define CONFIG_NET_MULTI	1
+#endif
 
 #if defined(CONFIG_TSEC_ENET)
 #define CONFIG_MII		1	/* MII PHY management */
 #define CONFIG_MII_DEFAULT_TSEC	1	/* Allow unregistered phys */
+
 #define CONFIG_TSEC1	1
 #define CONFIG_TSEC1_NAME	"eTSEC1"
 #define CONFIG_TSEC2	1
@@ -549,11 +635,19 @@
 #define CONFIG_TSEC3	1
 #define CONFIG_TSEC3_NAME	"eTSEC3"
 
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN) /* TONY_FOR_AP331IB */
+#define TSEC1_PHY_ADDR		2
+#define TSEC2_PHY_ADDR		1
+#define TSEC3_PHY_ADDR		0
+#undef CONFIG_VSC7385_ENET
+#else 
+
 #define TSEC1_PHY_ADDR		2
 #define TSEC2_PHY_ADDR		0
 #define TSEC3_PHY_ADDR		1
 
 #define CONFIG_VSC7385_ENET
+#endif /* END_OF_WGXTM_T*_BOREN */
 
 #define TSEC1_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
 #define TSEC2_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
@@ -579,48 +673,40 @@
 /*
  * Environment
  */
-#ifdef CONFIG_SPIFLASH
-#define CONFIG_ENV_IS_IN_SPI_FLASH
-#define CONFIG_ENV_SPI_BUS	0
-#define CONFIG_ENV_SPI_CS	0
-#define CONFIG_ENV_SPI_MAX_HZ	10000000
-#define CONFIG_ENV_SPI_MODE	0
-#define CONFIG_ENV_SIZE		0x2000	/* 8KB */
-#define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
-#define CONFIG_ENV_SECT_SIZE	0x10000
-#define CONFIG_ENV_ADDR		(CONFIG_SYS_INIT_L2_ADDR + (160 << 10))
-#elif defined(CONFIG_SDCARD)
+#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_RAMBOOT_NAND)
+	#define CONFIG_ENV_IS_IN_NAND	1
+	#define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+	#define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_RAMBOOT_SDCARD)
 #define CONFIG_ENV_IS_IN_MMC
-#define CONFIG_FSL_FIXED_MMC_LOCATION
-#define CONFIG_ENV_SIZE		0x2000
-#define CONFIG_SYS_MMC_ENV_DEV	0
-#define CONFIG_ENV_OFFSET	(512 * 0x800)
-#define CONFIG_ENV_ADDR		(CONFIG_SYS_INIT_L2_ADDR + (160 << 10))
-#elif defined(CONFIG_NAND)
-#ifdef CONFIG_TPL_BUILD
-#define CONFIG_ENV_SIZE		0x2000
-#define CONFIG_ENV_ADDR		(CONFIG_SYS_INIT_L2_ADDR + (160 << 10))
-#else
-#define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_RAMBOOT_SPIFLASH)
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_ENV_SPI_BUS	0
+	#define CONFIG_ENV_SPI_CS	0
+	#define CONFIG_ENV_SPI_MAX_HZ	10000000
+	#define CONFIG_ENV_SPI_MODE	0
+	#define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
+	#define CONFIG_ENV_SECT_SIZE	0x10000
+	#define CONFIG_ENV_SIZE		0x2000
+#endif
+#else
+	#define CONFIG_ENV_IS_IN_FLASH	1
+	#if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+	#define CONFIG_ENV_ADDR		0xfff80000
+	#else
+	#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+	#endif
+	#define CONFIG_ENV_SIZE		0x2000
+	#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
 #endif
-#define CONFIG_ENV_IS_IN_NAND
-#define CONFIG_ENV_OFFSET	(1024 * 1024)
-#define CONFIG_ENV_RANGE	(3 * CONFIG_ENV_SIZE)
-#elif defined(CONFIG_SYS_RAMBOOT)
-#define CONFIG_ENV_IS_NOWHERE	/* Store ENV in memory only */
-#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - 0x1000)
-#define CONFIG_ENV_SIZE		0x2000
-#else
-#define CONFIG_ENV_IS_IN_FLASH
-#define CONFIG_ENV_ADDR	(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
-#define CONFIG_ENV_SIZE		0x2000
-#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
-#endif
-
 
 #define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
 #define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
 
+
 /*
  * Command line configuration.
  */
@@ -641,8 +727,7 @@
 #endif
 
 #undef CONFIG_WATCHDOG			/* watchdog disabled */
-
-#define CONFIG_MMC	1
+#define CONFIG_MMC 1
 
 #ifdef CONFIG_MMC
 #define CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init */
@@ -682,6 +767,7 @@
 #define CONFIG_CMDLINE_EDITING			/* Command-line editing */
 #define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
 #define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
 #if defined(CONFIG_CMD_KGDB)
 #define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
 #else
@@ -691,17 +777,19 @@
 						/* Print Buffer Size */
 #define CONFIG_SYS_MAXARGS	16		/* max number of command args */
 #define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks */
 
 /*
  * For booting Linux, the board info and command line data
- * have to be in the first 64 MB of memory, since this is
+ * have to be in the first 16 MB of memory, since this is
  * the maximum mapped by the Linux kernel during initialization.
  */
-#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)/* Initial Memory map for Linux*/
-#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+#define CONFIG_SYS_BOOTMAPSZ	(16 << 20)/* Initial Memory map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(16 << 20)	/* Increase max gunzip size */
 
 #if defined(CONFIG_CMD_KGDB)
 #define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
 #endif
 
 /*
@@ -727,6 +815,20 @@
 
 #define CONFIG_BAUDRATE	115200
 
+#if defined(CONFIG_WGXTM_T30_BOREN)
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_FDT \
+	fdtfile=t30.dtb
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_WGKERNEL \
+	WGKernelfile=uImage_t30
+#elif defined(CONFIG_WGXTM_T50_BOREN)
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_FDT \
+	fdtfile=t50.dtb
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_WGKERNEL \
+	WGKernelfile=uImage_t50
+#else
+#error
+#endif
+
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
 	"netdev=eth0\0"						\
 	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
@@ -753,12 +855,18 @@
 	"norfdtaddr=ef040000\0"	\
 	"jffs2nand=mtdblock9\0"	\
 	"nandbootaddr=100000\0"	\
+	"nandkerneladdr=0\0"	\
+	"nandrootfsaddr=1400000\0"	\
+	"nanddtbaddr= 6400000\0"	\
 	"nandfdtaddr=80000\0"		\
 	"nandimgsize=400000\0"		\
+	"nandrernelsize=400000\0"		\
+	"nandrootfssize=400000\0"		\
+	"nanddtbsize=400000\0"		\
 	"nandfdtsize=80000\0"		\
 	"hwconfig=usb1:dr_mode=host,phy_type=ulpi\0"	\
 	"vscfw_addr=ef000000\0"	\
-	"othbootargs=ramdisk_size=600000\0" \
+	"othbootargs=ramdisk_size=102400\0" \
 	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
 	"console=$consoledev,$baudrate $othbootargs; "	\
 	"usb start;"			\
@@ -766,6 +874,9 @@
 	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
 	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
 	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+        "ethaddr=00:c0:02:12:35:88\0"  \
+	"eth1addr=00:c0:02:12:35:89\0"  \
+	"eth2addr=00:c0:02:12:35:90\0"  \
 	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
 	"console=$consoledev,$baudrate $othbootargs; "	\
 	"usb start;"			\
@@ -780,7 +891,42 @@
 	"console=$consoledev,$baudrate $othbootargs;"	\
 	"nand read 2000000 $nandbootaddr $nandimgsize;"	\
 	"nand read 3000000 $nandfdtaddr $nandfdtsize;"	\
-	"bootm 2000000 - 3000000;\0"
+	"bootm 2000000 - 3000000;\0"			\
+	"ethact=eTSEC1\0 "	\
+	"serverip=10.0.1.13\0 "	\
+	"gatewayip=10.0.1.13\0 "	\
+	"ipaddr=10.0.1.1\0 "	\
+	"netmask=255.255.255.0\0 "	\
+	__stringify(CONFIG_BOREN_BOARD_SPECIFIC_ENV_FDT) "\0"	\
+	__stringify(CONFIG_BOREN_BOARD_SPECIFIC_ENV_WGKERNEL) "\0"	\
+	"SysARoot=mmcblk0p3\0"	\
+	"SysBRoot=mmcblk0p2\0"	\
+	"wgBootBoot=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:1 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:1 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:2 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:2 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0" \
+	"nuke_env=protect off 0xeff60000 0xeff6ffff && " \
+	"erase 0xeff60000 0xeff6ffff \0" \
 
 #define CONFIG_NFSBOOTCOMMAND		\
 	"setenv bootargs root=/dev/nfs rw "	\
@@ -799,6 +945,14 @@
 	"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
 	"bootm $loadaddr - $fdtaddr"
 
+#define CONFIG_NANDBOOT			\
+	"setenv bootargs root=/dev/ram rw" \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read 0x1000000 0x0 0x800000;"	\
+	"nand read 0x2000000 0x1400000 0x1400000;"	\
+	"nand read 0xc00000 0x6400000 0x100000;"	\
+	"bootm 0x1000000  0x2000000 0xc00000;"
+
 #define CONFIG_RAMBOOTCOMMAND		\
 	"setenv bootargs root=/dev/ram rw "	\
 	"console=$consoledev,$baudrate $othbootargs; "	\
@@ -807,6 +961,6 @@
 	"tftp $fdtaddr $fdtfile;"		\
 	"bootm $loadaddr $ramdiskaddr $fdtaddr"
 
-#define CONFIG_BOOTCOMMAND		CONFIG_HDBOOT
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
 
 #endif	/* __CONFIG_H */
--- u-boot-2014.07/include/configs/BSC9132QDS.h.orig	2022-05-09 14:06:22.217190462 -0700
+++ u-boot-2014.07/include/configs/BSC9132QDS.h	2022-05-09 14:06:23.857124131 -0700
@@ -11,6 +11,9 @@
 #ifndef __CONFIG_H
 #define __CONFIG_H
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+
 #ifdef CONFIG_BSC9132QDS
 #define CONFIG_BSC9132
 #endif
--- u-boot-2014.07/include/configs/T208xRDB.h.orig	2022-05-09 14:06:22.249189168 -0700
+++ u-boot-2014.07/include/configs/T208xRDB.h	2022-05-09 14:06:23.889122837 -0700
@@ -11,6 +11,8 @@
 #ifndef __T2080RDB_H
 #define __T2080RDB_H
 
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
 #define CONFIG_T2080RDB
 #define CONFIG_ICS307_REFCLK_HZ 25000000  /* ICS307 ref clk freq */
 #define CONFIG_MMC
@@ -565,10 +567,26 @@
 #define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
 #define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
 #define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
 #define CONFIG_SYS_QMAN_NUM_PORTALS	18
 #define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
 #define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
 #define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
 
 #define CONFIG_SYS_DPAA_FMAN
 #define CONFIG_SYS_DPAA_PME
--- u-boot-2014.07/include/netdev.h.orig	2022-05-09 14:06:22.385183667 -0700
+++ u-boot-2014.07/include/netdev.h	2022-05-09 14:06:24.073115394 -0700
@@ -153,7 +153,11 @@
 #if defined(CONFIG_MV88E61XX_SWITCH)
 
 /* constants for any 88E61xx switch */
-#define MV88E61XX_MAX_PORTS_NUM	6
+#ifdef CONFIG_BOREN_ETHNET_SETUP
+ #define MV88E61XX_MAX_PORTS_NUM	7
+#else
+ #define MV88E61XX_MAX_PORTS_NUM	6
+#endif
 
 enum mv88e61xx_cfg_mdip {
 	MV88E61XX_MDIP_NOCHANGE,
--- u-boot-2014.07/include/spi_flash.h.orig	2022-05-09 14:06:22.401183020 -0700
+++ u-boot-2014.07/include/spi_flash.h	2022-05-09 14:06:24.085114909 -0700
@@ -20,6 +20,7 @@
 #include <linux/compiler.h>
 
 /* sf param flags */
+#define SECT_2K		(1 << 0)
 #define SECT_4K		1 << 1
 #define SECT_32K	1 << 2
 #define E_FSR		1 << 3
--- u-boot-2014.07/include/usb.h.orig	2022-05-09 14:06:22.405182858 -0700
+++ u-boot-2014.07/include/usb.h	2022-05-09 14:06:24.089114747 -0700
@@ -33,7 +33,7 @@
 #define USB_MAXCHILDREN			8	/* This is arbitrary */
 #define USB_MAX_HUB			16
 
-#define USB_CNTL_TIMEOUT 100 /* 100ms timeout */
+#define USB_CNTL_TIMEOUT 200 /* 100ms timeout */
 
 /*
  * This is the timeout to allow for submitting an urb in ms. We allow more
--- u-boot-2014.07/include/tsec.h.orig	2022-05-09 14:06:22.401183020 -0700
+++ u-boot-2014.07/include/tsec.h	2022-05-09 14:06:24.089114747 -0700
@@ -20,10 +20,15 @@
 #include <net.h>
 #include <config.h>
 #include <phy.h>
-#include <asm/fsl_enet.h>
+#include <fsl_mdio.h>
 
+#ifdef CONFIG_LS102XA
+#define TSEC_SIZE		0x40000
+#define TSEC_MDIO_OFFSET	0x40000
+#else
 #define TSEC_SIZE 		0x01000
 #define TSEC_MDIO_OFFSET	0x01000
+#endif
 
 #define CONFIG_SYS_MDIO_BASE_ADDR (MDIO_BASE_ADDR + 0x520)
 
@@ -125,9 +130,14 @@
 
 #define MINFLR_INIT_SETTINGS	0x00000040
 
+#ifdef CONFIG_LS102XA
+#define DMACTRL_INIT_SETTINGS	0x00000003
+#else
 #define DMACTRL_INIT_SETTINGS	0x000000c3
+#endif
 #define DMACTRL_GRS		0x00000010
 #define DMACTRL_GTS		0x00000008
+#define DMACTRL_LE		0x00008000
 
 #define TSTAT_CLEAR_THALT	0x80000000
 #define RSTAT_CLEAR_RHALT	0x00800000
--- u-boot-2014.07/include/fsl_mdio.h.orig	2022-05-09 14:06:22.353184961 -0700
+++ u-boot-2014.07/include/fsl_mdio.h	2022-05-09 14:06:24.049116365 -0700
@@ -10,7 +10,18 @@
 
 #include <net.h>
 #include <miiphy.h>
-#include <asm/fsl_enet.h>
+
+struct tsec_mii_mng {
+	u32 miimcfg;		/* MII management configuration reg */
+	u32 miimcom;		/* MII management command reg */
+	u32 miimadd;		/* MII management address reg */
+	u32 miimcon;		/* MII management control reg */
+	u32 miimstat;		/* MII management status reg  */
+	u32 miimind;		/* MII management indication reg */
+	u32 ifstat;		/* Interface Status Register */
+};
+
+int fdt_fixup_phy_connection(void *blob, int offset, phy_interface_t phyc);
 
 /* PHY register offsets */
 #define PHY_EXT_PAGE_ACCESS	0x1f
--- u-boot-2014.07/include/fsl_ddr_sdram.h.orig	2022-05-09 14:06:22.349185123 -0700
+++ u-boot-2014.07/include/fsl_ddr_sdram.h	2022-05-09 14:06:24.045116527 -0700
@@ -51,7 +51,6 @@
 #define CONFIG_FSL_SDRAM_TYPE	SDRAM_TYPE_DDR2
 #endif
 #elif defined(CONFIG_SYS_FSL_DDR3)
-#define FSL_DDR_MIN_TCKE_PULSE_WIDTH_DDR	(3)	/* FIXME */
 typedef ddr3_spd_eeprom_t generic_spd_eeprom_t;
 #ifndef CONFIG_FSL_SDRAM_TYPE
 #define CONFIG_FSL_SDRAM_TYPE	SDRAM_TYPE_DDR3
@@ -115,6 +114,7 @@
 #define SDRAM_CFG_2T_EN			0x00008000
 #define SDRAM_CFG_BI			0x00000001
 
+#define SDRAM_CFG2_FRC_SR		0x80000000
 #define SDRAM_CFG2_D_INIT		0x00000010
 #define SDRAM_CFG2_ODT_CFG_MASK		0x00600000
 #define SDRAM_CFG2_ODT_NEVER		0
@@ -164,6 +164,7 @@
 #define DDR_CDR1_ODT(x) ((x & DDR_CDR1_ODT_MASK) << DDR_CDR1_ODT_SHIFT)
 #define DDR_CDR2_ODT(x) (x & DDR_CDR2_ODT_MASK)
 #define DDR_CDR2_VREF_OVRD(x)	(0x00008080 | ((((x) - 37) & 0x3F) << 8))
+#define DDR_CDR2_VREF_TRAIN_EN	0x00000080
 
 #if (defined(CONFIG_SYS_FSL_DDR_VER) && \
 	(CONFIG_SYS_FSL_DDR_VER >= FSL_DDR_VER_4_7))
@@ -281,6 +282,7 @@
 #define DDR_DATA_BUS_WIDTH_64 0
 #define DDR_DATA_BUS_WIDTH_32 1
 #define DDR_DATA_BUS_WIDTH_16 2
+#define DDR_CSWL_CS0	0x04000001
 /*
  * Generalized parameters for memory controller configuration,
  * might be a little specific to the FSL memory controller
@@ -340,6 +342,7 @@
 	unsigned int cpo_override;
 	unsigned int write_data_delay;		/* DQS adjust */
 
+	unsigned int cswl_override;
 	unsigned int wrlvl_override;
 	unsigned int wrlvl_sample;		/* Write leveling */
 	unsigned int wrlvl_start;
@@ -350,7 +353,6 @@
 	unsigned int twot_en;
 	unsigned int threet_en;
 	unsigned int bstopre;
-	unsigned int tcke_clock_pulse_width_ps;	/* tCKE */
 	unsigned int tfaw_window_four_activates_ps;	/* tFAW --  FOUR_ACT */
 
 	/* Rtt impedance */
--- u-boot-2014.07/include/fsl_esdhc.h.orig	2022-05-09 14:06:22.353184961 -0700
+++ u-boot-2014.07/include/fsl_esdhc.h	2022-05-09 14:06:24.045116527 -0700
@@ -162,7 +162,19 @@
 };
 
 /* Select the correct accessors depending on endianess */
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#if defined CONFIG_SYS_FSL_ESDHC_LE
+#define esdhc_read32		in_le32
+#define esdhc_write32		out_le32
+#define esdhc_clrsetbits32	clrsetbits_le32
+#define esdhc_clrbits32		clrbits_le32
+#define esdhc_setbits32		setbits_le32
+#elif defined(CONFIG_SYS_FSL_ESDHC_BE)
+#define esdhc_read32            in_be32
+#define esdhc_write32           out_be32
+#define esdhc_clrsetbits32      clrsetbits_be32
+#define esdhc_clrbits32         clrbits_be32
+#define esdhc_setbits32         setbits_be32
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
 #define esdhc_read32		in_le32
 #define esdhc_write32		out_le32
 #define esdhc_clrsetbits32	clrsetbits_le32
--- u-boot-2014.07/include/fsl_usb.h.orig	2022-05-09 14:06:22.353184961 -0700
+++ u-boot-2014.07/include/fsl_usb.h	2022-05-09 14:06:24.049116365 -0700
@@ -85,4 +85,175 @@
 #define CONFIG_SYS_FSL_USB_SQUELCH_PROG_MASK 0x07
 #endif
 
+/* USB Erratum Checking code */
+#ifdef CONFIG_PPC
+
+static inline bool has_erratum_a006261(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_P1010:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	case SVR_P2041:
+	case SVR_P2040:
+		return IS_SVR_REV(svr, 1, 0) ||
+			IS_SVR_REV(svr, 1, 1) || IS_SVR_REV(svr, 2, 1);
+	case SVR_P3041:
+		return IS_SVR_REV(svr, 1, 0) ||
+			IS_SVR_REV(svr, 1, 1) ||
+			IS_SVR_REV(svr, 2, 0) || IS_SVR_REV(svr, 2, 1);
+	case SVR_P5010:
+	case SVR_P5020:
+	case SVR_P5021:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	case SVR_T4240:
+	case SVR_T4160:
+	case SVR_T4080:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	case SVR_T1040:
+		return IS_SVR_REV(svr, 1, 0);
+	case SVR_T2080:
+	case SVR_T2081:
+		return IS_SVR_REV(svr, 1, 0);
+	case SVR_P5040:
+		return IS_SVR_REV(svr, 1, 0);
+	}
+
+	return false;
+}
+
+static inline bool has_dual_phy(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_T1040:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
+	case SVR_T1023:
+	case SVR_T1024:
+		return IS_SVR_REV(svr, 1, 0);
+	case SVR_T2080:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1) ||
+				IS_SVR_REV(svr, 2, 0);
+	case SVR_T4240:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	}
+
+	return false;
+}
+
+static inline bool has_erratum_a007075(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_B4860:
+	case SVR_B4420:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	case SVR_P1010:
+		return IS_SVR_REV(svr, 1, 0);
+	case SVR_P4080:
+		return IS_SVR_REV(svr, 2, 0) || IS_SVR_REV(svr, 3, 0);
+	}
+	return false;
+}
+
+static inline bool has_erratum_a007798(void)
+{
+	return SVR_SOC_VER(get_svr()) == SVR_T4240 &&
+	IS_SVR_REV(get_svr(), 2, 0);
+}
+
+static inline bool has_erratum_a007792(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_T4240:
+	case SVR_T4160:
+		return IS_SVR_REV(svr, 2, 0);
+	case SVR_T1024:
+		return IS_SVR_REV(svr, 1, 0);
+	case SVR_T1040:
+	case SVR_T2080:
+	case SVR_T2081:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
+	}
+	return false;
+}
+
+static inline bool has_erratum_a004477(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_P1010:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	case SVR_P1022:
+	case SVR_9131:
+	case SVR_9132:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
+	case SVR_P2020:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0) ||
+			IS_SVR_REV(svr, 2, 1);
+	case SVR_B4860:
+	case SVR_B4420:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 2, 0);
+	case SVR_P4080:
+		return IS_SVR_REV(svr, 2, 0) || IS_SVR_REV(svr, 3, 0);
+	}
+
+	return false;
+}
+
+static inline bool has_erratum_a005697(void)
+{
+	u32 svr = get_svr();
+	u32 soc = SVR_SOC_VER(svr);
+
+	switch (soc) {
+	case SVR_9131:
+	case SVR_9132:
+		return IS_SVR_REV(svr, 1, 0) || IS_SVR_REV(svr, 1, 1);
+	}
+	return false;
+}
+
+#else
+
+static inline bool has_erratum_a006261(void)
+{
+	return false;
+}
+
+static inline bool has_erratum_a007075(void)
+{
+	return false;
+}
+
+static inline bool has_erratum_a007798(void)
+{
+	return false;
+}
+
+static inline bool has_erratum_a007792(void)
+{
+	return false;
+}
+static inline bool has_erratum_a004477(void)
+{
+	return false;
+}
+
+static inline bool has_erratum_a005697(void)
+{
+	return false;
+}
+#endif
 #endif /*_ASM_FSL_USB_H_ */
--- u-boot-2014.07/include/phy.h.orig	2022-05-09 14:06:22.389183505 -0700
+++ u-boot-2014.07/include/phy.h	2022-05-09 14:06:24.081115071 -0700
@@ -39,6 +39,7 @@
 	PHY_INTERFACE_MODE_MII,
 	PHY_INTERFACE_MODE_GMII,
 	PHY_INTERFACE_MODE_SGMII,
+	PHY_INTERFACE_MODE_SGMII_2500,
 	PHY_INTERFACE_MODE_QSGMII,
 	PHY_INTERFACE_MODE_TBI,
 	PHY_INTERFACE_MODE_RMII,
@@ -55,6 +56,7 @@
 	[PHY_INTERFACE_MODE_MII]		= "mii",
 	[PHY_INTERFACE_MODE_GMII]		= "gmii",
 	[PHY_INTERFACE_MODE_SGMII]		= "sgmii",
+	[PHY_INTERFACE_MODE_SGMII_2500]		= "sgmii-2500",
 	[PHY_INTERFACE_MODE_QSGMII]		= "qsgmii",
 	[PHY_INTERFACE_MODE_TBI]		= "tbi",
 	[PHY_INTERFACE_MODE_RMII]		= "rmii",
@@ -223,10 +225,12 @@
 
 int phy_atheros_init(void);
 int phy_broadcom_init(void);
+int phy_cortina_init(void);
 int phy_davicom_init(void);
 int phy_et1011c_init(void);
 int phy_lxt_init(void);
 int phy_marvell_init(void);
+int phy_marvell_sw_init(void);
 int phy_micrel_init(void);
 int phy_natsemi_init(void);
 int phy_realtek_init(void);
@@ -237,6 +241,7 @@
 int board_phy_config(struct phy_device *phydev);
 
 /* PHY UIDs for various PHYs that are referenced in external code */
+#define PHY_UID_CS4340  0x13e51002
 #define PHY_UID_TN2020	0x00a19410
 
 #endif
--- u-boot-2014.07/include/miiphy.h.orig	2022-05-09 14:06:22.377183991 -0700
+++ u-boot-2014.07/include/miiphy.h	2022-05-09 14:06:24.069115556 -0700
@@ -120,5 +120,29 @@
 /* phy EXSR */
 #define ESTATUS_1000XF		0x8000
 #define ESTATUS_1000XH		0x4000
+#if defined(CONFIG_M200) || defined(CONFIG_M300)
+#define R_mSMI_REG0          0x0
+#define R_mSMI_REG1          0x1
+#define R_SMI_READ_OPCODE (2<<10)
+#define R_SMI_WRITE_OPCODE (1<<10)
+#define R_SMI_READ_VALID (1<<15)
+#define R_SMI_BUSY  (1<<15)             
+#define R_SMI_22mode    (1<<12)
+#define R_SMI_45mode    0
+#define R_SMI_go        (1<<15) 
+#define SMI_TIMEOUT     1000
+#define DLAY    udelay(1000);
+
+unsigned int SMIRW(
+       int rw,                                 /* 0:read,   1:write */
+       int DevSMIAddr,   /* not used for 1112 type */
+       int Reg,                        /* for all */
+       int Val,
+       int MACchipSmiAddr,
+      int MasterSmiNum,
+       int PortSmiAddr,
+       uint16_t *readVal
+);
+#endif /* CONFIG_M200/M300 */
 
 #endif
--- u-boot-2014.07/include/fm_eth.h.orig	2022-05-09 14:06:22.349185123 -0700
+++ u-boot-2014.07/include/fm_eth.h	2022-05-09 14:06:24.045116527 -0700
@@ -8,8 +8,8 @@
 #define __FM_ETH_H__
 
 #include <common.h>
+#include <phy.h>
 #include <asm/types.h>
-#include <asm/fsl_enet.h>
 
 enum fm_port {
 	FM1_DTSEC1,
@@ -75,6 +75,20 @@
 				offsetof(struct ccsr_fman, memac[n-1]),\
 }
 
+#ifdef CONFIG_FSL_FM_10GEC_REGULAR_NOTATION
+#define FM_TGEC_INFO_INITIALIZER(idx, n) \
+{									\
+	FM_ETH_INFO_INITIALIZER(idx, CONFIG_SYS_FM1_TGEC_MDIO_ADDR)	\
+	.index		= idx,						\
+	.num		= n - 1,					\
+	.type		= FM_ETH_10G_E,					\
+	.port		= FM##idx##_10GEC##n,				\
+	.rx_port_id	= RX_PORT_10G_BASE2 + n - 1,			\
+	.tx_port_id	= TX_PORT_10G_BASE2 + n - 1,			\
+	.compat_offset	= CONFIG_SYS_FSL_FM##idx##_OFFSET +		\
+				 offsetof(struct ccsr_fman, memac[n-1]),\
+}
+#else
 #define FM_TGEC_INFO_INITIALIZER(idx, n) \
 {									\
 	FM_ETH_INFO_INITIALIZER(idx, CONFIG_SYS_FM2_TGEC_MDIO_ADDR)	\
@@ -87,6 +101,7 @@
 	.compat_offset	= CONFIG_SYS_FSL_FM##idx##_OFFSET +		\
 				offsetof(struct ccsr_fman, memac[n-1+8]),\
 }
+#endif
 
 #if (CONFIG_SYS_NUM_FM1_10GEC >= 3)
 #define FM_TGEC_INFO_INITIALIZER2(idx, n) \
--- u-boot-2014.07/include/common.h.orig	2022-05-09 14:06:22.213190623 -0700
+++ u-boot-2014.07/include/common.h	2022-05-09 14:06:23.853124292 -0700
@@ -231,7 +231,7 @@
 
 #if defined(CONFIG_ENV_IS_EMBEDDED)
 #define TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
-#elif ( ((CONFIG_ENV_ADDR+CONFIG_ENV_SIZE) < CONFIG_SYS_MONITOR_BASE) || \
+#elif ( ((CONFIG_ENV_ADDR+CONFIG_ENV_SIZE) <= CONFIG_SYS_MONITOR_BASE) || \
 	(CONFIG_ENV_ADDR >= (CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)) ) || \
       defined(CONFIG_ENV_IS_IN_NVRAM)
 #define	TOTAL_MALLOC_LEN	(CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)
--- u-boot-2014.07/include/version.h.orig	2022-05-09 14:06:22.409182696 -0700
+++ u-boot-2014.07/include/version.h	2022-05-09 14:06:24.093114586 -0700
@@ -14,6 +14,13 @@
 #include "generated/version_autogenerated.h"
 #endif
 
+#ifdef CONFIG_M200
+#define BOARD_VERSION "MB-M200 Ver.T07 2015-07-18"
+#endif
+#ifdef CONFIG_M300
+#define BOARD_VERSION "MB-M300 Ver.T07 2015-03-18"
+#endif
+
 #ifndef CONFIG_IDENT_STRING
 #define CONFIG_IDENT_STRING ""
 #endif
--- u-boot-2014.07/include/post.h.orig	2022-05-09 14:06:22.393183343 -0700
+++ u-boot-2014.07/include/post.h	2022-05-09 14:06:24.081115071 -0700
@@ -38,7 +38,7 @@
 #define _POST_WORD_ADDR	(CONFIG_SYS_IMMR + CPM_POST_WORD_ADDR)
 
 #elif defined(CONFIG_MPC8360)
-#include <asm/immap_qe.h>
+#include <linux/immap_qe.h>
 #define _POST_WORD_ADDR	(CONFIG_SYS_IMMR + CPM_POST_WORD_ADDR)
 
 #elif defined (CONFIG_MPC85xx)
--- u-boot-2014.07/common/cmd_show.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/common/cmd_show.c	2022-05-09 14:06:23.573135617 -0700
@@ -0,0 +1,141 @@
+#include <common.h>
+#include <command.h>
+#include <miiphy.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_RAMBOOT_PBL
+
+static int do_sw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned short value = 0;
+	unsigned short port,addr,reg,data;
+        int vid_1[7]={3, 2, 2, 2, 2, 2, 3};
+        int fid30_1[2]={0x1113, 0x3331};
+        int fid64_1[2]={0x311, 0x133};
+        int timeout;
+	int i;
+
+
+	if (strcmp(argv[1],"write") == 0) {
+		port = simple_strtoul(argv[2], NULL, 16);
+		addr = simple_strtoul(argv[3], NULL, 16);
+		reg = simple_strtoul(argv[4], NULL, 16);
+		data = simple_strtoul(argv[5], NULL, 16);
+		SMIRW(1, 0x10, addr, data, 0, 0, port, 0);
+		printf("W Port=%2x addr=%02x reg=%02x data=%08x\n",
+			port,addr,reg,data);
+	}else if (strcmp(argv[1],"read") == 0) {
+		port = simple_strtoul(argv[2], NULL, 16);
+		addr = simple_strtoul(argv[3], NULL, 16);
+		reg = simple_strtoul(argv[4], NULL, 16);
+		SMIRW(0, 0x10, addr, 0, 0, 0, port, &value);
+		printf("R Port=%2x addr=%02x reg=%02x data=%08x\n",
+			port,addr,reg,value);
+	}else if (strcmp(argv[1],"init") == 0) {
+                DLAY SMIRW(1, 0x10, 4, 0xa000, 0, 0, 0x1b, 0);
+
+                /* set rgmii delay  */
+                DLAY SMIRW(1, 0x10, 1, 0xc03e, 0, 0, 0x15, 0);  /* P15 */
+                DLAY SMIRW(1, 0x10, 1, 0xc03e, 0, 0, 0x16, 0);  /* P16 */
+                /* set LED function */
+                DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x10, 0);/* P0 */
+                DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x11, 0);/* P1 */
+                DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x12, 0);/* P1 */
+                DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x13, 0);/* P3 */
+                DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x14, 0);/* P4 */
+                /* set port to forwarding mode */
+                DLAY SMIRW(1, 0x10, 4, 0x007f, 0, 0, 0x10, 0);
+                DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x11, 0);
+                DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x12, 0);
+                DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x13, 0);
+                DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x14, 0);
+                DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x15, 0);
+                DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x16, 0);
+                /* reset PHY */
+                DLAY SMIRW(1, 0x10, 0 ,0x9140, 0, 0, 0x0, 0);
+                DLAY SMIRW(1, 0x10, 0 ,0x9140, 0, 0, 0x1, 0);
+                DLAY SMIRW(1, 0x10, 0 ,0x9140, 0, 0, 0x2, 0);
+                DLAY SMIRW(1, 0x10, 0 ,0x9140, 0, 0, 0x3, 0);
+                DLAY SMIRW(1, 0x10, 0 ,0x9140, 0, 0, 0x4, 0);
+                DLAY
+                DLAY
+                DLAY
+                /* Default power down mode , to disable */
+                DLAY SMIRW(1, 0x10, 0 ,0x1140, 0, 0, 0x0, 0);
+                DLAY SMIRW(0, 0x10, 0, 0x0, 0, 0, 0x0, &value);
+                printf("Port0 reg0 =%x \n",value);
+
+                DLAY SMIRW(1, 0x10, 0 ,0x1140, 0, 0, 0x1, 0);
+                DLAY SMIRW(0, 0x10, 0, 0x0, 0, 0, 0x1, &value);
+                printf("Port1 reg0 =%x \n",value);
+
+                DLAY SMIRW(1, 0x10, 0 ,0x1140, 0, 0, 0x2, 0);
+                DLAY SMIRW(0, 0x10, 0, 0x0, 0, 0, 0x2, &value);
+                printf("Port2 reg0 =%x \n",value);
+
+                DLAY SMIRW(1, 0x10, 0 ,0x1140, 0, 0, 0x3, 0);
+                DLAY SMIRW(0, 0x10, 0, 0x0, 0, 0, 0x3, &value);
+                printf("Port3 reg0 =%x \n",value);
+
+                DLAY SMIRW(1, 0x10, 0 ,0x1140, 0, 0, 0x4, 0);
+                DLAY SMIRW(0, 0x10, 0, 0x0, 0, 0, 0x4, &value);
+                printf("Port4 reg0 =%x \n",value);
+                printf("Done1\n");
+
+	}else if (strcmp(argv[1],"vlan") == 0) {
+                /* Set Switch 1 address 0x10 */
+                for( i = 0; i< 7 ; i++)
+                {
+                        DLAY SMIRW(1, 0x10, 0x7, vid_1[i], 0, 0,0x10 + i, 0);
+                        DLAY SMIRW(1, 0x10, 0x8, 0x2c80, 0, 0,0x10 + i, 0);
+                DLAY SMIRW(0, 0x10, 0x7, 0x0, 0, 0, 0x10 + i, &value);
+                printf("Port%d reg7 =%x \n",i,value);
+                DLAY SMIRW(0, 0x10, 0x8, 0x0, 0, 0, 0x10 + i, &value);
+                printf("Port%d reg8 =%x \n",i,value);
+                }
+                for( i = 0 ; i < 2 ;i++)
+                {
+                        /* current VID table 3 ~ 0 */
+                        DLAY SMIRW(1, 0x10, 0x7, fid30_1[i], 0, 0,0x1b, 0);
+                        /* current VID table 6 ~ 4 */
+                        DLAY SMIRW(1, 0x10, 0x8, fid64_1[i], 0, 0,0x1b, 0);
+                        /* Set VID ID,Start ID is 2 */
+                        DLAY SMIRW(1, 0x10, 0x6, 0x1002 + i , 0, 0,0x1b, 0);
+                        /* Set multiple address for vid */
+                        DLAY SMIRW(1, 0x10, 0x2, 0x02 + i , 0, 0,0x1b, 0);
+                        /* Store current VID */
+                        DLAY SMIRW(1, 0x10, 0x5, 0xb000, 0, 0,0x1b, 0);
+                        DLAY SMIRW(0, 0x10, 0x5, 0x0000, 0, 0,0x1b, &value);
+                        timeout = 0;
+                        while ( (value & 0x8000 ) != 0 && timeout > 200)
+                        {
+                                DLAY SMIRW(0, 0x10, 0x5, 0x0000, 0, 0,0x1b, &value);
+                                timeout++;
+                        }
+                        if(timeout >= 200 )
+                        {
+                                printf("Switch 0x10 VLAN Table %01d Set timeout \n",i+3);
+                        }
+                }
+
+
+	}
+
+
+	return 1;
+}
+
+
+/***************************************************/
+
+U_BOOT_CMD(
+	sw,	6,	1,	do_sw,
+	"read/write init and vlan",
+	"  - read port addr reg\n"
+	"  - write port addr reg data\n"
+	"  - init  \n"
+	"  - vlan\n"
+);
+
+#endif
--- u-boot-2014.07/common/wgmenu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/common/wgmenu.c	2022-05-09 14:06:23.617133838 -0700
@@ -0,0 +1,183 @@
+#include <common.h>
+#ifndef DO_DEPS_ONLY
+#include "generated/version_autogenerated.h"
+#include "generated/timestamp_autogenerated.h"
+#endif
+#include <wgmenu.h>
+
+#define WG_VERSION_STRING ("WatchGuard " U_BOOT_VERSION " - " U_BOOT_DATE " " U_BOOT_TIME)
+#define ANSI_CLEAR		"\e[2J"
+#define ANSI_REVERSE		"\e[7m"
+#define	ANSI_NORMAL		"\e[m"
+#define ANSI_GOTOYX		"\e[%d;%dH"
+
+#define SCREEN_HIGH		24
+#define SCREEN_WIDTH		80
+#define MAX_MENU_ITEMS		10
+
+#define FIRST_LINE_Y		2
+#define FIRST_LINE_X_FUN(len)	((SCREEN_WIDTH - len)/2)
+#define FIRST_LINE_X		FIRST_LINE_X_FUN(58)
+
+#define TABLE_START_Y		4
+#define TABLE_START_X		2 
+#define TABLE_LENGHT		(SCREEN_WIDTH - 6)
+#define TABLE_HIGH		(SCREEN_HIGH/2)
+
+#define	TOP_ROW			(TABLE_START_X + 1)
+#define	MENU_0_ROW		(TABLE_START_Y + 1)
+
+struct __wgmenu_option {
+	const char *label;		// WG:BH - We really only use the label...
+	void (*fn)(void *user);		// but we could add functionality to add dynamically generated menu items.
+	void *user;			// <<< this one is the argument to fn.
+};
+
+static struct __wgmenu_option wg_options[MAX_MENU_ITEMS];
+static int __wgmenu_max_width = TABLE_LENGHT - 4;
+static int __wgmenu_num_options = 0;
+static int __wgmenu_option_pos = 0;
+static int __wgmenu_boot_menu = 1;
+
+static void __wgmenu_print_option(const struct __wgmenu_option *opt, int reverse)
+{
+	int n = (opt - wg_options);
+	char format[10] = {'\0'};
+
+	printf(ANSI_GOTOYX, MENU_0_ROW+n, TABLE_START_X + 1);
+	if (reverse) {
+		printf(ANSI_REVERSE);
+	}
+
+	sprintf(format, "%%-%ds", __wgmenu_max_width);
+	printf(format, opt->label);
+
+	if (reverse) {
+		printf(ANSI_NORMAL);
+	}
+
+	printf(ANSI_GOTOYX ,SCREEN_HIGH + 2 , 1); 
+}
+
+static void __wgmenu_show_bootmenu_table(void)
+{
+	int i = 0,j = 0 ;
+
+	printf(ANSI_CLEAR ANSI_GOTOYX "%s", FIRST_LINE_Y,
+			(int)FIRST_LINE_X_FUN((strlen(WG_VERSION_STRING))), WG_VERSION_STRING);
+
+	for (i = 0 ; i < TABLE_LENGHT ; i++) {	//the above horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y, TABLE_START_X + i);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	//the left line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	// the right line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X + TABLE_LENGHT);
+	}
+	for (i = 1 ; i < TABLE_LENGHT ; i++) {	//the below horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y + TABLE_HIGH, TABLE_START_X + i);
+	}
+
+	printf(ANSI_GOTOYX "+",TABLE_START_Y, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y , TABLE_START_X + TABLE_LENGHT); 
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X + TABLE_LENGHT);
+
+	printf(ANSI_GOTOYX "Use the ^ and v keys to select which entry is highlighted.",
+			TABLE_START_Y + TABLE_HIGH + 2, 7);
+	printf(ANSI_GOTOYX "Press enter to boot the selected OS.",
+			TABLE_START_Y + TABLE_HIGH + 3, 7);
+
+	printf(ANSI_GOTOYX , SCREEN_HIGH + 2, 1);
+}
+
+static void __wgmenu_show_bootmenu(void)
+{
+	const struct __wgmenu_option *opt = {NULL};
+
+	__wgmenu_show_bootmenu_table();
+
+	for (opt = wg_options; opt != (wg_options + __wgmenu_num_options); opt++) {
+		__wgmenu_print_option(opt, opt == wg_options);
+	}
+}
+
+static int __wgmenu_wg_display_menu(int key)
+{
+	static struct __wgmenu_option *opt = wg_options;
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 0);
+
+	switch (key) {
+		case 65: //up
+			if(__wgmenu_option_pos > 0)
+				__wgmenu_option_pos--;
+			break; 
+		case 66: //down
+			if(__wgmenu_option_pos < (__wgmenu_num_options - 1))
+				__wgmenu_option_pos++;
+			break; 
+		case 13:
+		default:
+			break;
+	}
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 1);
+
+	return opt - wg_options ;
+}
+
+int wgmenu_hook(int key)
+{
+	static const struct __wgmenu_option *opt = wg_options;
+	int hooked = 0;
+
+	if ((key == 65 || key == 66) && opt && __wgmenu_num_options) {
+		hooked = 1;
+		__wgmenu_wg_display_menu(key);
+	}
+
+	return hooked;
+}
+
+
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user)
+{
+	int len;
+
+	wg_options[__wgmenu_num_options].label = label;
+	wg_options[__wgmenu_num_options].fn = fn;
+	wg_options[__wgmenu_num_options].user = user;
+	__wgmenu_num_options++;
+
+	len = strlen(label);
+
+	if (len > __wgmenu_max_width)
+		__wgmenu_max_width = len;
+}
+
+
+void wgmenu_show(void)
+{
+	wgmenu_add("WatchGuard (SYSA)", NULL, NULL);
+	wgmenu_add("WatchGuard (SYSB)", NULL, NULL);
+	wgmenu_add("WatchGuard (SAFE MODE)", NULL, NULL);
+	wgmenu_add("WatchGuard (SYSA BOOTDRIVE)", NULL, NULL);
+	__wgmenu_show_bootmenu();
+}
+
+int wgmenu_selected(void)
+{
+	return __wgmenu_option_pos;
+}
+
+int wgmenu_inmenu(void)
+{
+	return __wgmenu_boot_menu;
+}
+
+void wgmenu_exit(void)
+{
+	__wgmenu_boot_menu = 0;
+}
--- u-boot-2014.07/common/random.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/common/random.c	2022-05-09 14:06:23.585135132 -0700
@@ -0,0 +1,20 @@
+/* concatenation of following two 16-bit multiply with carry generators */
+/* x(n)=a*x(n-1)+carry mod 2^16 and y(n)=b*y(n-1)+carry mod 2^16, */
+/* number and carry packed within the same 32 bit integer.        */
+/******************************************************************/
+
+#include <random.h>
+static unsigned int SEED_X = 521288629;
+static unsigned int SEED_Y = 362436069;
+unsigned int rand_test ()
+{
+	static unsigned int a = 18000, b = 30903;
+	SEED_X = a*(SEED_X&65535) + (SEED_X>>16);
+	SEED_Y = b*(SEED_Y&65535) + (SEED_Y>>16);
+	return ((SEED_X<<16) + (SEED_Y&65535));
+}
+void rand_seed( unsigned int seed1, unsigned int seed2 )
+{
+	if (seed1) SEED_X = seed1;   /* use default seeds if parameter is 0 */
+	if (seed2) SEED_Y = seed2;
+}
--- u-boot-2014.07/tools/env/fw_env.config.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/tools/env/fw_env.config	2022-05-09 14:06:22.481179784 -0700
@@ -0,0 +1,22 @@
+# Configuration file for fw_(printenv/setenv) utility.
+# Up to two entries are valid, in this case the redundant
+# environment sector is assumed present.
+# Notice, that the "Number of sectors" is not required on NOR and SPI-dataflash.
+# Futhermore, if the Flash sector size is ommitted, this value is assumed to
+# be the same as the Environment size, which is valid for NOR and SPI-dataflash
+
+# NOR example
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+/dev/mtd1		0x0000		0x4000		0x4000
+/dev/mtd2		0x0000		0x4000		0x4000
+
+# MTD SPI-dataflash example
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+#/dev/mtd5		0x4200		0x4200
+#/dev/mtd6		0x4200		0x4200
+
+# NAND example
+#/dev/mtd0		0x4000		0x4000		0x20000			2
+
+# Block device example
+#/dev/mmcblk0		0xc0000		0x20000
--- u-boot-2014.07/board/freescale/t104xrdb/diu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t104xrdb/diu.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Author: Priyanka Jain <Priyanka.Jain@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <common.h>
+#include <command.h>
+#include <fsl_diu_fb.h>
+#include <linux/ctype.h>
+#include <video_fb.h>
+
+#include "../common/diu_ch7301.h"
+
+#include "cpld.h"
+#include "t104xrdb.h"
+
+/*
+ * DIU Area Descriptor
+ *
+ * Note that we need to byte-swap the value before it's written to the AD
+ * register. So even though the registers don't look like they're in the same
+ * bit positions as they are on the MPC8610, the same value is written to the
+ * AD register on the MPC8610 and on the P1022.
+ */
+#define AD_BYTE_F		0x10000000
+#define AD_ALPHA_C_SHIFT	25
+#define AD_BLUE_C_SHIFT		23
+#define AD_GREEN_C_SHIFT	21
+#define AD_RED_C_SHIFT		19
+#define AD_PIXEL_S_SHIFT	16
+#define AD_COMP_3_SHIFT		12
+#define AD_COMP_2_SHIFT		8
+#define AD_COMP_1_SHIFT		4
+#define AD_COMP_0_SHIFT		0
+
+void diu_set_pixel_clock(unsigned int pixclock)
+{
+	unsigned long speed_ccb, temp;
+	u32 pixval;
+	int ret;
+
+	speed_ccb = get_bus_freq(0);
+	temp = 1000000000 / pixclock;
+	temp *= 1000;
+	pixval = speed_ccb / temp;
+
+	/* Program HDMI encoder */
+	ret = diu_set_dvi_encoder(temp);
+	if (ret) {
+		puts("Failed to set DVI encoder\n");
+		return;
+	}
+
+	/* Program pixel clock */
+	out_be32((unsigned *)CONFIG_SYS_FSL_SCFG_PIXCLK_ADDR,
+		 ((pixval << PXCK_BITS_START) & PXCK_MASK));
+
+	/* enable clock*/
+	out_be32((unsigned *)CONFIG_SYS_FSL_SCFG_PIXCLK_ADDR, PXCKEN_MASK |
+		 ((pixval << PXCK_BITS_START) & PXCK_MASK));
+}
+
+int platform_diu_init(unsigned int xres, unsigned int yres, const char *port)
+{
+	u32 pixel_format;
+	u8 sw;
+
+	/*Configure Display ouput port as HDMI*/
+	sw = CPLD_READ(sfp_ctl_status);
+	CPLD_WRITE(sfp_ctl_status , sw & ~(CPLD_DIU_SEL_DFP));
+
+	pixel_format = cpu_to_le32(AD_BYTE_F | (3 << AD_ALPHA_C_SHIFT) |
+		(0 << AD_BLUE_C_SHIFT) | (1 << AD_GREEN_C_SHIFT) |
+		(2 << AD_RED_C_SHIFT) | (8 << AD_COMP_3_SHIFT) |
+		(8 << AD_COMP_2_SHIFT) | (8 << AD_COMP_1_SHIFT) |
+		(8 << AD_COMP_0_SHIFT) | (3 << AD_PIXEL_S_SHIFT));
+
+	printf("DIU: Switching to monitor DVI @ %ux%u\n",  xres, yres);
+
+	return fsl_diu_init(xres, yres, pixel_format, 0);
+}
--- u-boot-2014.07/board/freescale/t102xrdb/pci.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/pci.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2007-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/fsl_serdes.h>
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void pci_of_setup(void *blob, bd_t *bd)
+{
+	FT_FSL_PCI_SETUP;
+}
--- u-boot-2014.07/board/freescale/t102xrdb/t102xrdb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/t102xrdb.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,219 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <asm/mpc85xx_gpio.h>
+#include <fm_eth.h>
+#include "t102xrdb.h"
+#include "cpld.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	struct cpu_type *cpu = gd->arch.cpu;
+	static const char *freq[3] = {"100.00MHZ", "125.00MHz", "156.25MHZ"};
+
+	printf("Board: %sRDB, ", cpu->name);
+	printf("Board rev: 0x%02x CPLD ver: 0x%02x, boot from ",
+	       CPLD_READ(hw_ver), CPLD_READ(sw_ver));
+
+#ifdef CONFIG_SDCARD
+	puts("SD/MMC\n");
+#elif CONFIG_SPIFLASH
+	puts("SPI\n");
+#else
+	u8 reg;
+
+	reg = CPLD_READ(flash_csr);
+
+	if (reg & CPLD_BOOT_SEL) {
+		puts("NAND\n");
+	} else {
+		reg = ((reg & CPLD_LBMAP_MASK) >> CPLD_LBMAP_SHIFT);
+		printf("NOR vBank%d\n", reg);
+	}
+#endif
+
+	puts("SERDES Reference Clocks:\n");
+	printf("SD1_CLK1=%s, SD1_CLK2=%s\n", freq[2], freq[0]);
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	u32 reg;
+
+#ifdef CONFIG_SYS_FLASH_BASE
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	int flash_esel = find_tlb_idx((void *)flashbase, 1);
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+	if (flash_esel == -1) {
+		/* very unlikely unless something is messed up */
+		puts("Error: Could not find TLB for FLASH BASE\n");
+		flash_esel = 2;	/* give our best effort to continue */
+	} else {
+		/* invalidate existing TLB entry for flash + promjet */
+		disable_tlb(flash_esel);
+	}
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		0, flash_esel, BOOKE_PAGESZ_256M, 1);
+#endif
+
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+
+	/* Increase IO drive strength to avoid FCS error on RGMII */
+#define IODSECR1_LVDD_VAL  (0x7 << 26)
+#define IODSECR1_L1VDD_VAL (0x7 << 23)
+	reg = in_be32((unsigned *)CONFIG_SYS_FSL_SCFG_IODSECR1_ADDR);
+	reg |= IODSECR1_LVDD_VAL | IODSECR1_L1VDD_VAL;
+	out_be32((unsigned *)CONFIG_SYS_FSL_SCFG_IODSECR1_ADDR, reg);
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	return CONFIG_SYS_CLK_FREQ;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	return CONFIG_DDR_CLK_FREQ;
+}
+
+int misc_init_r(void)
+{
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+	fdt_fixup_dr_usb(blob, bd);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+}
+
+#ifdef CONFIG_DEEP_SLEEP
+void board_mem_sleep_setup(void)
+{
+	/* does not provide HW signals for power management */
+	CPLD_WRITE(misc_ctl_status, (CPLD_READ(misc_ctl_status) & ~0x40));
+	/* Disable MCKE isolation */
+	gpio_set_value(2, 0);
+	udelay(1);
+}
+#endif
+
+#ifdef CONFIG_FSL_DEEP_SLEEP
+/* determine if it is a warm boot */
+bool is_warm_boot(void)
+{
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	if (in_be32(&gur->scrtsr[0]) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_mem_setup(void)
+{
+	/* does not provide HW signals for power management */
+	CPLD_WRITE(misc_ctl_status, (CPLD_READ(misc_ctl_status) & ~0x40));
+	/* Disable MCKE isolation */
+	gpio_set_value(2, 0);
+	udelay(1);
+}
+
+void fsl_dp_ddr_restore(void)
+{
+#define DDR_BUFF_LEN	128
+	volatile u64 *src, *dst;
+	int i;
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	if (!is_warm_boot())
+		return;
+
+	/* get the address of ddr date from SPARECR3 */
+	src = (u64 *)in_be32(&scfg->sparecr[2]);
+	dst = (u64 *)CONFIG_SYS_SDRAM_BASE;
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst++ = *src++;
+
+	flush_dcache();
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	if (!is_warm_boot())
+		return 0;
+
+	fsl_dp_ddr_restore();
+
+	l2cache_init();
+#if defined(CONFIG_RAMBOOT_PBL)
+	disable_cpc_sram();
+#endif
+	enable_cpc();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_be32(&scfg->sparecr[1]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	kernel_resume();
+
+	return 0;
+}
+#endif
--- u-boot-2014.07/board/freescale/t102xrdb/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/law.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+#ifndef CONFIG_SYS_NO_FLASH
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_IFC),
+#endif
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
+#endif
+#ifdef CONFIG_SYS_CPLD_BASE_PHYS
+	SET_LAW(CONFIG_SYS_CPLD_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_4M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2014.07/board/freescale/t102xrdb/cpld.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/cpld.h	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,45 @@
+/**
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+
+struct cpld_data {
+	u8 cpld_ver;		/* 0x00 - CPLD Major Revision Register */
+	u8 cpld_ver_sub;	/* 0x01 - CPLD Minor Revision Register */
+	u8 hw_ver;		/* 0x02 - Hardware Revision Register */
+	u8 sw_ver;		/* 0x03 - Software Revision register */
+	u8 res0[12];		/* 0x04 - 0x0F - not used */
+	u8 reset_ctl1;		/* 0x10 - Reset control Register1 */
+	u8 reset_ctl2;		/* 0x11 - Reset control Register2 */
+	u8 int_status;		/* 0x12 - Interrupt status Register */
+	u8 flash_csr;		/* 0x13 - Flash control and status register */
+	u8 fan_ctl_status;	/* 0x14 - Fan control and status register  */
+	u8 led_ctl_status;	/* 0x15 - LED control and status register */
+	u8 sfp_ctl_status;	/* 0x16 - SFP control and status register  */
+	u8 misc_ctl_status;	/* 0x17 - Miscellanies ctrl & status register*/
+	u8 boot_override;	/* 0x18 - Boot override register */
+	u8 boot_config1;	/* 0x19 - Boot config override register*/
+	u8 boot_config2;	/* 0x1A - Boot config override register*/
+} cpld_data_t;
+
+
+/* Pointer to the CPLD register set */
+
+u8 cpld_read(unsigned int reg);
+void cpld_write(unsigned int reg, u8 value);
+
+#define CPLD_READ(reg) cpld_read(offsetof(struct cpld_data, reg))
+#define CPLD_WRITE(reg, value)\
+		cpld_write(offsetof(struct cpld_data, reg), value)
+
+/* CPLD on IFC */
+#define CPLD_LBMAP_MASK	 0x3F
+#define CPLD_BANK_SEL_MASK      0x07
+#define CPLD_BANK_OVERRIDE      0x40
+#define CPLD_LBMAP_ALTBANK      0x44 /* BANK OR | BANK 4 */
+#define CPLD_LBMAP_DFLTBANK     0x40 /* BANK OR | BANK 0 */
+#define CPLD_LBMAP_RESET	0xFF
+#define CPLD_LBMAP_SHIFT	0x03
+#define CPLD_BOOT_SEL	   0x80
--- u-boot-2014.07/board/freescale/t102xrdb/spl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/spl.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,132 @@
+/* Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <ns16550.h>
+#include <nand.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <spi_flash.h>
+#include <asm/mpc85xx_gpio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+phys_size_t get_effective_memsize(void)
+{
+	return CONFIG_SYS_L3_SIZE;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	return CONFIG_SYS_CLK_FREQ;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	return CONFIG_DDR_CLK_FREQ;
+}
+
+#ifdef CONFIG_FSL_DEEP_SLEEP
+bool is_warm_boot(void)
+{
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	if (in_be32(&gur->scrtsr[0]) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_mem_setup(void)
+{
+	void __iomem *cpld_base = (void *)CONFIG_SYS_CPLD_BASE;
+
+	/* does not provide HW signals for power management */
+	clrbits_8(cpld_base + 0x17, 0x40);
+	/* Disable MCKE isolation */
+	gpio_set_value(2, 0);
+	udelay(1);
+}
+#endif
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio, sys_clk, ccb_clk;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	/* Memcpy existing GD at CONFIG_SPL_GD_ADDR */
+	memcpy((void *)CONFIG_SPL_GD_ADDR, (void *)gd, sizeof(gd_t));
+
+	/* Update GD pointer */
+	gd = (gd_t *)(CONFIG_SPL_GD_ADDR);
+
+	console_init_f();
+
+	/* initialize selected port with appropriate baud rate */
+	sys_clk = get_board_sys_clk();
+	plat_ratio = (in_be32(&gur->rcwsr[0]) >> 25) & 0x1f;
+	ccb_clk = sys_clk * plat_ratio / 2;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+		     ccb_clk / 16 / CONFIG_BAUDRATE);
+
+#if defined(CONFIG_SPL_MMC_BOOT)
+	puts("\nSD boot...\n");
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	puts("\nSPI boot...\n");
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	puts("\nNAND boot...\n");
+#endif
+
+	relocate_code(CONFIG_SPL_RELOC_STACK, (gd_t *)CONFIG_SPL_GD_ADDR, 0x0);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	bd_t *bd;
+
+	bd = (bd_t *)(gd + sizeof(gd_t));
+	memset(bd, 0, sizeof(bd_t));
+	gd->bd = bd;
+	bd->bi_memstart = CONFIG_SYS_INIT_L3_ADDR;
+	bd->bi_memsize = CONFIG_SYS_L3_SIZE;
+
+	probecpu();
+	get_clocks();
+	mem_malloc_init(CONFIG_SPL_RELOC_MALLOC_ADDR,
+			CONFIG_SPL_RELOC_MALLOC_SIZE);
+
+#ifdef CONFIG_SPL_NAND_BOOT
+	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			    (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_initialize(bd);
+	mmc_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_SPI_BOOT
+	spi_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+
+	gd->env_addr  = (ulong)(CONFIG_ENV_ADDR);
+	gd->env_valid = 1;
+
+	i2c_init_all();
+
+	gd->ram_size = initdram(0);
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_boot();
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	spi_boot();
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	nand_boot();
+#endif
+}
--- u-boot-2014.07/board/freescale/t102xrdb/t1024_rcw.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/t1024_rcw.cfg	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,8 @@
+#PBL preamble and RCW header for T1024RDB
+aa55aa55 010e0100
+#SerDes Protocol: 0x95
+#Core/DDR: 1400Mhz/1600MT/s with single source clock
+0810000c 00000000 00000000 00000000
+4a800003 80000012 ec027000 21000000
+00000000 00000000 00000000 00030810
+00000000 0b005a08 00000000 00000006
--- u-boot-2014.07/board/freescale/t102xrdb/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/tlb.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L3_ADDR)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 256K SRAM, the address of the
+	 * SRAM is at 0xfffc0000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_256K, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+#ifndef CONFIG_SPL_BUILD
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256K, 1),
+
+	/* Bman/Qman */
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 5, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 7, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 8, BOOKE_PAGESZ_16M, 1),
+#endif
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 9, BOOKE_PAGESZ_4M, 1),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_64K, 1),
+#endif
+#ifdef CONFIG_SYS_CPLD_BASE
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 11, BOOKE_PAGESZ_256K, 1),
+#endif
+
+#if defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SPL_BUILD)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 12, BOOKE_PAGESZ_1G, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		      CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 13, BOOKE_PAGESZ_1G, 1)
+#endif
+	/* entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so if needed more, will use entry 16 later.
+	 */
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2014.07/board/freescale/t102xrdb/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/README	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,258 @@
+T1024 SoC Overview
+------------------
+The T1024/T1023 dual core and T1014/T1013 single core QorIQ communication processor
+combines two or one 64-bit Power Architecture e5500 core respectively with high
+performance datapath acceleration logic, and network peripheral bus interfaces
+required for networking and telecommunications. This processor can be used in
+applications such as enterprise WLAN access points, routers, switches, firewall
+and other packet processing intensive small enterprise and branch office appliances,
+and general-purpose embedded computing. Its high level of integration offers
+significant performance benefits and greatly helps to simplify board design.
+
+
+The T1024 SoC includes the following function and features:
+- two e5500 cores, each with a private 256 KB L2 cache
+  - Up to 1.4 GHz with 64-bit ISA support (Power Architecture v2.06-compliant)
+  - Three levels of instructions: User, supervisor, and hypervisor
+  - Independent boot and reset
+  - Secure boot capability
+- 256 KB shared L3 CoreNet platform cache (CPC)
+- Interconnect CoreNet platform
+  - CoreNet coherency manager supporting coherent and noncoherent transactions
+    with prioritization and bandwidth allocation amongst CoreNet endpoints
+  - 150 Gbps coherent read bandwidth
+- 32-/64-bit DDR3L/DDR4 SDRAM memory controller with ECC and interleaving support
+- Data Path Acceleration Architecture (DPAA) incorporating acceleration for the following functions:
+  - Packet parsing, classification, and distribution
+  - Queue management for scheduling, packet sequencing, and congestion management
+  - Cryptography Acceleration (SEC 5.x)
+  - IEEE 1588 support
+  - Hardware buffer management for buffer allocation and deallocation
+  - MACSEC on DPAA-based Ethernet ports
+- Ethernet interfaces
+  - Four 1 Gbps Ethernet controllers
+- Parallel Ethernet interfaces
+  - Two RGMII interfaces
+- High speed peripheral interfaces
+  - Three PCI Express 2.0 controllers/ports running at up to 5 GHz
+  - One SATA controller supporting 1.5 and 3.0 Gb/s operation
+  - One QSGMII interface
+  - Four SGMII interface supporting 1000 Mbps
+  - Three SGMII interfaces supporting up to 2500 Mbps
+  - 10GbE XFI or 10Base-KR interface
+- Additional peripheral interfaces
+  - Two USB 2.0 controllers with integrated PHY
+  - SD/eSDHC/eMMC
+  - eSPI controller
+  - Four I2C controllers
+  - Four UARTs
+  - Four GPIO controllers
+  - Integrated flash controller (IFC)
+  - LCD interface (DIU) with 12 bit dual data rate
+- Multicore programmable interrupt controller (PIC)
+- Two 8-channel DMA engines
+- Single source clocking implementation
+- Deep Sleep power implementaion (wakeup from GPIO/Timer/Ethernet/USB)
+- QUICC Engine block
+  - 32-bit RISC controller for flexible support of the communications peripherals
+  - Serial DMA channel for receive and transmit on all serial channels
+  - Two universal communication controllers, supporting TDM, HDLC, and UART
+
+T1023 Personality
+------------------
+T1023 is a reduced personality of T1024 without QUICC Engine, DIU, and
+unavailable deep sleep. Rest of the blocks are almost same as T1024.
+Differences between T1024 and T1023
+Feature		T1024  T1023
+QUICC Engine:	yes    no
+DIU:		yes    no
+Deep Sleep:	yes    no
+I2C controller: 4      3
+DDR:		64-bit 32-bit
+IFC:		32-bit 28-bit
+
+
+T1024RDB board Overview
+-----------------------
+ - Ethernet
+     - Two on-board 10M/100M/1G bps RGMII ethernet ports
+     - One on-board 10G bps Base-T port.
+ - DDR Memory
+     - Supports 64-bit 4GB DDR3L DIMM
+ - PCIe
+     - One on-board PCIe slot.
+     - Two on-board PCIe Mini-PCIe connectors.
+ - IFC/Local Bus
+     - NOR:  128MB 16-bit NOR Flash
+     - NAND: 1GB 8-bit NAND flash
+     - CPLD: for system controlling with programable header on-board
+ - USB
+     - Supports two USB 2.0 ports with integrated PHYs
+     - Two type A ports with 5V@1.5A per port.
+ - SDHC
+     - one SD connector supporting 1.8V/3.3V via J53.
+ - SPI
+     -  On-board 64MB SPI flash
+ - Other
+     - Two Serial ports
+     - Four I2C ports
+
+
+Memory map on T1024RDB
+----------------------
+Start Address  End Address      Description			Size
+0xF_FFDF_0000  0xF_FFDF_0FFF    IFC - CPLD			4KB
+0xF_FF80_0000  0xF_FF80_FFFF    IFC - NAND Flash		64KB
+0xF_FE00_0000  0xF_FEFF_FFFF    CCSRBAR				16MB
+0xF_F802_0000  0xF_F802_FFFF    PCI Express 3 I/O Space		64KB
+0xF_F801_0000  0xF_F801_FFFF    PCI Express 2 I/O Space		64KB
+0xF_F800_0000  0xF_F800_FFFF    PCI Express 1 I/O Space		64KB
+0xF_F600_0000  0xF_F7FF_FFFF    Queue manager software portal   32MB
+0xF_F400_0000  0xF_F5FF_FFFF    Buffer manager software portal  32MB
+0xF_E800_0000  0xF_EFFF_FFFF    IFC - NOR Flash			128MB
+0xF_0000_0000  0xF_003F_FFFF    DCSR				4MB
+0xC_2000_0000  0xC_2FFF_FFFF    PCI Express 3 Mem Space		256MB
+0xC_1000_0000  0xC_1FFF_FFFF    PCI Express 2 Mem Space		256MB
+0xC_0000_0000  0xC_0FFF_FFFF    PCI Express 1 Mem Space		256MB
+0x0_0000_0000  0x0_ffff_ffff    DDR				4GB
+
+
+128MB NOR Flash memory Map
+--------------------------
+Start Address   End Address     Definition			Max size
+0xEFF40000      0xEFFFFFFF      u-boot (current bank)		768KB
+0xEFF20000      0xEFF3FFFF      u-boot env (current bank)	128KB
+0xEFF00000      0xEFF1FFFF      FMAN Ucode (current bank)	128KB
+0xEFE00000      0xEFE3FFFF      QE firmware (current bank)	256KB
+0xED300000      0xEFEFFFFF      rootfs (alt bank)		44MB
+0xEC800000      0xEC8FFFFF      Hardware device tree (alt bank) 1MB
+0xEC020000      0xEC7FFFFF      Linux.uImage (alt bank)		7MB + 875KB
+0xEC000000      0xEC01FFFF      RCW (alt bank)			128KB
+0xEBF40000      0xEBFFFFFF      u-boot (alt bank)		768KB
+0xEBF20000      0xEBF3FFFF      u-boot env (alt bank)		128KB
+0xEBF00000      0xEBF1FFFF      FMAN ucode (alt bank)		128KB
+0xEBE00000      0xEBE3FFFF      QE firmware (alt bank)		256KB
+0xE9300000      0xEBEFFFFF      rootfs (current bank)		44MB
+0xE8800000      0xE88FFFFF      Hardware device tree (cur bank) 1MB
+0xE8020000      0xE86FFFFF      Linux.uImage (current bank)	7MB + 875KB
+0xE8000000      0xE801FFFF      RCW (current bank)		128KB
+
+
+T1024 Clock frequency
+---------------------
+BIN   Core     DDR       Platform  FMan
+Bin1: 1400MHz  1600MT/s  400MHz    700MHz
+Bin2: 1200MHz  1600MT/s  400MHz    600MHz
+Bin3: 1000MHz  1600MT/s  400MHz    500MHz
+
+
+Software configurations and board settings
+------------------------------------------
+1. NOR boot:
+   a. build NOR boot image
+	$  make T1024RDB_config
+	$  make
+   b. program u-boot.bin image to NOR flash
+	=> tftp 1000000 u-boot.bin
+	=> pro off all;era eff40000 efffffff;cp.b 1000000 eff40000 $filesize
+	set SW1[1:8] = '00010011', SW2[1] = '1', SW3[4] = '0' for NOR boot
+
+   Switching between default bank0 and alternate bank4 on NOR flash
+   To change boot source to vbank4:
+        via software:   run command 'cpld reset altbank' in u-boot.
+        via DIP-switch: set SW3[5:7] = '100'
+
+   To change boot source to vbank0:
+        via software:   run command 'cpld reset' in u-boot.
+        via DIP-Switch: set SW3[5:7] = '000'
+
+2. NAND Boot:
+   a. build PBL image for NAND boot
+	$ make T1024RDB_NAND_config
+	$ make
+   b. program u-boot-with-spl-pbl.bin to NAND flash
+	=> tftp 1000000 u-boot-with-spl-pbl.bin
+	=> nand erase 0 $filesize
+	=> nand write 1000000 0 $filesize
+	set SW1[1:8] = '10001000', SW2[1] = '1', SW3[4] = '1' for NAND boot
+
+3. SPI Boot:
+   a. build PBL image for SPI boot
+	$ make T1024RDB_SPIFLASH_config
+	$ make
+   b. program u-boot-with-spl-pbl.bin to SPI flash
+	=> tftp 1000000 u-boot-with-spl-pbl.bin
+	=> sf probe 0
+	=> sf erase 0 f0000
+	=> sf write 1000000 0 $filesize
+	set SW1[1:8] = '00100010', SW2[1] ='1' for SPI boot
+
+4. SD Boot:
+   a. build PBL image for SD boot
+	$ make T1024RDB_SDCARD_config
+	$ make
+   b. program u-boot-with-spl-pbl.bin to SD/MMC card
+	=> tftp 1000000 u-boot-with-spl-pbl.bin
+	=> mmc write 1000000 8 0x800
+	=> tftp 1000000 fsl_fman_ucode_t1024_xx.bin
+	=> mmc write 1000000 0x820 80
+	set SW1[1:8] = '00100000', SW2[1] = '0' for SD boot
+
+
+2-stage NAND/SPI/SD boot loader
+-------------------------------
+PBL initializes the internal CPC-SRAM and copy SPL(160K) to SRAM.
+SPL further initializes DDR using SPD and environment variables
+and copy u-boot(768 KB) from NAND/SPI/SD device to DDR.
+Finally SPL transers control to u-boot for futher booting.
+
+SPL has following features:
+ - Executes within 256K
+ - No relocation required
+
+Run time view of SPL framework
+-------------------------------------------------
+|Area		   | Address			|
+-------------------------------------------------
+|SecureBoot header | 0xFFFC0000 (32KB)		|
+-------------------------------------------------
+|GD, BD		   | 0xFFFC8000 (4KB)		|
+-------------------------------------------------
+|ENV		   | 0xFFFC9000 (8KB)		|
+-------------------------------------------------
+|HEAP		   | 0xFFFCB000 (30KB)		|
+-------------------------------------------------
+|STACK		   | 0xFFFD8000 (22KB)		|
+-------------------------------------------------
+|U-boot SPL	   | 0xFFFD8000 (160KB)		|
+-------------------------------------------------
+
+NAND Flash memory Map on T1024RDB
+-------------------------------------------------------------
+Start		End		Definition	Size
+0x000000	0x0FFFFF	u-boot		1MB(2 block)
+0x100000	0x17FFFF	u-boot env	512KB(1 block)
+0x180000	0x1FFFFF	FMAN Ucode	512KB(1 block)
+0x200000	0x27FFFF	QE Firmware	512KB(1 block)
+
+
+SD Card memory Map on T1024RDB
+----------------------------------------------------
+Block		#blocks		Definition	Size
+0x008		2048		u-boot img	1MB
+0x800		0016		u-boot env	8KB
+0x820		0256		FMAN Ucode	128KB
+0x920		0256		QE Firmware	128KB
+
+
+SPI Flash memory Map on T1024RDB
+----------------------------------------------------
+Start		End		Definition	Size
+0x000000	0x0FFFFF	u-boot img	1MB
+0x100000	0x101FFF	u-boot env	8KB
+0x110000	0x12FFFF	FMAN Ucode	128KB
+0x130000	0x14FFFF	QE Firmware	128KB
+
+
+For more details, please refer to T1024RDB Reference Manual and access
+website www.freescale.com and Freescale QorIQ SDK Infocenter document.
--- u-boot-2014.07/board/freescale/t102xrdb/eth_t102xrdb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/eth_t102xrdb.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <malloc.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <asm/fsl_dtsec.h>
+#include <asm/fsl_serdes.h>
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_FMAN_ENET)
+	int i, interface;
+	struct memac_mdio_info dtsec_mdio_info;
+	struct memac_mdio_info tgec_mdio_info;
+	struct mii_dev *dev;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 srds_s1;
+
+	srds_s1 = in_be32(&gur->rcwsr[4]) &
+					FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	srds_s1 >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	dtsec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the 1G MDIO bus */
+	fm_memac_mdio_init(bis, &dtsec_mdio_info);
+
+	tgec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tgec_mdio_info);
+
+	/* Set the two on-board RGMII PHY address */
+	fm_info_set_phy_address(FM1_DTSEC3, RGMII_PHY2_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC4, RGMII_PHY1_ADDR);
+
+	switch (srds_s1) {
+	case 0x95:
+		/* 10G XFI with Aquantia PHY */
+		fm_info_set_phy_address(FM1_10GEC1, FM1_10GEC1_PHY_ADDR);
+		break;
+	default:
+		printf("SerDes protocol 0x%x is not supported on T102xRDB\n",
+		       srds_s1);
+		break;
+	}
+
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		interface = fm_info_get_enet_if(i);
+		switch (interface) {
+		case PHY_INTERFACE_MODE_RGMII:
+			dev = miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME);
+			fm_info_set_mdio(i, dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	for (i = FM1_10GEC1; i < FM1_10GEC1 + CONFIG_SYS_NUM_FM1_10GEC; i++) {
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_XGMII:
+			dev = miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME);
+			fm_info_set_mdio(i, dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	cpu_eth_init(bis);
+#endif /* CONFIG_FMAN_ENET */
+
+	return pci_eth_init(bis);
+}
+
+void fdt_fixup_board_enet(void *fdt)
+{
+	return;
+}
--- u-boot-2014.07/board/freescale/t102xrdb/cpld.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/cpld.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,103 @@
+/**
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Freescale T1024RDB board-specific CPLD controlling supports.
+ *
+ * The following macros need to be defined:
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include "cpld.h"
+
+u8 cpld_read(unsigned int reg)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	return in_8(p + reg);
+}
+
+void cpld_write(unsigned int reg, u8 value)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	out_8(p + reg, value);
+}
+
+/**
+ * Set the boot bank to the alternate bank
+ */
+void cpld_set_altbank(void)
+{
+	u8 reg = CPLD_READ(flash_csr);
+
+	reg = (reg & ~CPLD_BANK_SEL_MASK) | CPLD_LBMAP_ALTBANK;
+
+	CPLD_WRITE(flash_csr, reg);
+	CPLD_WRITE(reset_ctl1, CPLD_LBMAP_RESET);
+}
+
+/**
+ * Set the boot bank to the default bank
+ */
+void cpld_set_defbank(void)
+{
+	u8 reg = CPLD_READ(flash_csr);
+
+	reg = (reg & ~CPLD_BANK_SEL_MASK) | CPLD_LBMAP_DFLTBANK;
+
+	CPLD_WRITE(flash_csr, reg);
+	CPLD_WRITE(reset_ctl1, CPLD_LBMAP_RESET);
+}
+
+static void cpld_dump_regs(void)
+{
+	printf("cpld_ver	 = 0x%02x\n", CPLD_READ(cpld_ver));
+	printf("cpld_ver_sub	 = 0x%02x\n", CPLD_READ(cpld_ver_sub));
+	printf("hw_ver		 = 0x%02x\n", CPLD_READ(hw_ver));
+	printf("sw_ver		 = 0x%02x\n", CPLD_READ(sw_ver));
+	printf("reset_ctl1	 = 0x%02x\n", CPLD_READ(reset_ctl1));
+	printf("reset_ctl2	 = 0x%02x\n", CPLD_READ(reset_ctl2));
+	printf("int_status	 = 0x%02x\n", CPLD_READ(int_status));
+	printf("flash_csr	 = 0x%02x\n", CPLD_READ(flash_csr));
+	printf("fan_ctl_status	 = 0x%02x\n", CPLD_READ(fan_ctl_status));
+	printf("led_ctl_status	 = 0x%02x\n", CPLD_READ(led_ctl_status));
+	printf("sfp_ctl_status	 = 0x%02x\n", CPLD_READ(sfp_ctl_status));
+	printf("misc_ctl_status	 = 0x%02x\n", CPLD_READ(misc_ctl_status));
+	printf("boot_override	 = 0x%02x\n", CPLD_READ(boot_override));
+	printf("boot_config1	 = 0x%02x\n", CPLD_READ(boot_config1));
+	printf("boot_config2	 = 0x%02x\n", CPLD_READ(boot_config2));
+	putc('\n');
+}
+
+int do_cpld(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rc = 0;
+
+	if (argc <= 1)
+		return cmd_usage(cmdtp);
+
+	if (strcmp(argv[1], "reset") == 0) {
+		if (strcmp(argv[2], "altbank") == 0)
+			cpld_set_altbank();
+		else
+			cpld_set_defbank();
+	} else if (strcmp(argv[1], "dump") == 0) {
+		cpld_dump_regs();
+	} else {
+		rc = cmd_usage(cmdtp);
+	}
+
+	return rc;
+}
+
+U_BOOT_CMD(
+	cpld, CONFIG_SYS_MAXARGS, 1, do_cpld,
+	"Reset the board or alternate bank",
+	"reset - hard reset to default bank\n"
+	"cpld reset altbank - reset to alternate bank\n"
+	"cpld dump - display the CPLD registers\n"
+	);
--- u-boot-2014.07/board/freescale/t102xrdb/t102xrdb.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/t102xrdb.h	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __T1024_RDB_H__
+#define __T1024_RDB_H__
+
+void fdt_fixup_board_enet(void *blob);
+void pci_of_setup(void *blob, bd_t *bd);
+
+#endif
--- u-boot-2014.07/board/freescale/t102xrdb/t1024_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/t1024_pbi.cfg	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,26 @@
+#PBI commands
+#Initialize CPC1
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+#Configure CPC1 as 256KB SRAM
+09010100 00000000
+09010104 fffc0007
+09010f00 08000000
+09010000 80000000
+#Configure LAW for CPC1
+09000cd0 00000000
+09000cd4 fffc0000
+09000cd8 81000011
+#Configure alternate space
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+#Configure SPI controller
+09110000 80000403
+09110020 2d170008
+09110024 00100008
+09110028 00100008
+0911002c 00100008
+#Flush PBL data
+091380c0 000FFFFF
--- u-boot-2014.07/board/freescale/t102xrdb/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/ddr.c	2022-05-09 14:06:23.353144515 -0700
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * datarate_mhz_high values need to be in ascending order
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl |
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |
+	 */
+	{2,  833,   0,  4,  6,  0x06060607,  0x08080807,},
+	{2,  1350,  0,  4,  7,  0x0708080A,  0x0A0B0C09,},
+	{2,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},
+	{1,  833,   0,  4,  6,  0x06060607,  0x08080807,},
+	{1,  1350,  0,  4,  7,  0x0708080A,  0x0A0B0C09,},
+	{1,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+	struct cpu_type *cpu = gd->arch.cpu;
+
+	if (ctrl_num > 1) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+	/* Get clk_adjust according to the board ddr freqency and n_banks
+	 * specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks &&
+		    (pdimm->rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found\n");
+		printf("for data rate %lu MT/s\n", ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n",
+	      pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb);
+	debug("\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, ",
+	      pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2);
+	debug("wrlvl_ctrl_3 0x%x\n", pbsp->wrlvl_ctl_3);
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * rtt and rtt_wr override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_OFF);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_OFF);
+
+	/* T1023 supports max DDR bus 32bit width, T1024 supports DDR 64bit,
+	 * force DDR bus width to 32bit for T1023
+	 */
+	if (cpu->soc_ver == SVR_T1023)
+		popts->data_bus_width = DDR_DATA_BUS_WIDTH_32;
+
+#ifdef CONFIG_FORCE_DDR_DATA_BUS_WIDTH_32
+	/* for DDR bus 32bit test on T1024 */
+	popts->data_bus_width = DDR_DATA_BUS_WIDTH_32;
+#endif
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_RAMBOOT_PBL)
+	puts("Initializing....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+#else
+	/* DDR has been initialised by first stage boot loader */
+	dram_size =  fsl_ddr_sdram_size();
+#endif
+	return dram_size;
+}
--- u-boot-2014.07/board/freescale/t102xrdb/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xrdb/Makefile	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,17 @@
+#
+# Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+else
+obj-y   += t102xrdb.o
+obj-y   += cpld.o
+obj-y   += eth_t102xrdb.o
+obj-$(CONFIG_PCI)       += pci.o
+endif
+obj-y   += ddr.o
+obj-y   += law.o
+obj-y   += tlb.o
--- u-boot-2014.07/board/freescale/ls1021aqds/ls102xa_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/ls102xa_pbi.cfg	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,12 @@
+#PBI commands
+
+09570200 ffffffff
+09570158 00000300
+8940007c 21f47300
+
+#Configure Scratch register
+09ee0200 10000000
+#Configure alternate space
+09570158 00001000
+#Flush PBL data
+096100c0 000FFFFF
--- u-boot-2014.07/board/freescale/ls1021aqds/ls1021aqds_qixis.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/ls1021aqds_qixis.h	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS1021AQDS_QIXIS_H__
+#define __LS1021AQDS_QIXIS_H__
+
+/* Definitions of QIXIS Registers for LS1021AQDS */
+
+/* BRDCFG4[4:7]] select EC1 and EC2 as a pair */
+#define BRDCFG4_EMISEL_MASK		0xe0
+#define BRDCFG4_EMISEL_SHIFT		5
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+#define QIXIS_SYSCLK_64			0x8
+
+/* DDRCLK */
+#define QIXIS_DDRCLK_66			0x0
+#define QIXIS_DDRCLK_100		0x1
+#define QIXIS_DDRCLK_125		0x2
+#define QIXIS_DDRCLK_133		0x3
+
+#define QIXIS_SRDS1CLK_100		0x0
+
+#endif
--- u-boot-2014.07/board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# serdes protocol
+0608000a 00000000 00000000 00000000
+60000000 00407900 e0106a00 21046000
+00000000 00000000 00000000 00038000
+00000000 001b7200 00000000 00000000
--- u-boot-2014.07/board/freescale/ls1021aqds/ddr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/ddr.h	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+	u32 cpo_override;
+	u32 write_data_delay;
+	u32 force_2t;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+	{1,  833,  1, 6,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{1,  1350, 1, 6,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{1,  833,  2, 6,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{1,  1350, 2, 6,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  833,  4, 6,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{2,  1350, 4, 6,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  1350, 0, 6,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  1666, 4, 4,   0xa, 0x0B08090C, 0x0B0E0D0A,   0x1f,    2,  0},
+	{2,  1666, 0, 4,   0xa, 0x0B08090C, 0x0B0E0D0A,   0x1f,    2,  0},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+#endif
--- u-boot-2014.07/board/freescale/ls1021aqds/eth.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/eth.c	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,186 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * This file handles the board muxing between the RGMII/SGMII PHYs on
+ * Freescale LS1021AQDS board. The RGMII PHYs are the three on-board 1Gb
+ * ports. The SGMII PHYs are provided by the standard Freescale four-port
+ * SGMII riser card.
+ *
+ * Muxing is handled via the PIXIS BRDCFG4 register. The EMI1 bits control
+ * muxing among the RGMII PHYs and the SGMII PHYs. The value for RGMII depends
+ * on which port is used. The value for SGMII depends on which slot the riser
+ * is inserted in.
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/arch/fsl_serdes.h>
+#include <fsl_mdio.h>
+#include <tsec.h>
+#include <malloc.h>
+
+#include "../common/sgmii_riser.h"
+#include "../common/qixis.h"
+
+#define EMI1_MASK       0x1f
+#define EMI1_RGMII0     1
+#define EMI1_RGMII1     2
+#define EMI1_RGMII2     3
+#define EMI1_SGMII1     0x1c
+#define EMI1_SGMII2     0x1d
+
+struct ls1021a_mdio {
+	struct mii_dev *realbus;
+};
+
+static void ls1021a_mux_mdio(int addr)
+{
+	u8 brdcfg4;
+
+	brdcfg4 = QIXIS_READ(brdcfg[4]);
+	brdcfg4 &= EMI1_MASK;
+
+	switch (addr) {
+	case EMI1_RGMII0:
+		brdcfg4 |= 0;
+		break;
+	case EMI1_RGMII1:
+		brdcfg4 |= 0x20;
+		break;
+	case EMI1_RGMII2:
+		brdcfg4 |= 0x40;
+		break;
+	case EMI1_SGMII1:
+		brdcfg4 |= 0x60;
+		break;
+	case EMI1_SGMII2:
+		brdcfg4 |= 0x80;
+		break;
+	default:
+		brdcfg4 |= 0xa0;
+		break;
+	}
+
+	QIXIS_WRITE(brdcfg[4], brdcfg4);
+}
+
+static int ls1021a_mdio_read(struct mii_dev *bus, int addr, int devad,
+			     int regnum)
+{
+	struct ls1021a_mdio *priv = bus->priv;
+
+	ls1021a_mux_mdio(addr);
+
+	return priv->realbus->read(priv->realbus, addr, devad, regnum);
+}
+
+static int ls1021a_mdio_write(struct mii_dev *bus, int addr, int devad,
+			      int regnum, u16 value)
+{
+	struct ls1021a_mdio *priv = bus->priv;
+
+	ls1021a_mux_mdio(addr);
+
+	return priv->realbus->write(priv->realbus, addr, devad, regnum, value);
+}
+
+static int ls1021a_mdio_reset(struct mii_dev *bus)
+{
+	struct ls1021a_mdio *priv = bus->priv;
+
+	return priv->realbus->reset(priv->realbus);
+}
+
+static int ls1021a_mdio_init(char *realbusname, char *fakebusname)
+{
+	struct ls1021a_mdio *lsmdio;
+	struct mii_dev *bus = mdio_alloc();
+
+	if (!bus) {
+		printf("Failed to allocate LS102xA MDIO bus\n");
+		return -1;
+	}
+
+	lsmdio = malloc(sizeof(*lsmdio));
+	if (!lsmdio) {
+		printf("Failed to allocate LS102xA private data\n");
+		free(bus);
+		return -1;
+	}
+
+	bus->read = ls1021a_mdio_read;
+	bus->write = ls1021a_mdio_write;
+	bus->reset = ls1021a_mdio_reset;
+	sprintf(bus->name, fakebusname);
+
+	lsmdio->realbus = miiphy_get_dev_by_name(realbusname);
+
+	if (!lsmdio->realbus) {
+		printf("No bus with name %s\n", realbusname);
+		free(bus);
+		free(lsmdio);
+		return -1;
+	}
+
+	bus->priv = lsmdio;
+
+	return mdio_register(bus);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	struct fsl_pq_mdio_info mdio_info;
+	struct tsec_info_struct tsec_info[3];
+	int num = 0;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	if (is_serdes_configured(SGMII_TSEC1)) {
+		puts("eTSEC1 is in sgmii mode\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+		tsec_info[num].mii_devname = "LS1021A_SGMII_MDIO";
+	} else {
+		tsec_info[num].mii_devname = "LS1021A_RGMII_MDIO";
+	}
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	if (is_serdes_configured(SGMII_TSEC2)) {
+		puts("eTSEC2 is in sgmii mode\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+		tsec_info[num].mii_devname = "LS1021A_SGMII_MDIO";
+	} else {
+		tsec_info[num].mii_devname = "LS1021A_RGMII_MDIO";
+	}
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	SET_STD_TSEC_INFO(tsec_info[num], 3);
+	tsec_info[num].mii_devname = "LS1021A_RGMII_MDIO";
+	num++;
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+#ifdef CONFIG_FSL_SGMII_RISER
+	fsl_sgmii_riser_init(tsec_info, num);
+#endif
+
+	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+	mdio_info.name = DEFAULT_MII_NAME;
+
+	fsl_pq_mdio_init(bis, &mdio_info);
+
+	/* Register the virtual MDIO front-ends */
+	ls1021a_mdio_init(DEFAULT_MII_NAME, "LS1021A_RGMII_MDIO");
+	ls1021a_mdio_init(DEFAULT_MII_NAME, "LS1021A_SGMII_MDIO");
+
+	tsec_eth_init(bis, tsec_info, num);
+
+	return pci_eth_init(bis);
+}
--- u-boot-2014.07/board/freescale/ls1021aqds/MAINTAINERS.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/MAINTAINERS	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,6 @@
+LS1021AQDS BOARD
+M:	Alison Wang <alison.wang@freescale.com>
+S:	Maintained
+F:	board/freescale/ls1021aqds/
+F:	include/configs/ls1021aqds.h
+F:	configs/ls1021aqds_nor_defconfig
--- u-boot-2014.07/board/freescale/ls1021aqds/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/README	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,112 @@
+Overview
+--------
+The LS1021AQDS is a Freescale reference board that hosts the LS1021A SoC.
+
+LS1021A SoC Overview
+------------------
+The QorIQ LS1 family, which includes the LS1021A communications processor,
+is built on Layerscape architecture, the industry's first software-aware,
+core-agnostic networking architecture to offer unprecedented efficiency
+and scale.
+
+A member of the value-performance tier, the QorIQ LS1021A processor provides
+extensive integration and power efficiency for fanless, small form factor
+enterprise networking applications. Incorporating dual ARM Cortex-A7 cores
+running up to 1.0 GHz, the LS1021A processor delivers pre-silicon CoreMark
+performance of over 6,000, as well as virtualization support, advanced
+security features and the broadest array of high-speed interconnects and
+optimized peripheral features ever offered in a sub-3 W processor.
+
+The QorIQ LS1021A processor features an integrated LCD controller,
+CAN controller for implementing industrial protocols, DDR3L/4 running
+up to 1600 MHz, integrated security engine and QUICC Engine, and ECC
+protection on both L1 and L2 caches. The LS1021A processor is pin- and
+software-compatible with the QorIQ LS1020A and LS1022A processors.
+
+The LS1021A SoC includes the following function and features:
+
+ - ARM Cortex-A7 MPCore compliant with ARMv7-A architecture
+ - Dual high-preformance ARM Cortex-A7 cores, each core includes:
+   - 32 Kbyte L1 Instruction Cache and Data Cache for each core (ECC protection)
+   - 512 Kbyte shared coherent L2 Cache (with ECC protection)
+   - NEON Co-processor (per core)
+   - 40-bit physical addressing
+   - Vector floating-point support
+ - ARM Core-Link CCI-400 Cache Coherent Interconnect
+ - One DDR3L/DDR4 SDRAM memory controller with x8/x16/x32-bit configuration
+   supporting speeds up to 1600Mtps
+   - ECC and interleaving support
+ - VeTSEC Ethernet complex
+   - Up to 3x virtualized 10/100/1000 Ethernet controllers
+   - MII, RMII, RGMII, and SGMII support
+   - QoS, lossless flow control, and IEEE 1588 support
+ - 4-lane 6GHz SerDes
+ - High speed interconnect (4 SerDes lanes with are muxed for these protocol)
+   - Two PCI Express Gen2 controllers running at up to 5 GHz
+   - One Serial ATA 3.0 supporting 6 GT/s operation
+   - Two SGMII interfaces supporting 1000 Mbps
+ - Additional peripheral interfaces
+   - One high-speed USB 3.0 controller with integrated PHY and one high-speed
+     USB 2.00 controller with ULPI
+   - Integrated flash controller (IFC) with 16-bit interface
+   - Quad SPI NOR Flash
+   - One enhanced Secure digital host controller
+   - Display controller unit (DCU) 24-bit RGB (12-bit DDR pin interface)
+   - Ten UARTs comprised of two 16550 compliant DUARTs, and six low power
+     UARTs
+   - Three I2C controllers
+   - Eight FlexTimers four supporting PWM and four FlexCAN ports
+   - Four GPIO controllers supporting up to 109 general purpose I/O signals
+ - Integrated advanced audio block:
+   - Four synchronous audio interfaces (SAI)
+   - Sony/Philips Digital Interconnect Format (SPDIF)
+   - Asynchronous Sample Rate Converter (ASRC)
+ - Hardware based crypto offload engine
+   - IPSec forwarding at up to 1Gbps
+   - QorIQ Trust Architecture, Secure Boot, and ARM TrustZone supported
+   - Public key hardware accelerator
+   - True Random Number Generator (NIST Certified)
+   - Advanced Encryption Standard Accelerators (AESA)
+   - Data Encryption Standard Accelerators
+ - QUICC Engine ULite block
+   - Two universal communication controllers (TDM and HDLC) supporting 64
+   multichannels, each running at 64 Kbps
+   - Support for 256 channels of HDLC
+ - QorIQ TrustArchitecture with Secure Boot, as well as ARM TrustZone supported
+
+LS1021AQDS board Overview
+-------------------------
+ - DDR Controller
+     - Supports rates of up to 1600 MHz data-rate
+     - Supports one DDR3LP UDIMM, of single-, dual- types.
+ - IFC/Local Bus
+     - NAND flash: 512M 8-bit NAND flash
+     - NOR: 128MB 16-bit NOR Flash
+ - Ethernet
+     - Three on-board RGMII 10/100/1G ethernet ports.
+ - FPGA
+ - Clocks
+     - System and DDR clock (SYSCLK, DDRCLK)
+     - SERDES clocks
+ - Power Supplies
+ - SDHC
+     - SDHC/SDXC connector
+ - Other IO
+    - Two Serial ports
+    - Three I2C ports
+
+Memory map
+-----------
+The addresses in brackets are physical addresses.
+
+Start Address	End Address	Description			Size
+0x00_0000_0000	0x00_000F_FFFF	Secure Boot ROM			1MB
+0x00_0100_0000	0x00_0FFF_FFFF	CCSRBAR				240MB
+0x00_1000_0000	0x00_1000_FFFF	OCRAM0				64KB
+0x00_1001_0000	0x00_1001_FFFF	OCRAM1				64KB
+0x00_2000_0000	0x00_20FF_FFFF	DCSR				16MB
+0x00_4000_0000	0x00_5FFF_FFFF	QSPI				512MB
+0x00_6000_0000	0x00_67FF_FFFF	IFC - NOR Flash			128MB
+0x00_7E80_0000	0x00_7E80_FFFF	IFC - NAND Flash		64KB
+0x00_7FB0_0000	0x00_7FB0_0FFF	IFC - FPGA			4KB
+0x00_8000_0000	0x00_FFFF_FFFF	DRAM1				2GB
--- u-boot-2014.07/board/freescale/ls1021aqds/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/Makefile	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,9 @@
+#
+# Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += ls1021aqds.o
+obj-y += ddr.o
+obj-y += eth.o
--- u-boot-2014.07/board/freescale/ls1021aqds/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/ddr.c	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include "ddr.h"
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 3) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				popts->cpo_override = pbsp->cpo_override;
+				popts->write_data_delay =
+					pbsp->write_data_delay;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for %lu MT/s\n",
+		       ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n",
+	      pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb);
+
+	/* force DDR bus width to 32 bits */
+	popts->data_bus_width = 1;
+	popts->otf_burst_chop_en = 0;
+	popts->burst_length = DDR_BL8;
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 1;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+	popts->cswl_override = DDR_CSWL_CS0;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+}
+
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 1073741824u,
+	.capacity = 1073741824u,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 15,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tckmin_x_ps = 1071,
+	.caslat_x = 0xfe << 4,	/* 5,6,7,8 */
+	.taa_ps = 13125,
+	.twr_ps = 15000,
+	.trcd_ps = 13125,
+	.trrd_ps = 7500,
+	.trp_ps = 13125,
+	.tras_ps = 37500,
+	.trc_ps = 50625,
+	.trfc_ps = 160000,
+	.twtr_ps = 7500,
+	.trtp_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tfaw_ps = 37500,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+			    unsigned int controller_number,
+			    unsigned int dimm_number)
+{
+	static const char dimm_model[] = "Fixed DDR on board";
+
+	if (((controller_number == 0) && (dimm_number == 0)) ||
+	    ((controller_number == 1) && (dimm_number == 0))) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+#endif
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL)
+	puts("Initializing DDR....using SPD\n");
+	dram_size = fsl_ddr_sdram();
+#else
+	dram_size =  fsl_ddr_sdram_size();
+#endif
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	fsl_dp_ddr_restore();
+#endif
+
+	return dram_size;
+}
+
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	gd->bd->bi_dram[0].size = gd->ram_size;
+}
--- u-boot-2014.07/board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,14 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+
+#enable IFC, disable QSPI and DSPI
+#0608000a 00000000 00000000 00000000
+#00000000 00404000 60025a00 21042000
+#00200000 00000000 00000000 01038000
+#00000000 001b1200 00000000 00000000
+
+#disable IFC, enable QSPI and DSPI
+0608000a 00000000 00000000 00000000
+60000000 00407900 e0025a00 21046000
+00000000 00000000 00000000 00038000
+20024800 001b7200 00000000 00000000
--- u-boot-2014.07/board/freescale/ls1021aqds/ls1021aqds.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/ls1021aqds.c	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,728 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <asm/io.h>
+#include <asm/arch/immap_ls102xa.h>
+#include <asm/arch/ns_access.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/fsl_serdes.h>
+#include <hwconfig.h>
+#include <asm/arch/ls102xa_stream_id.h>
+#include <asm/pcie_layerscape.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <fsl_ifc.h>
+#include <spl.h>
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
+#include <asm/armv7.h>
+#endif
+
+#include "../common/qixis.h"
+#include "ls1021aqds_qixis.h"
+#ifdef CONFIG_U_QE
+#include "../../../drivers/qe/qe.h"
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+#include <fsl_sec.h>
+#include <jr.h>
+#include <fsl_secboot_err.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_SECURE_BOOT
+struct jobring jr;
+#endif
+
+enum {
+	MUX_TYPE_CAN,
+	MUX_TYPE_GPIO,
+	MUX_TYPE_IIC2,
+	MUX_TYPE_RGMII,
+	MUX_TYPE_SAI,
+	MUX_TYPE_SDHC,
+	MUX_TYPE_SD_PCI4,
+	MUX_TYPE_SD_PC_SA_SG_SG,
+	MUX_TYPE_SD_PC_SA_PC_SG,
+	MUX_TYPE_SD_PC_SG_SG,
+};
+
+enum {
+	GE0_CLK125,
+	GE2_CLK125,
+	GE1_CLK125,
+};
+
+int checkboard(void)
+{
+#ifndef CONFIG_QSPI_BOOT
+	char buf[64];
+#endif
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+	u8 sw;
+#endif
+
+	puts("Board: LS1021AQDS\n");
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else if (sw == 0x8)
+		puts("PromJet\n");
+	else if (sw == 0x9)
+		puts("NAND\n");
+	else if (sw == 0x15)
+		printf("IFCCard\n");
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+#endif
+
+#ifndef CONFIG_QSPI_BOOT
+	printf("Sys ID:0x%02x, Sys Ver: 0x%02x\n",
+	       QIXIS_READ(id), QIXIS_READ(arch));
+
+	printf("FPGA:  v%d (%s), build %d\n",
+	       (int)QIXIS_READ(scver), qixis_read_tag(buf),
+	       (int)qixis_read_minor());
+#endif
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0f) {
+	case QIXIS_SYSCLK_64:
+		return 64000000;
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	/*
+	 * When resuming from deep sleep, the I2C channel may not be
+	 * in the default channel. So, switch to the default channel
+	 * before accessing DDR SPD.
+	 */
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+	gd->ram_size = initdram(0);
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg esdhc_cfg[1] = {
+	{CONFIG_SYS_FSL_ESDHC_ADDR},
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	esdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+
+	return fsl_esdhc_initialize(bis, &esdhc_cfg[0]);
+}
+#endif
+
+int board_early_init_f(void)
+{
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
+
+#ifdef CONFIG_TSEC_ENET
+	out_be32(&scfg->etsecdmamcr, SCFG_ETSECDMAMCR_LE_BD_FR);
+#endif
+
+#ifdef CONFIG_FSL_IFC
+	init_early_memctl_regs();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	out_be32(&scfg->qspi_cfg, SCFG_QSPI_CLKSEL);
+#endif
+
+	/*
+	 * Enable snoop requests and DVM message requests for
+	 * Slave insterface S4 (A7 core cluster)
+	 */
+	out_le32(&cci->slave[4].snoop_ctrl,
+		 CCI400_DVM_MESSAGE_REQ_EN | CCI400_SNOOP_REQ_EN);
+
+	/*
+	 * Set CCI-400 Slave interface S1, S2 Shareable Override Register
+	 * All transactions are treated as non-shareable
+	 */
+	out_le32(&cci->slave[1].sha_ord, CCI400_SHAORD_NON_SHAREABLE);
+	out_le32(&cci->slave[2].sha_ord, CCI400_SHAORD_NON_SHAREABLE);
+
+	/* Workaround for the issue that DDR could not respond to
+	 * barrier transaction which is generated by executing DSB/ISB
+	 * instruction. Set CCI-400 control override register to
+	 * terminate the barrier transaction. After DDR is initialized,
+	 * allow barrier transaction to DDR again */
+	out_le32(&cci->ctrl_ord, CCI400_CTRLORD_TERM_BARRIER);
+
+	return 0;
+}
+
+#ifdef CONFIG_SPL_BUILD
+void board_init_f(ulong dummy)
+{
+	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
+
+#ifdef CONFIG_NAND_BOOT
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	u32 porsr1, pinctl;
+
+	init_early_memctl_regs();
+
+	/*
+	 * There is LS1 SoC issue where NOR, FPGA are inaccessible during
+	 * NAND boot because IFC signals > IFC_AD7 are not enabled.
+	 * This workaround changes RCW source to make all signals enabled.
+	 */
+	porsr1 = in_be32(&gur->porsr1);
+	pinctl = ((porsr1 & ~(DCFG_CCSR_PORSR1_RCW_MASK)) | 0x24800000);
+	out_be32((unsigned int *)(CONFIG_SYS_DCSRBAR + 0x220000), pinctl);
+#endif
+
+	/* Set global data pointer */
+	gd = &gdata;
+
+	/* Clear the BSS */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	get_clocks();
+
+	preloader_console_init();
+
+#ifdef CONFIG_SPL_I2C_SUPPORT
+	i2c_init_all();
+#endif
+	out_le32(&cci->ctrl_ord, CCI400_CTRLORD_TERM_BARRIER);
+
+	dram_init();
+
+	board_init_r(NULL, 0);
+}
+#endif
+
+void config_etseccm_source(int etsec_gtx_125_mux)
+{
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+	switch (etsec_gtx_125_mux) {
+	case GE0_CLK125:
+		out_be32(&scfg->etsecmcr, 0x00000000);
+		debug("etseccm set to GE0_CLK125\n");
+		break;
+
+	case GE2_CLK125:
+		out_be32(&scfg->etsecmcr, 0x04000000);
+		debug("etseccm set to GE2_CLK125\n");
+		break;
+
+	case GE1_CLK125:
+		out_be32(&scfg->etsecmcr, 0x08000000);
+		debug("etseccm set to GE1_CLK125\n");
+		break;
+
+	default:
+		printf("Error! trying to set etseccm to invalid value\n");
+		break;
+	}
+}
+
+int config_board_mux(int ctrl_type)
+{
+	u8 reg12, reg14;
+
+	reg12 = QIXIS_READ(brdcfg[12]);
+	reg14 = QIXIS_READ(brdcfg[14]);
+
+	switch (ctrl_type) {
+	case MUX_TYPE_CAN:
+		config_etseccm_source(GE2_CLK125);
+
+		reg14 = (reg14 & 0xf0) | 0x03;
+		break;
+	case MUX_TYPE_GPIO:
+		config_etseccm_source(GE2_CLK125);
+
+		reg14 = (reg14 & 0x0f) | 0x20;
+		break;
+	case MUX_TYPE_IIC2:
+		reg14 = (reg14 & 0x0f) | 0xa0;
+		break;
+	case MUX_TYPE_RGMII:
+		reg14 = (reg14 & 0xf0) | 0x0;
+		break;
+	case MUX_TYPE_SAI:
+		config_etseccm_source(GE2_CLK125);
+
+		reg14 = (reg14 & 0xf0) | 0x0c;
+		break;
+	case MUX_TYPE_SDHC:
+		reg14 = (reg14 & 0x0f) | 0x0;
+		break;
+	case MUX_TYPE_SD_PCI4:
+		reg12 = 0x38;
+		break;
+	case MUX_TYPE_SD_PC_SA_SG_SG:
+		reg12 = 0x01;
+		break;
+	case MUX_TYPE_SD_PC_SA_PC_SG:
+		reg12 = 0x01;
+		break;
+	case MUX_TYPE_SD_PC_SG_SG:
+		reg12 = 0x21;
+		break;
+	default:
+		printf("Wrong mux interface type\n");
+		return -1;
+	}
+
+	QIXIS_WRITE(brdcfg[12], reg12);
+	QIXIS_WRITE(brdcfg[14], reg14);
+
+	return 0;
+}
+
+int config_serdes_mux(void)
+{
+	struct ccsr_gur *gur = (struct ccsr_gur *)CONFIG_SYS_FSL_GUTS_ADDR;
+	u32 cfg;
+
+	cfg = in_be32(&gur->rcwsr[4]) & RCWSR4_SRDS1_PRTCL_MASK;
+	cfg >>= RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	switch (cfg) {
+	case 0x0:
+		config_board_mux(MUX_TYPE_SD_PCI4);
+		break;
+	case 0x30:
+		config_board_mux(MUX_TYPE_SD_PC_SA_SG_SG);
+		break;
+	case 0x60:
+		config_board_mux(MUX_TYPE_SD_PC_SG_SG);
+		break;
+	case 0x70:
+		config_board_mux(MUX_TYPE_SD_PC_SA_PC_SG);
+		break;
+	default:
+		printf("SRDS1 prtcl:0x%x\n", cfg);
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LS102XA_NS_ACESS
+static struct csu_ns_dev ns_dev[] = {
+	{ CSU_CSLX_PCIE2_IO, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1_IO, CSU_ALL_RW },
+	{ CSU_CSLX_MG2TPR_IP, CSU_ALL_RW },
+	{ CSU_CSLX_IFC_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM, CSU_ALL_RW },
+	{ CSU_CSLX_GIC, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM2, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE2, CSU_ALL_RW },
+	{ CSU_CSLX_SATA, CSU_ALL_RW },
+	{ CSU_CSLX_USB3, CSU_ALL_RW },
+	{ CSU_CSLX_SERDES, CSU_ALL_RW },
+	{ CSU_CSLX_QDMA, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART2, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART1, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART4, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART3, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART6, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART5, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI2, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI1, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI, CSU_ALL_RW },
+	{ CSU_CSLX_ESDHC, CSU_ALL_RW },
+	{ CSU_CSLX_2D_ACE, CSU_ALL_RW },
+	{ CSU_CSLX_IFC, CSU_ALL_RW },
+	{ CSU_CSLX_I2C1, CSU_ALL_RW },
+	{ CSU_CSLX_USB2, CSU_ALL_RW },
+	{ CSU_CSLX_I2C3, CSU_ALL_RW },
+	{ CSU_CSLX_I2C2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART1, CSU_ALL_RW },
+	{ CSU_CSLX_WDT2, CSU_ALL_RW },
+	{ CSU_CSLX_WDT1, CSU_ALL_RW },
+	{ CSU_CSLX_EDMA, CSU_ALL_RW },
+	{ CSU_CSLX_SYS_CNT, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX2, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX1, CSU_ALL_RW },
+	{ CSU_CSLX_DDR, CSU_ALL_RW },
+	{ CSU_CSLX_QUICC, CSU_ALL_RW },
+	{ CSU_CSLX_DCFG_CCU_RCPM, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_BOOTROM, CSU_ALL_RW },
+	{ CSU_CSLX_SFP, CSU_ALL_RW },
+	{ CSU_CSLX_TMU, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_MONITOR, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED0, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC1, CSU_ALL_RW },
+	{ CSU_CSLX_SEC5_5, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC3, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO1, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO4, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO3, CSU_ALL_RW },
+	{ CSU_CSLX_PLATFORM_CONT, CSU_ALL_RW },
+	{ CSU_CSLX_CSU, CSU_ALL_RW },
+	{ CSU_CSLX_ASRC, CSU_ALL_RW },
+	{ CSU_CSLX_SPDIF, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN2, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN1, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN4, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN3, CSU_ALL_RW },
+	{ CSU_CSLX_SAI2, CSU_ALL_RW },
+	{ CSU_CSLX_SAI1, CSU_ALL_RW },
+	{ CSU_CSLX_SAI4, CSU_ALL_RW },
+	{ CSU_CSLX_SAI3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM2, CSU_ALL_RW },
+	{ CSU_CSLX_FTM1, CSU_ALL_RW },
+	{ CSU_CSLX_FTM4, CSU_ALL_RW },
+	{ CSU_CSLX_FTM3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM6, CSU_ALL_RW },
+	{ CSU_CSLX_FTM5, CSU_ALL_RW },
+	{ CSU_CSLX_FTM8, CSU_ALL_RW },
+	{ CSU_CSLX_FTM7, CSU_ALL_RW },
+	{ CSU_CSLX_COP_DCSR, CSU_ALL_RW },
+	{ CSU_CSLX_EPU, CSU_ALL_RW },
+	{ CSU_CSLX_GDI, CSU_ALL_RW },
+	{ CSU_CSLX_DDI, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED1, CSU_ALL_RW },
+	{ CSU_CSLX_USB3_PHY, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED2, CSU_ALL_RW },
+};
+#endif
+
+struct liodn_id_table sec_liodn_tbl[] = {
+	SET_SEC_JR_LIODN_ENTRY(0, 0x10, 0x10),
+	SET_SEC_JR_LIODN_ENTRY(1, 0x10, 0x10),
+	SET_SEC_JR_LIODN_ENTRY(2, 0x10, 0x10),
+	SET_SEC_JR_LIODN_ENTRY(3, 0x10, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(a, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(b, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(c, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(d, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(0, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(1, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(2, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(3, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(4, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(5, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(6, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(7, 0x10, 0x10),
+};
+
+#if defined(CONFIG_MISC_INIT_R)
+int misc_init_r(void)
+{
+	int conflict_flag;
+
+	/* some signals can not enable simultaneous*/
+	conflict_flag = 0;
+	if (hwconfig("sdhc"))
+		conflict_flag++;
+	if (hwconfig("iic2"))
+		conflict_flag++;
+	if (conflict_flag > 1) {
+		printf("WARNING: pin conflict !\n");
+		return 0;
+	}
+
+	conflict_flag = 0;
+	if (hwconfig("rgmii"))
+		conflict_flag++;
+	if (hwconfig("can"))
+		conflict_flag++;
+	if (hwconfig("gpio"))
+		conflict_flag++;
+	if (hwconfig("sai"))
+		conflict_flag++;
+	if (conflict_flag > 1) {
+		printf("WARNING: pin conflict !\n");
+		return 0;
+	}
+
+	if (hwconfig("can"))
+		config_board_mux(MUX_TYPE_CAN);
+	if (hwconfig("gpio"))
+		config_board_mux(MUX_TYPE_GPIO);
+	else if (hwconfig("rgmii"))
+		config_board_mux(MUX_TYPE_RGMII);
+	else if (hwconfig("sai"))
+		config_board_mux(MUX_TYPE_SAI);
+
+	if (hwconfig("iic2"))
+		config_board_mux(MUX_TYPE_IIC2);
+	else if (hwconfig("sdhc"))
+		config_board_mux(MUX_TYPE_SDHC);
+
+#ifdef CONFIG_SECURE_BOOT
+	if (sec_init(&jr) < 0)
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_INIT);
+
+	if (get_rng_vid() >= 4)
+		if (rng_init(&jr) < 0)
+			return -1;
+#endif
+	return 0;
+}
+#endif
+
+struct smmu_stream_id dev_stream_id[] = {
+	{ 0x100, 0x01, "ETSEC MAC1" },
+	{ 0x104, 0x02, "ETSEC MAC2" },
+	{ 0x108, 0x03, "ETSEC MAC3" },
+	{ 0x10c, 0x04, "PEX1" },
+	{ 0x110, 0x05, "PEX2" },
+	{ 0x114, 0x06, "qDMA" },
+	{ 0x118, 0x07, "SATA" },
+	{ 0x11c, 0x08, "USB3" },
+	{ 0x120, 0x09, "QE" },
+	{ 0x124, 0x0a, "eSDHC" },
+	{ 0x128, 0x0b, "eMA" },
+	{ 0x14c, 0x0c, "2D-ACE" },
+	{ 0x150, 0x0d, "USB2" },
+	{ 0x18c, 0x0e, "DEBUG" },
+};
+
+int board_init(void)
+{
+	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
+
+	/* Set CCI-400 control override register to
+	 * enable barrier transaction */
+	out_le32(&cci->ctrl_ord, CCI400_CTRLORD_EN_BARRIER);
+
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+
+#ifndef CONFIG_SYS_FSL_NO_SERDES
+	fsl_serdes_init();
+	config_serdes_mux();
+#endif
+
+	ls1021x_config_caam_stream_id(sec_liodn_tbl,
+				      ARRAY_SIZE(sec_liodn_tbl));
+	ls102xa_config_smmu_stream_id(dev_stream_id,
+				      ARRAY_SIZE(dev_stream_id));
+	/* Configure SMMU3 to make transactions with CAAM stream ID
+	 * as cacheable
+	 */
+	ls1021x_config_smmu3(0x10);
+
+#ifdef CONFIG_LS102XA_NS_ACESS
+	enable_devices_ns_access(ns_dev, ARRAY_SIZE(ns_dev));
+#endif
+
+#ifdef CONFIG_U_QE
+	u_qe_init();
+#endif
+
+	return 0;
+}
+
+int board_spi_find_bus(unsigned int bus, unsigned int cs)
+{
+	switch (bus) {
+	case SPI_BUS_FSL_DSPI1:
+	case SPI_BUS_FSL_DSPI2:
+	case SPI_BUS_FSL_QSPI:
+		break;
+	default:
+		return -1;
+	}
+
+	switch (bus) {
+	case SPI_BUS_FSL_DSPI1:
+		if (cs == 0)
+			return 0;
+	case SPI_BUS_FSL_DSPI2:
+		if (cs == 0)
+			return 0;
+	case SPI_BUS_FSL_QSPI:
+		if (cs == 0)
+			return 0;
+	default:
+		return -1;
+	}
+}
+
+void board_print_spi_device(void)
+{
+	printf("LS1021aqds spi flash info:\n");
+	printf("S25FL128S is on spi bus 0 cs 0\n");
+	printf("AT45DB021 is on spi bus 1 cs 0\n");
+}
+
+#ifdef CONFIG_SF_DATAFLASH
+int board_spi_is_dataflash(unsigned int bus, unsigned int cs)
+{
+	if (bus == SPI_BUS_FSL_DSPI1 && cs == 0)
+		return 1;
+	else
+		return 0;
+}
+#endif
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	ft_cpu_setup(blob, bd);
+
+#ifdef CONFIG_PCIE_LAYERSCAPE
+	ft_pcie_setup(blob, bd);
+#endif
+}
+
+u8 flash_read8(void *addr)
+{
+	return __raw_readb(addr + 1);
+}
+
+void flash_write16(u16 val, void *addr)
+{
+	u16 shftval = (((val >> 8) & 0xff) | ((val << 8) & 0xff00));
+
+	__raw_writew(shftval, addr);
+}
+
+u16 flash_read16(void *addr)
+{
+	u16 val = __raw_readw(addr);
+
+	return (((val) >> 8) & 0x00ff) | (((val) << 8) & 0xff00);
+}
+
+#ifdef CONFIG_FSL_DEEP_SLEEP
+/* determine if it is a warm boot */
+bool is_warm_boot(void)
+{
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+
+	if (in_be32(&gur->crstsr) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_mem_setup(void)
+{
+	/* does not provide HW signals for power management */
+	QIXIS_WRITE(pwr_ctl[1], (QIXIS_READ(pwr_ctl[1]) & ~0x2));
+	udelay(1);
+}
+
+void fsl_dp_ddr_restore(void)
+{
+#define DDR_BUFF_LEN	128
+	u64 *src, *dst;
+	int i;
+	struct ccsr_scfg *scfg = (void *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+	if (!is_warm_boot())
+		return;
+
+	/* get the address of ddr date from SPARECR3, little endian */
+	src = (u64 *)in_le32(&scfg->sparecr[2]);
+	dst = (u64 *)CONFIG_SYS_SDRAM_BASE;
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst++ = *src++;
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg *scfg = (void *)CONFIG_SYS_FSL_SCFG_ADDR;
+	struct ccsr_cci400 __iomem *cci = (void *)CONFIG_SYS_CCI400_ADDR;
+
+	if (!is_warm_boot())
+		return 0;
+
+	/* Set CCI-400 control override register to
+	 * enable barrier transaction */
+	out_le32(&cci->ctrl_ord, CCI400_CTRLORD_EN_BARRIER);
+
+#ifdef CONFIG_LS102XA_NS_ACESS
+	enable_devices_ns_access(ns_dev, ARRAY_SIZE(ns_dev));
+#endif
+
+#ifdef CONFIG_U_QE
+	u_qe_resume();
+#endif
+
+	armv7_switch_nonsec();
+	armv7_switch_hyp();
+	cleanup_before_linux();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_le32(&scfg->sparecr[1]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	kernel_resume();
+
+	return 0;
+}
+#endif
--- u-boot-2014.07/board/freescale/ls1021aqds/Kconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021aqds/Kconfig	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,23 @@
+if TARGET_LS1021AQDS
+
+config SYS_CPU
+	string
+	default "armv7"
+
+config SYS_BOARD
+	string
+	default "ls1021aqds"
+
+config SYS_VENDOR
+	string
+	default "freescale"
+
+config SYS_SOC
+	string
+	default "ls102xa"
+
+config SYS_CONFIG_NAME
+	string
+	default "ls1021aqds"
+
+endif
--- u-boot-2014.07/board/freescale/t4rdb/cpld.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t4rdb/cpld.h	2022-05-09 14:06:23.361144192 -0700
@@ -0,0 +1,49 @@
+/**
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * Author: Chunhe Lan <Chunhe.Lan@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * This file provides support for the ngPIXIS, a board-specific FPGA used on
+ * some Freescale reference boards.
+ */
+
+/*
+ * CPLD register set. Feel free to add board-specific #ifdefs where necessary.
+ */
+struct cpld_data {
+	u8 chip_id1;	/* 0x00 - CPLD Chip ID1 Register */
+	u8 chip_id2;	/* 0x01 - CPLD Chip ID2 Register */
+	u8 sw_maj_ver;	/* 0x02 - CPLD Code Major Version Register */
+	u8 sw_min_ver;	/* 0x03 - CPLD Code Minor Version Register */
+	u8 hw_ver;	/* 0x04 - PCBA Version Register */
+	u8 software_on;	/* 0x05 - Override Physical Switch Enable Register */
+	u8 cfg_rcw_src;	/* 0x06 - RCW Source Location Control Register */
+	u8 res0;	/* 0x07 - not used */
+	u8 vbank;	/* 0x08 - Flash Bank Selection Control Register */
+	u8 sw1_sysclk;	/* 0x09 - SW1 Status Read Back Register */
+	u8 sw2_status;	/* 0x0a - SW2 Status Read Back Register */
+	u8 sw3_status;	/* 0x0b - SW3 Status Read Back Register */
+	u8 sw4_status;	/* 0x0c - SW4 Status Read Back Register */
+	u8 sys_reset;	/* 0x0d - Reset System With Reserving Registers Value*/
+	u8 global_reset;/* 0x0e - Reset System With Default Registers Value */
+	u8 res1;	/* 0x0f - not used */
+};
+
+#define CPLD_BANK_SEL_MASK	0x07
+#define CPLD_BANK_SEL_EN	0x04
+#define CPLD_SYSTEM_RESET	0x01
+#define CPLD_SELECT_BANK0	0x00
+#define CPLD_SELECT_BANK4	0x04
+#define CPLD_DEFAULT_BANK	0x01
+
+/* Pointer to the CPLD register set */
+
+u8 cpld_read(unsigned int reg);
+void cpld_write(unsigned int reg, u8 value);
+
+#define CPLD_READ(reg) cpld_read(offsetof(struct cpld_data, reg))
+#define CPLD_WRITE(reg, value) \
+		cpld_write(offsetof(struct cpld_data, reg), value)
+
--- u-boot-2014.07/board/freescale/t4rdb/cpld.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t4rdb/cpld.c	2022-05-09 14:06:23.361144192 -0700
@@ -0,0 +1,136 @@
+/**
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * Author: Chunhe Lan <Chunhe.Lan@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * This file provides support for the board-specific CPLD used on some Freescale
+ * reference boards.
+ *
+ * The following macros need to be defined:
+ *
+ * CONFIG_SYS_CPLD_BASE - The virtual address of the base of the
+ * CPLD register map
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+
+#include "cpld.h"
+
+u8 cpld_read(unsigned int reg)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	return in_8(p + reg);
+}
+
+void cpld_write(unsigned int reg, u8 value)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	out_8(p + reg, value);
+}
+
+/**
+ * Set the boot bank to the alternate bank
+ */
+void cpld_set_altbank(void)
+{
+	u8 val, curbank, altbank, override;
+
+	val = CPLD_READ(vbank);
+	curbank = val & CPLD_BANK_SEL_MASK;
+
+	switch (curbank) {
+	case CPLD_SELECT_BANK0:
+		altbank = CPLD_SELECT_BANK4;
+		CPLD_WRITE(vbank, altbank);
+		override = CPLD_READ(software_on);
+		CPLD_WRITE(software_on, override | CPLD_BANK_SEL_EN);
+		CPLD_WRITE(sys_reset, CPLD_SYSTEM_RESET);
+		break;
+	case CPLD_SELECT_BANK4:
+		altbank = CPLD_SELECT_BANK0;
+		CPLD_WRITE(vbank, altbank);
+		override = CPLD_READ(software_on);
+		CPLD_WRITE(software_on, override | CPLD_BANK_SEL_EN);
+		CPLD_WRITE(sys_reset, CPLD_SYSTEM_RESET);
+		break;
+	default:
+		printf("CPLD Altbank Fail: Invalid value!\n");
+		return;
+	}
+}
+
+/**
+ * Set the boot bank to the default bank
+ */
+void cpld_set_defbank(void)
+{
+	u8 val;
+
+	val = CPLD_DEFAULT_BANK;
+
+	CPLD_WRITE(global_reset, val);
+}
+
+#ifdef DEBUG
+static void cpld_dump_regs(void)
+{
+	printf("chip_id1	= 0x%02x\n", CPLD_READ(chip_id1));
+	printf("chip_id2	= 0x%02x\n", CPLD_READ(chip_id2));
+	printf("sw_maj_ver	= 0x%02x\n", CPLD_READ(sw_maj_ver));
+	printf("sw_min_ver	= 0x%02x\n", CPLD_READ(sw_min_ver));
+	printf("hw_ver		= 0x%02x\n", CPLD_READ(hw_ver));
+	printf("software_on	= 0x%02x\n", CPLD_READ(software_on));
+	printf("cfg_rcw_src	= 0x%02x\n", CPLD_READ(cfg_rcw_src));
+	printf("res0		= 0x%02x\n", CPLD_READ(res0));
+	printf("vbank		= 0x%02x\n", CPLD_READ(vbank));
+	printf("sw1_sysclk	= 0x%02x\n", CPLD_READ(sw1_sysclk));
+	printf("sw2_status	= 0x%02x\n", CPLD_READ(sw2_status));
+	printf("sw3_status	= 0x%02x\n", CPLD_READ(sw3_status));
+	printf("sw4_status	= 0x%02x\n", CPLD_READ(sw4_status));
+	printf("sys_reset	= 0x%02x\n", CPLD_READ(sys_reset));
+	printf("global_reset	= 0x%02x\n", CPLD_READ(global_reset));
+	printf("res1		= 0x%02x\n", CPLD_READ(res1));
+	putc('\n');
+}
+#endif
+
+#ifndef CONFIG_SPL_BUILD
+int do_cpld(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rc = 0;
+
+	if (argc <= 1)
+		return cmd_usage(cmdtp);
+
+	if (strcmp(argv[1], "reset") == 0) {
+		if (strcmp(argv[2], "altbank") == 0)
+			cpld_set_altbank();
+		else
+			cpld_set_defbank();
+#ifdef DEBUG
+	} else if (strcmp(argv[1], "dump") == 0) {
+		cpld_dump_regs();
+#endif
+	} else
+		rc = cmd_usage(cmdtp);
+
+	return rc;
+}
+
+U_BOOT_CMD(
+	cpld, CONFIG_SYS_MAXARGS, 1, do_cpld,
+	"Reset the board or alternate bank",
+	"reset - reset to default bank\n"
+	"cpld reset altbank - reset to alternate bank\n"
+#ifdef DEBUG
+	"cpld dump - display the CPLD registers\n"
+#endif
+	);
+#endif
--- u-boot-2014.07/board/freescale/wgxtm_boren/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/Makefile	2022-05-09 14:06:23.361144192 -0700
@@ -0,0 +1,30 @@
+#
+# Copyright 2009 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+MINIMAL=
+
+ifdef CONFIG_SPL_BUILD
+ifdef CONFIG_SPL_INIT_MINIMAL
+MINIMAL=y
+endif
+endif
+
+ifdef MINIMAL
+
+obj-y	+= spl_minimal.o tlb.o law.o
+
+else
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+else
+obj-y	+= wgxtm_boren.o
+obj-$(CONFIG_PCI)  += pci.o
+endif
+obj-y	+= ddr.o
+obj-y	+= law.o
+obj-y	+= tlb.o
+
+endif
--- u-boot-2014.07/board/freescale/wgxtm_boren/config.mk.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/config.mk	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,31 @@
+#
+# Copyright 2009, 2011 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# wgxtm_boren board
+#
+
+ifndef NAND_SPL
+ifeq ($(CONFIG_NAND), y)
+LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-nand.lds
+endif
+endif
--- u-boot-2014.07/board/freescale/wgxtm_boren/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/law.c	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_16M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_VSC7385_BASE_PHYS, LAW_SIZE_128K, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_LBC),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2014.07/board/freescale/wgxtm_boren/pci.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/pci.c	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+#include <asm/io.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void ft_pci_board_setup(void *blob)
+{
+	FT_FSL_PCI_SETUP;
+}
--- u-boot-2014.07/board/freescale/wgxtm_boren/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/tlb.c	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+	/* W**G* - Flash/promjet, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 2, BOOKE_PAGESZ_16M, 1),
+
+#if defined(CONFIG_PCI)
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 4, BOOKE_PAGESZ_256K, 1),
+
+#endif /* #if defined(CONFIG_PCI) */
+	/* *I*G - NAND */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_1M, 1),
+
+	/* *I*G - VSC7385 Switch */
+	SET_TLB_ENTRY(1, CONFIG_SYS_VSC7385_BASE, CONFIG_SYS_VSC7385_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 6, BOOKE_PAGESZ_1M, 1),
+
+#if defined(CONFIG_SYS_RAMBOOT)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 7, BOOKE_PAGESZ_1G, 1)
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2014.07/board/freescale/wgxtm_boren/spl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/spl.c	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <ns16550.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <nand.h>
+#include <i2c.h>
+#include <fsl_esdhc.h>
+#include <spi_flash.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define SYSCLK_MASK	0x00200000
+#define BOARDREV_MASK	0x10100000
+
+#define SYSCLK_66	66666666
+#define SYSCLK_100	100000000
+
+unsigned long get_board_sys_clk(ulong dummy)
+{
+	ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+	u32 val_gpdat, sysclk_gpio;
+
+	val_gpdat = in_be32(&pgpio->gpdat);
+	sysclk_gpio = val_gpdat & SYSCLK_MASK;
+
+	if (sysclk_gpio == 0)
+		return SYSCLK_66;
+	else
+		return SYSCLK_100;
+
+	return 0;
+}
+
+phys_size_t get_effective_memsize(void)
+{
+	return CONFIG_SYS_L2_SIZE;
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio, bus_clk;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	console_init_f();
+
+	/* Set pmuxcr to allow both i2c1 and i2c2 */
+	setbits_be32(&gur->pmuxcr, in_be32(&gur->pmuxcr) | 0x1000);
+	setbits_be32(&gur->pmuxcr,
+		     in_be32(&gur->pmuxcr) | MPC85xx_PMUXCR_SD_DATA);
+
+	/* Read back the register to synchronize the write. */
+	in_be32(&gur->pmuxcr);
+
+#ifdef CONFIG_SPL_SPI_BOOT
+	clrbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_SD_DATA);
+#endif
+
+	/* initialize selected port with appropriate baud rate */
+	plat_ratio = in_be32(&gur->porpllsr) & MPC85xx_PORPLLSR_PLAT_RATIO;
+	plat_ratio >>= 1;
+	bus_clk = CONFIG_SYS_CLK_FREQ * plat_ratio;
+	gd->bus_clk = bus_clk;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+		     bus_clk / 16 / CONFIG_BAUDRATE);
+#ifdef CONFIG_SPL_MMC_BOOT
+	puts("\nSD boot...\n");
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	puts("\nSPI Flash boot...\n");
+#endif
+
+	/* copy code to RAM and jump to it - this should not return */
+	/* NOTE - code has to be copied out of NAND buffer before
+	 * other blocks can be read.
+	 */
+	relocate_code(CONFIG_SPL_RELOC_STACK, 0, CONFIG_SPL_RELOC_TEXT_BASE);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	/* Pointer is writable since we allocated a register for it */
+	gd = (gd_t *)CONFIG_SPL_GD_ADDR;
+	bd_t *bd;
+
+	memset(gd, 0, sizeof(gd_t));
+	bd = (bd_t *)(CONFIG_SPL_GD_ADDR + sizeof(gd_t));
+	memset(bd, 0, sizeof(bd_t));
+	gd->bd = bd;
+	bd->bi_memstart = CONFIG_SYS_INIT_L2_ADDR;
+	bd->bi_memsize = CONFIG_SYS_L2_SIZE;
+
+	probecpu();
+	get_clocks();
+	mem_malloc_init(CONFIG_SPL_RELOC_MALLOC_ADDR,
+			CONFIG_SPL_RELOC_MALLOC_SIZE);
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_initialize(bd);
+#endif
+	/* relocate environment function pointers etc. */
+#ifdef CONFIG_SPL_NAND_BOOT
+	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			    (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_NAND_BOOT
+	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			    (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_SPI_BOOT
+	spi_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+
+	gd->env_addr  = (ulong)(CONFIG_ENV_ADDR);
+	gd->env_valid = 1;
+
+	gd->ram_size = initdram(0);
+#ifdef CONFIG_SPL_NAND_BOOT
+	puts("Tertiary program loader running in sram...");
+#else
+	puts("Second program loader running in sram...\n");
+#endif
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_boot();
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	spi_boot();
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	nand_boot();
+#endif
+}
--- u-boot-2014.07/board/freescale/wgxtm_boren/spl_minimal.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/spl_minimal.c	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <ns16550.h>
+#include <asm/io.h>
+#include <nand.h>
+#include <linux/compiler.h>
+#include <asm/fsl_law.h>
+#include <fsl_ddr_sdram.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+#define SYSCLK_MASK	0x00200000
+#define BOARDREV_MASK	0x10100000
+
+#define SYSCLK_66	66666666
+#define SYSCLK_100	100000000
+
+unsigned long get_board_sys_clk(ulong dummy)
+{
+	ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+	u32 val_gpdat, sysclk_gpio;
+
+	val_gpdat = in_be32(&pgpio->gpdat);
+	sysclk_gpio = val_gpdat & SYSCLK_MASK;
+
+	if (sysclk_gpio == 0)
+		return SYSCLK_66;
+	else
+		return SYSCLK_100;
+
+	return 0;
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+#if defined(CONFIG_SYS_NAND_BR_PRELIM) && defined(CONFIG_SYS_NAND_OR_PRELIM)
+	set_lbc_br(0, CONFIG_SYS_NAND_BR_PRELIM);
+	set_lbc_or(0, CONFIG_SYS_NAND_OR_PRELIM);
+#endif
+
+	/* initialize selected port with appropriate baud rate */
+	plat_ratio = in_be32(&gur->porpllsr) & MPC85xx_PORPLLSR_PLAT_RATIO;
+	plat_ratio >>= 1;
+	gd->bus_clk = CONFIG_SYS_CLK_FREQ * plat_ratio;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+		     gd->bus_clk / 16 / CONFIG_BAUDRATE);
+
+	puts("\nNAND boot... ");
+
+	/* copy code to RAM and jump to it - this should not return */
+	/* NOTE - code has to be copied out of NAND buffer before
+	 * other blocks can be read.
+	 */
+	relocate_code(CONFIG_SPL_RELOC_STACK, 0, CONFIG_SPL_RELOC_TEXT_BASE);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	puts("\nSecond program loader running in sram...");
+	nand_boot();
+}
+
+void putc(char c)
+{
+	if (c == '\n')
+		NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, '\r');
+
+	NS16550_putc((NS16550_t)CONFIG_SYS_NS16550_COM1, c);
+}
+
+void puts(const char *str)
+{
+	while (*str)
+		putc(*str++);
+}
--- u-boot-2014.07/board/freescale/wgxtm_boren/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/README	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,145 @@
+Overview
+--------
+WatchGuard's Boren (a reference design based on P2020RDB) is a Low End Dual core platform supporting the P2020 processor
+of QorIQ series. P2020 is an e500 based dual core SOC.
+
+Building U-boot
+-----------
+To build the u-boot for WatchGuard BOREN:
+	make WGXTM_BOREN_config
+	make
+
+NOR Flash Banks
+-----------
+RDB board for P2020 has two flash banks. They are both present on boot.
+
+Booting by default is always from the boot bank at 0xef00_0000.
+
+Memory Map
+----------
+0xef00_0000 - 0xef7f_ffff	Alternate bank		8MB
+0xe800_0000 - 0xefff_ffff	Boot bank		8MB
+
+0xef74_0000 - 0xef7f_ffff	Alternate u-boot address	768KB
+0xeff4_0000 - 0xefff_ffff	Boot u-boot address		768KB
+
+Switch settings to boot from the NOR flash banks
+------------------------------------------------
+SW4[8]=0 default NOR Flash bank
+SW4[8]=1 Alternate NOR Flash bank
+
+Flashing Images
+---------------
+To place a new u-boot image in the alternate flash bank and then boot
+with that new image temporarily, use this:
+	tftp 1000000 u-boot.bin
+	erase ef740000 ef7fffff
+	cp.b 1000000 ef740000 c0000
+
+Now to boot from the alternate bank change the SW4[8] from 0 to 1.
+
+To program the image in the boot flash bank:
+	tftp 1000000 u-boot.bin
+	protect off all
+	erase eff40000 ffffffff
+	cp.b 1000000 eff40000 c0000
+
+Using the Device Tree Source File
+---------------------------------
+To create the DTB (Device Tree Binary) image file,
+use a command similar to this:
+
+	dtc -b 0 -f -I dts -O dtb p2020rdb.dts > p2020rdb.dtb
+
+Likely, that .dts file will come from here;
+
+	linux-2.6/arch/powerpc/boot/dts/p2020rdb.dts
+
+Booting Linux
+-------------
+Place a linux uImage in the TFTP disk area.
+
+	tftp 1000000 uImage.p2020rdb
+	tftp 2000000 rootfs.ext2.gz.uboot
+	tftp c00000 p2020rdb.dtb
+	bootm 1000000 2000000 c00000
+
+Implementing AMP(Asymmetric MultiProcessing)
+---------------------------------------------
+1. Build kernel image for core0:
+
+	a. $ make 85xx/p1_p2_rdb_defconfig
+
+	b. $ make menuconfig
+	   - un-select "Processor support"->
+		"Symetric multi-processing support"
+
+	c. $ make uImage
+
+	d. $ cp arch/powerpc/boot/uImage /tftpboot/uImage.core0
+
+2. Build kernel image for core1:
+
+	a. $ make 85xx/p1_p2_rdb_defconfig
+
+	b. $ make menuconfig
+	   - Un-select "Processor support"->
+		"Symetric multi-processing support"
+	   - Select "Advanced setup" ->
+		"Prompt for advanced kernel configuration options"
+		- Select
+			"Set physical address where the kernel is loaded"
+			and set it to 0x20000000, assuming core1 will
+			start from 512MB.
+		- Select "Set custom page offset address"
+		- Select "Set custom kernel base address"
+		- Select "Set maximum low memory"
+	   - "Exit" and save the selection.
+
+	c. $ make uImage
+
+	d. $ cp arch/powerpc/boot/uImage /tftpboot/uImage.core1
+
+3. Create dtb for core0:
+
+	$ dtc -I dts -O dtb -f -b 0
+		 arch/powerpc/boot/dts/p2020rdb_camp_core0.dts >
+		 /tftpboot/p2020rdb_camp_core0.dtb
+
+4. Create dtb for core1:
+
+	$ dtc -I dts -O dtb -f -b 1
+		 arch/powerpc/boot/dts/p2020rdb_camp_core1.dts >
+		 /tftpboot/p2020rdb_camp_core1.dtb
+
+5. Bring up two cores separately:
+
+	a. Power on the board, under u-boot prompt:
+		=> setenv <serverip>
+		=> setenv <ipaddr>
+		=> setenv bootargs root=/dev/ram rw console=ttyS0,115200
+	b. Bring up core1's kernel first:
+		=> setenv bootm_low 0x20000000
+		=> setenv bootm_size 0x10000000
+		=> tftp 21000000 uImage.core1
+		=> tftp 22000000 ramdiskfile
+		=> tftp 20c00000 p2020rdb_camp_core1.dtb
+		=> interrupts off
+		=> bootm start 21000000 22000000 20c00000
+		=> bootm loados
+		=> bootm ramdisk
+		=> bootm fdt
+		=> fdt boardsetup
+		=> fdt chosen $initrd_start $initrd_end
+		=> bootm prep
+		=> cpu 1 release $bootm_low - $fdtaddr -
+	c. Bring up core0's kernel(on the same u-boot console):
+		=> setenv bootm_low 0
+		=> setenv bootm_size 0x20000000
+		=> tftp 1000000 uImage.core0
+		=> tftp 2000000 ramdiskfile
+		=> tftp c00000 p2020rdb_camp_core0.dtb
+		=> bootm 1000000 2000000 c00000
+
+Please note only core0 will run u-boot, core1 starts kernel directly
+after "cpu release" command is issued.
--- u-boot-2014.07/board/freescale/wgxtm_boren/wgxtm_boren.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/wgxtm_boren.c	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,317 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <tsec.h>
+#include <vsc7385.h>
+#include <netdev.h>
+#include <rtc.h>
+#include <i2c.h>
+#include <hwconfig.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define VSC7385_RST_SET		0x00080000
+#define SLIC_RST_SET		0x00040000
+#define SGMII_PHY_RST_SET	0x00020000
+#define PCIE_RST_SET		0x00010000
+#define RGMII_PHY_RST_SET	0x02000000
+
+#define USB_RST_CLR		0x04000000
+#define USB2_PORT_OUT_EN        0x01000000
+
+#define GPIO_DIR		0x060f0000
+
+#define BOARD_PERI_RST_SET	VSC7385_RST_SET | SLIC_RST_SET | \
+				SGMII_PHY_RST_SET | PCIE_RST_SET | \
+				RGMII_PHY_RST_SET
+
+#define SYSCLK_MASK	0x00200000
+#define BOARDREV_MASK	0x10100000
+#define BOARDREV_C	0x00100000
+#define BOARDREV_D	0x00000000
+
+#define SYSCLK_66	66666666
+#define SYSCLK_100	100000000
+
+unsigned long get_board_sys_clk(ulong dummy)
+{
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+	u32 val_gpdat, sysclk_gpio;
+	return SYSCLK_66;
+
+	val_gpdat = in_be32(&pgpio->gpdat);
+	sysclk_gpio = val_gpdat & SYSCLK_MASK;
+
+	if(sysclk_gpio == 0)
+		return SYSCLK_66;
+	else
+		return SYSCLK_100;
+
+	return 0;
+}
+
+#ifdef CONFIG_MMC
+int board_early_init_f (void)
+{
+	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	setbits_be32(&gur->pmuxcr,
+			(MPC85xx_PMUXCR_SDHC_CD |
+			 MPC85xx_PMUXCR_SDHC_WP));
+	return 0;
+}
+#endif
+
+int checkboard (void)
+{
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+#ifdef CONFIG_WGXTM_BOREN
+	char board_rev[] = "Boren Board";
+#else
+	u32 val_gpdat, board_rev_gpio;
+	char board_rev = 0;
+#endif
+	struct cpu_type *cpu;
+
+#ifdef CONFIG_WGXTM_BOREN
+	cpu = gd->arch.cpu;
+	printf ("Board: %sRDB Rev[%s]\n", cpu->name, board_rev);
+#else
+	val_gpdat = in_be32(&pgpio->gpdat);
+	board_rev_gpio = val_gpdat & BOARDREV_MASK;
+	if (board_rev_gpio == BOARDREV_C)
+		board_rev = 'C';
+	else if (board_rev_gpio == BOARDREV_D)
+		board_rev = 'D';
+	else
+		panic ("Unexpected Board REV %x detected!!\n", board_rev_gpio);
+
+	cpu = gd->arch.cpu;
+	printf ("Board: %sRDB Rev%c\n", cpu->name, board_rev);
+#endif /* end of CONFIG_WGXTM_BOREN */
+
+	setbits_be32(&pgpio->gpdir, GPIO_DIR);
+
+/*
+ * Bringing the following peripherals out of reset via GPIOs
+ * 0 = reset and 1 = out of reset
+ * GPIO12 - Reset to Ethernet Switch
+ * GPIO13 - Reset to SLIC/SLAC devices
+ * GPIO14 - Reset to SGMII_PHY_N
+ * GPIO15 - Reset to PCIe slots
+ * GPIO6  - Reset to RGMII PHY
+ * GPIO5  - Reset to USB3300 devices 1 = reset and 0 = out of reset
+ */
+	clrsetbits_be32(&pgpio->gpdat, USB_RST_CLR, BOARD_PERI_RST_SET);
+
+	return 0;
+}
+
+int misc_init_r(void)
+{
+#if defined(CONFIG_SDCARD) || defined(CONFIG_SPIFLASH)
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+	ccsr_gpio_t *gpio = (void *)CONFIG_SYS_MPC85xx_GPIO_ADDR;
+
+	setbits_be32(&gpio->gpdir, USB2_PORT_OUT_EN);
+	setbits_be32(&gpio->gpdat, USB2_PORT_OUT_EN);
+	setbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_ELBC_OFF_USB2_ON);
+#endif
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	unsigned int orig_bus = i2c_get_bus_num();
+	u8 i2c_data;
+
+	i2c_set_bus_num(1);
+	if (i2c_read(CONFIG_SYS_I2C_PCA9557_ADDR, 0,
+		1, &i2c_data, sizeof(i2c_data)) == 0) {
+		if (i2c_data & 0x2)
+			puts("NOR Flash Bank : Secondary\n");
+		else
+			puts("NOR Flash Bank : Primary\n");
+
+		if (i2c_data & 0x1) {
+			setbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_SD_DATA);
+			puts("SD/MMC : 8-bit Mode\n");
+			puts("eSPI : Disabled\n");
+		} else {
+			puts("SD/MMC : 4-bit Mode\n");
+			puts("eSPI : Enabled\n");
+		}
+	} else {
+		puts("Failed reading I2C Chip 0x18 on bus 1\n");
+	}
+	i2c_set_bus_num(orig_bus);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_16M, 1);
+	rtc_reset();
+	return 0;
+}
+
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct fsl_pq_mdio_info mdio_info;
+	struct tsec_info_struct tsec_info[4];
+	int num = 0;
+	char *tmp;
+	unsigned int vscfw_addr;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	SET_STD_TSEC_INFO(tsec_info[num], 3);
+	if (is_serdes_configured(SGMII_TSEC3)) {
+		puts("eTSEC3 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+#ifdef CONFIG_VSC7385_ENET
+/* If a VSC7385 microcode image is present, then upload it. */
+	if ((tmp = getenv ("vscfw_addr")) != NULL) {
+		vscfw_addr = simple_strtoul (tmp, NULL, 16);
+		printf("uploading VSC7385 microcode from %x\n", vscfw_addr);
+		if (vsc7385_upload_firmware((void *) vscfw_addr,
+					CONFIG_VSC7385_IMAGE_SIZE))
+			puts("Failure uploading VSC7385 microcode.\n");
+	} else
+		puts("No address specified for VSC7385 microcode.\n");
+#endif
+	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+	mdio_info.name = DEFAULT_MII_NAME;
+	fsl_pq_mdio_init(bis, &mdio_info);
+
+	tsec_eth_init(bis, tsec_info, num);
+
+	return pci_eth_init(bis);
+}
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+extern void ft_pci_board_setup(void *blob);
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	const char *soc_usb_compat = "fsl-usb2-dr";
+	int err, usb1_off, usb2_off;
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+#if defined(CONFIG_PCI)
+	ft_pci_board_setup(blob);
+#endif /* #if defined(CONFIG_PCI) */
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+	fdt_fixup_dr_usb(blob, bd);
+
+#if defined(CONFIG_SDCARD) || defined(CONFIG_SPIFLASH)
+	/* Delete eLBC node as it is muxed with USB2 controller */
+	if (hwconfig("usb2")) {
+		const char *soc_elbc_compat = "fsl,p1020-elbc";
+		int off = fdt_node_offset_by_compatible(blob, -1,
+			soc_elbc_compat);
+		if (off < 0) {
+			printf("WARNING: could not find compatible node"
+				" %s: %s.\n", soc_elbc_compat,
+				fdt_strerror(off));
+				return;
+		}
+		err = fdt_del_node(blob, off);
+		if (err < 0) {
+			printf("WARNING: could not remove %s: %s.\n",
+				soc_elbc_compat, fdt_strerror(err));
+		}
+		return;
+	}
+#endif
+	/* Delete USB2 node as it is muxed with eLBC */
+	usb1_off = fdt_node_offset_by_compatible(blob, -1,
+		soc_usb_compat);
+	if (usb1_off < 0) {
+		printf("WARNING: could not find compatible node"
+			" %s: %s.\n", soc_usb_compat,
+			fdt_strerror(usb1_off));
+		return;
+	}
+	usb2_off = fdt_node_offset_by_compatible(blob, usb1_off,
+			soc_usb_compat);
+	if (usb2_off < 0) {
+		printf("WARNING: could not find compatible node"
+			" %s: %s.\n", soc_usb_compat,
+			fdt_strerror(usb2_off));
+		return;
+	}
+	err = fdt_del_node(blob, usb2_off);
+	if (err < 0)
+		printf("WARNING: could not remove %s: %s.\n",
+			soc_usb_compat, fdt_strerror(err));
+}
+#endif
--- u-boot-2014.07/board/freescale/wgxtm_boren/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/wgxtm_boren/ddr.c	2022-05-09 14:06:23.365144030 -0700
@@ -0,0 +1,359 @@
+/*
+ * Copyright 2009, 2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_WGXTM_BOREN /* DDR Settings for  */
+#if defined(CONFIG_WGXTM_T50_BOREN)
+/* DDR setup for T50: DDR size = 2048M */
+/* P1020 w/ 2G DDR3 */
+#define CONFIG_SYS_DDR_CS0_BNDS			0x0000007F
+#define CONFIG_SYS_DDR_CS0_CONFIG		0x80014402
+#define CONFIG_SYS_DDR_CS0_CONFIG_2		0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR		0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL		0x00000000 
+#define CONFIG_SYS_DDR_ZQ_CONTROL		0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655F607
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xC70C0008	/* Type = DDR3*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401010
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x02401400
+
+#define CONFIG_SYS_DDR_TIMING_3_400	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_400	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_400	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_400	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_400	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_400	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_400	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_400	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_533	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_533	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_533	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_533	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_533	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_533	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_533	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_533	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00070000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x6f6b0644
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0FA8910c/* tFAW as 17 clks */
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00061220
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0A280000//0x0A28028A
+
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6F6D8644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA890CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_800	0x00061420
+#define CONFIG_SYS_DDR_MODE_2_800	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0C300000//0x0C30030C
+#elif defined(CONFIG_WGXTM_T30_BOREN)	/* P1011, DDR setup for T30: DDR size = 1024M */
+/* P1020 w/ 1G DDR3 */
+#define CONFIG_SYS_DDR_CS0_BNDS			0x0000003F
+#define CONFIG_SYS_DDR_CS0_CONFIG		0x80014302
+#define CONFIG_SYS_DDR_CS0_CONFIG_2		0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR		0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL		0x00000000 
+#define CONFIG_SYS_DDR_ZQ_CONTROL		0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655F607
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xC70C0008	/* Type = DDR3*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401010
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x02401400
+
+#define CONFIG_SYS_DDR_TIMING_3_400	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_400	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_400	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_400	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_400	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_400	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_400	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_400	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_533	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_533	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_533	0x6F6B4846
+#define CONFIG_SYS_DDR_TIMING_2_533	0x0FA8C8CF
+#define CONFIG_SYS_DDR_CLK_CTRL_533	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_533	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_533	0x8000C000
+#define CONFIG_SYS_DDR_INTERVAL_533	0x0C300000
+
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x5D5BD544
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0FA890D1/* tFAW as 17 clks */
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00061220
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0A280000//0x0A28028A
+
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6F6D8644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA890CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_800	0x00061420
+#define CONFIG_SYS_DDR_MODE_2_800	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0C300000//0x0C30030C
+#else //(_SC_DRAM_SIZE_ == 512)
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000003F
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014202
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x00000000
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x00000000
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0x43000000	/* Type = DDR2*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401000
+#define CONFIG_SYS_DDR_TIMING_4		0x00000000
+#define CONFIG_SYS_DDR_TIMING_5		0x00000000
+
+#define CONFIG_SYS_DDR_TIMING_3_400	0x00010000
+#define CONFIG_SYS_DDR_TIMING_0_400	0x00260802
+#define CONFIG_SYS_DDR_TIMING_1_400	0x39355322
+#define CONFIG_SYS_DDR_TIMING_2_400	0x1f9048ca
+#define CONFIG_SYS_DDR_CLK_CTRL_400	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_400	0x00480432
+#define CONFIG_SYS_DDR_MODE_2_400	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_400	0x06180100
+
+#define CONFIG_SYS_DDR_TIMING_3_533	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_533	0x00260802
+#define CONFIG_SYS_DDR_TIMING_1_533	0x4c47c432
+#define CONFIG_SYS_DDR_TIMING_2_533	0x0f9848ce
+#define CONFIG_SYS_DDR_CLK_CTRL_533	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_533	0x00040642
+#define CONFIG_SYS_DDR_MODE_2_533	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_533	0x08200100
+
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x55770802
+#define CONFIG_SYS_DDR_TIMING_1_667	0x5f599543
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0fa074d1
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00040852
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0a280100
+
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00040000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00770802
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6b6543
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0fa074d1
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_800	0x00040852
+#define CONFIG_SYS_DDR_MODE_2_800	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0c300100
+#endif
+#endif /* END_OF_AP331IB */
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_400 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_400,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_400,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_400,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_400,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_400,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_400,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_400,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_400,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_533 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_533,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_533,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_533,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_533,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_533,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_533,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_533,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_533,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_667 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_667,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_667,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_667,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_667,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_667,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_667,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_667,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_667,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_800 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_800,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_800,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_800,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_800,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_800,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_800,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_800,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_800,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+
+phys_size_t fixed_sdram (void)
+{
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	size_t ddr_size;
+	struct cpu_type *cpu;
+	ulong ddr_freq, ddr_freq_mhz;
+
+	cpu = gd->arch.cpu;
+
+	ddr_size = CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+
+#if defined(CONFIG_SYS_RAMBOOT)
+	return ddr_size;
+#endif
+	ddr_freq = get_ddr_freq(0);
+	ddr_freq_mhz = ddr_freq / 1000000;
+
+	printf("Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, ddr_freq));
+
+	if(ddr_freq_mhz <= 400)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_400, sizeof(ddr_cfg_regs));
+	else if(ddr_freq_mhz <= 533)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_533, sizeof(ddr_cfg_regs));
+	else if(ddr_freq_mhz <= 667)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_667, sizeof(ddr_cfg_regs));
+	else if(ddr_freq_mhz <= 800)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_800, sizeof(ddr_cfg_regs));
+	else
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+					strmhz(buf, ddr_freq));
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+	/* disable DRAM Bus 32bit width support, we applied 16bit in AP331IB */
+	/* P1020 and it's derivatives support max 32bit DDR width */
+	if (cpu->soc_ver == SVR_P1020 || cpu->soc_ver == SVR_P1011) {
+		ddr_cfg_regs.ddr_sdram_cfg |= SDRAM_CFG_32_BE;
+		//ddr_cfg_regs.cs[0].bnds = 0x0000001F;
+	}
+#endif /* END_OF_AP331IB */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+	ddr_cfg_regs.ddr_cdr1 = 0x80080000;//DDR_CDR1_DHC_EN;
+	ddr_cfg_regs.ddr_cdr2 = 0x00000001;//DDR_CDR1_DHC_EN;
+    printf("Set HW AUTO ODT\n");
+    //out_be32(&ddr->timing_cfg_3, regs->timing_cfg_3);
+	//ddr_cfg_regs.ddr_cdr1 |= DDR_CDR1_DHC_EN;
+#endif
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
+	set_ddr_laws(0, ddr_size, LAW_TRGT_IF_DDR_1);
+	return ddr_size;
+}
--- u-boot-2014.07/board/freescale/ls1021atwr/ls102xa_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/ls102xa_pbi.cfg	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,12 @@
+#PBI commands
+
+09570200 ffffffff
+09570158 00000300
+8940007c 21f47300
+
+#Configure Scratch register
+09ee0200 10000000
+#Configure alternate space
+09570158 00001000
+#Flush PBL data
+096100c0 000FFFFF
--- u-boot-2014.07/board/freescale/ls1021atwr/MAINTAINERS.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/MAINTAINERS	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,6 @@
+LS1021ATWR BOARD
+M:	Alison Wang <alison.wang@freescale.com>
+S:	Maintained
+F:	board/freescale/ls1021atwr/
+F:	include/configs/ls1021atwr.h
+F:	configs/ls1021atwr_nor_defconfig
--- u-boot-2014.07/board/freescale/ls1021atwr/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/Makefile	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,8 @@
+#
+# Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += ls1021atwr.o
+obj-$(CONFIG_FSL_DCU_FB) += dcu.o
--- u-boot-2014.07/board/freescale/ls1021atwr/ls1021atwr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/ls1021atwr.c	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,723 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <asm/io.h>
+#include <asm/arch/immap_ls102xa.h>
+#include <asm/arch/ns_access.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/ls102xa_stream_id.h>
+#include <asm/pcie_layerscape.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <fsl_ifc.h>
+#include <netdev.h>
+#include <fsl_mdio.h>
+#include <tsec.h>
+#include <spl.h>
+#ifdef CONFIG_U_QE
+#include "../../../drivers/qe/qe.h"
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+#include <fsl_sec.h>
+#include <jr.h>
+#include <fsl_secboot_err.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_SECURE_BOOT
+struct jobring jr;
+#endif
+
+#define VERSION_MASK		0x00FF
+#define BANK_MASK		0x0001
+#define CONFIG_RESET		0x1
+#define INIT_RESET		0x1
+
+#define CPLD_SET_MUX_SERDES	0x20
+#define CPLD_SET_BOOT_BANK	0x40
+
+#define BOOT_FROM_UPPER_BANK	0x0
+#define BOOT_FROM_LOWER_BANK	0x1
+
+#define LANEB_SATA		(0x01)
+#define LANEB_SGMII1		(0x02)
+#define LANEC_SGMII1		(0x04)
+#define LANEC_PCIEX1		(0x08)
+#define LANED_PCIEX2		(0x10)
+#define LANED_SGMII2		(0x20)
+
+#define MASK_LANE_B		0x1
+#define MASK_LANE_C		0x2
+#define MASK_LANE_D		0x4
+#define MASK_SGMII		0x8
+
+#define KEEP_STATUS		0x0
+#define NEED_RESET		0x1
+
+struct cpld_data {
+	u8 cpld_ver;		/* cpld revision */
+	u8 cpld_ver_sub;	/* cpld sub revision */
+	u8 pcba_ver;		/* pcb revision number */
+	u8 system_rst;		/* reset system by cpld */
+	u8 soft_mux_on;		/* CPLD override physical switches Enable */
+	u8 cfg_rcw_src1;	/* Reset config word 1 */
+	u8 cfg_rcw_src2;	/* Reset config word 2 */
+	u8 vbank;		/* Flash bank selection Control */
+	u8 gpio;		/* GPIO for TWR-ELEV */
+	u8 i2c3_ifc_mux;
+	u8 mux_spi2;
+	u8 can3_usb2_mux;	/* CAN3 and USB2 Selection */
+	u8 qe_lcd_mux;		/* QE and LCD Selection */
+	u8 serdes_mux;		/* Multiplexed pins for SerDes Lanes */
+	u8 global_rst;		/* reset with init CPLD reg to default */
+	u8 rev1;		/* Reserved */
+	u8 rev2;		/* Reserved */
+};
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+static void convert_serdes_mux(int type, int need_reset);
+
+void cpld_show(void)
+{
+	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+
+	printf("CPLD:  V%x.%x\nPCBA:  V%x.0\nVBank: %d\n",
+	       in_8(&cpld_data->cpld_ver) & VERSION_MASK,
+	       in_8(&cpld_data->cpld_ver_sub) & VERSION_MASK,
+	       in_8(&cpld_data->pcba_ver) & VERSION_MASK,
+	       in_8(&cpld_data->vbank) & BANK_MASK);
+
+#ifdef CONFIG_DEBUG
+	printf("soft_mux_on =%x\n",
+	       in_8(&cpld_data->soft_mux_on));
+	printf("cfg_rcw_src1 =%x\n",
+	       in_8(&cpld_data->cfg_rcw_src1));
+	printf("cfg_rcw_src2 =%x\n",
+	       in_8(&cpld_data->cfg_rcw_src2));
+	printf("vbank =%x\n",
+	       in_8(&cpld_data->vbank));
+	printf("gpio =%x\n",
+	       in_8(&cpld_data->gpio));
+	printf("i2c3_ifc_mux =%x\n",
+	       in_8(&cpld_data->i2c3_ifc_mux));
+	printf("mux_spi2 =%x\n",
+	       in_8(&cpld_data->mux_spi2));
+	printf("can3_usb2_mux =%x\n",
+	       in_8(&cpld_data->can3_usb2_mux));
+	printf("qe_lcd_mux =%x\n",
+	       in_8(&cpld_data->qe_lcd_mux));
+	printf("serdes_mux =%x\n",
+	       in_8(&cpld_data->serdes_mux));
+#endif
+}
+#endif
+
+int checkboard(void)
+{
+	puts("Board: LS1021ATWR\n");
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+	cpld_show();
+#endif
+
+	return 0;
+}
+
+void ddrmc_init(void)
+{
+	struct ccsr_ddr *ddr = (struct ccsr_ddr *)CONFIG_SYS_FSL_DDR_ADDR;
+
+	out_be32(&ddr->sdram_cfg, DDR_SDRAM_CFG);
+
+	out_be32(&ddr->cs0_bnds, DDR_CS0_BNDS);
+	out_be32(&ddr->cs0_config, DDR_CS0_CONFIG);
+
+	out_be32(&ddr->timing_cfg_0, DDR_TIMING_CFG_0);
+	out_be32(&ddr->timing_cfg_1, DDR_TIMING_CFG_1);
+	out_be32(&ddr->timing_cfg_2, DDR_TIMING_CFG_2);
+	out_be32(&ddr->timing_cfg_3, DDR_TIMING_CFG_3);
+	out_be32(&ddr->timing_cfg_4, DDR_TIMING_CFG_4);
+	out_be32(&ddr->timing_cfg_5, DDR_TIMING_CFG_5);
+
+	out_be32(&ddr->sdram_cfg_2,  DDR_SDRAM_CFG_2);
+
+	out_be32(&ddr->sdram_mode, DDR_SDRAM_MODE);
+	out_be32(&ddr->sdram_mode_2, DDR_SDRAM_MODE_2);
+
+	out_be32(&ddr->sdram_interval, DDR_SDRAM_INTERVAL);
+
+	out_be32(&ddr->ddr_wrlvl_cntl, DDR_DDR_WRLVL_CNTL);
+
+	out_be32(&ddr->ddr_wrlvl_cntl_2, DDR_DDR_WRLVL_CNTL_2);
+	out_be32(&ddr->ddr_wrlvl_cntl_3, DDR_DDR_WRLVL_CNTL_3);
+
+	out_be32(&ddr->ddr_cdr1, DDR_DDR_CDR1);
+	out_be32(&ddr->ddr_cdr2, DDR_DDR_CDR2);
+
+	out_be32(&ddr->sdram_clk_cntl, DDR_SDRAM_CLK_CNTL);
+	out_be32(&ddr->ddr_zq_cntl, DDR_DDR_ZQ_CNTL);
+
+	out_be32(&ddr->cs0_config_2, DDR_CS0_CONFIG_2);
+	udelay(1);
+	out_be32(&ddr->sdram_cfg, DDR_SDRAM_CFG | DDR_SDRAM_CFG_MEM_EN);
+}
+
+int dram_init(void)
+{
+#if (!defined(CONFIG_SPL) || defined(CONFIG_SPL_BUILD))
+	ddrmc_init();
+#endif
+
+	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+	return 0;
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg esdhc_cfg[1] = {
+	{CONFIG_SYS_FSL_ESDHC_ADDR},
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	esdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+
+	return fsl_esdhc_initialize(bis, &esdhc_cfg[0]);
+}
+#endif
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct fsl_pq_mdio_info mdio_info;
+	struct tsec_info_struct tsec_info[4];
+	int num = 0;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	if (is_serdes_configured(SGMII_TSEC1)) {
+		puts("eTSEC1 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	if (is_serdes_configured(SGMII_TSEC2)) {
+		puts("eTSEC2 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	SET_STD_TSEC_INFO(tsec_info[num], 3);
+	num++;
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+	mdio_info.name = DEFAULT_MII_NAME;
+	fsl_pq_mdio_init(bis, &mdio_info);
+
+	tsec_eth_init(bis, tsec_info, num);
+
+	return pci_eth_init(bis);
+}
+#endif
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+int config_serdes_mux(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 protocol = in_be32(&gur->rcwsr[4]) & RCWSR4_SRDS1_PRTCL_MASK;
+
+	protocol >>= RCWSR4_SRDS1_PRTCL_SHIFT;
+	switch (protocol) {
+	case 0x10:
+		convert_serdes_mux(LANEB_SATA, KEEP_STATUS);
+		convert_serdes_mux(LANED_PCIEX2 |
+				LANEC_PCIEX1, KEEP_STATUS);
+		break;
+	case 0x20:
+		convert_serdes_mux(LANEB_SGMII1, KEEP_STATUS);
+		convert_serdes_mux(LANEC_PCIEX1, KEEP_STATUS);
+		convert_serdes_mux(LANED_SGMII2, KEEP_STATUS);
+		break;
+	case 0x30:
+		convert_serdes_mux(LANEB_SATA, KEEP_STATUS);
+		convert_serdes_mux(LANEC_SGMII1, KEEP_STATUS);
+		convert_serdes_mux(LANED_SGMII2, KEEP_STATUS);
+		break;
+	case 0x70:
+		convert_serdes_mux(LANEB_SATA, KEEP_STATUS);
+		convert_serdes_mux(LANEC_PCIEX1, KEEP_STATUS);
+		convert_serdes_mux(LANED_SGMII2, KEEP_STATUS);
+		break;
+	}
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+#ifdef CONFIG_TSEC_ENET
+	out_be32(&scfg->etsecdmamcr, SCFG_ETSECDMAMCR_LE_BD_FR);
+	out_be32(&scfg->etsecmcr, SCFG_ETSECCMCR_GE2_CLK125);
+#endif
+
+#ifdef CONFIG_FSL_IFC
+	init_early_memctl_regs();
+#endif
+
+#ifdef CONFIG_FSL_DCU_FB
+	out_be32(&scfg->pixclkcr, SCFG_PIXCLKCR_PXCKEN);
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	out_be32(&scfg->qspi_cfg, SCFG_QSPI_CLKSEL);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_SPL_BUILD
+void board_init_f(ulong dummy)
+{
+	/* Set global data pointer */
+	gd = &gdata;
+
+	/* Clear the BSS */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	get_clocks();
+
+	preloader_console_init();
+
+	dram_init();
+
+	board_init_r(NULL, 0);
+}
+#endif
+
+#ifdef CONFIG_LS102XA_NS_ACESS
+static struct csu_ns_dev ns_dev[] = {
+	{ CSU_CSLX_PCIE2_IO, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1_IO, CSU_ALL_RW },
+	{ CSU_CSLX_MG2TPR_IP, CSU_ALL_RW },
+	{ CSU_CSLX_IFC_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM, CSU_ALL_RW },
+	{ CSU_CSLX_GIC, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE1, CSU_ALL_RW },
+	{ CSU_CSLX_OCRAM2, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI_MEM, CSU_ALL_RW },
+	{ CSU_CSLX_PCIE2, CSU_ALL_RW },
+	{ CSU_CSLX_SATA, CSU_ALL_RW },
+	{ CSU_CSLX_USB3, CSU_ALL_RW },
+	{ CSU_CSLX_SERDES, CSU_ALL_RW },
+	{ CSU_CSLX_QDMA, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART2, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART1, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART4, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART3, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART6, CSU_ALL_RW },
+	{ CSU_CSLX_LPUART5, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI2, CSU_ALL_RW },
+	{ CSU_CSLX_DSPI1, CSU_ALL_RW },
+	{ CSU_CSLX_QSPI, CSU_ALL_RW },
+	{ CSU_CSLX_ESDHC, CSU_ALL_RW },
+	{ CSU_CSLX_2D_ACE, CSU_ALL_RW },
+	{ CSU_CSLX_IFC, CSU_ALL_RW },
+	{ CSU_CSLX_I2C1, CSU_ALL_RW },
+	{ CSU_CSLX_USB2, CSU_ALL_RW },
+	{ CSU_CSLX_I2C3, CSU_ALL_RW },
+	{ CSU_CSLX_I2C2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART2, CSU_ALL_RW },
+	{ CSU_CSLX_DUART1, CSU_ALL_RW },
+	{ CSU_CSLX_WDT2, CSU_ALL_RW },
+	{ CSU_CSLX_WDT1, CSU_ALL_RW },
+	{ CSU_CSLX_EDMA, CSU_ALL_RW },
+	{ CSU_CSLX_SYS_CNT, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX2, CSU_ALL_RW },
+	{ CSU_CSLX_DMA_MUX1, CSU_ALL_RW },
+	{ CSU_CSLX_DDR, CSU_ALL_RW },
+	{ CSU_CSLX_QUICC, CSU_ALL_RW },
+	{ CSU_CSLX_DCFG_CCU_RCPM, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_BOOTROM, CSU_ALL_RW },
+	{ CSU_CSLX_SFP, CSU_ALL_RW },
+	{ CSU_CSLX_TMU, CSU_ALL_RW },
+	{ CSU_CSLX_SECURE_MONITOR, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED0, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC1, CSU_ALL_RW },
+	{ CSU_CSLX_SEC5_5, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC3, CSU_ALL_RW },
+	{ CSU_CSLX_ETSEC2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO2, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO1, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO4, CSU_ALL_RW },
+	{ CSU_CSLX_GPIO3, CSU_ALL_RW },
+	{ CSU_CSLX_PLATFORM_CONT, CSU_ALL_RW },
+	{ CSU_CSLX_CSU, CSU_ALL_RW },
+	{ CSU_CSLX_ASRC, CSU_ALL_RW },
+	{ CSU_CSLX_SPDIF, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN2, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN1, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN4, CSU_ALL_RW },
+	{ CSU_CSLX_FLEXCAN3, CSU_ALL_RW },
+	{ CSU_CSLX_SAI2, CSU_ALL_RW },
+	{ CSU_CSLX_SAI1, CSU_ALL_RW },
+	{ CSU_CSLX_SAI4, CSU_ALL_RW },
+	{ CSU_CSLX_SAI3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM2, CSU_ALL_RW },
+	{ CSU_CSLX_FTM1, CSU_ALL_RW },
+	{ CSU_CSLX_FTM4, CSU_ALL_RW },
+	{ CSU_CSLX_FTM3, CSU_ALL_RW },
+	{ CSU_CSLX_FTM6, CSU_ALL_RW },
+	{ CSU_CSLX_FTM5, CSU_ALL_RW },
+	{ CSU_CSLX_FTM8, CSU_ALL_RW },
+	{ CSU_CSLX_FTM7, CSU_ALL_RW },
+	{ CSU_CSLX_COP_DCSR, CSU_ALL_RW },
+	{ CSU_CSLX_EPU, CSU_ALL_RW },
+	{ CSU_CSLX_GDI, CSU_ALL_RW },
+	{ CSU_CSLX_DDI, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED1, CSU_ALL_RW },
+	{ CSU_CSLX_USB3_PHY, CSU_ALL_RW },
+	{ CSU_CSLX_RESERVED2, CSU_ALL_RW },
+};
+#endif
+
+struct liodn_id_table sec_liodn_tbl[] = {
+	SET_SEC_JR_LIODN_ENTRY(0, 0x10, 0x10),
+	SET_SEC_JR_LIODN_ENTRY(1, 0x10, 0x10),
+	SET_SEC_JR_LIODN_ENTRY(2, 0x10, 0x10),
+	SET_SEC_JR_LIODN_ENTRY(3, 0x10, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(a, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(b, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(c, 0x10),
+	SET_SEC_RTIC_LIODN_ENTRY(d, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(0, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(1, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(2, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(3, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(4, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(5, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(6, 0x10, 0x10),
+	SET_SEC_DECO_LIODN_ENTRY(7, 0x10, 0x10),
+};
+
+struct smmu_stream_id dev_stream_id[] = {
+	{ 0x100, 0x01, "ETSEC MAC1" },
+	{ 0x104, 0x02, "ETSEC MAC2" },
+	{ 0x108, 0x03, "ETSEC MAC3" },
+	{ 0x10c, 0x04, "PEX1" },
+	{ 0x110, 0x05, "PEX2" },
+	{ 0x114, 0x06, "qDMA" },
+	{ 0x118, 0x07, "SATA" },
+	{ 0x11c, 0x08, "USB3" },
+	{ 0x120, 0x09, "QE" },
+	{ 0x124, 0x0a, "eSDHC" },
+	{ 0x128, 0x0b, "eMA" },
+	{ 0x14c, 0x0c, "2D-ACE" },
+	{ 0x150, 0x0d, "USB2" },
+	{ 0x18c, 0x0e, "DEBUG" },
+};
+
+int board_init(void)
+{
+	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
+
+	/*
+	 * Set CCI-400 Slave interface S1, S2 Shareable Override Register
+	 * All transactions are treated as non-shareable
+	 */
+	out_le32(&cci->slave[1].sha_ord, CCI400_SHAORD_NON_SHAREABLE);
+	out_le32(&cci->slave[2].sha_ord, CCI400_SHAORD_NON_SHAREABLE);
+	out_le32(0x1185000, 0x3);
+#ifndef CONFIG_SYS_FSL_NO_SERDES
+	fsl_serdes_init();
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+	config_serdes_mux();
+#endif
+#endif
+
+	ls1021x_config_caam_stream_id(sec_liodn_tbl,
+				      ARRAY_SIZE(sec_liodn_tbl));
+	ls102xa_config_smmu_stream_id(dev_stream_id,
+				      ARRAY_SIZE(dev_stream_id));
+	/* Configure SMMU3 to make transactions with CAAM stream ID
+	 * as cacheable
+	 */
+	ls1021x_config_smmu3(0x10);
+#ifdef CONFIG_LS102XA_NS_ACESS
+	enable_devices_ns_access(ns_dev, ARRAY_SIZE(ns_dev));
+#endif
+
+#ifdef CONFIG_U_QE
+	u_qe_init();
+#endif
+
+	return 0;
+}
+
+#if defined(CONFIG_MISC_INIT_R)
+int misc_init_r(void)
+{
+#ifdef CONFIG_SECURE_BOOT
+	if (sec_init(&jr) < 0)
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_INIT);
+
+	if (get_rng_vid() >= 4)
+		if (rng_init(&jr) < 0)
+			return -1;
+#endif
+	return 0;
+}
+#endif
+
+int board_spi_find_bus(unsigned int bus, unsigned int cs)
+{
+	switch (bus) {
+	case SPI_BUS_FSL_QSPI:
+		break;
+	default:
+		return -1;
+	}
+
+	switch (bus) {
+	case SPI_BUS_FSL_QSPI:
+		if (cs == 0)
+			return 0;
+	default:
+		return -1;
+	}
+}
+
+void board_print_spi_device(void)
+{
+	printf("LS1021atwr spi flash info:\n");
+	printf("N25Q128A13 is on spi bus 0 cs 0\n");
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	ft_cpu_setup(blob, bd);
+
+#ifdef CONFIG_PCIE_LAYERSCAPE
+	ft_pcie_setup(blob, bd);
+#endif
+}
+
+u8 flash_read8(void *addr)
+{
+	return __raw_readb(addr + 1);
+}
+
+void flash_write16(u16 val, void *addr)
+{
+	u16 shftval = (((val >> 8) & 0xff) | ((val << 8) & 0xff00));
+
+	__raw_writew(shftval, addr);
+}
+
+u16 flash_read16(void *addr)
+{
+	u16 val = __raw_readw(addr);
+
+	return (((val) >> 8) & 0x00ff) | (((val) << 8) & 0xff00);
+}
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+static void convert_flash_bank(char bank)
+{
+	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+
+	printf("Now switch to boot from flash bank %d.\n", bank);
+	cpld_data->soft_mux_on = CPLD_SET_BOOT_BANK;
+	cpld_data->vbank = bank;
+
+	printf("Reset board to enable configuration.\n");
+	cpld_data->system_rst = CONFIG_RESET;
+}
+
+static int flash_bank_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+			  char * const argv[])
+{
+	if (argc != 2)
+		return CMD_RET_USAGE;
+	if (strcmp(argv[1], "0") == 0)
+		convert_flash_bank(BOOT_FROM_UPPER_BANK);
+	else if (strcmp(argv[1], "1") == 0)
+		convert_flash_bank(BOOT_FROM_LOWER_BANK);
+	else
+		return CMD_RET_USAGE;
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	boot_bank, 2, 0, flash_bank_cmd,
+	"Flash bank Selection Control",
+	"bank[0-upper bank/1-lower bank] (e.g. boot_bank 0)"
+);
+
+static int cpld_reset_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+			  char * const argv[])
+{
+	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+
+	if (argc > 2)
+		return CMD_RET_USAGE;
+	if ((argc == 1) || (strcmp(argv[1], "conf") == 0))
+		cpld_data->system_rst = CONFIG_RESET;
+	else if (strcmp(argv[1], "init") == 0)
+		cpld_data->global_rst = INIT_RESET;
+	else
+		return CMD_RET_USAGE;
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	cpld_reset, 2, 0, cpld_reset_cmd,
+	"Reset via CPLD",
+	"conf\n"
+	"	-reset with current CPLD configuration\n"
+	"init\n"
+	"	-reset and initial CPLD configuration with default value"
+
+);
+
+static void convert_serdes_mux(int type, int need_reset)
+{
+	char current_serdes;
+	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+
+	current_serdes = cpld_data->serdes_mux;
+
+	switch (type) {
+	case LANEB_SATA:
+		current_serdes &= ~MASK_LANE_B;
+		break;
+	case LANEB_SGMII1:
+		current_serdes |= (MASK_LANE_B | MASK_SGMII | MASK_LANE_C);
+		break;
+	case LANEC_SGMII1:
+		current_serdes &= ~(MASK_LANE_B | MASK_SGMII | MASK_LANE_C);
+		break;
+	case LANED_SGMII2:
+		current_serdes |= MASK_LANE_D;
+		break;
+	case LANEC_PCIEX1:
+		current_serdes |= MASK_LANE_C;
+		break;
+	case (LANED_PCIEX2 | LANEC_PCIEX1):
+		current_serdes |= MASK_LANE_C;
+		current_serdes &= ~MASK_LANE_D;
+		break;
+	default:
+		printf("CPLD serdes MUX: unsupported MUX type 0x%x\n", type);
+		return;
+	}
+
+	cpld_data->soft_mux_on |= CPLD_SET_MUX_SERDES;
+	cpld_data->serdes_mux = current_serdes;
+
+	if (need_reset == 1) {
+		printf("Reset board to enable configuration\n");
+		cpld_data->system_rst = CONFIG_RESET;
+	}
+}
+
+void print_serdes_mux(void)
+{
+	char current_serdes;
+	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+
+	current_serdes = cpld_data->serdes_mux;
+
+	printf("Serdes Lane B: ");
+	if ((current_serdes & MASK_LANE_B) == 0)
+		printf("SATA,\n");
+	else
+		printf("SGMII 1,\n");
+
+	printf("Serdes Lane C: ");
+	if ((current_serdes & MASK_LANE_C) == 0)
+		printf("SGMII 1,\n");
+	else
+		printf("PCIe,\n");
+
+	printf("Serdes Lane D: ");
+	if ((current_serdes & MASK_LANE_D) == 0)
+		printf("PCIe,\n");
+	else
+		printf("SGMII 2,\n");
+
+	printf("SGMII 1 is on lane ");
+	if ((current_serdes & MASK_SGMII) == 0)
+		printf("C.\n");
+	else
+		printf("B.\n");
+}
+
+static int serdes_mux_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+			  char * const argv[])
+{
+	if (argc != 2)
+		return CMD_RET_USAGE;
+	if (strcmp(argv[1], "sata") == 0) {
+		printf("Set serdes lane B to SATA.\n");
+		convert_serdes_mux(LANEB_SATA, NEED_RESET);
+	} else if (strcmp(argv[1], "sgmii1b") == 0) {
+		printf("Set serdes lane B to SGMII 1.\n");
+		convert_serdes_mux(LANEB_SGMII1, NEED_RESET);
+	} else if (strcmp(argv[1], "sgmii1c") == 0) {
+		printf("Set serdes lane C to SGMII 1.\n");
+		convert_serdes_mux(LANEC_SGMII1, NEED_RESET);
+	} else if (strcmp(argv[1], "sgmii2") == 0) {
+		printf("Set serdes lane D to SGMII 2.\n");
+		convert_serdes_mux(LANED_SGMII2, NEED_RESET);
+	} else if (strcmp(argv[1], "pciex1") == 0) {
+		printf("Set serdes lane C to PCIe X1.\n");
+		convert_serdes_mux(LANEC_PCIEX1, NEED_RESET);
+	} else if (strcmp(argv[1], "pciex2") == 0) {
+		printf("Set serdes lane C & lane D to PCIe X2.\n");
+		convert_serdes_mux((LANED_PCIEX2 | LANEC_PCIEX1), NEED_RESET);
+	} else if (strcmp(argv[1], "show") == 0) {
+		print_serdes_mux();
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	lane_bank, 2, 0, serdes_mux_cmd,
+	"Multiplexed function setting for SerDes Lanes",
+	"sata\n"
+	"	-change lane B to sata\n"
+	"lane_bank sgmii1b\n"
+	"	-change lane B to SGMII1\n"
+	"lane_bank sgmii1c\n"
+	"	-change lane C to SGMII1\n"
+	"lane_bank sgmii2\n"
+	"	-change lane D to SGMII2\n"
+	"lane_bank pciex1\n"
+	"	-change lane C to PCIeX1\n"
+	"lane_bank pciex2\n"
+	"	-change lane C & lane D to PCIeX2\n"
+	"\nWARNING: If you aren't familiar with the setting of serdes, don't try to change anything!\n"
+);
+#endif
--- u-boot-2014.07/board/freescale/ls1021atwr/Kconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/Kconfig	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,23 @@
+if TARGET_LS1021ATWR
+
+config SYS_CPU
+	string
+	default "armv7"
+
+config SYS_BOARD
+	string
+	default "ls1021atwr"
+
+config SYS_VENDOR
+	string
+	default "freescale"
+
+config SYS_SOC
+	string
+	default "ls102xa"
+
+config SYS_CONFIG_NAME
+	string
+	default "ls1021atwr"
+
+endif
--- u-boot-2014.07/board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,14 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+
+#enable IFC, disable QSPI and DSPI
+#0608000a 00000000 00000000 00000000
+#20000000 00404000 60025a00 21042000
+#00200000 00000000 00000000 01038000
+#00000000 001b1200 00000000 00000000
+
+#disable IFC, enable QSPI and DSPI
+0608000a 00000000 00000000 00000000
+20000000 00407900 60025a00 21046000
+00000000 00000000 00000000 01038000
+20024800 881b1540 00000000 00000000
--- u-boot-2014.07/board/freescale/ls1021atwr/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/README	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,109 @@
+Overview
+--------
+The LS1021ATWR is a Freescale reference board that hosts the LS1021A SoC.
+
+LS1021A SoC Overview
+------------------
+The QorIQ LS1 family, which includes the LS1021A communications processor,
+is built on Layerscape architecture, the industry's first software-aware,
+core-agnostic networking architecture to offer unprecedented efficiency
+and scale.
+
+A member of the value-performance tier, the QorIQ LS1021A processor provides
+extensive integration and power efficiency for fanless, small form factor
+enterprise networking applications. Incorporating dual ARM Cortex-A7 cores
+running up to 1.0 GHz, the LS1021A processor delivers pre-silicon CoreMark
+performance of over 6,000, as well as virtualization support, advanced
+security features and the broadest array of high-speed interconnects and
+optimized peripheral features ever offered in a sub-3 W processor.
+
+The QorIQ LS1021A processor features an integrated LCD controller,
+CAN controller for implementing industrial protocols, DDR3L/4 running
+up to 1600 MHz, integrated security engine and QUICC Engine, and ECC
+protection on both L1 and L2 caches. The LS1021A processor is pin- and
+software-compatible with the QorIQ LS1020A and LS1022A processors.
+
+The LS1021A SoC includes the following function and features:
+
+ - ARM Cortex-A7 MPCore compliant with ARMv7-A architecture
+ - Dual high-preformance ARM Cortex-A7 cores, each core includes:
+   - 32 Kbyte L1 Instruction Cache and Data Cache for each core (ECC protection)
+   - 512 Kbyte shared coherent L2 Cache (with ECC protection)
+   - NEON Co-processor (per core)
+   - 40-bit physical addressing
+   - Vector floating-point support
+ - ARM Core-Link CCI-400 Cache Coherent Interconnect
+ - One DDR3L/DDR4 SDRAM memory controller with x8/x16/x32-bit configuration
+   supporting speeds up to 1600Mtps
+   - ECC and interleaving support
+ - VeTSEC Ethernet complex
+   - Up to 3x virtualized 10/100/1000 Ethernet controllers
+   - MII, RMII, RGMII, and SGMII support
+   - QoS, lossless flow control, and IEEE 1588 support
+ - 4-lane 6GHz SerDes
+ - High speed interconnect (4 SerDes lanes with are muxed for these protocol)
+   - Two PCI Express Gen2 controllers running at up to 5 GHz
+   - One Serial ATA 3.0 supporting 6 GT/s operation
+   - Two SGMII interfaces supporting 1000 Mbps
+ - Additional peripheral interfaces
+   - One high-speed USB 3.0 controller with integrated PHY and one high-speed
+     USB 2.00 controller with ULPI
+   - Integrated flash controller (IFC) with 16-bit interface
+   - Quad SPI NOR Flash
+   - One enhanced Secure digital host controller
+   - Display controller unit (DCU) 24-bit RGB (12-bit DDR pin interface)
+   - Ten UARTs comprised of two 16550 compliant DUARTs, and six low power
+     UARTs
+   - Three I2C controllers
+   - Eight FlexTimers four supporting PWM and four FlexCAN ports
+   - Four GPIO controllers supporting up to 109 general purpose I/O signals
+ - Integrated advanced audio block:
+   - Four synchronous audio interfaces (SAI)
+   - Sony/Philips Digital Interconnect Format (SPDIF)
+   - Asynchronous Sample Rate Converter (ASRC)
+ - Hardware based crypto offload engine
+   - IPSec forwarding at up to 1Gbps
+   - QorIQ Trust Architecture, Secure Boot, and ARM TrustZone supported
+   - Public key hardware accelerator
+   - True Random Number Generator (NIST Certified)
+   - Advanced Encryption Standard Accelerators (AESA)
+   - Data Encryption Standard Accelerators
+ - QUICC Engine ULite block
+   - Two universal communication controllers (TDM and HDLC) supporting 64
+   multichannels, each running at 64 Kbps
+   - Support for 256 channels of HDLC
+ - QorIQ TrustArchitecture with Secure Boot, as well as ARM TrustZone supported
+
+LS1021ATWR board Overview
+-------------------------
+ - DDR Controller
+     - Supports rates of up to 1600 MHz data-rate
+     - Supports one DDR3LP SDRAM.
+ - IFC/Local Bus
+     - NOR: 128MB 16-bit NOR Flash
+ - Ethernet
+     - Three on-board RGMII 10/100/1G ethernet ports.
+ - CPLD
+ - Clocks
+     - System and DDR clock (SYSCLK, DDRCLK)
+     - SERDES clocks
+ - Power Supplies
+ - SDHC
+     - SDHC/SDXC connector
+ - Other IO
+    - One Serial port
+    - Three I2C ports
+
+Memory map
+-----------
+The addresses in brackets are physical addresses.
+
+Start Address	End Address	Description			Size
+0x00_0000_0000	0x00_000F_FFFF	Secure Boot ROM			1MB
+0x00_0100_0000	0x00_0FFF_FFFF	CCSRBAR				240MB
+0x00_1000_0000	0x00_1000_FFFF	OCRAM0				64KB
+0x00_1001_0000	0x00_1001_FFFF	OCRAM1				64KB
+0x00_2000_0000	0x00_20FF_FFFF	DCSR				16MB
+0x00_4000_0000	0x00_5FFF_FFFF	QSPI				512MB
+0x00_6000_0000	0x00_67FF_FFFF	IFC - NOR Flash			128MB
+0x00_8000_0000	0x00_FFFF_FFFF	DRAM1				2GB
--- u-boot-2014.07/board/freescale/ls1021atwr/dcu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/ls1021atwr/dcu.c	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * FSL DCU Framebuffer driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_dcu_fb.h>
+#include "div64.h"
+#include "../common/dcu_sii9022a.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+unsigned int dcu_set_pixel_clock(unsigned int pixclock)
+{
+	unsigned long long div;
+
+	div = (unsigned long long)(gd->bus_clk / 1000);
+	div *= (unsigned long long)pixclock;
+	do_div(div, 1000000000);
+
+	return div;
+}
+
+int platform_dcu_init(unsigned int xres, unsigned int yres,
+		      const char *port,
+		      struct fb_videomode *dcu_fb_videomode)
+{
+	const char *name;
+	unsigned int pixel_format;
+
+	if (strncmp(port, "twr_lcd", 4) == 0) {
+		name = "TWR_LCD_RGB card";
+	} else {
+		name = "HDMI";
+		dcu_set_dvi_encoder(dcu_fb_videomode);
+	}
+
+	printf("DCU: Switching to %s monitor @ %ux%u\n", name, xres, yres);
+
+	pixel_format = 32;
+	fsl_dcu_init(xres, yres, pixel_format);
+
+	return 0;
+}
--- u-boot-2014.07/board/freescale/common/dcu_sii9022a.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/dcu_sii9022a.h	2022-05-09 14:06:23.285147265 -0700
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __DCU_HDMI_SII9022A__
+#define __DCU_HDMI_SII9022A__
+
+/* Programming of Silicon SII9022A connector HDMI Transmitter*/
+int dcu_set_dvi_encoder(struct fb_videomode *videomode);
+
+#endif
--- u-boot-2014.07/board/freescale/common/vid.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/vid.c	2022-05-09 14:06:23.289147104 -0700
@@ -0,0 +1,491 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <asm/immap_85xx.h>
+#include "vid.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int __weak i2c_multiplexer_select_vid_channel(u8 channel)
+{
+	return 0;
+}
+
+/*
+ * Compensate for a board specific voltage drop between regulator and SoC
+ * return a value in mV
+ */
+int __weak board_vdd_drop_compensation(void)
+{
+	return 0;
+}
+
+/*
+ * Get the i2c address configuration for the IR regulator chip
+ *
+ * There are some variance in the RDB HW regarding the I2C address configuration
+ * for the IR regulator chip, which is likely a problem of external resistor
+ * accuracy. So we just check each address in a hopefully non-intrusive mode
+ * and use the first one that seems to work
+ *
+ * The IR chip can show up under the following addresses:
+ * 0x08 (Verified on T1040RDB-PA,T4240RDB-PB,X-T4240RDB-16GPA)
+ * 0x09 (Verified on T1040RDB-PA)
+ * 0x38 (Verified on T2080QDS, T2081QDS)
+ */
+static int find_ir_chip_on_i2c(void)
+{
+	int i2caddress;
+	int ret;
+	u8 byte;
+	int i;
+	const int ir_i2c_addr[] = {0x38, 0x08, 0x09};
+
+	/* Check all the address */
+	for (i = 0; i < (sizeof(ir_i2c_addr)/sizeof(ir_i2c_addr[0])); i++) {
+		i2caddress = ir_i2c_addr[i];
+		ret = i2c_read(i2caddress,
+			       IR36021_MFR_ID_OFFSET, 1, (void *)&byte,
+			       sizeof(byte));
+		if ((ret >= 0) && (byte == IR36021_MFR_ID))
+			return i2caddress;
+	}
+	return -1;
+}
+
+/* Maximum loop count waiting for new voltage to take effect */
+#define MAX_LOOP_WAIT_NEW_VOL		100
+/* Maximum loop count waiting for the voltage to be stable */
+#define MAX_LOOP_WAIT_VOL_STABLE	100
+/*
+ * read_voltage from sensor on I2C bus
+ * We use average of 4 readings, waiting for WAIT_FOR_ADC before
+ * another reading
+ */
+#define NUM_READINGS    4       /* prefer to be power of 2 for efficiency */
+
+/* If an INA220 chip is available, we can use it to read back the voltage
+ * as it may have a higher accuracy than the IR chip for the same purpose
+ */
+#ifdef CONFIG_VOL_MONITOR_INA220
+#define WAIT_FOR_ADC	532	/* wait for 532 microseconds for ADC */
+#define ADC_MIN_ACCURACY	4
+#else
+#define WAIT_FOR_ADC	138	/* wait for 138 microseconds for ADC */
+#define ADC_MIN_ACCURACY	4
+#endif
+
+#ifdef CONFIG_VOL_MONITOR_INA220
+static int read_voltage_from_INA220(int i2caddress)
+{
+	int i, ret, voltage_read = 0;
+	u16 vol_mon;
+	u8 buf[2];
+
+	for (i = 0; i < NUM_READINGS; i++) {
+		ret = i2c_read(I2C_VOL_MONITOR_ADDR,
+			       I2C_VOL_MONITOR_BUS_V_OFFSET, 1,
+			       (void *)&buf, 2);
+		if (ret) {
+			printf("VID: failed to read core voltage\n");
+			return ret;
+		}
+		vol_mon = (buf[0] << 8) | buf[1];
+		if (vol_mon & I2C_VOL_MONITOR_BUS_V_OVF) {
+			printf("VID: Core voltage sensor error\n");
+			return -1;
+		}
+		debug("VID: bus voltage reads 0x%04x\n", vol_mon);
+		/* LSB = 4mv */
+		voltage_read += (vol_mon >> I2C_VOL_MONITOR_BUS_V_SHIFT) * 4;
+		udelay(WAIT_FOR_ADC);
+	}
+	/* calculate the average */
+	voltage_read /= NUM_READINGS;
+
+	return voltage_read;
+}
+#endif
+
+/* read voltage from IR */
+#ifdef CONFIG_VOL_MONITOR_IR36021_READ
+static int read_voltage_from_IR(int i2caddress)
+{
+	int i, ret, voltage_read = 0;
+	u16 vol_mon;
+	u8 buf;
+
+	for (i = 0; i < NUM_READINGS; i++) {
+		ret = i2c_read(i2caddress,
+			       IR36021_LOOP1_VOUT_OFFSET,
+			       1, (void *)&buf, 1);
+		if (ret) {
+			printf("VID: failed to read vcpu\n");
+			return ret;
+		}
+		vol_mon = buf;
+		if (!vol_mon) {
+			printf("VID: Core voltage sensor error\n");
+			return -1;
+		}
+		debug("VID: bus voltage reads 0x%02x\n", vol_mon);
+		/* Resolution is 1/128V. We scale up here to get 1/128mV
+		 * and divide at the end
+		 */
+		voltage_read += vol_mon * 1000;
+		udelay(WAIT_FOR_ADC);
+	}
+	/* Scale down to the real mV as IR resolution is 1/128V, rounding up */
+	voltage_read = DIV_ROUND_UP(voltage_read, 128);
+
+	/* calculate the average */
+	voltage_read /= NUM_READINGS;
+
+	/* Compensate for a board specific voltage drop between regulator and
+	 * SoC before converting into an IR VID value
+	 */
+	voltage_read -= board_vdd_drop_compensation();
+
+	return voltage_read;
+}
+#endif
+
+static int read_voltage(int i2caddress)
+{
+	int voltage_read;
+#ifdef CONFIG_VOL_MONITOR_INA220
+	voltage_read = read_voltage_from_INA220(i2caddress);
+#elif defined CONFIG_VOL_MONITOR_IR36021_READ
+	voltage_read = read_voltage_from_IR(i2caddress);
+#else
+	return -1;
+#endif
+	return voltage_read;
+}
+
+/*
+ * We need to calculate how long before the voltage stops to drop
+ * or increase. It returns with the loop count. Each loop takes
+ * several readings (WAIT_FOR_ADC)
+ */
+static int wait_for_new_voltage(int vdd, int i2caddress)
+{
+	int timeout, vdd_current;
+
+	vdd_current = read_voltage(i2caddress);
+	/* wait until voltage starts to reach the target. Voltage slew
+	 * rates by typical regulators will always lead to stable readings
+	 * within each fairly long ADC interval in comparison to the
+	 * intended voltage delta change until the target voltage is
+	 * reached. The fairly small voltage delta change to any target
+	 * VID voltage also means that this function will always complete
+	 * within few iterations. If the timeout was ever reached, it would
+	 * point to a serious failure in the regulator system.
+	 */
+	for (timeout = 0;
+	     abs(vdd - vdd_current) > (IR_VDD_STEP_UP + IR_VDD_STEP_DOWN) &&
+	     timeout < MAX_LOOP_WAIT_NEW_VOL; timeout++) {
+		vdd_current = read_voltage(i2caddress);
+	}
+	if (timeout >= MAX_LOOP_WAIT_NEW_VOL) {
+		printf("VID: Voltage adjustment timeout\n");
+		return -1;
+	}
+	return timeout;
+}
+
+/*
+ * this function keeps reading the voltage until it is stable or until the
+ * timeout expires
+ */
+static int wait_for_voltage_stable(int i2caddress)
+{
+	int timeout, vdd_current, vdd;
+
+	vdd = read_voltage(i2caddress);
+	udelay(NUM_READINGS * WAIT_FOR_ADC);
+
+	/* wait until voltage is stable */
+	vdd_current = read_voltage(i2caddress);
+	/* The maximum timeout is
+	 * MAX_LOOP_WAIT_VOL_STABLE * NUM_READINGS * WAIT_FOR_ADC
+	 */
+	for (timeout = MAX_LOOP_WAIT_VOL_STABLE;
+	     abs(vdd - vdd_current) > ADC_MIN_ACCURACY &&
+	     timeout > 0; timeout--) {
+		vdd = vdd_current;
+		udelay(NUM_READINGS * WAIT_FOR_ADC);
+		vdd_current = read_voltage(i2caddress);
+	}
+	if (timeout == 0)
+		return -1;
+	return vdd_current;
+}
+
+#ifdef CONFIG_VOL_MONITOR_IR36021_SET
+/* Set the voltage to the IR chip */
+static int set_voltage_to_IR(int i2caddress, int vdd)
+{
+	int wait, vdd_last;
+	int ret;
+	u8 vid;
+
+	/* Compensate for a board specific voltage drop between regulator and
+	 * SoC before converting into an IR VID value
+	 */
+	vdd += board_vdd_drop_compensation();
+	vid = DIV_ROUND_UP(vdd - 245, 5);
+
+	ret = i2c_write(i2caddress, IR36021_LOOP1_MANUAL_ID_OFFSET,
+			1, (void *)&vid, sizeof(vid));
+	if (ret) {
+		printf("VID: failed to write VID\n");
+		return -1;
+	}
+	wait = wait_for_new_voltage(vdd, i2caddress);
+	if (wait < 0)
+		return -1;
+	debug("VID: Waited %d us\n", wait * NUM_READINGS * WAIT_FOR_ADC);
+
+	vdd_last = wait_for_voltage_stable(i2caddress);
+	if (vdd_last < 0)
+		return -1;
+	debug("VID: Current voltage is %d mV\n", vdd_last);
+	return vdd_last;
+}
+#endif
+
+static int set_voltage(int i2caddress, int vdd)
+{
+	int vdd_last = -1;
+
+#ifdef CONFIG_VOL_MONITOR_IR36021_SET
+	vdd_last = set_voltage_to_IR(i2caddress, vdd);
+#else
+	#error Specific voltage monitor must be defined
+#endif
+	return vdd_last;
+}
+
+int adjust_vdd(ulong vdd_override)
+{
+	int re_enable = disable_interrupts();
+	ccsr_gur_t __iomem *gur =
+		(void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 fusesr;
+	u8 vid;
+	int vdd_target, vdd_current, vdd_last;
+	int ret, i2caddress;
+	unsigned long vdd_string_override;
+	char *vdd_string;
+	static const uint16_t vdd[32] = {
+		0,      /* unused */
+		9875,   /* 0.9875V */
+		9750,
+		9625,
+		9500,
+		9375,
+		9250,
+		9125,
+		9000,
+		8875,
+		8750,
+		8625,
+		8500,
+		8375,
+		8250,
+		8125,
+		10000,  /* 1.0000V */
+		10125,
+		10250,
+		10375,
+		10500,
+		10625,
+		10750,
+		10875,
+		11000,
+		0,      /* reserved */
+	};
+	struct vdd_drive {
+		u8 vid;
+		unsigned voltage;
+	};
+
+	ret = i2c_multiplexer_select_vid_channel(I2C_MUX_CH_VOL_MONITOR);
+	if (ret) {
+		debug("VID: I2C failed to switch channel\n");
+		ret = -1;
+		goto exit;
+	}
+	ret = find_ir_chip_on_i2c();
+	if (ret < 0) {
+		printf("VID: Could not find voltage regulator on I2C.\n");
+		ret = -1;
+		goto exit;
+	} else {
+		i2caddress = ret;
+		debug("VID: IR Chip found on I2C address 0x%02x\n", i2caddress);
+	}
+
+	/* get the voltage ID from fuse status register */
+	fusesr = in_be32(&gur->dcfg_fusesr);
+	/*
+	 * VID is used according to the table below
+	 *                ---------------------------------------
+	 *                |                DA_V                 |
+	 *                |-------------------------------------|
+	 *                | 5b00000 | 5b00001-5b11110 | 5b11111 |
+	 * ---------------+---------+-----------------+---------|
+	 * | D | 5b00000  | NO VID  | VID = DA_V      | NO VID  |
+	 * | A |----------+---------+-----------------+---------|
+	 * | _ | 5b00001  |VID =    | VID =           |VID =    |
+	 * | V |   ~      | DA_V_ALT|   DA_V_ALT      | DA_A_VLT|
+	 * | _ | 5b11110  |         |                 |         |
+	 * | A |----------+---------+-----------------+---------|
+	 * | L | 5b11111  | No VID  | VID = DA_V      | NO VID  |
+	 * | T |          |         |                 |         |
+	 * ------------------------------------------------------
+	 */
+	vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_ALTVID_SHIFT) &
+		FSL_CORENET_DCFG_FUSESR_ALTVID_MASK;
+	if ((vid == 0) || (vid == FSL_CORENET_DCFG_FUSESR_ALTVID_MASK)) {
+		vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_VID_SHIFT) &
+			FSL_CORENET_DCFG_FUSESR_VID_MASK;
+	}
+	vdd_target = vdd[vid];
+
+	/* check override variable for overriding VDD */
+	vdd_string = getenv(CONFIG_VID_FLS_ENV);
+	if (vdd_override == 0 && vdd_string &&
+	    !strict_strtoul(vdd_string, 10, &vdd_string_override))
+		vdd_override = vdd_string_override;
+	if (vdd_override >= VDD_MV_MIN && vdd_override <= VDD_MV_MAX) {
+		vdd_target = vdd_override * 10; /* convert to 1/10 mV */
+		debug("VDD override is %lu\n", vdd_override);
+	} else if (vdd_override != 0) {
+		printf("Invalid value.\n");
+	}
+	if (vdd_target == 0) {
+		debug("VID: VID not used\n");
+		ret = 0;
+		goto exit;
+	} else {
+		/* divide and round up by 10 to get a value in mV */
+		vdd_target = DIV_ROUND_UP(vdd_target, 10);
+		debug("VID: vid = %d mV\n", vdd_target);
+	}
+
+	/*
+	 * Read voltage monitor to check real voltage.
+	 */
+	vdd_last = read_voltage(i2caddress);
+	if (vdd_last < 0) {
+		printf("VID: Couldn't read sensor abort VID adjustment\n");
+		ret = -1;
+		goto exit;
+	}
+	vdd_current = vdd_last;
+	debug("VID: Core voltage is currently at %d mV\n", vdd_last);
+	/*
+	  * Adjust voltage to at or one step above target.
+	  * As measurements are less precise than setting the values
+	  * we may run through dummy steps that cancel each other
+	  * when stepping up and then down.
+	  */
+	while (vdd_last > 0 &&
+	       vdd_last < vdd_target) {
+		vdd_current += IR_VDD_STEP_UP;
+		vdd_last = set_voltage(i2caddress, vdd_current);
+	}
+	while (vdd_last > 0 &&
+	       vdd_last > vdd_target + (IR_VDD_STEP_DOWN - 1)) {
+		vdd_current -= IR_VDD_STEP_DOWN;
+		vdd_last = set_voltage(i2caddress, vdd_current);
+	}
+
+	if (vdd_last > 0)
+		printf("VID: Core voltage after adjustment is at %d mV\n",
+		       vdd_last);
+	else
+		ret = -1;
+exit:
+	if (re_enable)
+		enable_interrupts();
+	return ret;
+}
+
+static int print_vdd(void)
+{
+	int vdd_last, ret, i2caddress;
+
+	ret = i2c_multiplexer_select_vid_channel(I2C_MUX_CH_VOL_MONITOR);
+	if (ret) {
+		debug("VID : I2c failed to switch channel\n");
+		return -1;
+	}
+	ret = find_ir_chip_on_i2c();
+	if (ret < 0) {
+		printf("VID: Could not find voltage regulator on I2C.\n");
+		return -1;
+	} else {
+		i2caddress = ret;
+		debug("VID: IR Chip found on I2C address 0x%02x\n", i2caddress);
+	}
+
+	/*
+	 * Read voltage monitor to check real voltage.
+	 */
+	vdd_last = read_voltage(i2caddress);
+	if (vdd_last < 0) {
+		printf("VID: Couldn't read sensor abort VID adjustment\n");
+		return -1;
+	}
+	printf("VID: Core voltage is at %d mV\n", vdd_last);
+
+	return 0;
+}
+
+static int do_vdd_override(cmd_tbl_t *cmdtp,
+			   int flag, int argc,
+			   char * const argv[])
+{
+	ulong override;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	if (!strict_strtoul(argv[1], 10, &override))
+		adjust_vdd(override);   /* the value is checked by callee */
+	else
+		return CMD_RET_USAGE;
+	return 0;
+}
+
+static int do_vdd_read(cmd_tbl_t *cmdtp,
+			 int flag, int argc,
+			 char * const argv[])
+{
+	if (argc < 1)
+		return CMD_RET_USAGE;
+	print_vdd();
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	vdd_override, 2, 0, do_vdd_override,
+	"override VDD",
+	" - override with the voltage specified in mV, eg. 1050"
+);
+
+U_BOOT_CMD(
+	vdd_read, 1, 0, do_vdd_read,
+	"read VDD",
+	" - Read the voltage specified in mV"
+)
--- u-boot-2014.07/board/freescale/common/diu_ch7301.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/diu_ch7301.c	2022-05-09 14:06:23.285147265 -0700
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Authors: Priyanka Jain <Priyanka.Jain@freescale.com>
+ *	    Wang Dongsheng <dongsheng.wang@freescale.com>
+ *
+ * This file is copied and modified from the original t1040qds/diu.c.
+ * Encoder can be used in T104x and LSx Platform.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <stdio_dev.h>
+#include <i2c.h>
+
+#define I2C_DVI_INPUT_DATA_FORMAT_REG		0x1F
+#define I2C_DVI_PLL_CHARGE_CNTL_REG		0x33
+#define I2C_DVI_PLL_DIVIDER_REG			0x34
+#define I2C_DVI_PLL_SUPPLY_CNTL_REG		0x35
+#define I2C_DVI_PLL_FILTER_REG			0x36
+#define I2C_DVI_TEST_PATTERN_REG		0x48
+#define I2C_DVI_POWER_MGMT_REG			0x49
+#define I2C_DVI_LOCK_STATE_REG			0x4D
+#define I2C_DVI_SYNC_POLARITY_REG		0x56
+
+/*
+ * Set VSYNC/HSYNC to active high. This is polarity of sync signals
+ * from DIU->DVI. The DIU default is active igh, so DVI is set to
+ * active high.
+ */
+#define I2C_DVI_INPUT_DATA_FORMAT_VAL		0x98
+
+#define I2C_DVI_PLL_CHARGE_CNTL_HIGH_SPEED_VAL	0x06
+#define I2C_DVI_PLL_DIVIDER_HIGH_SPEED_VAL	0x26
+#define I2C_DVI_PLL_FILTER_HIGH_SPEED_VAL	0xA0
+#define I2C_DVI_PLL_CHARGE_CNTL_LOW_SPEED_VAL	0x08
+#define I2C_DVI_PLL_DIVIDER_LOW_SPEED_VAL	0x16
+#define I2C_DVI_PLL_FILTER_LOW_SPEED_VAL	0x60
+
+/* Clear test pattern */
+#define I2C_DVI_TEST_PATTERN_VAL		0x18
+/* Exit Power-down mode */
+#define I2C_DVI_POWER_MGMT_VAL			0xC0
+
+/* Monitor polarity is handled via DVI Sync Polarity Register */
+#define I2C_DVI_SYNC_POLARITY_VAL		0x00
+
+/* Programming of HDMI Chrontel CH7301 connector */
+int diu_set_dvi_encoder(unsigned int pixclock)
+{
+	int ret;
+	u8 temp;
+
+	temp = I2C_DVI_TEST_PATTERN_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_TEST_PATTERN_REG, 1,
+			&temp, 1);
+	if (ret) {
+		puts("I2C: failed to select proper dvi test pattern\n");
+		return ret;
+	}
+	temp = I2C_DVI_INPUT_DATA_FORMAT_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_INPUT_DATA_FORMAT_REG,
+			1, &temp, 1);
+	if (ret) {
+		puts("I2C: failed to select dvi input data format\n");
+		return ret;
+	}
+
+	/* Set Sync polarity register */
+	temp = I2C_DVI_SYNC_POLARITY_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_SYNC_POLARITY_REG, 1,
+			&temp, 1);
+	if (ret) {
+		puts("I2C: failed to select dvi syc polarity\n");
+		return ret;
+	}
+
+	/* Set PLL registers based on pixel clock rate*/
+	if (pixclock > 65000000) {
+		temp = I2C_DVI_PLL_CHARGE_CNTL_HIGH_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_CHARGE_CNTL_REG, 1,	&temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll charge_cntl\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_DIVIDER_HIGH_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_DIVIDER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll divider\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_FILTER_HIGH_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_FILTER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll filter\n");
+			return ret;
+		}
+	} else {
+		temp = I2C_DVI_PLL_CHARGE_CNTL_LOW_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_CHARGE_CNTL_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll charge_cntl\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_DIVIDER_LOW_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_DIVIDER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll divider\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_FILTER_LOW_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_FILTER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll filter\n");
+			return ret;
+		}
+	}
+
+	temp = I2C_DVI_POWER_MGMT_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_POWER_MGMT_REG, 1,
+			&temp, 1);
+	if (ret) {
+		puts("I2C: failed to select dvi power mgmt\n");
+		return ret;
+	}
+
+	udelay(500);
+
+	return 0;
+}
--- u-boot-2014.07/board/freescale/common/ls102xa_stream_id.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/ls102xa_stream_id.c	2022-05-09 14:06:23.285147265 -0700
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/ls102xa_stream_id.h>
+
+void ls102xa_config_smmu_stream_id(struct smmu_stream_id *id, uint32_t num)
+{
+	uint32_t *scfg = (uint32_t *)CONFIG_SYS_FSL_SCFG_ADDR;
+	int i;
+
+	for (i = 0; i < num; i++)
+		out_be32(scfg + id[i].offset, id[i].stream_id);
+}
+
+void ls1021x_config_smmu3(uint32_t liodn)
+{
+	uint32_t *addr;
+	u32 smr, s2cr, nscr;
+
+	addr = (uint32_t *)(CONFIG_SYS_SMMU3_ADDR + CONFIG_SMMU_NSCR_OFFSET);
+       /* SMMU NSCR configuration */
+	nscr = in_le32(addr);
+
+	nscr = nscr  & ~(1 << SMMU_NSCR_CLIENTPD_SHIFT |
+			 1 << SMMU_NSCR_MTCFG_SHIFT);
+	out_le32(addr, nscr);
+
+	/* SMMU SMR configuration */
+	addr = (uint32_t *)(CONFIG_SYS_SMMU3_ADDR + CONFIG_SMMU_SMR_OFFSET);
+
+	smr = 0;
+	smr = smr & (~(SMR_ID_MASK << SMR_MASK_SHIFT));
+	smr = smr | (1 << SMR_SMR_VALID_SHIFT) | liodn;
+
+	out_le32(addr, smr);
+
+	/* SMMU S2CR configuration */
+	addr = (uint32_t *)(CONFIG_SYS_SMMU3_ADDR + CONFIG_SMMU_S2CR_OFFSET);
+	s2cr = (S2CR_WACFG_WRITE_ALLOCATE << S2CR_WACFG_SHIFT) |
+		(S2CR_RACFG_READ_ALLOCATE << S2CR_RACFG_SHIFT) |
+		(S2CR_TYPE_BYPASS << S2CR_TYPE_SHIFT) |
+		(S2CR_MEM_ATTR_CACHEABLE << S2CR_MEM_ATTR_SHIFT) |
+		S2CR_MTCFG |
+		(S2CR_SHCFG_OUTER_CACHEABLE << S2CR_SHCFG_SHIFT);
+
+	out_le32(addr, s2cr);
+}
+
+void ls1021x_config_caam_stream_id(struct liodn_id_table *tbl, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i++) {
+		u32 liodn;
+		if (tbl[i].num_ids == 2)
+			liodn = (tbl[i].id[0] << 16) | tbl[i].id[1];
+		else
+			liodn = tbl[i].id[0];
+
+		out_le32((uint32_t *)(tbl[i].reg_offset), liodn);
+	}
+}
--- u-boot-2014.07/board/freescale/common/ns_access.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/ns_access.c	2022-05-09 14:06:23.289147104 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * Xiubo Li <Li.Xiubo@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/ns_access.h>
+
+void enable_devices_ns_access(struct csu_ns_dev *ns_dev, uint32_t num)
+{
+	u32 *base = (u32 *)CONFIG_SYS_FSL_CSU_ADDR;
+	u32 *reg;
+	uint32_t val;
+	int i;
+
+	for (i = 0; i < num; i++) {
+		reg = base + ns_dev[i].ind / 2;
+		val = in_be32(reg);
+		if (ns_dev[i].ind % 2 == 0) {
+			val &= 0x0000ffff;
+			val |= ns_dev[i].val << 16;
+		} else {
+			val &= 0xffff0000;
+			val |= ns_dev[i].val;
+		}
+		out_be32(reg, val);
+	}
+}
--- u-boot-2014.07/board/freescale/common/cmd_esbc_validate.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/cmd_esbc_validate.c	2022-05-09 14:06:23.285147265 -0700
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <fsl_validate.h>
+
+static int do_esbc_validate(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	return fsl_secboot_validate(cmdtp, flag, argc, argv);
+}
+
+static int do_esbc_blob_encap(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	if (argc < 5)
+		return cmd_usage(cmdtp);
+	return fsl_secboot_blob_encap(cmdtp, flag, argc, argv);
+}
+
+static int do_esbc_blob_decap(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	if (argc < 5)
+		return cmd_usage(cmdtp);
+	return fsl_secboot_blob_decap(cmdtp, flag, argc, argv);
+}
+
+U_BOOT_CMD(
+	esbc_validate,	3,	0,	do_esbc_validate,
+	"Validates signature on a given image using RSA verification",
+	"<hdr_addr> <hash_val>"
+);
+
+static int do_esbc_halt(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	printf("Core is entering spin loop.\n");
+loop:
+	goto loop;
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	esbc_halt,	1,	0,	do_esbc_halt,
+	"Put the core in spin loop ",
+	""
+);
+
+U_BOOT_CMD(
+	esbc_blob_encap,	5,	0,	do_esbc_blob_encap,
+	"Creates a Cryptographic blob using a Blob Key",
+	"<src addr> <dest addr > <size of data> <128 bit key idnfr>"
+);
+
+U_BOOT_CMD(
+	esbc_blob_decap,	5,	0,	do_esbc_blob_decap,
+	"Decapsulates the cryptgraphic blob",
+	"<blob pointer> <dest addr> <size of decap blob> <128 bit key idnfr>"
+);
--- u-boot-2014.07/board/freescale/common/fsl_validate.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/fsl_validate.c	2022-05-09 14:06:23.285147265 -0700
@@ -0,0 +1,1036 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_validate.h>
+#include <fsl_secboot_err.h>
+#include <fsl_sfp.h>
+#include <fsl_sec.h>
+#include <command.h>
+#include <malloc.h>
+#include <rsa_sec.h>
+#include <sha.h>
+#include <jr.h>
+#include <jobdesc.h>
+#ifdef CONFIG_FSL_CORENET
+#include <asm/fsl_pamu.h>
+#endif
+#ifndef CONFIG_MPC85xx
+#include <asm/arch/immap_ls102xa.h>
+#endif
+
+#define SHA256_BITS	256
+#define SHA256_BYTES	(256/8)
+#define SHA256_NIBBLES	(256/4)
+#define NUM_HEX_CHARS	(sizeof(ulong) * 2)
+
+/* This array contains DER value for SHA-256 */
+static const u8 hash_identifier[] = { 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60,
+		0x86, 0x48, 0x01, 0x65,	0x03, 0x04, 0x02, 0x01, 0x05, 0x00,
+		0x04, 0x20
+		};
+
+static u8 hash_val[SHA256_BYTES];
+static const u8 barker_code[ESBC_BARKER_LEN] = { 0x68, 0x39, 0x27, 0x81 };
+
+void branch_to_self(void) __attribute__ ((noreturn));
+
+/*
+ * This function will put core in infinite loop.
+ * This will be called when the ESBC can not proceed further due
+ * to some unknown errors.
+ */
+void branch_to_self(void)
+{
+	printf("Core is in infinite loop due to errors.\n");
+self:
+	goto self;
+}
+
+#if defined(CONFIG_FSL_ISBC_KEY_EXT)
+static u32 check_ie(struct fsl_secboot_img_priv *img)
+{
+	if (img->hdr.ie_flag)
+		return 1;
+
+	return 0;
+}
+
+/* This function returns the CSF Header Address of uboot
+ * For MPC85xx based platforms, the LAW mapping for NOR
+ * flash changes in uboot code. Hence the offset needs
+ * to be calculated and added to the new NOR flash base
+ * address
+ */
+#if defined(CONFIG_MPC85xx)
+int get_csf_base_addr(ulong *csf_addr, ulong *flash_base_addr)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 csf_hdr_addr = in_be32(&gur->scratchrw[0]);
+	u32 csf_flash_offset = csf_hdr_addr & ~(CONFIG_SYS_PBI_FLASH_BASE);
+	ulong flash_addr, addr;
+	int found = 0;
+	int i = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i++) {
+		flash_addr = flash_info[i].start[0];
+		addr = flash_info[i].start[0] + csf_flash_offset;
+		if (memcmp((u8 *)addr, barker_code, ESBC_BARKER_LEN) == 0) {
+			debug("Barker found on addr %lx\n", addr);
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return -1;
+
+	*csf_addr = addr;
+	*flash_base_addr = flash_addr;
+
+	return 0;
+}
+#else
+/* For platforms like LS1020, correct flash address is present in
+ * the header. So the function reqturns flash base address as 0
+ */
+int get_csf_base_addr(ulong *csf_addr, ulong *flash_base_addr)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 csf_hdr_addr = in_be32(&gur->scratchrw[0]);
+
+	if (memcmp((u8 *)csf_hdr_addr, barker_code, ESBC_BARKER_LEN))
+		return -1;
+
+	*csf_addr = csf_hdr_addr;
+	*flash_base_addr = 0;
+	return 0;
+}
+#endif
+
+static int get_ie_info_addr(ulong *ie_addr)
+{
+	struct fsl_secboot_img_hdr *hdr;
+	struct fsl_secboot_sg_table *sg_tbl;
+	ulong flash_base_addr, csf_addr;
+
+	if (get_csf_base_addr(&csf_addr, &flash_base_addr))
+		return -1;
+
+	hdr = (struct fsl_secboot_img_hdr *)csf_addr;
+
+	/* For SoC's with Trust Architecture v1 with corenet bus
+	 * the sg table field in CSF header has absolute address
+	 * for sg table in memory. In other Trust Architecture,
+	 * this field specifies the offset of sg table from the
+	 * base address of CSF Header
+	 */
+#if defined(CONFIG_FSL_TRUST_ARCH_v1) && defined(CONFIG_FSL_CORENET)
+	sg_tbl = (struct fsl_secboot_sg_table *)
+		 (((ulong)hdr->psgtable & ~(CONFIG_SYS_PBI_FLASH_BASE)) +
+		  flash_base_addr);
+#else
+	sg_tbl = (struct fsl_secboot_sg_table *)(csf_addr +
+						 (ulong)hdr->psgtable);
+#endif
+
+	/* IE Key Table is the first entry in the SG Table */
+#if defined(CONFIG_MPC85xx)
+	*ie_addr = (sg_tbl->src_addr & ~(CONFIG_SYS_PBI_FLASH_BASE)) +
+		   flash_base_addr;
+#else
+	*ie_addr = sg_tbl->src_addr;
+#endif
+
+	debug("IE Table address is %lx\n", *ie_addr);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_KEY_REVOCATION
+/* This function checks srk_table_flag in header and set/reset srk_flag.*/
+static u32 check_srk(struct fsl_secboot_img_priv *img)
+{
+	if (img->hdr.len_kr.srk_table_flag & SRK_FLAG)
+		return 1;
+
+	return 0;
+}
+
+/* This function returns ospr's key_revoc values.*/
+static u32 get_key_revoc(void)
+{
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CONFIG_SYS_SFP_ADDR);
+	return (sfp_in32(&sfp_regs->ospr) & OSPR_KEY_REVOC_MASK) >>
+		OSPR_KEY_REVOC_SHIFT;
+}
+
+/* This function checks if selected key is revoked or not.*/
+static u32 is_key_revoked(u32 keynum, u32 rev_flag)
+{
+	if (keynum == UNREVOCABLE_KEY)
+		return 0;
+
+	if ((u32)(1 << (ALIGN_REVOC_KEY - keynum)) & rev_flag)
+		return 1;
+
+	return 0;
+}
+
+/* It validates srk_table key lengths.*/
+static u32 validate_srk_tbl(struct srk_table *tbl, u32 num_entries)
+{
+	int i = 0;
+	for (i = 0; i < num_entries; i++) {
+		if (!((tbl[i].key_len == 2 * KEY_SIZE_BYTES/4) ||
+		      (tbl[i].key_len == 2 * KEY_SIZE_BYTES/2) ||
+		      (tbl[i].key_len == 2 * KEY_SIZE_BYTES)))
+			return ERROR_ESBC_CLIENT_HEADER_INV_SRK_ENTRY_KEYLEN;
+	}
+	return 0;
+}
+#endif
+
+/* This function return length of public key.*/
+static inline u32 get_key_len(struct fsl_secboot_img_priv *img)
+{
+	return img->key_len;
+}
+
+/*
+ * Handles the ESBC uboot client header verification failure.
+ * This  function  handles all the errors which might occur in the
+ * parsing and checking of ESBC uboot client header. It will also
+ * set the error bits in the SNVS.
+ */
+static void fsl_secboot_header_verification_failure(void)
+{
+	struct ccsr_snvs_regs *snvs_regs = (void *)(CONFIG_SYS_SNVS_ADDR);
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CONFIG_SYS_SFP_ADDR);
+	u32 sts = snvs_in32(&snvs_regs->hp_stat);
+
+	/* 29th bit of OSPR is ITS */
+	u32 its = sfp_in32(&sfp_regs->ospr) >> 2;
+
+	/*
+	 * Read the SNVS status register
+	 * Read SSM_ST field
+	 */
+	sts = snvs_in32(&snvs_regs->hp_stat);
+	if ((sts & HPSR_SSM_ST_MASK) == HPSR_SSM_ST_TRUST) {
+		if (its == 1)
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+					     HPSR_SSM_ST_SOFT_FAIL);
+		else
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+					     HPSR_SSM_ST_NON_SECURE);
+	}
+
+	printf("Generating reset request\n");
+	do_reset(NULL, 0, 0, NULL);
+}
+
+/*
+ * Handles the ESBC uboot client image verification failure.
+ * This  function  handles all the errors which might occur in the
+ * public key hash comparison and signature verification of
+ * ESBC uboot client image. It will also
+ * set the error bits in the SNVS.
+ */
+static void fsl_secboot_image_verification_failure(void)
+{
+	struct ccsr_snvs_regs *snvs_regs = (void *)(CONFIG_SYS_SNVS_ADDR);
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CONFIG_SYS_SFP_ADDR);
+	u32 sts = snvs_in32(&snvs_regs->hp_stat);
+
+	u32 its = sfp_in32(&sfp_regs->ospr) & ITS_MASK >> ITS_BIT;
+
+	/*
+	 * Read the SNVS status register
+	 * Read SSM_ST field
+	 */
+	sts = snvs_in32(&snvs_regs->hp_stat);
+	if ((sts & HPSR_SSM_ST_MASK) == HPSR_SSM_ST_TRUST) {
+		if (its == 1) {
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+					     HPSR_SSM_ST_SOFT_FAIL);
+
+			printf("Generating reset request\n");
+			do_reset(NULL, 0, 0, NULL);
+		} else {
+			change_sec_mon_state(HPSR_SSM_ST_TRUST,
+					     HPSR_SSM_ST_NON_SECURE);
+		}
+	}
+}
+
+static void fsl_secboot_bootscript_parse_failure(void)
+{
+	fsl_secboot_header_verification_failure();
+}
+
+/*
+ * Handles the errors in esbc boot.
+ * This  function  handles all the errors which might occur in the
+ * esbc boot phase. It will call the appropriate api to log the
+ * errors and set the error bits in the SNVS.
+ */
+void fsl_secboot_handle_error(int error)
+{
+	const struct fsl_secboot_errcode *e;
+
+	for (e = fsl_secboot_errcodes; e->errcode != ERROR_ESBC_CLIENT_MAX;
+		e++) {
+		if (e->errcode == error)
+			printf("ERROR :: %x :: %s\n", error, e->name);
+	}
+
+	switch (error) {
+	case ERROR_ESBC_CLIENT_HEADER_BARKER:
+	case ERROR_ESBC_CLIENT_HEADER_IMG_SIZE:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_SIG_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1:
+	case ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2:
+	case ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD:
+	case ERROR_ESBC_CLIENT_HEADER_SG_ESBC_EP:
+	case ERROR_ESBC_CLIENT_HEADER_SG_ENTIRES_BAD:
+#ifdef CONFIG_KEY_REVOCATION
+	case ERROR_ESBC_CLIENT_HEADER_KEY_REVOKED:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_SRK_NUM_ENTRY:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_KEY_NUM:
+	case ERROR_ESBC_CLIENT_HEADER_INV_SRK_ENTRY_KEYLEN:
+#endif
+#if defined(CONFIG_FSL_ISBC_KEY_EXT)
+	/*@fallthrough@*/
+	case ERROR_ESBC_CLIENT_HEADER_IE_KEY_REVOKED:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_IE_NUM_ENTRY:
+	case ERROR_ESBC_CLIENT_HEADER_INVALID_IE_KEY_NUM:
+	case ERROR_ESBC_CLIENT_HEADER_INV_IE_ENTRY_KEYLEN:
+	case ERROR_IE_TABLE_NOT_FOUND:
+#endif
+		fsl_secboot_header_verification_failure();
+		break;
+	case ERROR_ESBC_SEC_RESET:
+	case ERROR_ESBC_SEC_DEQ:
+	case ERROR_ESBC_SEC_ENQ:
+	case ERROR_ESBC_SEC_DEQ_TO:
+	case ERROR_ESBC_SEC_JOBQ_STATUS:
+	case ERROR_ESBC_CLIENT_HASH_COMPARE_KEY:
+	case ERROR_ESBC_CLIENT_HASH_COMPARE_EM:
+		fsl_secboot_image_verification_failure();
+		break;
+	case ERROR_ESBC_MISSING_BOOTM:
+		fsl_secboot_bootscript_parse_failure();
+		break;
+	case ERROR_ESBC_WRONG_CMD:
+	default:
+		branch_to_self();
+		break;
+	}
+}
+
+static void fsl_secblk_handle_error(int error)
+{
+	switch (error) {
+	case ERROR_ESBC_SEC_ENQ:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_ENQ);
+		break;
+	case ERROR_ESBC_SEC_DEQ:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_DEQ);
+		break;
+	case ERROR_ESBC_SEC_DEQ_TO:
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_DEQ_TO);
+		break;
+	default:
+		printf("Job Queue Output status %x\n", error);
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_JOBQ_STATUS);
+		break;
+	}
+}
+
+/*
+ * Calculate hash of key obtained via offset present in ESBC uboot
+ * client hdr. This function calculates the hash of key which is obtained
+ * through offset present in ESBC uboot client header.
+ */
+static int calc_img_key_hash(struct sha_ctx *ctx,
+				struct fsl_secboot_img_priv *img)
+{
+	int i;
+	int ret = 0;
+
+	/* calc hash of the esbc key */
+	sha_init(ctx, &jr);
+#ifdef CONFIG_KEY_REVOCATION
+	if (check_srk(img))
+		sha_update(ctx, (u8 *)(img->ehdrloc + img->hdr.srk_tbl_off),
+			   img->hdr.len_kr.num_srk * sizeof(struct srk_table));
+	else
+		sha_update(ctx, img->img_key, img->key_len);
+
+#else
+	sha_update(ctx, img->img_key, img->key_len);
+#endif
+
+	ret = sha_final(ctx);
+	if (ret)
+		return ret;
+
+	ret = sha_digest(ctx, hash_val);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < SHA256_BYTES; i++)
+		img->img_key_hash[i] = hash_val[i];
+
+	return 0;
+}
+
+/*
+ * Calculate hash of ESBC hdr and ESBC. This function calculates the
+ * single hash of ESBC header and ESBC image. If SG flag is on, all
+ * SG entries are also hashed alongwith the complete SG table.
+ */
+static int calc_esbchdr_esbc_hash(struct sha_ctx *ctx,
+	struct fsl_secboot_img_priv *img)
+{
+	int ret = 0;
+	int key_hash = 0;
+
+	/* calculate the hash of the CSF header */
+	sha_init(ctx, &jr);
+	sha_update(ctx, (u8 *)&img->hdr, sizeof(struct fsl_secboot_img_hdr));
+
+	/* Update the hash with that of srk table if srk flag is 1
+	 * If IE Table is selected, key is not added in the hash
+	 * If neither rk table nor IE key tabel available, add key
+	 * from header in the hash calculation
+	 */
+#ifdef CONFIG_KEY_REVOCATION
+	if (check_srk(img)) {
+		sha_update(ctx, (u8 *)(img->ehdrloc + img->hdr.srk_tbl_off),
+			   img->hdr.len_kr.num_srk * sizeof(struct srk_table));
+		key_hash = 1;
+	}
+#endif
+#if defined(CONFIG_FSL_ISBC_KEY_EXT)
+	if (!key_hash && check_ie(img))
+		key_hash = 1;
+#endif
+	if (!key_hash)
+		sha_update(ctx, img->img_key, img->hdr.key_len);
+
+	/* contiguous ESBC */
+	sha_update(ctx, (u8 *)img->hdr.pimg, img->hdr.img_size);
+
+	ret = sha_final(ctx);
+	if (ret)
+		return ret;
+
+	ret = sha_digest(ctx, hash_val);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/*
+ * Construct encoded hash EM' wrt PKCSv1.5. This function calculates the
+ * pointers for padding, DER value and hash. And finally, constructs EM'
+ * which includes hash of complete CSF header and ESBC image. If SG flag
+ * is on, hash of SG table and entries is also included.
+ */
+static void construct_img_encoded_hash_second(struct fsl_secboot_img_priv *img)
+{
+	/*
+	 * RSA PKCSv1.5 encoding format for encoded message is below
+	 * EM = 0x0 || 0x1 || PS || 0x0 || DER || Hash
+	 * PS is Padding String
+	 * DER is DER value for SHA-256
+	 * Hash is SHA-256 hash
+	 * *********************************************************
+	 * representative points to first byte of EM initially and is
+	 * filled with 0x0
+	 * representative is incremented by 1 and second byte is filled
+	 * with 0x1
+	 * padding points to third byte of EM
+	 * digest points to full length of EM - 32 bytes
+	 * hash_id (DER value) points to 19 bytes before pDigest
+	 * separator is one byte which separates padding and DER
+	 */
+
+	size_t len;
+	u8 *representative;
+	u8 *padding, *digest;
+	u8 *hash_id, *separator;
+	int i;
+
+	len = (get_key_len(img) / 2) - 1;
+	representative = img->img_encoded_hash_second;
+	representative[0] = 0;
+	representative[1] = 1;  /* block type 1 */
+
+	padding = &representative[2];
+	digest = &representative[1] + len - 32;
+	hash_id = digest - sizeof(hash_identifier);
+	separator = hash_id - 1;
+
+	/* fill padding area pointed by padding with 0xff */
+	memset(padding, 0xff, separator - padding);
+
+	/* fill byte pointed by separator */
+	*separator = 0;
+
+	/* fill SHA-256 DER value  pointed by HashId */
+	memcpy(hash_id, hash_identifier, sizeof(hash_identifier));
+
+	/* fill hash pointed by Digest */
+	for (i = 0; i < SHA256_BYTES; i++)
+		digest[i] = hash_val[i];
+}
+
+/*
+ * Reads and validates the ESBC client header.
+ * This function reads key and signature from the ESBC client header.
+ * If Scatter/Gather flag is on, lengths and offsets of images
+ * present as SG entries are also read. This function also checks
+ * whether the header is valid or not.
+ */
+static int read_validate_esbc_client_header(struct fsl_secboot_img_priv *img)
+{
+	char buf[20];
+	struct fsl_secboot_img_hdr *hdr = &img->hdr;
+	void *esbc = (u8 *)img->ehdrloc;
+	u8 *k, *s;
+#ifdef CONFIG_KEY_REVOCATION
+	u32 ret;
+	u32 key_num, key_revoc_flag, size;
+#endif
+#if defined(CONFIG_FSL_ISBC_KEY_EXT)
+	struct ie_key_info *ie_info;
+	u32 ie_num, ie_revoc_flag, ie_key_len;
+#endif
+	int  key_found = 0;
+
+	/* check barker code */
+	if (memcmp(hdr->barker, barker_code, ESBC_BARKER_LEN))
+		return ERROR_ESBC_CLIENT_HEADER_BARKER;
+
+	sprintf(buf, "%p", hdr->pimg);
+	setenv("img_addr", buf);
+
+	if (!hdr->img_size)
+		return ERROR_ESBC_CLIENT_HEADER_IMG_SIZE;
+
+	/* Key checking*/
+#ifdef CONFIG_KEY_REVOCATION
+	if (check_srk(img)) {
+		if ((hdr->len_kr.num_srk == 0) ||
+		    (hdr->len_kr.num_srk > MAX_KEY_ENTRIES))
+			return ERROR_ESBC_CLIENT_HEADER_INVALID_SRK_NUM_ENTRY;
+
+		key_num = hdr->len_kr.srk_sel;
+		if (key_num == 0 || key_num > hdr->len_kr.num_srk)
+			return ERROR_ESBC_CLIENT_HEADER_INVALID_KEY_NUM;
+
+		/* Get revoc key from sfp */
+		key_revoc_flag = get_key_revoc();
+		ret = is_key_revoked(key_num, key_revoc_flag);
+		if (ret)
+			return ERROR_ESBC_CLIENT_HEADER_KEY_REVOKED;
+
+		size = hdr->len_kr.num_srk * sizeof(struct srk_table);
+
+		memcpy(&img->srk_tbl, esbc + hdr->srk_tbl_off, size);
+
+		ret = validate_srk_tbl(img->srk_tbl, hdr->len_kr.num_srk);
+
+		if (ret != 0)
+			return ret;
+
+		img->key_len = img->srk_tbl[key_num - 1].key_len;
+
+		memcpy(&img->img_key, &(img->srk_tbl[key_num - 1].pkey),
+		       img->key_len);
+
+		key_found = 1;
+	}
+#endif
+
+#if defined(CONFIG_FSL_ISBC_KEY_EXT)
+	if (!key_found && check_ie(img)) {
+		if (get_ie_info_addr(&img->ie_addr))
+			return ERROR_IE_TABLE_NOT_FOUND;
+		ie_info = (struct ie_key_info *)img->ie_addr;
+		if (ie_info->num_keys == 0 || ie_info->num_keys > 32)
+			return ERROR_ESBC_CLIENT_HEADER_INVALID_IE_NUM_ENTRY;
+
+		ie_num = hdr->ie_key_sel;
+		if (ie_num == 0 || ie_num > ie_info->num_keys)
+			return ERROR_ESBC_CLIENT_HEADER_INVALID_IE_KEY_NUM;
+
+		ie_revoc_flag = ie_info->key_revok;
+		if ((u32)(1 << (ie_num - 1)) & ie_revoc_flag)
+			return ERROR_ESBC_CLIENT_HEADER_IE_KEY_REVOKED;
+
+		ie_key_len = ie_info->ie_key_tbl[ie_num - 1].key_len;
+
+		if (!((ie_key_len == 2 * KEY_SIZE_BYTES / 4) ||
+		      (ie_key_len == 2 * KEY_SIZE_BYTES / 2) ||
+		      (ie_key_len == 2 * KEY_SIZE_BYTES)))
+			return ERROR_ESBC_CLIENT_HEADER_INV_IE_ENTRY_KEYLEN;
+
+		memcpy(&img->img_key, &(ie_info->ie_key_tbl[ie_num - 1].pkey),
+		       ie_key_len);
+
+		img->key_len = ie_key_len;
+		key_found = 1;
+	}
+#endif
+
+	if (key_found == 0) {
+		/* check key length */
+		if (!((hdr->key_len == 2 * KEY_SIZE_BYTES / 4) ||
+		      (hdr->key_len == 2 * KEY_SIZE_BYTES / 2) ||
+		      (hdr->key_len == 2 * KEY_SIZE_BYTES)))
+			return ERROR_ESBC_CLIENT_HEADER_KEY_LEN;
+
+		memcpy(&img->img_key, esbc + hdr->pkey, hdr->key_len);
+
+		img->key_len = hdr->key_len;
+
+		key_found = 1;
+	}
+
+	/* check signaure */
+	if (get_key_len(img) == 2 * hdr->sign_len) {
+		/* check signature length */
+		if (!((hdr->sign_len == KEY_SIZE_BYTES / 4) ||
+		      (hdr->sign_len == KEY_SIZE_BYTES / 2) ||
+		      (hdr->sign_len == KEY_SIZE_BYTES)))
+			return ERROR_ESBC_CLIENT_HEADER_SIG_LEN;
+	} else {
+		return ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN;
+	}
+
+	memcpy(&img->img_sign, esbc + hdr->psign, hdr->sign_len);
+
+	/* No SG support */
+	if (hdr->sg_flag)
+		return ERROR_ESBC_CLIENT_HEADER_SG;
+
+	/* modulus most significant bit should be set */
+	k = (u8 *)&img->img_key;
+
+	if ((k[0] & 0x80) == 0)
+		return ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1;
+
+	/* modulus value should be odd */
+	if ((k[get_key_len(img) / 2 - 1] & 0x1) == 0)
+		return ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2;
+
+	/* Check signature value < modulus value */
+	s = (u8 *)&img->img_sign;
+
+	if (!(memcmp(s, k, hdr->sign_len) < 0))
+		return ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD;
+
+	return ESBC_VALID_HDR;
+}
+
+static inline int str2longbe(const char *p, ulong *num)
+{
+	char *endptr;
+	ulong tmp;
+
+	if (!p) {
+		return 0;
+	} else {
+		tmp = simple_strtoul(p, &endptr, 16);
+		if (sizeof(ulong) == 4)
+			*num = cpu_to_be32(tmp);
+		else
+			*num = cpu_to_be64(tmp);
+	}
+
+	return *p != '\0' && *endptr == '\0';
+}
+
+void done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *x = arg;
+	x->status = status;
+	x->err = caam_jr_strstatus(x->outstr, status);
+	x->done = 1;
+}
+
+int fsl_secboot_blob_decap(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	ulong enc_addr = simple_strtoul(argv[1], NULL, 16);
+	ulong blob_decap_addr = simple_strtoul(argv[2], NULL, 16);
+	ulong out_sz = simple_strtoul(argv[3], NULL, 16);
+
+	int ret;
+	uint32_t desc[64];
+	struct result op;
+	unsigned long long timeval;
+	unsigned long long timeout;
+	char key_str[NUM_HEX_CHARS + 1];
+	ulong key_id[16/sizeof(ulong)];
+
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+	memset(&op, 0, sizeof(struct result));
+
+	if (argc == 5) {
+		char *cp = argv[4];
+		int i = 0;
+
+		if (*cp == '0' && *(cp + 1) == 'x')
+			cp += 2;
+
+		/* The input string expected is in hex, where
+		 * each 4 bits would be represented by a hex
+		 * sha256 hash is 256 bits long, which would mean
+		 * num of characters = 256 / 4
+		 */
+		if (strlen(cp) != 32) {
+			printf("%s is not a 16 byte hex string as expected\n",
+			       argv[4]);
+			return -1;
+		}
+
+		for (i = 0; i < sizeof(key_id)/sizeof(ulong); i++) {
+			strncpy(key_str, cp + (i * NUM_HEX_CHARS),
+				NUM_HEX_CHARS);
+			key_str[NUM_HEX_CHARS] = '\0';
+			if (!str2longbe(key_str, &key_id[i])) {
+				printf("%s is not a 128 bit hex string\n",
+				       argv[4]);
+				return -1;
+			}
+		}
+	}
+
+#ifdef DEBUG
+	printf("enc text at addr %lx" , enc_addr);
+	printf("blob_decap text at addr %lx" , blob_decap_addr);
+	printf("size %lx" , out_sz);
+#endif
+	printf("Decapsulating\n");
+
+	inline_cnstr_jobdesc_blob_decap(desc, (uint8_t *)key_id,
+					(uint8_t *)enc_addr,
+					(uint8_t *)blob_decap_addr, out_sz);
+
+	ret = jr_enqueue(&jr, desc, done, &op);
+	if (ret) {
+		printf("enq failed with ret %d\n", ret);
+		fsl_secblk_handle_error(ret);
+		goto out;
+	}
+
+#ifdef DEBUG
+	printf("Descriptor\n");
+	for (i = 0; i < 16; i++)
+		printf("0x%x\n", desc[i]);
+#endif
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (op.done != 1) {
+		if (jr_dequeue(&jr)) {
+			printf("Deq error ERROR_ESBC_SEC_DEQ\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ);
+			goto out;
+		}
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ_TO);
+			goto out;
+		}
+	}
+
+	if (op.err < 0) {
+		fsl_secblk_handle_error(op.status);
+		goto out;
+	}
+
+	printf("Decapsulation successful\n");
+
+out:
+#ifdef CONFIG_FSL_CORENET
+	pamu_disable();
+#endif
+	if (jr_reset(&jr) < 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_RESET);
+		return 0;
+	}
+	return 0;
+}
+
+int fsl_secboot_blob_encap(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	ulong plain_addr = simple_strtoul(argv[1], NULL, 16);
+	ulong enc_addr = simple_strtoul(argv[2], NULL, 16);
+	ulong in_sz = simple_strtoul(argv[3], NULL, 16);
+	int ret;
+	uint32_t desc[64];
+	struct result op;
+	unsigned long long timeval;
+	unsigned long long timeout;
+	int i = 0;
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+	char key_str[NUM_HEX_CHARS + 1];
+	ulong key_id[KEY_IDNFR_SZ_BYTES/sizeof(ulong)];
+
+	memset(&op, 0, sizeof(struct result));
+
+	if (argc == 5) {
+		char *cp = argv[4];
+		int i = 0;
+
+		if (*cp == '0' && *(cp + 1) == 'x')
+			cp += 2;
+
+		/* The input string expected is in hex, where
+		 * each 4 bits would be represented by a hex
+		 * sha256 hash is 256 bits long, which would mean
+		 * num of characters = 256 / 4
+		 */
+		if (strlen(cp) != 32) {
+			printf("%s is not a 16 byte hex string as expected\n",
+			       argv[4]);
+			return -1;
+		}
+
+		for (i = 0; i < sizeof(key_id)/sizeof(ulong); i++) {
+			strncpy(key_str, cp + (i * NUM_HEX_CHARS),
+				NUM_HEX_CHARS);
+			key_str[NUM_HEX_CHARS] = '\0';
+			if (!str2longbe(key_str, &key_id[i])) {
+				printf("%s is not a 128 bit hex string\n"
+					, argv[4]);
+				return -1;
+			}
+		}
+	}
+
+	printf("\nEncapsulating data\n");
+
+#ifdef DEBUG
+	printf("plain text at addr %lx\n" , plain_addr);
+	printf("enc text at addr %lx\n" , enc_addr);
+	printf("size %lx\n" , in_sz);
+	for (i = 0; i < 4; i++)
+		printf("%x\t", key_id[i]);
+#endif
+
+	inline_cnstr_jobdesc_blob_encap(desc, (uint8_t *)key_id,
+					(uint8_t *)plain_addr,
+					(uint8_t *)enc_addr, in_sz);
+	ret = jr_enqueue(&jr, desc, done, &op);
+	if (ret) {
+		printf("enq failed with ret %d\n", ret);
+		fsl_secblk_handle_error(ret);
+		goto out;
+	}
+
+#ifdef DEBUG
+#endif
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (op.done != 1) {
+		if (jr_dequeue(&jr)) {
+			printf("deq error ERROR_ESBC_SEC_DEQ\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ);
+			goto out;
+		}
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			fsl_secblk_handle_error(ERROR_ESBC_SEC_DEQ_TO);
+			goto out;
+		}
+	}
+
+	if (op.err < 0) {
+		fsl_secblk_handle_error(op.status);
+		printf("Descriptor\n");
+		for (i = 0; i < 16; i++)
+			printf("0x%x\n", desc[i]);
+		goto out;
+	}
+
+	printf("Encapsulation succesful\n");
+
+out:
+#ifdef CONFIG_FSL_CORENET
+	pamu_disable();
+#endif
+	if (jr_reset(&jr) < 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_RESET);
+		return 0;
+	}
+	return 0;
+}
+
+int fsl_secboot_validate(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[])
+{
+	int hash_cmd = 0;
+	struct ccsr_sfp_regs *sfp_regs = (void *)(CONFIG_SYS_SFP_ADDR);
+	ulong hash[SHA256_BYTES/sizeof(ulong)];
+	char hash_str[NUM_HEX_CHARS + 1];
+	struct sha_ctx ctx;
+	struct rsa_context rsa_ctx;
+	ulong addr = simple_strtoul(argv[1], NULL, 16);
+	struct fsl_secboot_img_priv *img;
+	struct fsl_secboot_img_hdr *hdr;
+	void *esbc;
+	int ret, i;
+	u32 srk_hash[8];
+
+	if (argc == 3) {
+		char *cp = argv[2];
+		int i = 0;
+
+		if (*cp == '0' && *(cp + 1) == 'x')
+			cp += 2;
+
+		/* The input string expected is in hex, where
+		 * each 4 bits would be represented by a hex
+		 * sha256 hash is 256 bits long, which would mean
+		 * num of characters = 256 / 4
+		 */
+		if (strlen(cp) != SHA256_NIBBLES) {
+			printf("%s is not a 256 bits hex string as expected\n",
+			       argv[2]);
+			return -1;
+		}
+
+		for (i = 0; i < sizeof(hash)/sizeof(ulong); i++) {
+			strncpy(hash_str, cp + (i * NUM_HEX_CHARS),
+				NUM_HEX_CHARS);
+			hash_str[NUM_HEX_CHARS] = '\0';
+			if (!str2longbe(hash_str, &hash[i])) {
+				printf("%s is not a 256 bits hex string ",
+				       argv[2]);
+				return -1;
+			}
+		}
+
+		hash_cmd = 1;
+	}
+
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+	img = malloc(sizeof(struct fsl_secboot_img_priv));
+
+	if (!img)
+		return -1;
+
+	memset(img, 0, sizeof(struct fsl_secboot_img_priv));
+
+	hdr = &img->hdr;
+	img->ehdrloc = addr;
+	esbc = (u8 *)img->ehdrloc;
+
+	memcpy(hdr, esbc, sizeof(struct fsl_secboot_img_hdr));
+
+	/* read and validate esbc header */
+	ret = read_validate_esbc_client_header(img);
+
+	if (ret != ESBC_VALID_HDR) {
+		fsl_secboot_handle_error(ret);
+		goto exit1;
+	}
+
+	/* SRKH present in SFP */
+	for (i = 0; i < NUM_SRKH_REGS; i++)
+		srk_hash[i] = srk_in32(&sfp_regs->srk_hash[i]);
+
+	/*
+	 * Calculate hash of key obtained via offset present in
+	 * ESBC uboot client hdr
+	 */
+	ret = calc_img_key_hash(&ctx, img);
+	if (ret) {
+		fsl_secblk_handle_error(ret);
+		goto exit;
+	}
+
+	/* Compare hash obtained above with SRK hash present in SFP */
+	if (hash_cmd)
+		ret = memcmp(&hash, &img->img_key_hash, SHA256_BYTES);
+	else
+		ret = memcmp(srk_hash, img->img_key_hash, SHA256_BYTES);
+
+#if defined(CONFIG_FSL_ISBC_KEY_EXT)
+	if (!hash_cmd && check_ie(img))
+		ret = 0;
+#endif
+
+	if (ret != 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_CLIENT_HASH_COMPARE_KEY);
+		goto exit;
+	}
+
+	ret = calc_esbchdr_esbc_hash(&ctx, img);
+	if (ret) {
+		fsl_secblk_handle_error(ret);
+		goto exit;
+	}
+
+	/* Construct encoded hash EM' wrt PKCSv1.5 */
+	construct_img_encoded_hash_second(img);
+
+	ret = rsa_public_verif_sec(img->img_sign, img->img_encoded_hash,
+		img->img_key, get_key_len(img) / 2, &rsa_ctx, &jr);
+	if (ret) {
+		fsl_secblk_handle_error(ret);
+		goto exit;
+	}
+
+	/*
+	 * compare the encoded messages EM' and EM wrt RSA PKCSv1.5
+	 * memcmp returns zero on success
+	 * memcmp returns non-zero on failure
+	 */
+	ret = memcmp(&img->img_encoded_hash_second, &img->img_encoded_hash,
+		img->hdr.sign_len);
+
+	if (ret) {
+		fsl_secboot_handle_error(ERROR_ESBC_CLIENT_HASH_COMPARE_EM);
+		goto exit;
+	}
+
+	printf("esbc_validate command successful\n");
+
+exit:
+	if (jr_reset(&jr) < 0) {
+		fsl_secboot_handle_error(ERROR_ESBC_SEC_RESET);
+		return 0;
+	}
+exit1:
+#ifdef CONFIG_FSL_CORENET
+	pamu_disable();
+#endif
+	return 0;
+}
--- u-boot-2014.07/board/freescale/common/diu_ch7301.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/diu_ch7301.h	2022-05-09 14:06:23.285147265 -0700
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __DIU_HDMI_CH7301__
+#define __DIU_HDMI_CH7301__
+
+/* Programming of HDMI Chrontel CH7301 connector */
+int diu_set_dvi_encoder(unsigned int pixclock);
+
+#endif
--- u-boot-2014.07/board/freescale/common/dcu_sii9022a.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/dcu_sii9022a.c	2022-05-09 14:06:23.285147265 -0700
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_dcu_fb.h>
+#include <i2c.h>
+#include <linux/fb.h>
+
+#define PIXEL_CLK_LSB_REG		0x00
+#define PIXEL_CLK_MSB_REG		0x01
+#define VERT_FREQ_LSB_REG		0x02
+#define VERT_FREQ_MSB_REG		0x03
+#define TOTAL_PIXELS_LSB_REG		0x04
+#define TOTAL_PIXELS_MSB_REG		0x05
+#define TOTAL_LINES_LSB_REG		0x06
+#define TOTAL_LINES_MSB_REG		0x07
+#define TPI_INBUS_FMT_REG		0x08
+#define TPI_INPUT_FMT_REG		0x09
+#define TPI_OUTPUT_FMT_REG		0x0A
+#define TPI_SYS_CTRL_REG		0x1A
+#define TPI_PWR_STAT_REG		0x1E
+#define TPI_AUDIO_HANDING_REG		0x25
+#define TPI_AUDIO_INTF_REG		0x26
+#define TPI_AUDIO_FREQ_REG		0x27
+#define TPI_SET_PAGE_REG		0xBC
+#define TPI_SET_OFFSET_REG		0xBD
+#define TPI_RW_ACCESS_REG		0xBE
+#define TPI_TRANS_MODE_REG		0xC7
+
+#define TPI_INBUS_CLOCK_RATIO_1		(1 << 6)
+#define TPI_INBUS_FULL_PIXEL_WIDE	(1 << 5)
+#define TPI_INBUS_RISING_EDGE		(1 << 4)
+#define TPI_INPUT_CLR_DEPTH_8BIT	(0 << 6)
+#define TPI_INPUT_VRANGE_EXPAN_AUTO	(0 << 2)
+#define TPI_INPUT_CLR_RGB		(0 << 0)
+#define TPI_OUTPUT_CLR_DEPTH_8BIT	(0 << 6)
+#define TPI_OUTPUT_VRANGE_COMPRE_AUTO	(0 << 2)
+#define TPI_OUTPUT_CLR_HDMI_RGB		(0 << 0)
+#define TPI_SYS_TMDS_OUTPUT		(0 << 4)
+#define TPI_SYS_AV_NORAML		(0 << 3)
+#define TPI_SYS_AV_MUTE			(1 << 3)
+#define TPI_SYS_DVI_MODE		(0 << 0)
+#define TPI_SYS_HDMI_MODE		(1 << 0)
+#define TPI_PWR_STAT_MASK		(3 << 0)
+#define TPI_PWR_STAT_D0			(0 << 0)
+#define TPI_AUDIO_PASS_BASIC		(0 << 0)
+#define TPI_AUDIO_INTF_I2S		(2 << 6)
+#define TPI_AUDIO_INTF_NORMAL		(0 << 4)
+#define TPI_AUDIO_TYPE_PCM		(1 << 0)
+#define TPI_AUDIO_SAMP_SIZE_16BIT	(1 << 6)
+#define TPI_AUDIO_SAMP_FREQ_44K		(2 << 3)
+#define TPI_SET_PAGE_SII9022A		0x01
+#define TPI_SET_OFFSET_SII9022A		0x82
+#define TPI_RW_EN_SRC_TERMIN		(1 << 0)
+#define TPI_TRANS_MODE_ENABLE		(0 << 7)
+
+/* Programming of Silicon SIi9022a HDMI Transmitter */
+int dcu_set_dvi_encoder(struct fb_videomode *videomode)
+{
+	u8 temp;
+	u16 temp1, temp2;
+	u32 temp3;
+
+	i2c_set_bus_num(CONFIG_SYS_I2C_DVI_BUS_NUM);
+
+	/* Enable TPI transmitter mode */
+	temp = TPI_TRANS_MODE_ENABLE;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_TRANS_MODE_REG, 1, &temp, 1);
+
+	/* Enter into D0 state, full operation */
+	i2c_read(CONFIG_SYS_I2C_DVI_ADDR, TPI_PWR_STAT_REG, 1, &temp, 1);
+	temp &= ~TPI_PWR_STAT_MASK;
+	temp |= TPI_PWR_STAT_D0;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_PWR_STAT_REG, 1, &temp, 1);
+
+	/* Enable source termination */
+	temp = TPI_SET_PAGE_SII9022A;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_SET_PAGE_REG, 1, &temp, 1);
+	temp = TPI_SET_OFFSET_SII9022A;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_SET_OFFSET_REG, 1, &temp, 1);
+
+	i2c_read(CONFIG_SYS_I2C_DVI_ADDR, TPI_RW_ACCESS_REG, 1, &temp, 1);
+	temp |= TPI_RW_EN_SRC_TERMIN;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_RW_ACCESS_REG, 1, &temp, 1);
+
+	/* Set TPI system control */
+	temp = TPI_SYS_TMDS_OUTPUT | TPI_SYS_AV_NORAML | TPI_SYS_DVI_MODE;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_SYS_CTRL_REG, 1, &temp, 1);
+
+	/* Set pixel clock */
+	temp1 = PICOS2KHZ(videomode->pixclock) / 10;
+	temp = (u8)(temp1 & 0xFF);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, PIXEL_CLK_LSB_REG, 1, &temp, 1);
+	temp = (u8)(temp1 >> 8);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, PIXEL_CLK_MSB_REG, 1, &temp, 1);
+
+	/* Set total pixels per line */
+	temp1 = videomode->hsync_len + videomode->left_margin +
+		videomode->xres + videomode->right_margin;
+	temp = (u8)(temp1 & 0xFF);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TOTAL_PIXELS_LSB_REG, 1, &temp, 1);
+	temp = (u8)(temp1 >> 8);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TOTAL_PIXELS_MSB_REG, 1, &temp, 1);
+
+	/* Set total lines */
+	temp2 = videomode->vsync_len + videomode->upper_margin +
+		videomode->yres + videomode->lower_margin;
+	temp = (u8)(temp2 & 0xFF);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TOTAL_LINES_LSB_REG, 1, &temp, 1);
+	temp = (u8)(temp2 >> 8);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TOTAL_LINES_MSB_REG, 1, &temp, 1);
+
+	/* Set vertical frequency in Hz */
+	temp3 = temp1 * temp2;
+	temp3 = (PICOS2KHZ(videomode->pixclock) * 1000) / temp3;
+	temp1 = (u16)temp3 * 100;
+	temp = (u8)(temp1 & 0xFF);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, VERT_FREQ_LSB_REG, 1, &temp, 1);
+	temp = (u8)(temp1 >> 8);
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, VERT_FREQ_MSB_REG, 1, &temp, 1);
+
+	/* Set TPI input bus and pixel repetition data */
+	temp = TPI_INBUS_CLOCK_RATIO_1 | TPI_INBUS_FULL_PIXEL_WIDE |
+		TPI_INBUS_RISING_EDGE;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_INBUS_FMT_REG, 1, &temp, 1);
+
+	/* Set TPI AVI Input format data */
+	temp = TPI_INPUT_CLR_DEPTH_8BIT | TPI_INPUT_VRANGE_EXPAN_AUTO |
+		TPI_INPUT_CLR_RGB;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_INPUT_FMT_REG, 1, &temp, 1);
+
+	/* Set TPI AVI Output format data */
+	temp = TPI_OUTPUT_CLR_DEPTH_8BIT | TPI_OUTPUT_VRANGE_COMPRE_AUTO |
+		TPI_OUTPUT_CLR_HDMI_RGB;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_OUTPUT_FMT_REG, 1, &temp, 1);
+
+	/* Set TPI audio configuration write data */
+	temp = TPI_AUDIO_PASS_BASIC;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_AUDIO_HANDING_REG, 1, &temp, 1);
+
+	temp = TPI_AUDIO_INTF_I2S | TPI_AUDIO_INTF_NORMAL |
+		TPI_AUDIO_TYPE_PCM;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_AUDIO_INTF_REG, 1, &temp, 1);
+
+	temp = TPI_AUDIO_SAMP_SIZE_16BIT | TPI_AUDIO_SAMP_FREQ_44K;
+	i2c_write(CONFIG_SYS_I2C_DVI_ADDR, TPI_AUDIO_FREQ_REG, 1, &temp, 1);
+
+	return 0;
+}
--- u-boot-2014.07/board/freescale/common/vid.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/common/vid.h	2022-05-09 14:06:23.289147104 -0700
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __VID_H_
+#define __VID_H_
+
+#define IR36021_LOOP1_MANUAL_ID_OFFSET	0x6A
+#define IR36021_LOOP1_VOUT_OFFSET	0x9A
+#define IR36021_MFR_ID_OFFSET		0x92
+#define IR36021_MFR_ID			0x43
+
+/* step the IR regulator in 5mV increments */
+#define IR_VDD_STEP_DOWN		5
+#define IR_VDD_STEP_UP			5
+int adjust_vdd(ulong vdd_override);
+
+#endif  /* __VID_H_ */
--- u-boot-2014.07/board/freescale/m200/ddr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/ddr.h	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 2,
+	.rank_density = 2147483648u,
+	.capacity = 4294967296u,
+	.primary_sdram_width = 64,
+	.ec_sdram_width = 8,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 15,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 2,	/* ECC */
+	.burst_lengths_bitmask = 0x0c,
+	.tckmin_x_ps = 1071,
+	.caslat_x = 0xfe << 4,	/* 5,6,7,8,9,10,11 */
+	.taa_ps = 13125,
+	.twr_ps = 15000,
+	.trcd_ps = 13125,
+	.trrd_ps = 6000,
+	.trp_ps = 13125,
+	.tras_ps = 34000,
+	.trc_ps = 48125,
+	.trfc_ps = 260000,
+	.twtr_ps = 7500,
+	.trtp_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tfaw_ps = 35000,
+};
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2
+	 */
+	{2,  833,  4, 4,     6, 0x06060607, 0x08080807},
+	{2,  833,  0, 4,     6, 0x06060607, 0x08080807},
+	{2,  1350, 4, 4,     7, 0x0708080A, 0x0A0B0C09},
+	{2,  1350, 0, 4,     7, 0x0708080A, 0x0A0B0C09},
+	{2,  1666, 4, 4,     7, 0x0808090B, 0x0C0D0E0A},
+	{2,  1666, 0, 4,     7, 0x0808090B, 0x0C0D0E0A},
+	{1,  833,  4, 4,     6, 0x06060607, 0x08080807},
+	{1,  833,  0, 4,     6, 0x06060607, 0x08080807},
+	{1,  1350, 4, 4,     7, 0x0708080A, 0x0A0B0C09},
+	{1,  1350, 0, 4,     7, 0x0708080A, 0x0A0B0C09},
+	{1,  1666, 4, 4,     7, 0x0808090B, 0x0C0D0E0A},
+	{1,  1666, 0, 4,     7, 0x0808090B, 0x0C0D0E0A},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+#endif
--- u-boot-2014.07/board/freescale/m200/spl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/spl.c	2022-05-09 14:06:23.301146618 -0700
@@ -0,0 +1,118 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <ns16550.h>
+#include <nand.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <spi_flash.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+phys_size_t get_effective_memsize(void)
+{
+	return CONFIG_SYS_L3_SIZE;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	return CONFIG_SYS_CLK_FREQ;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	return CONFIG_DDR_CLK_FREQ;
+}
+
+#define FSL_CORENET_CCSR_PORSR1_RCW_MASK	0xFF800000
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio, sys_clk, uart_clk;
+#ifdef CONFIG_SPL_NAND_BOOT
+	u32 porsr1, pinctl;
+#endif
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+#ifdef CONFIG_SPL_NAND_BOOT
+	/*
+	 * There is T1040 SoC issue where NOR, FPGA are inaccessible during
+	 * NAND boot because IFC signals > IFC_AD7 are not enabled.
+	 * This workaround changes RCW source to make all signals enabled.
+	 */
+	porsr1 = in_be32(&gur->porsr1);
+	pinctl = ((porsr1 & ~(FSL_CORENET_CCSR_PORSR1_RCW_MASK)) | 0x24800000);
+	out_be32((unsigned int *)(CONFIG_SYS_DCSRBAR + 0x20000), pinctl);
+#endif
+
+	/* Memcpy existing GD at CONFIG_SPL_GD_ADDR */
+	memcpy((void *)CONFIG_SPL_GD_ADDR, (void *)gd, sizeof(gd_t));
+
+	/* Update GD pointer */
+	gd = (gd_t *)(CONFIG_SPL_GD_ADDR);
+	__asm__ __volatile__("" : : : "memory");
+
+	console_init_f();
+
+	/* initialize selected port with appropriate baud rate */
+	sys_clk = get_board_sys_clk();
+	plat_ratio = (in_be32(&gur->rcwsr[0]) >> 25) & 0x1f;
+	uart_clk = sys_clk * plat_ratio / 2;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+		     uart_clk / 16 / CONFIG_BAUDRATE);
+
+	relocate_code(CONFIG_SPL_RELOC_STACK, (gd_t *)CONFIG_SPL_GD_ADDR, 0x0);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	bd_t *bd;
+
+	bd = (bd_t *)(gd + sizeof(gd_t));
+	memset(bd, 0, sizeof(bd_t));
+	gd->bd = bd;
+	bd->bi_memstart = CONFIG_SYS_INIT_L3_ADDR;
+	bd->bi_memsize = CONFIG_SYS_L3_SIZE;
+
+	probecpu();
+	get_clocks();
+	mem_malloc_init(CONFIG_SPL_RELOC_MALLOC_ADDR,
+			CONFIG_SPL_RELOC_MALLOC_SIZE);
+
+#ifndef CONFIG_SPL_NAND_BOOT
+	env_init();
+#endif
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_initialize(bd);
+#endif
+
+	/* relocate environment function pointers etc. */
+#ifdef CONFIG_SPL_NAND_BOOT
+	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			    (uchar *)CONFIG_ENV_ADDR);
+	gd->env_addr  = (ulong)(CONFIG_ENV_ADDR);
+	gd->env_valid = 1;
+#else
+	env_relocate();
+#endif
+
+	i2c_init_all();
+
+	puts("\n\n");
+
+	gd->ram_size = initdram(0);
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_boot();
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	spi_boot();
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	nand_boot();
+#endif
+}
--- u-boot-2014.07/board/freescale/m200/m200.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/m200.c	2022-05-09 14:06:23.297146780 -0700
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+#include <asm/mpc85xx_gpio.h>
+#include <version.h>
+
+
+#include "m200.h"
+
+/* 
+ * 	GPO 27 reset
+ * 	GPO 28 
+ * 	GPO 29 
+ * 	RED 	28=L 29=H
+ * 	GREEN	28=H 29=L
+ *
+ */
+#define GPIO_RESET  0x10
+#define GPIO_RED  0x8    
+#define GPIO_GREEN  0x4
+#define GPIO_DIR 0x0000001c
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	struct cpu_type *cpu = gd->arch.cpu;
+        volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	printf("Board: %sRDB, ", cpu->name);
+	printf ("%s\n",BOARD_VERSION);
+#ifndef CONFIG_RAMBOOT_PBL
+        setbits_be32(&pgpio->gpdir, GPIO_DIR);
+        clrsetbits_be32(&pgpio->gpdat, GPIO_GREEN, GPIO_RED);
+	gpio_set_value(4, 1);
+	udelay(5);
+	gpio_set_value(4, 0);
+	udelay(5);
+	gpio_set_value(4, 1);
+#endif
+
+
+	return 0;
+}
+
+
+int board_early_init_r(void)
+{
+	const u8 temp[7] = { 0x49, 0x4E, 0x52, 0x56, 0x59, 0x5c, 0x5f}; 
+	const u8 fan[7]  = { 0x0a, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f};
+	int i = 0;
+
+#ifdef CONFIG_SYS_FLASH_BASE
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		0, flash_esel, BOOKE_PAGESZ_256M, 1);
+#endif
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+/*W83793D Smart fan enbale*/
+	/*  W83793D smartfan default setting */
+	i2c_reg_write(0x2d, 0, 0x82);
+	/* Enable Temp 1 smartfan function */
+	i2c_reg_write(0x2d, 0x1, 0x4);
+	for ( i = 0 ; i < 7 ; i++)
+	{
+		/* Set temp level */
+		i2c_reg_write(0x2d, 0x30 + i, temp[i]);
+		/* Set fan level */
+		i2c_reg_write(0x2d, 0x38 + i, fan[i]);
+	}
+	i2c_reg_write(0x2d, 0, 0x80);
+	/* Set Uptime */
+	i2c_reg_write(0x2d, 0xc3, 0x1);
+	/* Set Downtime */
+	i2c_reg_write(0x2d, 0xc4, 0x20);
+        /* Set Critical Temperature */
+        i2c_reg_write(0x2d, 0xc5, 0x5f);
+/*W83793D Smart fan enbale*/
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+	fdt_fixup_dr_usb(blob, bd);
+#endif
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+#endif
+}
+#ifdef CONFIG_DEEP_SLEEP
+void board_mem_sleep_setup(void)
+{
+	/* does not provide HW signals for power management */
+/*	CPLD_WRITE(misc_ctl_status, (CPLD_READ(misc_ctl_status) & ~0x40)); */
+	/* Disable MCKE isolation */
+	udelay(1);
+}
+#endif
--- u-boot-2014.07/board/freescale/m200/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/tlb.c	2022-05-09 14:06:23.301146618 -0700
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L3_ADDR)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 256K SRAM, the address of the
+	 * SRAM is at 0xfffc0000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_256K, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+#ifndef CONFIG_SPL_BUILD
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256K, 1),
+
+	/* Bman/Qman */
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 5, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 7, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 8, BOOKE_PAGESZ_16M, 1),
+#endif
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 9, BOOKE_PAGESZ_4M, 1),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE
+	/*
+	 * *I*G - NAND
+	 * entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so we use entry 16 for nand.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_64K, 1),
+#endif
+
+#if defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SPL_BUILD)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 12, BOOKE_PAGESZ_1G, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		      CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 13, BOOKE_PAGESZ_1G, 1)
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2014.07/board/freescale/m200/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/law.c	2022-05-09 14:06:23.297146780 -0700
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+#ifndef CONFIG_SYS_NO_FLASH
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_IFC),
+#endif
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_4M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2014.07/board/freescale/m200/pci.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/pci.c	2022-05-09 14:06:23.301146618 -0700
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/fsl_serdes.h>
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void pci_of_setup(void *blob, bd_t *bd)
+{
+	FT_FSL_PCI_SETUP;
+}
--- u-boot-2014.07/board/freescale/m200/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/Makefile	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,16 @@
+#
+# Copyright 2013 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+else
+obj-y	+= m200.o
+obj-y	+= eth.o
+obj-$(CONFIG_PCI)	+= pci.o
+endif
+obj-y	+= ddr.o
+obj-y	+= law.o
+obj-y	+= tlb.o
--- u-boot-2014.07/board/freescale/m200/eth.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/eth.c	2022-05-09 14:06:23.297146780 -0700
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/immap_85xx.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <asm/fsl_dtsec.h>
+#include <miiphy.h>
+
+#include "../common/fman.h"
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	struct memac_mdio_info memac_mdio_info;
+	unsigned int i;
+	int phy_addr = 0;
+	unsigned short value;
+#endif
+	printf("Initializing Fman\n");
+
+	memac_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+	memac_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the real 1G MDIO bus */
+	fm_memac_mdio_init(bis, &memac_mdio_info);
+
+	/*
+	 * Program on board RGMII, SGMII PHY addresses.
+	 */
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		int idx = i - FM1_DTSEC1;
+
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_SGMII:
+			if ( i == FM1_DTSEC1 )
+			fm_info_set_phy_address(FM1_DTSEC1, 1);
+			else if ( i == FM1_DTSEC2 )
+			fm_info_set_phy_address(FM1_DTSEC2, 2);
+			else if ( i == FM1_DTSEC3 )
+			fm_info_set_phy_address(FM1_DTSEC3, 0);
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			if (FM1_DTSEC4 == i)
+				phy_addr = CONFIG_SYS_RGMII1_PHY_ADDR;
+			if (FM1_DTSEC5 == i)
+				phy_addr = CONFIG_SYS_RGMII2_PHY_ADDR;
+			fm_info_set_phy_address(i, phy_addr);
+			break;
+		case PHY_INTERFACE_MODE_QSGMII:
+			fm_info_set_phy_address(i, 0);
+			break;
+		case PHY_INTERFACE_MODE_NONE:
+			fm_info_set_phy_address(i, 0);
+			break;
+		default:
+			printf("Fman1: DTSEC%u set to unknown interface %i\n",
+			       idx + 1, fm_info_get_enet_if(i));
+			fm_info_set_phy_address(i, 0);
+			break;
+		}
+		fm_info_set_mdio(i,
+				 miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	}
+
+	cpu_eth_init(bis);
+	const char      *devname;
+	devname = miiphy_get_current_dev();
+	miiphy_write(devname, 0x10, 0, 0x9a03);
+	miiphy_read(devname,  0x10, 1, &value);
+	if ( (value&0xffff) != 0x1712 ) {
+		printf("Error!!!! switch setting incorrect, check H/W\n");
+	}
+	else
+	{
+		printf("Init switch to forwarding mode... ");
+		/* Reset and Disable INTx  */
+		DLAY SMIRW(1, 0x10, 4, 0xe000, 0, 0, 0x1b, 0);
+
+		/* set rgmii delay  */
+		DLAY SMIRW(1, 0x10, 1, 0xc03e, 0, 0, 0x15, 0);  /* P15 */
+		DLAY SMIRW(1, 0x10, 1, 0xc03e, 0, 0, 0x16, 0);  /* P16 */
+		/* set LED function */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x10, 0);/* P0 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x11, 0);/* P1 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x12, 0);/* P1 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x13, 0);/* P3 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x14, 0);/* P4 */
+		/* set port to forwarding mode */
+		DLAY SMIRW(1, 0x10, 4, 0x007f, 0, 0, 0x10, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x11, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x12, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x13, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x14, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x15, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x16, 0);
+		DLAY
+		DLAY
+		DLAY
+		printf("Done\n");
+	}
+
+	return pci_eth_init(bis);
+}
--- u-boot-2014.07/board/freescale/m200/m200_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/m200_pbi.cfg	2022-05-09 14:06:23.297146780 -0700
@@ -0,0 +1,33 @@
+#PBI commands
+#Initialize CPC1
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+#Reset and Set LED to RED
+09130000 0000001c
+09130008 0000001a
+091380c0 0000001F
+09130008 0000000a
+091380c0 0000001F
+09130008 0000001a
+#Configure CPC1 as 256KB SRAM
+09010100 00000000
+09010104 fffc0007
+09010f00 08000000
+09010000 80000000
+#Configure LAW for CPC1
+09000cd0 00000000
+09000cd4 fffc0000
+09000cd8 81000011
+#Configure alternate space
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+#Configure SPI controller
+09110000 80000403
+09110020 2d170008
+09110024 00100008
+09110028 00100008
+0911002c 00100008
+#Flush PBL data
+091380c0 000FFFFF
--- u-boot-2014.07/board/freescale/m200/m200.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/m200.h	2022-05-09 14:06:23.297146780 -0700
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __T104x_RDB_H__
+#define __T104x_RDB_H__
+
+void fdt_fixup_board_enet(void *blob);
+void pci_of_setup(void *blob, bd_t *bd);
+
+#endif
--- u-boot-2014.07/board/freescale/m200/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/ddr.c	2022-05-09 14:06:23.293146942 -0700
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include <asm/fsl_law.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "RAW timing DDR";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 1) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+	/* Get clk_adjust according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks &&
+		    (pdimm->rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found\n");
+		printf("for data rate %lu MT/s\n", ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, "
+		"wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * rtt and rtt_wr override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_OFF);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_OFF);
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_RAMBOOT_PBL)
+	puts("Initializing....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+
+#else
+	dram_size =  fsl_ddr_sdram_size();
+#endif
+	return dram_size;
+}
--- u-boot-2014.07/board/freescale/m200/m200_rcw.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m200/m200_rcw.cfg	2022-05-09 14:06:23.297146780 -0700
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 010e0100
+# serdes protocol 0x66
+0a18000c 0c000000 00000000 00000000
+86000002 80000002 ec027000 01000000
+00000000 00000000 00000000 000309fc
+00000000 01fd5206 00000000 00000000
--- u-boot-2014.07/board/freescale/t102xqds/diu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/diu.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Author: Priyanka Jain <Priyanka.Jain@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <linux/ctype.h>
+#include <asm/io.h>
+#include <stdio_dev.h>
+#include <video_fb.h>
+#include <fsl_diu_fb.h>
+#include "../common/qixis.h"
+#include "t102xqds.h"
+#include "t102xqds_qixis.h"
+#include <i2c.h>
+
+
+#define I2C_DVI_INPUT_DATA_FORMAT_REG		0x1F
+#define I2C_DVI_PLL_CHARGE_CNTL_REG		0x33
+#define I2C_DVI_PLL_DIVIDER_REG			0x34
+#define I2C_DVI_PLL_SUPPLY_CNTL_REG		0x35
+#define I2C_DVI_PLL_FILTER_REG			0x36
+#define I2C_DVI_TEST_PATTERN_REG		0x48
+#define I2C_DVI_POWER_MGMT_REG			0x49
+#define I2C_DVI_LOCK_STATE_REG			0x4D
+#define I2C_DVI_SYNC_POLARITY_REG		0x56
+
+/*
+ * Set VSYNC/HSYNC to active high. This is polarity of sync signals
+ * from DIU->DVI. The DIU default is active igh, so DVI is set to
+ * active high.
+ */
+#define I2C_DVI_INPUT_DATA_FORMAT_VAL		0x98
+
+#define I2C_DVI_PLL_CHARGE_CNTL_HIGH_SPEED_VAL	0x06
+#define I2C_DVI_PLL_DIVIDER_HIGH_SPEED_VAL	0x26
+#define I2C_DVI_PLL_FILTER_HIGH_SPEED_VAL	0xA0
+#define I2C_DVI_PLL_CHARGE_CNTL_LOW_SPEED_VAL	0x08
+#define I2C_DVI_PLL_DIVIDER_LOW_SPEED_VAL	0x16
+#define I2C_DVI_PLL_FILTER_LOW_SPEED_VAL	0x60
+
+/* Clear test pattern */
+#define I2C_DVI_TEST_PATTERN_VAL		0x18
+/* Exit Power-down mode */
+#define I2C_DVI_POWER_MGMT_VAL			0xC0
+
+/* Monitor polarity is handled via DVI Sync Polarity Register */
+#define I2C_DVI_SYNC_POLARITY_VAL		0x00
+
+/*
+ * DIU Area Descriptor
+ *
+ * Note that we need to byte-swap the value before it's written to the AD
+ * register.  So even though the registers don't look like they're in the same
+ * bit positions as they are on the MPC8610, the same value is written to the
+ * AD register on the MPC8610 and on the P1022.
+ */
+#define AD_BYTE_F		0x10000000
+#define AD_ALPHA_C_SHIFT	25
+#define AD_BLUE_C_SHIFT		23
+#define AD_GREEN_C_SHIFT	21
+#define AD_RED_C_SHIFT		19
+#define AD_PIXEL_S_SHIFT	16
+#define AD_COMP_3_SHIFT		12
+#define AD_COMP_2_SHIFT		8
+#define AD_COMP_1_SHIFT		4
+#define AD_COMP_0_SHIFT		0
+
+/* Programming of HDMI Chrontel CH7301 connector */
+int diu_set_dvi_encoder(unsigned int pixclock)
+{
+	int ret;
+	u8 temp;
+	select_i2c_ch_pca9547(I2C_MUX_CH_DIU);
+
+	temp = I2C_DVI_TEST_PATTERN_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_TEST_PATTERN_REG, 1,
+			&temp, 1);
+	if (ret) {
+		puts("I2C: failed to select proper dvi test pattern\n");
+		return ret;
+	}
+	temp = I2C_DVI_INPUT_DATA_FORMAT_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_INPUT_DATA_FORMAT_REG,
+			1, &temp, 1);
+	if (ret) {
+		puts("I2C: failed to select dvi input data format\n");
+		return ret;
+	}
+
+	/* Set Sync polarity register */
+	temp = I2C_DVI_SYNC_POLARITY_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_SYNC_POLARITY_REG, 1,
+			&temp, 1);
+	if (ret) {
+		puts("I2C: failed to select dvi syc polarity\n");
+		return ret;
+	}
+
+	/* Set PLL registers based on pixel clock rate*/
+	if (pixclock > 65000000) {
+		temp = I2C_DVI_PLL_CHARGE_CNTL_HIGH_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_CHARGE_CNTL_REG, 1,	&temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll charge_cntl\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_DIVIDER_HIGH_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_DIVIDER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll divider\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_FILTER_HIGH_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_FILTER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll filter\n");
+			return ret;
+		}
+	} else {
+		temp = I2C_DVI_PLL_CHARGE_CNTL_LOW_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_CHARGE_CNTL_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll charge_cntl\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_DIVIDER_LOW_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_DIVIDER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll divider\n");
+			return ret;
+		}
+		temp = I2C_DVI_PLL_FILTER_LOW_SPEED_VAL;
+		ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR,
+				I2C_DVI_PLL_FILTER_REG, 1, &temp, 1);
+		if (ret) {
+			puts("I2C: failed to select dvi pll filter\n");
+			return ret;
+		}
+	}
+
+	temp = I2C_DVI_POWER_MGMT_VAL;
+	ret = i2c_write(CONFIG_SYS_I2C_DVI_ADDR, I2C_DVI_POWER_MGMT_REG, 1,
+			&temp, 1);
+	if (ret) {
+		puts("I2C: failed to select dvi power mgmt\n");
+		return ret;
+	}
+
+	udelay(500);
+
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+	return 0;
+}
+
+void diu_set_pixel_clock(unsigned int pixclock)
+{
+	unsigned long speed_ccb, temp;
+	u32 pixval;
+	int ret = 0;
+	speed_ccb = get_bus_freq(0);
+	temp = 1000000000 / pixclock;
+	temp *= 1000;
+	pixval = speed_ccb / temp;
+
+	/* Program HDMI encoder */
+	ret = diu_set_dvi_encoder(temp);
+	if (ret) {
+		puts("Failed to set DVI encoder\n");
+		return;
+	}
+
+	/* Program pixel clock */
+	out_be32((unsigned *)CONFIG_SYS_FSL_SCFG_PIXCLK_ADDR,
+		 ((pixval << PXCK_BITS_START) & PXCK_MASK));
+	/* enable clock*/
+	out_be32((unsigned *)CONFIG_SYS_FSL_SCFG_PIXCLK_ADDR, PXCKEN_MASK |
+		 ((pixval << PXCK_BITS_START) & PXCK_MASK));
+}
+
+int platform_diu_init(unsigned int xres, unsigned int yres, const char *port)
+{
+	u32 pixel_format;
+	u8 sw;
+
+	/*Route I2C4 to DIU system as HSYNC/VSYNC*/
+	sw = QIXIS_READ(brdcfg[5]);
+	QIXIS_WRITE(brdcfg[5],
+		    ((sw & ~(BRDCFG5_IMX_MASK)) | (BRDCFG5_IMX_DIU)));
+
+	/*Configure Display ouput port as HDMI*/
+	sw = QIXIS_READ(brdcfg[15]);
+	QIXIS_WRITE(brdcfg[15],
+		    ((sw & ~(BRDCFG15_LCDPD_MASK | BRDCFG15_DIUSEL_MASK))
+		      | (BRDCFG15_LCDPD_ENABLED | BRDCFG15_DIUSEL_HDMI)));
+
+	pixel_format = cpu_to_le32(AD_BYTE_F | (3 << AD_ALPHA_C_SHIFT) |
+		(0 << AD_BLUE_C_SHIFT) | (1 << AD_GREEN_C_SHIFT) |
+		(2 << AD_RED_C_SHIFT) | (8 << AD_COMP_3_SHIFT) |
+		(8 << AD_COMP_2_SHIFT) | (8 << AD_COMP_1_SHIFT) |
+		(8 << AD_COMP_0_SHIFT) | (3 << AD_PIXEL_S_SHIFT));
+
+	printf("DIU:   Switching to monitor @ %ux%u\n",  xres, yres);
+
+
+	return fsl_diu_init(xres, yres, pixel_format, 0);
+}
--- u-boot-2014.07/board/freescale/t102xqds/t102xqds_qixis.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/t102xqds_qixis.h	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __T1024QDS_QIXIS_H__
+#define __T1024QDS_QIXIS_H__
+
+/* Definitions of QIXIS Registers for T1024/T1023 QDS */
+
+/* BRDCFG4[4:7]] select EC1 and EC2 as a pair */
+#define BRDCFG4_EMISEL_MASK		0xE0
+#define BRDCFG4_EMISEL_SHIFT		5
+
+/* BRDCFG5[0:1] controls routing and use of I2C3 & I2C4 ports*/
+#define BRDCFG5_IMX_MASK		0xC0
+#define BRDCFG5_IMX_DIU			0x80
+
+#define BRDCFG5_SPIRTE_MASK		0x07
+#define BRDCFG5_SPIRTE_TDM		0x01
+#define BRDCFG5_SPIRTE_SDHC		0x02
+#define BRDCFG9_XFI_TX_DISABLE		0x10
+
+/* BRDCFG13[0:5] TDM configuration and setup */
+#define BRDCFG13_TDM_MASK		0xfc
+#define BRDCFG13_TDM_INTERFACE		0x37
+#define BRDCFG13_HDLC_LOOPBACK		0x29
+#define BRDCFG13_TDM_LOOPBACK		0x31
+
+/* BRDCFG15[3] controls LCD Panel Powerdown */
+#define BRDCFG15_LCDFM			0x20
+#define BRDCFG15_LCDPD			0x10
+#define BRDCFG15_LCDPD_MASK		0x10
+#define BRDCFG15_LCDPD_ENABLED		0x00
+
+/* BRDCFG15[6:7] controls DIU MUX selction*/
+#define BRDCFG15_DIUSEL_MASK		0x03
+#define BRDCFG15_DIUSEL_HDMI		0x00
+#define BRDCFG15_DIUSEL_LCD		0x01
+#define BRDCFG15_DIUSEL_UCC		0x02
+#define BRDCFG15_DIUSEL_TDM		0x03
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+#define QIXIS_SYSCLK_64			0x8
+
+/* DDRCLK */
+#define QIXIS_DDRCLK_66			0x0
+#define QIXIS_DDRCLK_100		0x1
+#define QIXIS_DDRCLK_125		0x2
+#define QIXIS_DDRCLK_133		0x3
+
+
+#define QIXIS_SRDS1CLK_122		0x5a
+#define QIXIS_SRDS1CLK_125		0x5e
+#endif
--- u-boot-2014.07/board/freescale/t102xqds/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/ddr.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * datarate_mhz_high values need to be in ascending order
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl |
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |
+	 */
+#if defined(CONFIG_SYS_FSL_DDR4)
+	{2,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},
+	{2,  1900,  0,  4,  6,  0x08080A0C,  0x0D0E0F0A,},
+	{1,  1666,  0,  4,  6,  0x0708090B,  0x0C0D0E09,},
+	{1,  1900,  0,  4,  6,  0x08080A0C,  0x0D0E0F0A,},
+	{1,  2200,  0,  4,  7,  0x08090A0D,  0x0F0F100C,},
+#elif defined(CONFIG_SYS_FSL_DDR3)
+	{2,  833,   0,  4,  6,  0x06060607,  0x08080807,},
+	{2,  1350,  0,  4,  7,  0x0708080A,  0x0A0B0C09,},
+	{2,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},
+	{1,  833,   0,  4,  6,  0x06060607,  0x08080807,},
+	{1,  1350,  0,  4,  7,  0x0708080A,  0x0A0B0C09,},
+	{1,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},
+#else
+#error DDR type not defined
+#endif
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+	struct cpu_type *cpu = gd->arch.cpu;
+
+	if (ctrl_num > 2) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+	/* Get clk_adjust according to the board ddr freqency and n_banks
+	 * specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks &&
+		    (pdimm->rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found\n");
+		printf("for data rate %lu MT/s\n", ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n",
+	      pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb);
+	debug("\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, ",
+	      pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2);
+	debug("wrlvl_ctrl_3 0x%x\n", pbsp->wrlvl_ctl_3);
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 1;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * rtt and rtt_wr override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+#ifdef CONFIG_SYS_FSL_DDR4
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_80ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_80ohm) |
+			  DDR_CDR2_VREF_OVRD(70);	/* Vref = 70% */
+#else
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+#endif
+
+	/* T1023 supports max DDR bus 32bit width, T1024 supports DDR 64bit,
+	 * set DDR bus width to 32bit for T1023
+	 */
+	if (cpu->soc_ver == SVR_T1023)
+		popts->data_bus_width = DDR_DATA_BUS_WIDTH_32;
+
+#ifdef CONFIG_FORCE_DDR_DATA_BUS_WIDTH_32
+	/* for DDR bus 32bit test on T1024 */
+	popts->data_bus_width = DDR_DATA_BUS_WIDTH_32;
+#endif
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_RAMBOOT_PBL)
+	puts("Initializing....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+#else
+	/* DDR has been initialised by first stage boot loader */
+	dram_size =  fsl_ddr_sdram_size();
+#endif
+	return dram_size;
+}
--- u-boot-2014.07/board/freescale/t102xqds/t1024_rcw.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/t1024_rcw.cfg	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,10 @@
+# single-source clock:Sys_Clock = DDR_Refclock = Diff_Sysclk = 100 MHz
+# Core/DDR/Platform/FMan = 1400MHz/1600MT/s/400MHz/700MHz
+
+# PBL preamble and RCW header for T1024QDS
+aa55aa55 010e0100
+# Serdes protocol 0x6F
+0810000e 00000000 00000000 00000000
+37800001 00000012 e8104000 21000000
+00000000 00000000 00000000 00030810
+00000000 036c5a00 00000000 00000006
--- u-boot-2014.07/board/freescale/t102xqds/t102xqds.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/t102xqds.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,406 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+#include <hwconfig.h>
+#include <asm/mpc85xx_gpio.h>
+#include "../common/qixis.h"
+#include "t102xqds.h"
+#include "t102xqds_qixis.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	char buf[64];
+	struct cpu_type *cpu = gd->arch.cpu;
+	static const char *const freq[] = {"100", "125", "156.25", "100.0"};
+	int clock;
+	u8 sw = QIXIS_READ(arch);
+
+	printf("Board: %sQDS, ", cpu->name);
+	printf("Sys ID: 0x%02x, Board Arch: V%d, ", QIXIS_READ(id), sw >> 4);
+	printf("Board Version: %c, boot from ", (sw & 0xf) + 'A' - 1);
+
+#ifdef CONFIG_SDCARD
+	puts("SD/MMC\n");
+#elif CONFIG_SPIFLASH
+	puts("SPI\n");
+#else
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else if (sw == 0x8)
+		puts("PromJet\n");
+	else if (sw == 0x9)
+		puts("NAND\n");
+	else if (sw == 0x15)
+		printf("IFC Card\n");
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+#endif
+
+	printf("FPGA: v%d (%s), build %d",
+	       (int)QIXIS_READ(scver), qixis_read_tag(buf),
+	       (int)qixis_read_minor());
+	/* the timestamp string contains "\n" at the end */
+	printf(" on %s", qixis_read_time(buf));
+
+	puts("SERDES Reference: ");
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = (sw >> 6) & 3;
+	printf("Clock1=%sMHz ", freq[clock]);
+	clock = (sw >> 4) & 3;
+	printf("Clock2=%sMHz\n", freq[clock]);
+
+	return 0;
+}
+
+int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int board_mux_lane_to_slot(void)
+{
+	ccsr_gur_t __iomem *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 srds_prtcl_s1;
+	u8 brdcfg9;
+
+	srds_prtcl_s1 = in_be32(&gur->rcwsr[4]) &
+				FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	srds_prtcl_s1 >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+
+	brdcfg9 = QIXIS_READ(brdcfg[9]);
+	QIXIS_WRITE(brdcfg[9], brdcfg9 | BRDCFG9_XFI_TX_DISABLE);
+
+	switch (srds_prtcl_s1) {
+	case 0:
+		/* SerDes1 is not enabled */
+		break;
+	case 0xd5:
+	case 0x5b:
+	case 0x6b:
+	case 0x77:
+	case 0x6f:
+	case 0x7f:
+		QIXIS_WRITE(brdcfg[12], 0x8c);
+		break;
+	case 0x40:
+		QIXIS_WRITE(brdcfg[12], 0xfc);
+		break;
+	case 0xd6:
+	case 0x5a:
+	case 0x6a:
+	case 0x56:
+		QIXIS_WRITE(brdcfg[12], 0x88);
+		break;
+	case 0x47:
+		QIXIS_WRITE(brdcfg[12], 0xcc);
+		break;
+	case 0x46:
+		QIXIS_WRITE(brdcfg[12], 0xc8);
+		break;
+	case 0x95:
+	case 0x99:
+		brdcfg9 &= ~BRDCFG9_XFI_TX_DISABLE;
+		QIXIS_WRITE(brdcfg[9], brdcfg9);
+		QIXIS_WRITE(brdcfg[12], 0x8c);
+		break;
+	case 0x116:
+		QIXIS_WRITE(brdcfg[12], 0x00);
+		break;
+	case 0x115:
+	case 0x119:
+	case 0x129:
+	case 0x12b:
+		/* Aurora, PCIe, SGMII, SATA */
+		QIXIS_WRITE(brdcfg[12], 0x04);
+		break;
+	default:
+		printf("WARNING: unsupported for SerDes Protocol %d\n",
+		       srds_prtcl_s1);
+		return -1;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PPC_T1024
+static void board_mux_setup(void)
+{
+	u8 brdcfg15;
+
+	brdcfg15 = QIXIS_READ(brdcfg[15]);
+	brdcfg15 &= ~BRDCFG15_DIUSEL_MASK;
+
+	if (hwconfig_arg_cmp("pin_mux", "tdm")) {
+		/* Route QE_TDM multiplexed signals to TDM Riser slot */
+		QIXIS_WRITE(brdcfg[15], brdcfg15 | BRDCFG15_DIUSEL_TDM);
+		QIXIS_WRITE(brdcfg[13], BRDCFG13_TDM_INTERFACE << 2);
+		QIXIS_WRITE(brdcfg[5], (QIXIS_READ(brdcfg[5]) &
+			    ~BRDCFG5_SPIRTE_MASK) | BRDCFG5_SPIRTE_TDM);
+	} else if (hwconfig_arg_cmp("pin_mux", "ucc")) {
+		/* to UCC (ProfiBus) interface */
+		QIXIS_WRITE(brdcfg[15], brdcfg15 | BRDCFG15_DIUSEL_UCC);
+	} else if (hwconfig_arg_cmp("pin_mux", "hdmi")) {
+		/* to DVI (HDMI) encoder */
+		QIXIS_WRITE(brdcfg[15], brdcfg15 | BRDCFG15_DIUSEL_HDMI);
+	} else if (hwconfig_arg_cmp("pin_mux", "lcd")) {
+		/* to DFP (LCD) encoder */
+		QIXIS_WRITE(brdcfg[15], brdcfg15 | BRDCFG15_LCDFM |
+			    BRDCFG15_LCDPD | BRDCFG15_DIUSEL_LCD);
+	}
+
+	if (hwconfig_arg_cmp("adaptor", "sdxc"))
+		/* Route SPI_CS multiplexed signals to SD slot */
+		QIXIS_WRITE(brdcfg[5], (QIXIS_READ(brdcfg[5]) &
+			    ~BRDCFG5_SPIRTE_MASK) | BRDCFG5_SPIRTE_SDHC);
+}
+#endif
+
+void board_retimer_init(void)
+{
+	u8 reg;
+
+	/* Retimer is connected to I2C1_CH7_CH5 */
+	reg = I2C_MUX_CH7;
+	i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &reg, 1);
+	reg = I2C_MUX_CH5;
+	i2c_write(I2C_MUX_PCA_ADDR_SEC, 0, 1, &reg, 1);
+
+	/* Access to Control/Shared register */
+	reg = 0x0;
+	i2c_write(I2C_RETIMER_ADDR, 0xff, 1, &reg, 1);
+
+	/* Read device revision and ID */
+	i2c_read(I2C_RETIMER_ADDR, 1, 1, &reg, 1);
+	debug("Retimer version id = 0x%x\n", reg);
+
+	/* Enable Broadcast. All writes target all channel register sets */
+	reg = 0x0c;
+	i2c_write(I2C_RETIMER_ADDR, 0xff, 1, &reg, 1);
+
+	/* Reset Channel Registers */
+	i2c_read(I2C_RETIMER_ADDR, 0, 1, &reg, 1);
+	reg |= 0x4;
+	i2c_write(I2C_RETIMER_ADDR, 0, 1, &reg, 1);
+
+	/* Enable override divider select and Enable Override Output Mux */
+	i2c_read(I2C_RETIMER_ADDR, 9, 1, &reg, 1);
+	reg |= 0x24;
+	i2c_write(I2C_RETIMER_ADDR, 9, 1, &reg, 1);
+
+	/* Select VCO Divider to full rate (000) */
+	i2c_read(I2C_RETIMER_ADDR, 0x18, 1, &reg, 1);
+	reg &= 0x8f;
+	i2c_write(I2C_RETIMER_ADDR, 0x18, 1, &reg, 1);
+
+	/* Selects active PFD MUX Input as Re-timed Data (001) */
+	i2c_read(I2C_RETIMER_ADDR, 0x1e, 1, &reg, 1);
+	reg &= 0x3f;
+	reg |= 0x20;
+	i2c_write(I2C_RETIMER_ADDR, 0x1e, 1, &reg, 1);
+
+	/* Set data rate as 10.3125 Gbps */
+	reg = 0x0;
+	i2c_write(I2C_RETIMER_ADDR, 0x60, 1, &reg, 1);
+	reg = 0xb2;
+	i2c_write(I2C_RETIMER_ADDR, 0x61, 1, &reg, 1);
+	reg = 0x90;
+	i2c_write(I2C_RETIMER_ADDR, 0x62, 1, &reg, 1);
+	reg = 0xb3;
+	i2c_write(I2C_RETIMER_ADDR, 0x63, 1, &reg, 1);
+	reg = 0xcd;
+	i2c_write(I2C_RETIMER_ADDR, 0x64, 1, &reg, 1);
+}
+
+int board_early_init_r(void)
+{
+	u32 reg;
+
+#ifdef CONFIG_SYS_FLASH_BASE
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash + promjet */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		0, flash_esel, BOOKE_PAGESZ_256M, 1);
+#endif
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+	board_mux_lane_to_slot();
+	board_retimer_init();
+
+	/* Increase IO drive strength to avoid FCS error on RGMII */
+#define IODSECR1_LVDD_VAL  (0x7 << 26)
+#define IODSECR1_L1VDD_VAL (0x7 << 23)
+	reg = in_be32((unsigned *)CONFIG_SYS_FSL_SCFG_IODSECR1_ADDR);
+	reg |= IODSECR1_LVDD_VAL | IODSECR1_L1VDD_VAL;
+	out_be32((unsigned *)CONFIG_SYS_FSL_SCFG_IODSECR1_ADDR, reg);
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0F) {
+	case QIXIS_SYSCLK_64:
+		return 64000000;
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+#define NUM_SRDS_PLL	2
+int misc_init_r(void)
+{
+#ifdef CONFIG_PPC_T1024
+	board_mux_setup();
+#endif
+	return 0;
+}
+
+void fdt_fixup_spi_mux(void *blob)
+{
+	int nodeoff = 0;
+
+	if (hwconfig_arg_cmp("pin_mux", "tdm")) {
+		while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+			"eon,en25s64")) >= 0) {
+			fdt_del_node(blob, nodeoff);
+		}
+	} else {
+		/* remove tdm node */
+		while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+			"maxim,ds26522")) >= 0) {
+			fdt_del_node(blob, nodeoff);
+		}
+	}
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+	fdt_fixup_dr_usb(blob, bd);
+#endif
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+	fdt_fixup_spi_mux(blob);
+}
+
+void qixis_dump_switch(void)
+{
+	int i, nr_of_cfgsw;
+
+	QIXIS_WRITE(cms[0], 0x00);
+	nr_of_cfgsw = QIXIS_READ(cms[1]);
+
+	puts("DIP switch settings dump:\n");
+	for (i = 1; i <= nr_of_cfgsw; i++) {
+		QIXIS_WRITE(cms[0], i);
+		printf("SW%d = (0x%02x)\n", i, QIXIS_READ(cms[1]));
+	}
+}
+
+#ifdef CONFIG_DEEP_SLEEP
+void board_mem_sleep_setup(void)
+{
+	/* does not provide HW signals for power management */
+	QIXIS_WRITE(pwr_ctl[1], (QIXIS_READ(pwr_ctl[1]) & ~0x2));
+	/* Disable MCKE isolation */
+	gpio_set_value(2, 0);
+	udelay(1);
+}
+#endif
--- u-boot-2014.07/board/freescale/t102xqds/eth_t102xqds.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/eth_t102xqds.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,442 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Shengzhou Liu <Shengzhou.Liu@freescale.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <malloc.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <asm/fsl_dtsec.h>
+#include <asm/fsl_serdes.h>
+#include "../common/qixis.h"
+#include "../common/fman.h"
+#include "t102xqds_qixis.h"
+
+#define EMI_NONE	0xFFFFFFFF
+#define EMI1_RGMII1	0
+#define EMI1_RGMII2	1
+#define EMI1_SLOT1	2
+#define EMI1_SLOT2	3
+#define EMI1_SLOT3	4
+#define EMI1_SLOT4	5
+#define EMI1_SLOT5	6
+#define EMI2		7
+
+static int mdio_mux[NUM_FM_PORTS];
+
+static const char * const mdio_names[] = {
+	"T1024QDS_MDIO_RGMII1",
+	"T1024QDS_MDIO_RGMII2",
+	"T1024QDS_MDIO_SLOT1",
+	"T1024QDS_MDIO_SLOT2",
+	"T1024QDS_MDIO_SLOT3",
+	"T1024QDS_MDIO_SLOT4",
+	"T1024QDS_MDIO_SLOT5",
+	"T1024QDS_MDIO_10GC",
+	"NULL",
+};
+
+/* Map SerDes1 4 lanes to default slot, will be initialized dynamically */
+static u8 lane_to_slot[] = {2, 3, 4, 5};
+
+static const char *t1024qds_mdio_name_for_muxval(u8 muxval)
+{
+	return mdio_names[muxval];
+}
+
+struct mii_dev *mii_dev_for_muxval(u8 muxval)
+{
+	struct mii_dev *bus;
+	const char *name;
+
+	if (muxval > EMI2)
+		return NULL;
+
+	name = t1024qds_mdio_name_for_muxval(muxval);
+
+	if (!name) {
+		printf("No bus for muxval %x\n", muxval);
+		return NULL;
+	}
+
+	bus = miiphy_get_dev_by_name(name);
+
+	if (!bus) {
+		printf("No bus by name %s\n", name);
+		return NULL;
+	}
+
+	return bus;
+}
+
+struct t1024qds_mdio {
+	u8 muxval;
+	struct mii_dev *realbus;
+};
+
+static void t1024qds_mux_mdio(u8 muxval)
+{
+	u8 brdcfg4;
+	if (muxval < 7) {
+		brdcfg4 = QIXIS_READ(brdcfg[4]);
+		brdcfg4 &= ~BRDCFG4_EMISEL_MASK;
+		brdcfg4 |= (muxval << BRDCFG4_EMISEL_SHIFT);
+		QIXIS_WRITE(brdcfg[4], brdcfg4);
+	}
+}
+
+static int t1024qds_mdio_read(struct mii_dev *bus, int addr, int devad,
+				int regnum)
+{
+	struct t1024qds_mdio *priv = bus->priv;
+
+	t1024qds_mux_mdio(priv->muxval);
+
+	return priv->realbus->read(priv->realbus, addr, devad, regnum);
+}
+
+static int t1024qds_mdio_write(struct mii_dev *bus, int addr, int devad,
+				int regnum, u16 value)
+{
+	struct t1024qds_mdio *priv = bus->priv;
+
+	t1024qds_mux_mdio(priv->muxval);
+
+	return priv->realbus->write(priv->realbus, addr, devad, regnum, value);
+}
+
+static int t1024qds_mdio_reset(struct mii_dev *bus)
+{
+	struct t1024qds_mdio *priv = bus->priv;
+
+	return priv->realbus->reset(priv->realbus);
+}
+
+static int t1024qds_mdio_init(char *realbusname, u8 muxval)
+{
+	struct t1024qds_mdio *pmdio;
+	struct mii_dev *bus = mdio_alloc();
+
+	if (!bus) {
+		printf("Failed to allocate t1024qds MDIO bus\n");
+		return -1;
+	}
+
+	pmdio = malloc(sizeof(*pmdio));
+	if (!pmdio) {
+		printf("Failed to allocate t1024qds private data\n");
+		free(bus);
+		return -1;
+	}
+
+	bus->read = t1024qds_mdio_read;
+	bus->write = t1024qds_mdio_write;
+	bus->reset = t1024qds_mdio_reset;
+	sprintf(bus->name, t1024qds_mdio_name_for_muxval(muxval));
+
+	pmdio->realbus = miiphy_get_dev_by_name(realbusname);
+
+	if (!pmdio->realbus) {
+		printf("No bus with name %s\n", realbusname);
+		free(bus);
+		free(pmdio);
+		return -1;
+	}
+
+	pmdio->muxval = muxval;
+	bus->priv = pmdio;
+	return mdio_register(bus);
+}
+
+void board_ft_fman_fixup_port(void *fdt, char *compat, phys_addr_t addr,
+				enum fm_port port, int offset)
+{
+	struct fixed_link f_link;
+
+	if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_RGMII) {
+		if (port == FM1_DTSEC3) {
+			fdt_set_phy_handle(fdt, compat, addr, "rgmii_phy2");
+			fdt_setprop(fdt, offset, "phy-connection-type",
+				    "rgmii", 5);
+			fdt_status_okay_by_alias(fdt, "emi1_rgmii1");
+		}
+	} else if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_SGMII) {
+		if (port == FM1_DTSEC1) {
+			fdt_set_phy_handle(fdt, compat, addr,
+					   "sgmii_vsc8234_phy_s5");
+		} else if (port == FM1_DTSEC2) {
+			fdt_set_phy_handle(fdt, compat, addr,
+					   "sgmii_vsc8234_phy_s4");
+		}
+	} else if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_SGMII_2500) {
+		if (port == FM1_DTSEC3) {
+			fdt_set_phy_handle(fdt, compat, addr,
+					   "sgmii_aqr105_phy_s3");
+		}
+	} else if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_QSGMII) {
+		switch (port) {
+		case FM1_DTSEC1:
+			fdt_set_phy_handle(fdt, compat, addr, "qsgmii_phy_p1");
+			break;
+		case FM1_DTSEC2:
+			fdt_set_phy_handle(fdt, compat, addr, "qsgmii_phy_p2");
+			break;
+		case FM1_DTSEC3:
+			fdt_set_phy_handle(fdt, compat, addr, "qsgmii_phy_p3");
+			break;
+		case FM1_DTSEC4:
+			fdt_set_phy_handle(fdt, compat, addr, "qsgmii_phy_p4");
+			break;
+		default:
+			break;
+		}
+		fdt_delprop(fdt, offset, "phy-connection-type");
+		fdt_setprop(fdt, offset, "phy-connection-type", "qsgmii", 6);
+		fdt_status_okay_by_alias(fdt, "emi1_slot2");
+	} else if (fm_info_get_enet_if(port) == PHY_INTERFACE_MODE_XGMII) {
+		/* XFI interface */
+		f_link.phy_id = port;
+		f_link.duplex = 1;
+		f_link.link_speed = 10000;
+		f_link.pause = 0;
+		f_link.asym_pause = 0;
+		/* no PHY for XFI */
+		fdt_delprop(fdt, offset, "phy-handle");
+		fdt_setprop(fdt, offset, "fixed-link", &f_link, sizeof(f_link));
+		fdt_setprop(fdt, offset, "phy-connection-type", "xgmii", 5);
+	}
+}
+
+void fdt_fixup_board_enet(void *fdt)
+{
+	return;
+}
+
+/*
+ * This function reads RCW to check if Serdes1{A:D} is configured
+ * to slot 1/2/3/4/5 and update the lane_to_slot[] array accordingly
+ */
+static void initialize_lane_to_slot(void)
+{
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 srds_s1 = in_be32(&gur->rcwsr[4]) &
+				FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+
+	srds_s1 >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	switch (srds_s1) {
+	case 0x46:
+	case 0x47:
+		lane_to_slot[1] = 2;
+		break;
+	default:
+		break;
+	}
+}
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_FMAN_ENET)
+	int i, idx, lane, slot, interface;
+	struct memac_mdio_info dtsec_mdio_info;
+	struct memac_mdio_info tgec_mdio_info;
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 srds_s1;
+
+	srds_s1 = in_be32(&gur->rcwsr[4]) &
+					FSL_CORENET2_RCWSR4_SRDS1_PRTCL;
+	srds_s1 >>= FSL_CORENET2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	initialize_lane_to_slot();
+
+	/* Initialize the mdio_mux array so we can recognize empty elements */
+	for (i = 0; i < NUM_FM_PORTS; i++)
+		mdio_mux[i] = EMI_NONE;
+
+	dtsec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the 1G MDIO bus */
+	fm_memac_mdio_init(bis, &dtsec_mdio_info);
+
+	tgec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tgec_mdio_info);
+
+	/* Register the muxing front-ends to the MDIO buses */
+	t1024qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_RGMII1);
+	t1024qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_RGMII2);
+	t1024qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_SLOT1);
+	t1024qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_SLOT2);
+	t1024qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_SLOT3);
+	t1024qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_SLOT4);
+	t1024qds_mdio_init(DEFAULT_FM_MDIO_NAME, EMI1_SLOT5);
+	t1024qds_mdio_init(DEFAULT_FM_TGEC_MDIO_NAME, EMI2);
+
+	/* Set the two on-board RGMII PHY address */
+	fm_info_set_phy_address(FM1_DTSEC3, RGMII_PHY2_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC4, RGMII_PHY1_ADDR);
+
+	switch (srds_s1) {
+	case 0xd5:
+	case 0xd6:
+		/* QSGMII in Slot2 */
+		fm_info_set_phy_address(FM1_DTSEC1, 0x8);
+		fm_info_set_phy_address(FM1_DTSEC2, 0x9);
+		fm_info_set_phy_address(FM1_DTSEC3, 0xa);
+		fm_info_set_phy_address(FM1_DTSEC4, 0xb);
+		break;
+	case 0x95:
+	case 0x99:
+		/*
+		 * XFI does not need a PHY to work, but to avoid U-boot use
+		 * default PHY address which is zero to a MAC when it found
+		 * a MAC has no PHY address, we give a PHY address to XFI
+		 * MAC, and should not use a real XAUI PHY address, since
+		 * MDIO can access it successfully, and then MDIO thinks the
+		 * XAUI card is used for the XFI MAC, which will cause error.
+		 */
+		fm_info_set_phy_address(FM1_10GEC1, 4);
+		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_PORT1_PHY_ADDR);
+		break;
+	case 0x6f:
+		/* SGMII in Slot3, Slot4, Slot5 */
+		fm_info_set_phy_address(FM1_DTSEC1, SGMII_CARD_AQ_PHY_ADDR_S5);
+		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_AQ_PHY_ADDR_S4);
+		fm_info_set_phy_address(FM1_DTSEC3, SGMII_CARD_PORT1_PHY_ADDR);
+		break;
+	case 0x7f:
+		fm_info_set_phy_address(FM1_DTSEC1, SGMII_CARD_AQ_PHY_ADDR_S5);
+		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_AQ_PHY_ADDR_S4);
+		fm_info_set_phy_address(FM1_DTSEC3, SGMII_CARD_AQ_PHY_ADDR_S3);
+		break;
+	case 0x47:
+		fm_info_set_phy_address(FM1_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
+		break;
+	case 0x77:
+		fm_info_set_phy_address(FM1_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3, SGMII_CARD_AQ_PHY_ADDR_S3);
+		break;
+	case 0x5a:
+		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_PORT1_PHY_ADDR);
+		break;
+	case 0x6a:
+		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_PORT1_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3, SGMII_CARD_PORT1_PHY_ADDR);
+		break;
+	case 0x5b:
+		fm_info_set_phy_address(FM1_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_PORT1_PHY_ADDR);
+		break;
+	case 0x6b:
+		fm_info_set_phy_address(FM1_DTSEC1, SGMII_CARD_PORT1_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC2, SGMII_CARD_PORT1_PHY_ADDR);
+		fm_info_set_phy_address(FM1_DTSEC3, SGMII_CARD_PORT1_PHY_ADDR);
+		break;
+	default:
+		break;
+	}
+
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		idx = i - FM1_DTSEC1;
+		interface = fm_info_get_enet_if(i);
+		switch (interface) {
+		case PHY_INTERFACE_MODE_SGMII:
+		case PHY_INTERFACE_MODE_SGMII_2500:
+		case PHY_INTERFACE_MODE_QSGMII:
+			if (interface == PHY_INTERFACE_MODE_SGMII) {
+				lane = serdes_get_first_lane(FSL_SRDS_1,
+						SGMII_FM1_DTSEC1 + idx);
+			} else if (interface == PHY_INTERFACE_MODE_SGMII_2500) {
+				lane = serdes_get_first_lane(FSL_SRDS_1,
+						SGMII_2500_FM1_DTSEC1 + idx);
+			} else {
+				lane = serdes_get_first_lane(FSL_SRDS_1,
+						QSGMII_FM1_A);
+			}
+
+			if (lane < 0)
+				break;
+
+			slot = lane_to_slot[lane];
+			debug("FM1@DTSEC%u expects SGMII in slot %u\n",
+			      idx + 1, slot);
+			if (QIXIS_READ(present2) & (1 << (slot - 1)))
+				fm_disable_port(i);
+
+			switch (slot) {
+			case 2:
+				mdio_mux[i] = EMI1_SLOT2;
+				fm_info_set_mdio(i, mii_dev_for_muxval(
+						 mdio_mux[i]));
+				break;
+			case 3:
+				mdio_mux[i] = EMI1_SLOT3;
+				fm_info_set_mdio(i, mii_dev_for_muxval(
+						 mdio_mux[i]));
+				break;
+			case 4:
+				mdio_mux[i] = EMI1_SLOT4;
+				fm_info_set_mdio(i, mii_dev_for_muxval(
+						 mdio_mux[i]));
+				break;
+			case 5:
+				mdio_mux[i] = EMI1_SLOT5;
+				fm_info_set_mdio(i, mii_dev_for_muxval(
+						 mdio_mux[i]));
+				break;
+			}
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			if (i == FM1_DTSEC3)
+				mdio_mux[i] = EMI1_RGMII2;
+			else if (i == FM1_DTSEC4)
+				mdio_mux[i] = EMI1_RGMII1;
+			fm_info_set_mdio(i, mii_dev_for_muxval(mdio_mux[i]));
+			break;
+		default:
+			break;
+		}
+	}
+
+	for (i = FM1_10GEC1; i < FM1_10GEC1 + CONFIG_SYS_NUM_FM1_10GEC; i++) {
+		idx = i - FM1_10GEC1;
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_XGMII:
+			lane = serdes_get_first_lane(FSL_SRDS_1,
+						     XFI_FM1_MAC1 + idx);
+			if (lane < 0)
+				break;
+			mdio_mux[i] = EMI2;
+			fm_info_set_mdio(i, mii_dev_for_muxval(mdio_mux[i]));
+			break;
+		default:
+			break;
+		}
+	}
+
+	cpu_eth_init(bis);
+#endif /* CONFIG_FMAN_ENET */
+
+	return pci_eth_init(bis);
+}
--- u-boot-2014.07/board/freescale/t102xqds/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/README	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,328 @@
+T1024 SoC Overview
+------------------
+The T1024/T1023 dual core and T1014/T1013 single core QorIQ communication processor
+combines two or one 64-bit Power Architecture e5500 core respectively with high
+performance datapath acceleration logic, and network peripheral bus interfaces
+required for networking and telecommunications. This processor can be used in
+applications such as enterprise WLAN access points, routers, switches, firewall
+and other packet processing intensive small enterprise and branch office appliances,
+and general-purpose embedded computing. Its high level of integration offers
+significant performance benefits and greatly helps to simplify board design.
+
+
+The T1024 SoC includes the following function and features:
+- two e5500 cores, each with a private 256 KB L2 cache
+  - Up to 1.4 GHz with 64-bit ISA support (Power Architecture v2.06-compliant)
+  - Three levels of instructions: User, supervisor, and hypervisor
+  - Independent boot and reset
+  - Secure boot capability
+- 256 KB shared L3 CoreNet platform cache (CPC)
+- Interconnect CoreNet platform
+  - CoreNet coherency manager supporting coherent and noncoherent transactions
+    with prioritization and bandwidth allocation amongst CoreNet endpoints
+  - 150 Gbps coherent read bandwidth
+- 32-/64-bit DDR3L/DDR4 SDRAM memory controller with ECC and interleaving support
+- Data Path Acceleration Architecture (DPAA) incorporating acceleration for the following functions:
+  - Packet parsing, classification, and distribution
+  - Queue management for scheduling, packet sequencing, and congestion management
+  - Cryptography Acceleration (SEC 5.x)
+  - IEEE 1588 support
+  - Hardware buffer management for buffer allocation and deallocation
+  - MACSEC on DPAA-based Ethernet ports
+- Ethernet interfaces
+  - Four 1 Gbps Ethernet controllers
+- Parallel Ethernet interfaces
+  - Two RGMII interfaces
+- High speed peripheral interfaces
+  - Three PCI Express 2.0 controllers/ports running at up to 5 GHz
+  - One SATA controller supporting 1.5 and 3.0 Gb/s operation
+  - One QSGMII interface
+  - Four SGMII interface supporting 1000 Mbps
+  - Three SGMII interfaces supporting up to 2500 Mbps
+  - 10GbE XFI or 10Base-KR interface
+- Additional peripheral interfaces
+  - Two USB 2.0 controllers with integrated PHY
+  - SD/eSDHC/eMMC
+  - eSPI controller
+  - Four I2C controllers
+  - Four UARTs
+  - Four GPIO controllers
+  - Integrated flash controller (IFC)
+  - LCD interface (DIU) with 12 bit dual data rate
+- Multicore programmable interrupt controller (PIC)
+- Two 8-channel DMA engines
+- Single source clocking implementation
+- Deep Sleep power implementaion (wakeup from GPIO/Timer/Ethernet/USB)
+- QUICC Engine block
+  - 32-bit RISC controller for flexible support of the communications peripherals
+  - Serial DMA channel for receive and transmit on all serial channels
+  - Two universal communication controllers, supporting TDM, HDLC, and UART
+
+T1023 Personality
+------------------
+T1023 is a reduced personality of T1024 without QUICC Engine, DIU, and
+unavailable deep sleep. Rest of the blocks are almost same as T1024.
+Differences between T1024 and T1023
+Feature		T1024  T1023
+QUICC Engine:	yes    no
+DIU:		yes    no
+Deep Sleep:	yes    no
+I2C controller: 4      3
+DDR:		64-bit 32-bit
+IFC:		32-bit 28-bit
+
+
+T1024QDS board Overview
+-----------------------
+- SERDES Connections
+  4 lanes supporting the following:
+  - PCI Express: supports Gen 1 and Gen 2
+  - SGMII 1G and SGMII 2.5G
+  - QSGMII
+  - XFI
+  - SATA 2.0
+  - High-speed multiplexers route the SerDes traffic to appropriate slots or connectors.
+  - Aurora debug with dedicated connectors.
+- DDR Controller
+  - Supports up to 1600 MTPS data-rate.
+  - Supports one DDR4 or DDR3L module using DDR4 to DDR3L adapter card.
+    - Supports Single-, dual- or quad-rank DIMMs
+  - DDR power supplies 1.35V (DDR3L)/1.20V (DDR4) to all devices with automatic tracking of VTT.
+- IFC/Local Bus
+  - NAND Flash: 8-bit, async, up to 2GB
+  - NOR: 8-bit or 16-bit, non-multiplexed, up to 512MB
+    - NOR devices support 8 virtual banks
+    - Socketed to allow alternate devices
+  - GASIC: Simple (minimal) target within QIXIS FPGA
+  - PromJET rapid memory download support
+  - IFC Debug/Development card
+- Ethernet
+  - Two on-board RGMII 10M/100M/1G ethernet ports.
+  - One QSGMII interface
+  - Four SGMII interface supporting 1Gbps
+  - Three SGMII interfaces supporting 2.5Gbps
+  - one 10Gbps XFI or 10Base-KR interface
+- QIXIS System Logic FPGA
+  - Manages system power and reset sequencing.
+  - Manages the configurations of DUT, board, and clock for dynamic shmoo.
+  - Collects V-I-T data in background for code/power profiling.
+  - Supports legacy TMT test features (POSt, IRS, SYSCLK-synchronous assertion).
+  - General fault monitoring and logging.
+  - Powered from ATX 'standby' power supply that allows continuous operation while rest of the system is off.
+- Clocks
+  - System and DDR clock (SYSCLK, DDRCLK).
+    - Switch selectable to one of 16 common settings in the interval of 64 MHz-166 MHz.
+    - Software programmable in 1 MHz increments from 1-200 MHz.
+  - SERDES clocks
+    - Provides clocks to SerDes blocks and slots.
+    - 100 MHz, 125 MHz and 156.25 MHz options.
+    - Spread-spectrum option for 100 MHz.
+- Power Supplies
+  - Dedicated PMBus regulator for VDD and VDDC.
+  - Adjustable from 0.7V to 1.3V at 35A
+    - VDD can be disabled independanty from VDDC for “deep sleep”.
+    - DDR3L/DDR4 power supply for GVDD: 1.35 or 1.20V at up to 22A.
+    - VTT/MVREF automatically track operating voltage.
+    - Dedicated 2.5V VPP supply.
+  - Dedicated regulators/filters for AVDD supplies.
+  - Dedicated regulators for other supplies, for example OVDD, CVDD, DVDD, LVDD, POVDD, and EVDD.
+- Video
+  - DIU supports video up to 1280x1024x32 bpp.
+    - Chrontel CH7201 for HDMI connection.
+    - TI DS90C387R for direct LCD connection.
+    - Raw (not encoded) video connector for testing or other encoders.
+- USB
+  - Supports two USB 2.0 ports with integrated PHYs.
+    - Two type A ports with 5V@1.5A per port.
+    - Second port can be converted to OTG mini-AB.
+- SDHC
+  For T1024QDS, the SDHC port connects directly to an adapter card slot that has the following features:
+    - upport for optional clock feedback paths.
+    - Support for optional high-speed voltage translation direction controls.
+    - Support for SD slots for: SD, SDHC (1x, 4x, 8x) and MMC.
+    - Support for eMMC memory devices.
+- SPI
+  -On-board support of 3 different devices and sizes.
+- Other IO
+  - Two Serial ports
+  - ProfiBus port
+  - Four I2C ports
+
+
+Memory map on T1024QDS
+----------------------
+Start Address  End Address      Description			Size
+0xF_FFDF_0000  0xF_FFDF_0FFF    IFC - FPGA			4KB
+0xF_FF80_0000  0xF_FF80_FFFF    IFC - NAND Flash		64KB
+0xF_FE00_0000  0xF_FEFF_FFFF    CCSRBAR				16MB
+0xF_F802_0000  0xF_F802_FFFF    PCI Express 3 I/O Space		64KB
+0xF_F801_0000  0xF_F801_FFFF    PCI Express 2 I/O Space		64KB
+0xF_F800_0000  0xF_F800_FFFF    PCI Express 1 I/O Space		64KB
+0xF_F600_0000  0xF_F7FF_FFFF    Queue manager software portal   32MB
+0xF_F400_0000  0xF_F5FF_FFFF    Buffer manager software portal  32MB
+0xF_E800_0000  0xF_EFFF_FFFF    IFC - NOR Flash			128MB
+0xF_E000_0000  0xF_E7FF_FFFF    Promjet				128MB
+0xF_0000_0000  0xF_003F_FFFF    DCSR				4MB
+0xC_2000_0000  0xC_2FFF_FFFF    PCI Express 3 Mem Space		256MB
+0xC_1000_0000  0xC_1FFF_FFFF    PCI Express 2 Mem Space		256MB
+0xC_0000_0000  0xC_0FFF_FFFF    PCI Express 1 Mem Space		256MB
+0x0_0000_0000  0x0_ffff_ffff    DDR				4GB
+
+
+128MB NOR Flash memory Map
+--------------------------
+Start Address   End Address     Definition			Max size
+0xEFF40000      0xEFFFFFFF      u-boot (current bank)		768KB
+0xEFF20000      0xEFF3FFFF      u-boot env (current bank)	128KB
+0xEFF00000      0xEFF1FFFF      FMAN Ucode (current bank)	128KB
+0xEFE00000      0xEFE3FFFF      QE firmware (current bank)	256KB
+0xED300000      0xEFEFFFFF      rootfs (alt bank)		44MB
+0xEC800000      0xEC8FFFFF      Hardware device tree (alt bank) 1MB
+0xEC020000      0xEC7FFFFF      Linux.uImage (alt bank)		7MB + 875KB
+0xEC000000      0xEC01FFFF      RCW (alt bank)			128KB
+0xEBF40000      0xEBFFFFFF      u-boot (alt bank)		768KB
+0xEBF20000      0xEBF3FFFF      u-boot env (alt bank)		128KB
+0xEBF00000      0xEBF1FFFF      FMAN ucode (alt bank)		128KB
+0xEBE00000      0xEBE3FFFF      QE firmware (alt bank)		256KB
+0xE9300000      0xEBEFFFFF      rootfs (current bank)		44MB
+0xE8800000      0xE88FFFFF      Hardware device tree (cur bank) 1MB
+0xE8020000      0xE86FFFFF      Linux.uImage (current bank)	7MB + 875KB
+0xE8000000      0xE801FFFF      RCW (current bank)		128KB
+
+
+SerDes clock vs DIP-switch settings
+-----------------------------------
+SRDS_PRTCL_S1	SD1_REF_CLK1	SD1_REF_CLK2	SW4[1:4]
+0x6F		100MHz		125MHz		1101
+0xD6		100MHz		100MHz		1111
+0x99		156.25MHz	100MHz		1011
+
+
+T1024 Clock frequency
+----------------------
+BIN   Core     DDR       Platform  FMan
+Bin1: 1400MHz  1600MT/s  400MHz    700MHz
+Bin2: 1200MHz  1600MT/s  400MHz    600MHz
+Bin3: 1000MHz  1600MT/s  400MHz    500MHz
+
+
+
+Software configurations and board settings
+------------------------------------------
+1. NOR boot:
+   a. build NOR boot image
+	$  make T1024QDS_config    (For DDR3L, by default)
+	or make T1024QDS_D4_config (For DDR4)
+	$  make
+   b. program u-boot.bin image to NOR flash
+	=> tftp 1000000 u-boot.bin
+	=> pro off all;era eff40000 efffffff;cp.b 1000000 eff40000 $filesize
+	set SW1[1:8] = '00010011', SW2[1] = '1', SW6[1:4] = '0000' for NOR boot
+
+   Switching between default bank0 and alternate bank4 on NOR flash
+   To change boot source to vbank4:
+	via software:   run command 'qixis_reset altbank' in u-boot.
+	via DIP-switch: set SW6[1:4] = '0100'
+
+   To change boot source to vbank0:
+	via software:   run command 'qixis_reset' in u-boot.
+	via DIP-Switch: set SW6[1:4] = '0000'
+
+2. NAND Boot:
+   a. build PBL image for NAND boot
+	$ make T1024QDS_NAND_config
+	$ make
+   b. program u-boot-with-spl-pbl.bin to NAND flash
+	=> tftp 1000000 u-boot-with-spl-pbl.bin
+	=> nand erase 0 $filesize
+	=> nand write 1000000 0 $filesize
+	set SW1[1:8] = '10000010', SW2[1] = '0' and SW6[1:4] = '1001' for NAND boot
+
+3. SPI Boot:
+   a. build PBL image for SPI boot
+	$ make T1024QDS_SPIFLASH_config
+	$ make
+   b. program u-boot-with-spl-pbl.bin to SPI flash
+	=> tftp 1000000 u-boot-with-spl-pbl.bin
+	=> sf probe 0
+	=> sf erase 0 f0000
+	=> sf write 1000000 0 $filesize
+	set SW1[1:8] = '00100010', SW2[1] ='1' for SPI boot
+
+4. SD Boot:
+   a. build PBL image for SD boot
+	$ make T1024QDS_SDCARD_config
+	$ make
+   b. program u-boot-with-spl-pbl.bin to SD/MMC card
+	=> tftp 1000000 u-boot-with-spl-pbl.bin
+	=> mmc write 1000000 8 0x800
+	=> tftp 1000000 fsl_fman_ucode_t1024_xx.bin
+	=> mmc write 1000000 0x820 80
+	set SW1[1:8] = '00100000', SW2[1] = '0' for SD boot
+
+
+DIU/QE-TDM/SDXC settings
+-------------------
+a) For TDM Riser:     set pin_mux=tdm in hwconfig
+b) For UCC(ProfiBus): set pin_mux=ucc in hwconfig
+c) For HDMI(DVI):     set pin_mux=hdmi in hwconfig
+d) For LCD(DFP):      set pin_mux=lcd in hwconfig
+e) For SDXC:	      set adaptor=sdxc in hwconfig
+
+2-stage NAND/SPI/SD boot loader
+-------------------------------
+PBL initializes the internal CPC-SRAM and copy SPL(160K) to SRAM.
+SPL further initializes DDR using SPD and environment variables
+and copy u-boot(768 KB) from NAND/SPI/SD device to DDR.
+Finally SPL transers control to u-boot for futher booting.
+
+SPL has following features:
+ - Executes within 256K
+ - No relocation required
+
+Run time view of SPL framework
+-------------------------------------------------
+|Area		   | Address			|
+-------------------------------------------------
+|SecureBoot header | 0xFFFC0000 (32KB)		|
+-------------------------------------------------
+|GD, BD		   | 0xFFFC8000 (4KB)		|
+-------------------------------------------------
+|ENV		   | 0xFFFC9000 (8KB)		|
+-------------------------------------------------
+|HEAP		   | 0xFFFCB000 (30KB)		|
+-------------------------------------------------
+|STACK		   | 0xFFFD8000 (22KB)		|
+-------------------------------------------------
+|U-boot SPL	   | 0xFFFD8000 (160KB)		|
+-------------------------------------------------
+
+NAND Flash memory Map on T1024QDS
+-------------------------------------------------------------
+Start		End		Definition	Size
+0x000000	0x0FFFFF	u-boot		1MB
+0x100000	0x15FFFF	u-boot env	8KB
+0x160000	0x17FFFF	FMAN Ucode	128KB
+0x180000	0x19FFFF	QE Firmware	128KB
+
+
+SD Card memory Map on T1024QDS
+----------------------------------------------------
+Block		#blocks		Definition	Size
+0x008		2048		u-boot img	1MB
+0x800		0016		u-boot env	8KB
+0x820		0256		FMAN Ucode	128KB
+0x920		0256		QE Firmware	128KB
+
+
+SPI Flash memory Map on T1024QDS
+----------------------------------------------------
+Start		End		Definition	Size
+0x000000	0x0FFFFF	u-boot img	1MB
+0x100000	0x101FFF	u-boot env	8KB
+0x110000	0x12FFFF	FMAN Ucode	128KB
+0x130000	0x14FFFF	QE Firmware	128KB
+
+
+For more details, please refer to T1024QDS Reference Manual and access
+website www.freescale.com and Freescale QorIQ SDK Infocenter document.
--- u-boot-2014.07/board/freescale/t102xqds/spl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/spl.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,151 @@
+/* Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <ns16550.h>
+#include <nand.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <spi_flash.h>
+#include "../common/qixis.h"
+#include "t102xqds_qixis.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+phys_size_t get_effective_memsize(void)
+{
+	return CONFIG_SYS_L3_SIZE;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0F) {
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio, sys_clk, ccb_clk;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+#if defined(CONFIG_PPC_T1040) && defined(CONFIG_SPL_NAND_BOOT)
+	/*
+	 * There is T1040 SoC issue where NOR, FPGA are inaccessible during
+	 * NAND boot because IFC signals > IFC_AD7 are not enabled.
+	 * This workaround changes RCW source to make all signals enabled.
+	 */
+	u32 porsr1, pinctl;
+#define FSL_CORENET_CCSR_PORSR1_RCW_MASK        0xFF800000
+
+	porsr1 = in_be32(&gur->porsr1);
+	pinctl = ((porsr1 & ~(FSL_CORENET_CCSR_PORSR1_RCW_MASK)) | 0x24800000);
+	out_be32((unsigned int *)(CONFIG_SYS_DCSRBAR + 0x20000), pinctl);
+#endif
+
+	/* Memcpy existing GD at CONFIG_SPL_GD_ADDR */
+	memcpy((void *)CONFIG_SPL_GD_ADDR, (void *)gd, sizeof(gd_t));
+
+	/* Update GD pointer */
+	gd = (gd_t *)(CONFIG_SPL_GD_ADDR);
+
+	console_init_f();
+
+	/* initialize selected port with appropriate baud rate */
+	sys_clk = get_board_sys_clk();
+	plat_ratio = (in_be32(&gur->rcwsr[0]) >> 25) & 0x1f;
+	ccb_clk = sys_clk * plat_ratio / 2;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+		     ccb_clk / 16 / CONFIG_BAUDRATE);
+
+#if defined(CONFIG_SPL_MMC_BOOT)
+	puts("\nSD boot...\n");
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	puts("\nSPI boot...\n");
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	puts("\nNAND boot...\n");
+#endif
+
+	relocate_code(CONFIG_SPL_RELOC_STACK, (gd_t *)CONFIG_SPL_GD_ADDR, 0x0);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	bd_t *bd;
+
+	bd = (bd_t *)(gd + sizeof(gd_t));
+	memset(bd, 0, sizeof(bd_t));
+	gd->bd = bd;
+	bd->bi_memstart = CONFIG_SYS_INIT_L3_ADDR;
+	bd->bi_memsize = CONFIG_SYS_L3_SIZE;
+
+	probecpu();
+	get_clocks();
+	mem_malloc_init(CONFIG_SPL_RELOC_MALLOC_ADDR,
+			CONFIG_SPL_RELOC_MALLOC_SIZE);
+
+#ifdef CONFIG_SPL_NAND_BOOT
+	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			    (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_initialize(bd);
+	mmc_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_SPI_BOOT
+	spi_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+
+	gd->env_addr  = (ulong)(CONFIG_ENV_ADDR);
+	gd->env_valid = 1;
+
+	i2c_init_all();
+
+	gd->ram_size = initdram(0);
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_boot();
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	spi_boot();
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	nand_boot();
+#endif
+}
--- u-boot-2014.07/board/freescale/t102xqds/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/tlb.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L3_ADDR)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 256K SRAM, the address of the
+	 * SRAM is at 0xfffc0000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_256K, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+#ifndef CONFIG_SPL_BUILD
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256K, 1),
+
+	/* Bman/Qman */
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 5, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 7, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 8, BOOKE_PAGESZ_16M, 1),
+#endif
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 9, BOOKE_PAGESZ_4M, 1),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_64K, 1),
+#endif
+#ifdef QIXIS_BASE
+	SET_TLB_ENTRY(1, QIXIS_BASE, QIXIS_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 11, BOOKE_PAGESZ_4K, 1),
+#endif
+
+#if defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SPL_BUILD)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 12, BOOKE_PAGESZ_1G, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		      CONFIG_SYS_DDR_SDRAM_BASE + 0x40000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 13, BOOKE_PAGESZ_1G, 1)
+#endif
+	/* entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so if needed more, will use entry 16 later.
+	 */
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2014.07/board/freescale/t102xqds/t102xqds.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/t102xqds.h	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __T102x_QDS_H__
+#define __T102x_QDS_H__
+
+void fdt_fixup_board_enet(void *blob);
+void pci_of_setup(void *blob, bd_t *bd);
+int select_i2c_ch_pca9547(u8 ch);
+
+#endif
--- u-boot-2014.07/board/freescale/t102xqds/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/law.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+#ifndef CONFIG_SYS_NO_FLASH
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_IFC),
+#endif
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
+#endif
+#ifdef QIXIS_BASE_PHYS
+	SET_LAW(QIXIS_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_4M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_64K, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2014.07/board/freescale/t102xqds/t1024_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/t1024_pbi.cfg	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,26 @@
+#PBI commands
+#Initialize CPC1
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+#Configure CPC1 as 256KB SRAM
+09010100 00000000
+09010104 fffc0007
+09010f00 08000000
+09010000 80000000
+#Configure LAW for CPC1
+09000cd0 00000000
+09000cd4 fffc0000
+09000cd8 81000011
+#Configure alternate space
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+#Configure SPI controller
+09110000 80000403
+09110020 2d170008
+09110024 00100008
+09110028 00100008
+0911002c 00100008
+#Flush PBL data
+091380c0 000FFFFF
--- u-boot-2014.07/board/freescale/t102xqds/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/Makefile	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,17 @@
+#
+# Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+else
+obj-y	+= t102xqds.o
+obj-y	+= eth_t102xqds.o
+obj-$(CONFIG_PCI) += pci.o
+obj-$(CONFIG_FSL_DIU_FB) += diu.o
+endif
+obj-y   += ddr.o
+obj-y   += law.o
+obj-y   += tlb.o
--- u-boot-2014.07/board/freescale/t102xqds/pci.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/t102xqds/pci.c	2022-05-09 14:06:23.349144677 -0700
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/fsl_serdes.h>
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void pci_of_setup(void *blob, bd_t *bd)
+{
+	FT_FSL_PCI_SETUP;
+}
--- u-boot-2014.07/board/freescale/m300/m300.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/m300.c	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2009-2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+#include <asm/mpc85xx_gpio.h>
+#include <version.h>
+#include "m300.h"
+
+/* 
+ * 	GPO 27 reset
+ * 	GPO 28 
+ * 	GPO 29 
+ * 	RED 	28=L 29=H
+ * 	GREEN	28=H 29=L
+ *
+ */
+#define GPIO_RESET  0x10
+#define GPIO_RED  0x8    
+#define GPIO_GREEN  0x4
+#define GPIO_DIR 0x0000001c
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	struct cpu_type *cpu = gd->arch.cpu;
+        volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	printf("Board: %sRDB, ", cpu->name);
+	printf ("%s\n",BOARD_VERSION);
+#ifndef CONFIG_RAMBOOT_PBL
+        setbits_be32(&pgpio->gpdir, GPIO_DIR);
+        clrsetbits_be32(&pgpio->gpdat, GPIO_GREEN, GPIO_RED);
+	gpio_set_value(4, 1);
+	udelay(5);
+	gpio_set_value(4, 0);
+	udelay(5);
+	gpio_set_value(4, 1);
+#endif
+
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const u8 temp[7] = { 0x49, 0x4e, 0x52, 0x56, 0x59, 0x5c, 0x5f};
+	const u8 fan[7]  = { 0x0a, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f};
+	int i=0;
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash + promjet */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+		MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		0, flash_esel, BOOKE_PAGESZ_256M, 1);
+
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+/*W83793D Smart fan enbale*/
+	/*  W83793D smartfan default setting */
+	i2c_reg_write(0x2d, 0, 0x82);
+	/* Enable Temp 1 smartfan function */
+	i2c_reg_write(0x2d, 0x1, 0x4);
+	for ( i = 0 ; i < 7 ; i++)
+	{
+		/* Set temp level */
+		i2c_reg_write(0x2d, 0x30 + i, temp[i]);
+		/* Set fan level */
+		i2c_reg_write(0x2d, 0x38 + i, fan[i]);
+	}
+	i2c_reg_write(0x2d, 0, 0x80);
+	/* Set Uptime */
+	i2c_reg_write(0x2d, 0xc3, 0x1);
+	/* Set Downtime */
+	i2c_reg_write(0x2d, 0xc4, 0x20);
+	/* Set Critical Temperature */
+	i2c_reg_write(0x2d, 0xc5, 0x5f);
+/*W83793D Smart fan enbale*/
+	return 0;
+}
+
+
+int misc_init_r(void)
+{
+	return 0;
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+	fdt_fixup_dr_usb(blob, bd);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+}
--- u-boot-2014.07/board/freescale/m300/eth.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/eth.c	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Shengzhou Liu <Shengzhou.Liu@freescale.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <malloc.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <asm/fsl_dtsec.h>
+#include <asm/fsl_serdes.h>
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_FMAN_ENET)
+	struct memac_mdio_info dtsec_mdio_info;
+
+	unsigned short value;
+
+
+	dtsec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the 1G MDIO bus */
+	fm_memac_mdio_init(bis, &dtsec_mdio_info);
+
+
+	/* Set the two on-board RGMII PHY address */
+	fm_info_set_phy_address(FM1_DTSEC3, RGMII_PHY1_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC4, RGMII_PHY2_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC10, 0);
+	fm_info_set_phy_address(FM1_DTSEC1, 1);
+	fm_info_set_phy_address(FM1_DTSEC2, 2);
+
+	fm_info_set_mdio(FM1_DTSEC10, miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	fm_info_set_mdio(FM1_DTSEC1, miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	fm_info_set_mdio(FM1_DTSEC2, miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	fm_info_set_mdio(FM1_DTSEC3, miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	fm_info_set_mdio(FM1_DTSEC4, miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME));
+	fm_disable_port(FM1_DTSEC6);
+
+	cpu_eth_init(bis);
+
+	const char      *devname;
+	devname = miiphy_get_current_dev();
+	miiphy_write(devname, 0x10, 0, 0x9a03);
+	miiphy_read(devname,  0x10, 1, &value);
+	if ( (value&0xffff) != 0x1712 ) {
+		printf("Error!!!! switch setting incorrect, check H/W\n");
+	}
+	else
+	{
+		printf("Init switch to forwarding mode... \n");
+		/* Reset and Disable INTx  */
+		DLAY SMIRW(1, 0x10, 4, 0xe000, 0, 0, 0x1b, 0);
+
+		/* set rgmii delay  */
+		DLAY SMIRW(1, 0x10, 1, 0xc03e, 0, 0, 0x15, 0);  /* P15 */
+		DLAY SMIRW(1, 0x10, 1, 0xc03e, 0, 0, 0x16, 0);  /* P16 */
+		/* set LED function */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x10, 0);/* P0 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x11, 0);/* P1 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x12, 0);/* P1 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x13, 0);/* P3 */
+		DLAY SMIRW(1, 0x10, 0x16, 0x9038, 0, 0,0x14, 0);/* P4 */
+		/* set port to forwarding mode */
+		DLAY SMIRW(1, 0x10, 4, 0x007f, 0, 0, 0x10, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x11, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x12, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x13, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x14, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x15, 0);
+		DLAY SMIRW(1, 0x10, 4 ,0x007f, 0, 0, 0x16, 0);
+		/* reset PHY */
+		DLAY
+		DLAY
+		DLAY
+	}
+
+#endif /* CONFIG_FMAN_ENET */
+
+	return pci_eth_init(bis);
+}
+
+void fdt_fixup_board_enet(void *fdt)
+{
+	return;
+}
--- u-boot-2014.07/board/freescale/m300/pci.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/pci.c	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2007-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/fsl_serdes.h>
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void pci_of_setup(void *blob, bd_t *bd)
+{
+	FT_FSL_PCI_SETUP;
+}
--- u-boot-2014.07/board/freescale/m300/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/law.c	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2008-2014 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_IFC),
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	/* Limit DCSR to 32M to access NPC Trace Buffer */
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2014.07/board/freescale/m300/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/tlb.c	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2008-2014 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L3_ADDR)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 1M SRAM, the address of the
+	 * SRAM is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_1M, 1),
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. When slave boot, the address of the
+	 * space is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR,
+		      CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_1M, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+#ifndef CONFIG_SPL_BUILD
+	/* *I*G* - PCIe 1, 0x80000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_512M, 1),
+
+	/* *I*G* - PCIe 2, 0xa0000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE2_MEM_VIRT, CONFIG_SYS_PCIE2_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCIe 3, 0xb0000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT, CONFIG_SYS_PCIE3_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 5, BOOKE_PAGESZ_256M, 1),
+
+
+	/* *I*G* - PCIe 4, 0xc0000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE4_MEM_VIRT, CONFIG_SYS_PCIE4_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 7, BOOKE_PAGESZ_256K, 1),
+
+	/* Bman/Qman */
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 9, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 10, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 11, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 12, BOOKE_PAGESZ_16M, 1),
+#endif
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 13, BOOKE_PAGESZ_32M, 1),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE
+	/*
+	 * *I*G - NAND
+	 * entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so we use entry 16 for nand.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 16, BOOKE_PAGESZ_64K, 1),
+#endif
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. 1M space from 0xffe00000 for
+	 * fetching ucode and ENV from master
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR,
+		      CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_G,
+		      0, 18, BOOKE_PAGESZ_1M, 1),
+#endif
+#if defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SPL_BUILD)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_M,
+		      0, 19, BOOKE_PAGESZ_2G, 1)
+#endif
+
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2014.07/board/freescale/m300/spl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/spl.c	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,108 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <ns16550.h>
+#include <nand.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <spi_flash.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+phys_size_t get_effective_memsize(void)
+{
+	return CONFIG_SYS_L3_SIZE;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	return CONFIG_SYS_CLK_FREQ;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	return CONFIG_DDR_CLK_FREQ;
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio, sys_clk, ccb_clk;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	/* Memcpy existing GD at CONFIG_SPL_GD_ADDR */
+	memcpy((void *)CONFIG_SPL_GD_ADDR, (void *)gd, sizeof(gd_t));
+
+	/* Update GD pointer */
+	gd = (gd_t *)(CONFIG_SPL_GD_ADDR);
+
+	console_init_f();
+
+	/* initialize selected port with appropriate baud rate */
+	sys_clk = get_board_sys_clk();
+	plat_ratio = (in_be32(&gur->rcwsr[0]) >> 25) & 0x1f;
+	ccb_clk = sys_clk * plat_ratio / 2;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+		     ccb_clk / 16 / CONFIG_BAUDRATE);
+
+#if defined(CONFIG_SPL_MMC_BOOT)
+	puts("\nSD boot...\n");
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	puts("\nSPI boot...\n");
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	puts("\nNAND boot...\n");
+#endif
+
+	relocate_code(CONFIG_SPL_RELOC_STACK, (gd_t *)CONFIG_SPL_GD_ADDR, 0x0);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	bd_t *bd;
+
+	bd = (bd_t *)(gd + sizeof(gd_t));
+	memset(bd, 0, sizeof(bd_t));
+	gd->bd = bd;
+	bd->bi_memstart = CONFIG_SYS_INIT_L3_ADDR;
+	bd->bi_memsize = CONFIG_SYS_L3_SIZE;
+
+	probecpu();
+	get_clocks();
+	mem_malloc_init(CONFIG_SPL_RELOC_MALLOC_ADDR,
+			CONFIG_SPL_RELOC_MALLOC_SIZE);
+
+#ifndef CONFIG_SPL_NAND_BOOT
+	env_init();
+#endif
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_initialize(bd);
+#endif
+
+	/* relocate environment function pointers etc. */
+#ifdef CONFIG_SPL_NAND_BOOT
+	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			    (uchar *)CONFIG_ENV_ADDR);
+	gd->env_addr  = (ulong)(CONFIG_ENV_ADDR);
+	gd->env_valid = 1;
+#else
+	env_relocate();
+#endif
+
+	i2c_init_all();
+
+	gd->ram_size = initdram(0);
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_boot();
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	spi_boot();
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	nand_boot();
+#endif
+}
--- u-boot-2014.07/board/freescale/m300/ddr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/ddr.h	2022-05-09 14:06:23.301146618 -0700
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+static const struct board_specific_parameters udimm0_v10[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl |
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |
+	 */
+	{2,  1200, 2, 5,     7, 0x0808090a, 0x0b0c0c0a},
+	{2,  1500, 2, 5,     6, 0x07070809, 0x0a0b0b09},
+	{2,  1600, 2, 5,     8, 0x0808070b, 0x0c0d0e0a},
+	{2,  1700, 2, 4,     7, 0x080a0a0c, 0x0c0d0e0a},
+	{2,  1900, 2, 5,     9, 0x0a0b0c0e, 0x0f10120c},
+	{1,  1200, 2, 5,     7, 0x0808090a, 0x0b0c0c0a},
+	{1,  1500, 2, 5,     6, 0x07070809, 0x0a0b0b09},
+//	{1,  1600, 2, 4,     8, 0x0808070b, 0x0c0d0e0a},
+	{1,  1600, 2, 4,     8, 0x0b0b0b0b, 0x0c0d0e0b}, //one dimm
+	{1,  1700, 2, 4,     7, 0x080a0a0c, 0x0c0d0e0a},
+	{1,  1900, 2, 5,     9, 0x0a0b0c0e, 0x0f10120c},
+	{}
+};
+
+static const struct board_specific_parameters *udimms_v10[] = {
+	udimm0_v10,
+};
+
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl |
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |
+	 */
+	{2,  1200, 2, 5,     7, 0x0808090a, 0x0b0c0c0a},
+	{2,  1500, 2, 5,     6, 0x07070809, 0x0a0b0b09},
+	{2,  1600, 2, 5,     8, 0x0808070b, 0x0c0d0e0a},
+	{2,  1700, 2, 4,     7, 0x080a0a0c, 0x0c0d0e0a},
+	{2,  1900, 2, 5,     9, 0x0a0b0c0e, 0x0f10120c},
+	{1,  1200, 2, 5,     7, 0x0808090a, 0x0b0c0c0a},
+	{1,  1500, 2, 5,     6, 0x07070809, 0x0a0b0b09},
+	{1,  1600, 2, 4,     8, 0x08080709, 0x0c0d0e0a},
+	{1,  1700, 2, 4,     7, 0x080a0a0c, 0x0c0d0e0a},
+	{1,  1900, 2, 5,     9, 0x0a0b0c0e, 0x0f10120c},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+#endif
--- u-boot-2014.07/board/freescale/m300/m300_rcw.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/m300_rcw.cfg	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,8 @@
+#PBL preamble and RCW header for T2080RDB
+aa55aa55 010e0100
+#SerDes Protocol:
+#Core/DDR: 1533Mhz/1200MT/s
+0c06000f 0f000000 00000000 00000000
+f2000002 c0008000 ec027000 a1000000
+00000000 00000000 00000000 000309fc
+00000000 00200000 00000000 00000005
--- u-boot-2014.07/board/freescale/m300/m300.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/m300.h	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CORENET_DS_H__
+#define __CORENET_DS_H__
+
+void fdt_fixup_board_enet(void *blob);
+void pci_of_setup(void *blob, bd_t *bd);
+
+#endif
--- u-boot-2014.07/board/freescale/m300/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/Makefile	2022-05-09 14:06:23.301146618 -0700
@@ -0,0 +1,17 @@
+#
+# Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+else
+obj-$(CONFIG_M300) += m300.o
+obj-$(CONFIG_M300) += eth.o
+obj-$(CONFIG_PCI)      += pci.o
+endif
+
+obj-y   += ddr.o
+obj-y   += law.o
+obj-y   += tlb.o
--- u-boot-2014.07/board/freescale/m300/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/ddr.c	2022-05-09 14:06:23.301146618 -0700
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * Version 2 or later as published by the Free Software Foundation.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include <asm/fsl_law.h>
+#include <asm/processor.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+	__maybe_unused u32 svr;
+
+	if (ctrl_num > 1) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	svr = get_svr();
+	if((SVR_MAJ(svr) > 1) || (SVR_MIN(svr) >= 1))	
+		pbsp = udimms[0];
+	else
+		pbsp = udimms_v10[0];
+	
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks &&
+		    (pdimm->rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found");
+		printf("for data rate %lu MT/s\n", ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, "
+		"wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_RAMBOOT_PBL)
+	puts("Initializing....using SPD\n");
+	dram_size = fsl_ddr_sdram();
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+#else
+	/* DDR has been initialised by first stage boot loader */
+	dram_size = fsl_ddr_sdram_size();
+#endif
+	return dram_size;
+}
--- u-boot-2014.07/board/freescale/m300/m300_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/board/freescale/m300/m300_pbi.cfg	2022-05-09 14:06:23.305146457 -0700
@@ -0,0 +1,48 @@
+#
+# Copyright 2013 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+# Refer doc/README.pblimage for more details about how-to configure
+# and create PBL boot image
+#
+
+#PBI commands
+#Initialize CPC1
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+#Reset and Set LED to Red
+09130000 0000001c
+09130008 0000001a
+091380c0 0000001F
+09130008 0000000a
+091380c0 0000001F
+09130008 0000001a
+#512KB SRAM
+09010100 00000000
+09010104 fff80009
+09010f00 08000000
+#enable CPC1
+09010000 80000000
+#Configure LAW for CPC1
+09000d00 00000000
+09000d04 fff80000
+09000d08 81000012
+#Initialize eSPI controller, default configuration is slow for eSPI to
+#load data, this configuration comes from u-boot eSPI driver.
+09110000 80000403
+09110020 2d170008
+09110024 00100008
+09110028 00100008
+0911002c 00100008
+#Errata for slowing down the MDC clock to make it <= 2.5 MHZ
+094fc030 00008148
+094fd030 00008148
+#Configure alternate space
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+#Flush PBL data
+09138000 00000000
+091380c0 00000000
--- u-boot-2014.07/drivers/net/phy/marvell_sw.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/net/phy/marvell_sw.c	2022-05-09 14:06:23.737128984 -0700
@@ -0,0 +1,45 @@
+/*
+ * Marvell PHY drivers
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ * author Andy Fleming
+ */
+#include <config.h>
+#include <common.h>
+#include <phy.h>
+
+static int sw_startup(struct phy_device *phydev)
+{
+	phydev->link = 1;
+	phydev->duplex = DUPLEX_FULL;
+	phydev->speed = SPEED_1000;
+	return 0;
+
+}
+
+/* Marvell 88E1111S */
+static int sw_config(struct phy_device *phydev)
+{
+
+	return 0;
+}
+
+static struct phy_driver SW_driver = {
+	.name = "Marvell 88E6171",
+	.uid = 0x12345678,
+	.mask = 0xffffff0,
+	.features = PHY_GBIT_FEATURES,
+	.config = &sw_config,
+	.startup = &sw_startup,
+	.shutdown = &genphy_shutdown,
+};
+
+
+int phy_marvell_sw_init(void)
+{
+	phy_register(&SW_driver);
+
+	return 0;
+}
--- u-boot-2014.07/drivers/net/phy/cortina.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/net/phy/cortina.c	2022-05-09 14:06:23.737128984 -0700
@@ -0,0 +1,336 @@
+/*
+ * Cortina CS4315/CS4340 10G PHY drivers
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ */
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/err.h>
+#include <phy.h>
+#include <cortina.h>
+#ifdef CONFIG_SYS_CORTINA_FW_IN_NAND
+#include <nand.h>
+#elif defined(CONFIG_SYS_CORTINA_FW_IN_SPIFLASH)
+#include <spi_flash.h>
+#elif defined(CONFIG_SYS_CORTINA_FW_IN_MMC)
+#include <mmc.h>
+#endif
+
+#ifndef CONFIG_PHYLIB_10G
+#error The Cortina PHY needs 10G support
+#endif
+
+struct cortina_reg_config cortina_reg_cfg[] = {
+	/* CS4315_enable_sr_mode */
+	{VILLA_GLOBAL_MSEQCLKCTRL, 0x8004},
+	{VILLA_MSEQ_OPTIONS, 0xf},
+	{VILLA_MSEQ_PC, 0x0},
+	{VILLA_MSEQ_BANKSELECT,	   0x4},
+	{VILLA_LINE_SDS_COMMON_SRX0_RX_CPA, 0x55},
+	{VILLA_LINE_SDS_COMMON_SRX0_RX_LOOP_FILTER, 0x30},
+	{VILLA_DSP_SDS_SERDES_SRX_DFE0_SELECT, 0x1},
+	{VILLA_DSP_SDS_DSP_COEF_DFE0_SELECT, 0x2},
+	{VILLA_LINE_SDS_COMMON_SRX0_RX_CPB, 0x2003},
+	{VILLA_DSP_SDS_SERDES_SRX_FFE_DELAY_CTRL, 0xF047},
+	{VILLA_MSEQ_ENABLE_MSB, 0x0000},
+	{VILLA_MSEQ_SPARE21_LSB, 0x6},
+	{VILLA_MSEQ_RESET_COUNT_LSB, 0x0},
+	{VILLA_MSEQ_SPARE12_MSB, 0x0000},
+	/*
+	 * to invert the receiver path, uncomment the next line
+	 * write (VILLA_MSEQ_SPARE12_MSB, 0x4000)
+	 *
+	 * SPARE2_LSB is used to configure the device while in sr mode to
+	 * enable power savings and to use the optical module LOS signal.
+	 * in power savings mode, the internal prbs checker can not be used.
+	 * if the optical module LOS signal is used as an input to the micro
+	 * code, then the micro code will wait until the optical module
+	 * LOS = 0 before turning on the adaptive equalizer.
+	 * Setting SPARE2_LSB bit 0 to 1 places the devie in power savings mode
+	 * while setting bit 0 to 0 disables power savings mode.
+	 * Setting SPARE2_LSB bit 2 to 0 configures the device to use the
+	 * optical module LOS signal while setting bit 2 to 1 configures the
+	 * device so that it will ignore the optical module LOS SPARE2_LSB = 0
+	 */
+
+	/* enable power savings, ignore optical module LOS */
+	{VILLA_MSEQ_SPARE2_LSB, 0x5},
+
+	{VILLA_MSEQ_SPARE7_LSB, 0x1e},
+	{VILLA_MSEQ_BANKSELECT, 0x4},
+	{VILLA_MSEQ_SPARE9_LSB, 0x2},
+	{VILLA_MSEQ_SPARE3_LSB, 0x0F53},
+	{VILLA_MSEQ_SPARE3_MSB, 0x2006},
+	{VILLA_MSEQ_SPARE8_LSB, 0x3FF7},
+	{VILLA_MSEQ_SPARE8_MSB, 0x0A46},
+	{VILLA_MSEQ_COEF8_FFE0_LSB, 0xD500},
+	{VILLA_MSEQ_COEF8_FFE1_LSB, 0x0200},
+	{VILLA_MSEQ_COEF8_FFE2_LSB, 0xBA00},
+	{VILLA_MSEQ_COEF8_FFE3_LSB, 0x0100},
+	{VILLA_MSEQ_COEF8_FFE4_LSB, 0x0300},
+	{VILLA_MSEQ_COEF8_FFE5_LSB, 0x0300},
+	{VILLA_MSEQ_COEF8_DFE0_LSB, 0x0700},
+	{VILLA_MSEQ_COEF8_DFE0N_LSB, 0x0E00},
+	{VILLA_MSEQ_COEF8_DFE1_LSB, 0x0B00},
+	{VILLA_DSP_SDS_DSP_COEF_LARGE_LEAK, 0x2},
+	{VILLA_DSP_SDS_SERDES_SRX_DAC_ENABLEB_LSB, 0xD000},
+	{VILLA_MSEQ_POWER_DOWN_LSB, 0xFFFF},
+	{VILLA_MSEQ_POWER_DOWN_MSB, 0x0},
+	{VILLA_MSEQ_CAL_RX_SLICER, 0x80},
+	{VILLA_DSP_SDS_SERDES_SRX_DAC_BIAS_SELECT1_MSB, 0x3f},
+	{VILLA_GLOBAL_MSEQCLKCTRL, 0x4},
+	{VILLA_MSEQ_OPTIONS, 0x7},
+
+	/* set up min value for ffe1 */
+	{VILLA_MSEQ_COEF_INIT_SEL, 0x2},
+	{VILLA_DSP_SDS_DSP_PRECODEDINITFFE21, 0x41},
+
+	/* CS4315_sr_rx_pre_eq_set_4in */
+	{VILLA_GLOBAL_MSEQCLKCTRL, 0x8004},
+	{VILLA_MSEQ_OPTIONS, 0xf},
+	{VILLA_MSEQ_BANKSELECT, 0x4},
+	{VILLA_MSEQ_PC, 0x0},
+
+	/* for lengths from 3.5 to 4.5inches */
+	{VILLA_MSEQ_SERDES_PARAM_LSB, 0x0306},
+	{VILLA_MSEQ_SPARE25_LSB, 0x0306},
+	{VILLA_MSEQ_SPARE21_LSB, 0x2},
+	{VILLA_MSEQ_SPARE23_LSB, 0x2},
+	{VILLA_MSEQ_CAL_RX_DFE_EQ, 0x0},
+
+	{VILLA_GLOBAL_MSEQCLKCTRL, 0x4},
+	{VILLA_MSEQ_OPTIONS, 0x7},
+
+	/* CS4315_rx_drive_4inch */
+	/* for length  4inches */
+	{VILLA_GLOBAL_VILLA2_COMPATIBLE, 0x0000},
+	{VILLA_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, 0x3023},
+	{VILLA_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, 0xc01E},
+
+	/* CS4315_tx_drive_4inch */
+	/* for length  4inches */
+	{VILLA_GLOBAL_VILLA2_COMPATIBLE, 0x0000},
+	{VILLA_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA, 0x3023},
+	{VILLA_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB, 0xc01E},
+};
+
+void cs4340_upload_firmware(struct phy_device *phydev)
+{
+	char line_temp[0x50] = {0};
+	char reg_addr[0x50] = {0};
+	char reg_data[0x50] = {0};
+	int i, line_cnt = 0, column_cnt = 0;
+	struct cortina_reg_config fw_temp;
+	char *addr = NULL;
+
+#if defined(CONFIG_SYS_CORTINA_FW_IN_NOR) || \
+	defined(CONFIG_SYS_CORTINA_FW_IN_REMOTE)
+
+	addr = (char *)CONFIG_CORTINA_FW_ADDR;
+#elif defined(CONFIG_SYS_CORTINA_FW_IN_NAND)
+	int ret;
+	size_t fw_length = CONFIG_CORTINA_FW_LENGTH;
+
+	addr = malloc(CONFIG_CORTINA_FW_LENGTH);
+	ret = nand_read(&nand_info[0], (loff_t)CONFIG_CORTINA_FW_ADDR,
+		       &fw_length, (u_char *)addr);
+	if (ret == -EUCLEAN) {
+		printf("NAND read of Cortina firmware at 0x%x failed %d\n",
+		       CONFIG_CORTINA_FW_ADDR, ret);
+	}
+#elif defined(CONFIG_SYS_CORTINA_FW_IN_SPIFLASH)
+	int ret;
+	struct spi_flash *ucode_flash;
+
+	addr = malloc(CONFIG_CORTINA_FW_LENGTH);
+	ucode_flash = spi_flash_probe(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+				CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+	if (!ucode_flash) {
+		puts("SF: probe for Cortina ucode failed\n");
+	} else {
+		ret = spi_flash_read(ucode_flash, CONFIG_CORTINA_FW_ADDR,
+				     CONFIG_CORTINA_FW_LENGTH, addr);
+		if (ret)
+			puts("SF: read for Cortina ucode failed\n");
+		spi_flash_free(ucode_flash);
+	}
+#elif defined(CONFIG_SYS_CORTINA_FW_IN_MMC)
+	int dev = CONFIG_SYS_MMC_ENV_DEV;
+	u32 cnt = CONFIG_CORTINA_FW_LENGTH / 512;
+	u32 blk = CONFIG_CORTINA_FW_ADDR / 512;
+	struct mmc *mmc = find_mmc_device(CONFIG_SYS_MMC_ENV_DEV);
+
+	if (!mmc) {
+		puts("Failed to find MMC device for Cortina ucode\n");
+	} else {
+		addr = malloc(CONFIG_CORTINA_FW_LENGTH);
+		printf("MMC read: dev # %u, block # %u, count %u ...\n",
+		       dev, blk, cnt);
+		mmc_init(mmc);
+		(void)mmc->block_dev.block_read(dev, blk, cnt, addr);
+		/* flush cache after read */
+		flush_cache((ulong)addr, cnt * 512);
+	}
+#endif
+
+	while (*addr != 'Q') {
+		i = 0;
+
+		while (*addr != 0x0a) {
+			line_temp[i++] = *addr++;
+			if (0x50 < i) {
+				printf("Not found Cortina PHY ucode at 0x%x\n",
+				       CONFIG_CORTINA_FW_ADDR);
+				return;
+			}
+		}
+
+		addr++;  /* skip '\n' */
+		line_cnt++;
+		column_cnt = i;
+		line_temp[column_cnt] = '\0';
+
+		if (CONFIG_CORTINA_FW_LENGTH < line_cnt)
+			return;
+
+		for (i = 0; i < column_cnt; i++) {
+			if (isspace(line_temp[i++]))
+				break;
+		}
+
+		memcpy(reg_addr, line_temp, i);
+		memcpy(reg_data, &line_temp[i], column_cnt - i);
+		strim(reg_addr);
+		strim(reg_data);
+		fw_temp.reg_addr = (simple_strtoul(reg_addr, NULL, 0)) & 0xffff;
+		fw_temp.reg_value = (simple_strtoul(reg_data, NULL, 0)) &
+				     0xffff;
+		phy_write(phydev, 0x00, fw_temp.reg_addr, fw_temp.reg_value);
+	}
+}
+
+int cs4340_phy_init(struct phy_device *phydev)
+{
+	int timeout = 100;  /* 100ms */
+	int reg_value;
+
+	/* step1: BIST test */
+	phy_write(phydev, 0x00, VILLA_GLOBAL_MSEQCLKCTRL,     0x0004);
+	phy_write(phydev, 0x00, VILLA_GLOBAL_LINE_SOFT_RESET, 0x0000);
+	phy_write(phydev, 0x00, VILLA_GLOBAL_BIST_CONTROL,    0x0001);
+	while (--timeout) {
+		reg_value = phy_read(phydev, 0x00, VILLA_GLOBAL_BIST_STATUS);
+		if (reg_value & mseq_edc_bist_done) {
+			if (0 == (reg_value & mseq_edc_bist_fail))
+				break;
+		}
+		udelay(1000);
+	}
+
+	if (!timeout) {
+		printf("%s BIST mseq_edc_bist_done timeout!\n", __func__);
+		return -1;
+	}
+
+	/* setp2: upload ucode */
+	cs4340_upload_firmware(phydev);
+	reg_value = phy_read(phydev, 0x00, VILLA_GLOBAL_DWNLD_CHECKSUM_STATUS);
+	if (reg_value) {
+		debug("%s checksum status failed.\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+int cs4340_config(struct phy_device *phydev)
+{
+	cs4340_phy_init(phydev);
+	return 0;
+}
+
+int cs4340_startup(struct phy_device *phydev)
+{
+	phydev->link = 1;
+
+	/* For now just lie and say it's 10G all the time */
+	phydev->speed = SPEED_10000;
+	phydev->duplex = DUPLEX_FULL;
+	return 0;
+}
+
+struct phy_driver cs4340_driver = {
+	.name = "Cortina CS4315/CS4340",
+	.uid = PHY_UID_CS4340,
+	.mask = 0xfffffff0,
+	.features = PHY_10G_FEATURES,
+	.mmds = (MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS |
+		 MDIO_DEVS_PHYXS | MDIO_DEVS_AN |
+		 MDIO_DEVS_VEND1 | MDIO_DEVS_VEND2),
+	.config = &cs4340_config,
+	.startup = &cs4340_startup,
+	.shutdown = &gen10g_shutdown,
+};
+
+int phy_cortina_init(void)
+{
+	phy_register(&cs4340_driver);
+	return 0;
+}
+
+int get_phy_id(struct mii_dev *bus, int addr, int devad, u32 *phy_id)
+{
+	int phy_reg;
+	bool is_cortina_phy = false;
+
+	switch (addr) {
+#ifdef CORTINA_PHY_ADDR1
+	case CORTINA_PHY_ADDR1:
+		/* fallthrough */
+#endif
+#ifdef CORTINA_PHY_ADDR2
+	case CORTINA_PHY_ADDR2:
+		/* fallthrough */
+#endif
+#ifdef CORTINA_PHY_ADDR3
+	case CORTINA_PHY_ADDR3:
+		/* fallthrough */
+#endif
+#ifdef CORTINA_PHY_ADDR4
+	case CORTINA_PHY_ADDR4:
+#endif
+		is_cortina_phy = true;
+		break;
+	default:
+		break;
+	}
+
+	/* Cortina PHY has non-standard offset of PHY ID registers */
+	if (is_cortina_phy)
+		phy_reg = bus->read(bus, addr, 0, VILLA_GLOBAL_CHIP_ID_LSB);
+	else
+		phy_reg = bus->read(bus, addr, devad, MII_PHYSID1);
+
+	if (phy_reg < 0)
+		return -EIO;
+
+	*phy_id = (phy_reg & 0xffff) << 16;
+	if (is_cortina_phy)
+		phy_reg = bus->read(bus, addr, 0, VILLA_GLOBAL_CHIP_ID_MSB);
+	else
+		phy_reg = bus->read(bus, addr, devad, MII_PHYSID2);
+
+	if (phy_reg < 0)
+		return -EIO;
+
+	*phy_id |= (phy_reg & 0xffff);
+
+	return 0;
+}
--- u-boot-2014.07/drivers/net/fm/t1024.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/net/fm/t1024.c	2022-05-09 14:06:23.725129469 -0700
@@ -0,0 +1,88 @@
+/* Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Shengzhou Liu <Shengzhou.Liu@freescale.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <phy.h>
+#include <fm_eth.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+
+u32 port_to_devdisr[] = {
+	[FM1_DTSEC1] = FSL_CORENET_DEVDISR2_DTSEC1_1,
+	[FM1_DTSEC2] = FSL_CORENET_DEVDISR2_DTSEC1_2,
+	[FM1_DTSEC3] = FSL_CORENET_DEVDISR2_DTSEC1_3,
+	[FM1_DTSEC4] = FSL_CORENET_DEVDISR2_DTSEC1_4,
+	[FM1_10GEC1] = FSL_CORENET_DEVDISR2_10GEC1_1, /* MAC1 */
+};
+
+static int is_device_disabled(enum fm_port port)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 devdisr2 = in_be32(&gur->devdisr2);
+
+	return port_to_devdisr[port] & devdisr2;
+}
+
+void fman_disable_port(enum fm_port port)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	setbits_be32(&gur->devdisr2, port_to_devdisr[port]);
+}
+
+phy_interface_t fman_port_enet_if(enum fm_port port)
+{
+	ccsr_gur_t *gur = (void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 rcwsr13 = in_be32(&gur->rcwsr[13]);
+
+	if (is_device_disabled(port))
+		return PHY_INTERFACE_MODE_NONE;
+
+	if ((port == FM1_10GEC1) && (is_serdes_configured(XFI_FM1_MAC1)))
+		return PHY_INTERFACE_MODE_XGMII;
+
+	if ((port == FM1_DTSEC3) && ((rcwsr13 & FSL_CORENET_RCWSR13_EC2) ==
+		FSL_CORENET_RCWSR13_EC2_RGMII) &&
+					(!is_serdes_configured(QSGMII_FM1_A)))
+		return PHY_INTERFACE_MODE_RGMII;
+
+	if ((port == FM1_DTSEC4) && ((rcwsr13 & FSL_CORENET_RCWSR13_EC1) ==
+		FSL_CORENET_RCWSR13_EC1_RGMII) &&
+					(!is_serdes_configured(QSGMII_FM1_A)))
+		return PHY_INTERFACE_MODE_RGMII;
+
+	/* handle SGMII */
+	switch (port) {
+	case FM1_DTSEC1:
+	case FM1_DTSEC2:
+	case FM1_DTSEC3:
+		if (is_serdes_configured(SGMII_FM1_DTSEC1 + port - FM1_DTSEC1))
+			return PHY_INTERFACE_MODE_SGMII;
+		else if (is_serdes_configured(SGMII_2500_FM1_DTSEC1
+			 + port - FM1_DTSEC1))
+			return PHY_INTERFACE_MODE_SGMII_2500;
+		break;
+	default:
+		break;
+	}
+
+	/* handle QSGMII */
+	switch (port) {
+	case FM1_DTSEC1:
+	case FM1_DTSEC2:
+	case FM1_DTSEC3:
+	case FM1_DTSEC4:
+		/* check lane A on SerDes1 */
+		if (is_serdes_configured(QSGMII_FM1_A))
+			return PHY_INTERFACE_MODE_QSGMII;
+		break;
+	default:
+		break;
+	}
+
+	return PHY_INTERFACE_MODE_NONE;
+}
--- u-boot-2014.07/drivers/pci/pcie_layerscape.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/pci/pcie_layerscape.c	2022-05-09 14:06:23.745128661 -0700
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Layerscape PCIe driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/fsl_serdes.h>
+#include <pci.h>
+#include <asm/io.h>
+#include <asm/pcie_layerscape.h>
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <libfdt.h>
+#include <fdt_support.h>
+
+static void ft_pcie_ls_setup(void *blob, const char *pci_compat,
+			     unsigned long ctrl_addr, enum srds_prtcl dev)
+{
+	int off;
+
+	off = fdt_node_offset_by_compat_reg(blob, pci_compat,
+					    (phys_addr_t)ctrl_addr);
+	if (off < 0)
+		return;
+
+	if (!is_serdes_configured(dev))
+		fdt_set_node_status(blob, off, FDT_STATUS_DISABLED, 0);
+}
+
+void ft_pcie_setup(void *blob, bd_t *bd)
+{
+	#ifdef CONFIG_PCIE1
+	ft_pcie_ls_setup(blob, FSL_PCIE_COMPAT, CONFIG_SYS_PCIE1_ADDR, PCIE1);
+	#endif
+
+	#ifdef CONFIG_PCIE2
+	ft_pcie_ls_setup(blob, FSL_PCIE_COMPAT, CONFIG_SYS_PCIE2_ADDR, PCIE2);
+	#endif
+}
+
+#else
+void ft_pcie_setup(void *blob, bd_t *bd)
+{
+}
+#endif
+
+void pci_init_board(void)
+{
+}
--- u-boot-2014.07/drivers/sec/jr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/jr.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,312 @@
+/*
+ * Copyright 2011, 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <fsl_sec.h>
+#include <jr.h>
+#ifdef CONFIG_FSL_CORENET
+#include <asm/fsl_pamu.h>
+#endif
+#include <fsl_secboot_err.h>
+
+#define CIRC_CNT(head, tail, size)	(((head) - (tail)) & (size - 1))
+#define CIRC_SPACE(head, tail, size)	CIRC_CNT((tail), (head) + 1, (size))
+
+static inline void start_jr0(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	u32 ctpr_ms = sec_in32(&sec->ctpr_ms);
+	u32 scfgr = sec_in32(&sec->scfgr);
+
+	if (ctpr_ms & SEC_CTPR_MS_VIRT_EN_INCL) {
+		/* VIRT_EN_INCL = 1 & VIRT_EN_POR = 1 or
+		 * VIRT_EN_INCL = 1 & VIRT_EN_POR = 0 & SEC_SCFGR_VIRT_EN = 1
+		 */
+		if ((ctpr_ms & SEC_CTPR_MS_VIRT_EN_POR) ||
+		    (!(ctpr_ms & SEC_CTPR_MS_VIRT_EN_POR) &&
+					(scfgr & SEC_SCFGR_VIRT_EN)))
+			sec_out32(&sec->jrstartr, CONFIG_JRSTARTR_JR0);
+	} else {
+		/* VIRT_EN_INCL = 0 && VIRT_EN_POR_VALUE = 1 */
+		if (ctpr_ms & SEC_CTPR_MS_VIRT_EN_POR)
+			sec_out32(&sec->jrstartr, CONFIG_JRSTARTR_JR0);
+	}
+}
+
+static inline void jr_reset_liodn(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	sec_out32(&sec->jrliodnr[0].ls, 0);
+}
+
+static inline void jr_disable_irq(void)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	uint32_t jrcfg = sec_in32(&regs->jrcfg1);
+
+	jrcfg = jrcfg | JR_INTMASK;
+
+	sec_out32(&regs->jrcfg1, jrcfg);
+}
+
+static void jr_initregs(struct jobring *jr)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	phys_addr_t ip_base = virt_to_phys((void *)jr->input_ring);
+	phys_addr_t op_base = virt_to_phys((void *)jr->output_ring);
+
+#ifdef CONFIG_PHYS_64BIT
+	sec_out32(&regs->irba_h, ip_base >> 32);
+#else
+	sec_out32(&regs->irba_h, 0x0);
+#endif
+	sec_out32(&regs->irba_l, (uint32_t)ip_base);
+#ifdef CONFIG_PHYS_64BIT
+	sec_out32(&regs->orba_h, op_base >> 32);
+#else
+	sec_out32(&regs->orba_h, 0x0);
+#endif
+	sec_out32(&regs->orba_l, (uint32_t)op_base);
+	sec_out32(&regs->ors, JR_SIZE);
+	sec_out32(&regs->irs, JR_SIZE);
+
+	if (!jr->irq)
+		jr_disable_irq();
+}
+
+int jr_init(struct jobring *jr)
+{
+	memset(jr, 0, sizeof(struct jobring));
+
+	jr->jq_id = DEFAULT_JR_ID;
+	jr->irq = DEFAULT_IRQ;
+
+#ifdef CONFIG_FSL_CORENET
+	jr->liodn = DEFAULT_JR_LIODN;
+#endif
+	jr->size = JR_SIZE;
+	jr->input_ring = (dma_addr_t *)malloc(JR_SIZE * sizeof(dma_addr_t));
+	if (!jr->input_ring)
+		return -1;
+	jr->output_ring =
+	    (struct op_ring *)malloc(JR_SIZE * sizeof(struct op_ring));
+	if (!jr->output_ring)
+		return -1;
+
+	memset(jr->input_ring, 0, JR_SIZE * sizeof(dma_addr_t));
+	memset(jr->output_ring, 0, JR_SIZE * sizeof(struct op_ring));
+
+	start_jr0();
+
+	jr_initregs(jr);
+
+	return 0;
+}
+
+int jr_sw_cleanup(struct jobring *jr)
+{
+	jr->head = 0;
+	jr->tail = 0;
+	jr->read_idx = 0;
+	jr->write_idx = 0;
+	memset(jr->info, 0, sizeof(jr->info));
+	memset(jr->input_ring, 0, jr->size * sizeof(dma_addr_t));
+	memset(jr->output_ring, 0, jr->size * sizeof(struct op_ring));
+
+	return 0;
+}
+
+int sec_init(struct jobring *jr)
+{
+	int ret = 0;
+
+#ifdef CONFIG_FSL_CORENET
+	uint32_t liodnr;
+	uint32_t liodn_ns;
+	uint32_t liodn_s;
+#endif
+
+#ifdef CONFIG_PHYS_64BIT
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	uint32_t mcr = sec_in32(&sec->mcfgr);
+
+	sec_out32(&sec->mcfgr, mcr | 1 << MCFGR_PS_SHIFT);
+#endif
+
+#ifdef CONFIG_FSL_CORENET
+	liodnr = sec_in32(&sec->jrliodnr[0].ls);
+	liodn_ns = (liodnr & JRNSLIODN_MASK) >> JRNSLIODN_SHIFT;
+	liodn_s = (liodnr & JRSLIODN_MASK) >> JRSLIODN_SHIFT;
+#endif
+	ret = jr_init(jr);
+	if (ret < 0)
+		return -1;
+
+#ifdef CONFIG_FSL_CORENET
+	ret = sec_config_pamu_table(liodn_ns, liodn_s);
+	if (ret < 0)
+		return -1;
+
+#ifdef CONFIG_FSL_CORENET
+	pamu_enable();
+#endif
+
+#endif
+
+	return ret;
+}
+
+int jr_hw_reset(void)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	uint32_t timeout = 100000;
+	uint32_t jrint, jrcr;
+
+	sec_out32(&regs->jrcr, JRCR_RESET);
+	do {
+		jrint = sec_in32(&regs->jrint);
+	} while (((jrint & JRINT_ERR_HALT_MASK) ==
+		  JRINT_ERR_HALT_INPROGRESS) && --timeout);
+
+	jrint = sec_in32(&regs->jrint);
+	if (((jrint & JRINT_ERR_HALT_MASK) !=
+	     JRINT_ERR_HALT_INPROGRESS) && timeout == 0)
+		return -1;
+
+	timeout = 100000;
+	sec_out32(&regs->jrcr, JRCR_RESET);
+	do {
+		jrcr = sec_in32(&regs->jrcr);
+	} while ((jrcr & JRCR_RESET) && --timeout);
+
+	if (timeout == 0)
+		return -1;
+
+	return 0;
+}
+
+int jr_reset(struct jobring *jr)
+{
+	if (jr_hw_reset() < 0)
+		return -1;
+
+	/* Clean up the jobring structure maintained by software */
+	jr_sw_cleanup(jr);
+
+	return 0;
+}
+
+int sec_reset(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	uint32_t mcfgr = sec_in32(&sec->mcfgr);
+	uint32_t timeout = 100000;
+
+	mcfgr |= MCFGR_SWRST;
+	sec_out32(&sec->mcfgr, mcfgr);
+
+	mcfgr |= MCFGR_DMA_RST;
+	sec_out32(&sec->mcfgr, mcfgr);
+	do {
+		mcfgr = sec_in32(&sec->mcfgr);
+	} while ((mcfgr & MCFGR_DMA_RST) == MCFGR_DMA_RST && --timeout);
+
+	if (timeout == 0)
+		return -1;
+
+	timeout = 100000;
+	do {
+		mcfgr = sec_in32(&sec->mcfgr);
+	} while ((mcfgr & MCFGR_SWRST) == MCFGR_SWRST && --timeout);
+
+	if (timeout == 0)
+		return -1;
+
+	return 0;
+}
+
+/* -1 --- error, can't enqueue -- no space available */
+int jr_enqueue(struct jobring *jr, uint32_t *desc_addr,
+	       void (*callback)(uint32_t desc, uint32_t status, void *arg),
+	       void *arg)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	int head = jr->head;
+	dma_addr_t desc_phys_addr = virt_to_phys(desc_addr);
+
+	if (sec_in32(&regs->irsa) == 0 ||
+	    CIRC_SPACE(jr->head, jr->tail, jr->size) <= 0)
+		return ERROR_ESBC_SEC_ENQ;
+
+	jr->input_ring[head] = desc_phys_addr;
+	jr->info[head].desc_phys_addr = desc_phys_addr;
+	jr->info[head].desc_addr = (uint32_t)desc_addr;
+	jr->info[head].callback = (void *)callback;
+	jr->info[head].arg = arg;
+	jr->info[head].op_done = 0;
+
+	jr->head = (head + 1) & (jr->size - 1);
+
+	sec_out32(&regs->irja, 1);
+
+	return 0;
+}
+
+int jr_dequeue(struct jobring *jr)
+{
+	struct jr_regs *regs = (struct jr_regs *)CONFIG_SYS_FSL_JR0_ADDR;
+	int head = jr->head;
+	int tail = jr->tail;
+	int idx, i, found;
+	void (*callback)(uint32_t desc, uint32_t status, void *arg);
+	void *arg = NULL;
+
+	while (sec_in32(&regs->orsf) &&
+	       CIRC_CNT(jr->head, jr->tail, jr->size)) {
+		found = 0;
+
+		dma_addr_t op_desc = jr->output_ring[jr->tail].desc;
+		uint32_t status = jr->output_ring[jr->tail].status;
+		uint32_t desc_virt;
+
+		for (i = 0; CIRC_CNT(head, tail + i, jr->size) >= 1; i++) {
+			idx = (tail + i) & (jr->size - 1);
+			if (op_desc == jr->info[idx].desc_phys_addr) {
+				desc_virt = jr->info[idx].desc_addr;
+				found = 1;
+				break;
+			}
+		}
+
+		/* Error condition if match not found */
+		if (!found)
+			return ERROR_ESBC_SEC_DEQ;
+
+		jr->info[idx].op_done = 1;
+		callback = (void *)jr->info[idx].callback;
+		arg = jr->info[idx].arg;
+
+		/* When the job on tail idx gets done, increment
+		 * tail till the point where job completed out of oredr has
+		 * been taken into account
+		 */
+		if (idx == tail)
+			do {
+				tail = (tail + 1) & (jr->size - 1);
+			} while (jr->info[tail].op_done);
+
+		jr->tail = tail;
+		jr->read_idx = (jr->read_idx + 1) & (jr->size - 1);
+
+		sec_out32(&regs->orjr, 1);
+		jr->info[idx].op_done = 0;
+
+		callback(desc_virt, status, arg);
+	}
+
+	return 0;
+}
--- u-boot-2014.07/drivers/sec/rng.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/rng.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,186 @@
+/*
+ * RNG initialization
+ *
+ * Derived from linux caam driver ctrl.c
+ *
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <jr.h>
+#include <desc_constr.h>
+#include <desc.h>
+#include <fsl_sec.h>
+
+u8 get_rng_vid(void)
+{
+	ccsr_sec_t *sec = (void *)CONFIG_SYS_FSL_SEC_ADDR;
+	u32 cha_vid = sec_in32(&sec->chavid_ls);
+
+	return (cha_vid & SEC_CHAVID_RNG_LS_MASK) >> SEC_CHAVID_LS_RNG_SHIFT;
+}
+
+/*
+ * Descriptor to instantiate RNG State Handle 0 in normal mode and
+ * load the JDKEK, TDKEK and TDSK registers
+ */
+static void build_instantiation_desc(u32 *desc)
+{
+	u32 *jump_cmd;
+
+	init_job_desc(desc, 0);
+
+	/* INIT RNG in non-test mode */
+	append_operation(desc, OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |
+			 OP_ALG_AS_INIT);
+
+	/* wait for done */
+	jump_cmd = append_jump(desc, JUMP_CLASS_CLASS1);
+	set_jump_tgt_here(desc, jump_cmd);
+
+	/*
+	 * load 1 to clear written reg:
+	 * resets the done interrrupt and returns the RNG to idle.
+	 */
+	append_load_imm_u32(desc, 1, LDST_SRCDST_WORD_CLRW);
+
+	/* generate secure keys (non-test) */
+	append_operation(desc, OP_TYPE_CLASS1_ALG | OP_ALG_ALGSEL_RNG |
+			 OP_ALG_RNG4_SK);
+}
+
+void rng4_init_done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *instantiation = arg;
+	instantiation->status = status;
+	instantiation->err = caam_jr_strstatus(instantiation->outstr, status);
+	instantiation->done = 1;
+}
+
+static int instantiate_rng(struct jobring *jr)
+{
+	struct result op;
+	u32 *desc;
+	u32 rdsta_val;
+	int ret = 0;
+	unsigned long long timeval;
+	unsigned long long timeout;
+	ccsr_sec_t __iomem *sec =
+			(ccsr_sec_t __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
+	struct rng4tst __iomem *rng =
+			(struct rng4tst __iomem *)&sec->rng;
+
+	memset(&op, 0, sizeof(struct result));
+
+	desc = malloc(CAAM_CMD_SZ * 6);
+	if (!desc) {
+		printf("cannot allocate RNG init descriptor memory\n");
+		return -1;
+	}
+
+	build_instantiation_desc(desc);
+	ret = jr_enqueue(jr, desc, rng4_init_done, &op);
+	if (ret)
+		return -1;
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (op.done != 1) {
+		if (jr_dequeue(jr)) {
+			printf("RNG Instantiation :deq error\n");
+			return -1;
+		}
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("RNG Instantiation : SEC Dequeue timed out\n");
+			return -1;
+		}
+	}
+
+	if (op.status)
+		printf("RNG: Instantiation failed with error %x\n", op.status);
+
+	rdsta_val = sec_in32(&rng->rdsta);
+	if (op.status || !(rdsta_val & RNG_STATE0_HANDLE_INSTANTIATED))
+		return -1;
+
+	return ret;
+}
+
+/*
+ * By default, the TRNG runs for 200 clocks per sample;
+ * 1200 clocks per sample generates better entropy.
+ */
+static void kick_trng(int ent_delay)
+{
+	ccsr_sec_t __iomem *sec =
+			(ccsr_sec_t __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
+	struct rng4tst __iomem *rng =
+			(struct rng4tst __iomem *)&sec->rng;
+	u32 val;
+
+	/* put RNG4 into program mode */
+	setbits_be32(&rng->rtmctl, RTMCTL_PRGM);
+	/* rtsdctl bits 0-15 contain "Entropy Delay, which defines the
+	 * length (in system clocks) of each Entropy sample taken
+	 * */
+	val = sec_in32(&rng->rtsdctl);
+	val = (val & ~RTSDCTL_ENT_DLY_MASK) |
+	      (ent_delay << RTSDCTL_ENT_DLY_SHIFT);
+	sec_out32(&rng->rtsdctl, val);
+	/* min. freq. count, equal to 1/4 of the entropy sample length */
+	sec_out32(&rng->rtfreqmin, ent_delay >> 2);
+	/* max. freq. count, equal to 8 times the entropy sample length */
+	sec_out32(&rng->rtfreqmax, ent_delay << 3);
+	/* put RNG4 into run mode */
+	clrbits_be32(&rng->rtmctl, RTMCTL_PRGM);
+}
+
+int rng_init(struct jobring *jr)
+{
+	int ret, ent_delay = RTSDCTL_ENT_DLY_MIN;
+	ccsr_sec_t __iomem *sec =
+			(ccsr_sec_t __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
+	struct rng4tst __iomem *rng =
+			(struct rng4tst __iomem *)&sec->rng;
+
+	u32 rdsta = sec_in32(&rng->rdsta);
+
+	/* Check if RNG state 0 handler is already instantiated */
+	if (rdsta & RNG_STATE0_HANDLE_INSTANTIATED)
+		return 0;
+
+	do {
+		/*
+		 * If either of the SH's were instantiated by somebody else
+		 * then it is assumed that the entropy
+		 * parameters are properly set and thus the function
+		 * setting these (kick_trng(...)) is skipped.
+		 * Also, if a handle was instantiated, do not change
+		 * the TRNG parameters.
+		 */
+		kick_trng(ent_delay);
+		ent_delay += 400;
+		/*
+		 * if instantiate_rng(...) fails, the loop will rerun
+		 * and the kick_trng(...) function will modfiy the
+		 * upper and lower limits of the entropy sampling
+		 * interval, leading to a sucessful initialization of
+		 * the RNG.
+		 */
+		ret = instantiate_rng(jr);
+	} while ((ret == -1) && (ent_delay < RTSDCTL_ENT_DLY_MAX));
+	if (ret) {
+		printf("RNG: Failed to instantiate RNG\n");
+		return ret;
+	}
+
+	 /* Enable RDB bit so that RNG works faster */
+	setbits_be32(&sec->scfgr, SEC_SCFGR_RDBENABLE);
+
+	return ret;
+}
--- u-boot-2014.07/drivers/sec/sec.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/sec.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#if CONFIG_SYS_FSL_SEC_COMPAT == 2 || CONFIG_SYS_FSL_SEC_COMPAT >= 4
+#include <fsl_sec.h>
+#endif
+
+/*
+ * update crypto node properties to a specified revision of the SEC
+ * called with sec_rev == 0 if not on an E processor
+ */
+#if CONFIG_SYS_FSL_SEC_COMPAT == 2 /* SEC 2.x/3.x */
+void fdt_fixup_crypto_node(void *blob, int sec_rev)
+{
+	static const struct sec_rev_prop {
+		u32 sec_rev;
+		u32 num_channels;
+		u32 channel_fifo_len;
+		u32 exec_units_mask;
+		u32 descriptor_types_mask;
+	} sec_rev_prop_list[] = {
+		{ 0x0200, 4, 24, 0x07e, 0x01010ebf }, /* SEC 2.0 */
+		{ 0x0201, 4, 24, 0x0fe, 0x012b0ebf }, /* SEC 2.1 */
+		{ 0x0202, 1, 24, 0x04c, 0x0122003f }, /* SEC 2.2 */
+		{ 0x0204, 4, 24, 0x07e, 0x012b0ebf }, /* SEC 2.4 */
+		{ 0x0300, 4, 24, 0x9fe, 0x03ab0ebf }, /* SEC 3.0 */
+		{ 0x0301, 4, 24, 0xbfe, 0x03ab0ebf }, /* SEC 3.1 */
+		{ 0x0303, 4, 24, 0x97c, 0x03a30abf }, /* SEC 3.3 */
+	};
+	static char compat_strlist[ARRAY_SIZE(sec_rev_prop_list) *
+				   sizeof("fsl,secX.Y")];
+	int crypto_node, sec_idx, err;
+	char *p;
+	u32 val;
+
+	/* locate crypto node based on lowest common compatible */
+	crypto_node = fdt_node_offset_by_compatible(blob, -1, "fsl,sec2.0");
+	if (crypto_node == -FDT_ERR_NOTFOUND)
+		return;
+
+	/* delete it if not on an E-processor */
+	if (crypto_node > 0 && !sec_rev) {
+		fdt_del_node(blob, crypto_node);
+		return;
+	}
+
+	/* else we got called for possible uprev */
+	for (sec_idx = 0; sec_idx < ARRAY_SIZE(sec_rev_prop_list); sec_idx++)
+		if (sec_rev_prop_list[sec_idx].sec_rev == sec_rev)
+			break;
+
+	if (sec_idx == ARRAY_SIZE(sec_rev_prop_list)) {
+		puts("warning: unknown SEC revision number\n");
+		return;
+	}
+
+	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].num_channels);
+	err = fdt_setprop(blob, crypto_node, "fsl,num-channels", &val, 4);
+	if (err < 0)
+		printf("WARNING: could not set crypto property: %s\n",
+		       fdt_strerror(err));
+
+	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].descriptor_types_mask);
+	err = fdt_setprop(blob, crypto_node, "fsl,descriptor-types-mask",
+			  &val, 4);
+	if (err < 0)
+		printf("WARNING: could not set crypto property: %s\n",
+		       fdt_strerror(err));
+
+	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].exec_units_mask);
+	err = fdt_setprop(blob, crypto_node, "fsl,exec-units-mask", &val, 4);
+	if (err < 0)
+		printf("WARNING: could not set crypto property: %s\n",
+		       fdt_strerror(err));
+
+	val = cpu_to_fdt32(sec_rev_prop_list[sec_idx].channel_fifo_len);
+	err = fdt_setprop(blob, crypto_node, "fsl,channel-fifo-len", &val, 4);
+	if (err < 0)
+		printf("WARNING: could not set crypto property: %s\n",
+		       fdt_strerror(err));
+
+	val = 0;
+	while (sec_idx >= 0) {
+		p = compat_strlist + val;
+		val += sprintf(p, "fsl,sec%d.%d",
+			(sec_rev_prop_list[sec_idx].sec_rev & 0xff00) >> 8,
+			sec_rev_prop_list[sec_idx].sec_rev & 0x00ff) + 1;
+		sec_idx--;
+	}
+	err = fdt_setprop(blob, crypto_node, "compatible", &compat_strlist,
+			  val);
+	if (err < 0)
+		printf("WARNING: could not set crypto property: %s\n",
+		       fdt_strerror(err));
+}
+#elif CONFIG_SYS_FSL_SEC_COMPAT >= 4  /* SEC4 */
+static u8 caam_get_era(void)
+{
+	static const struct {
+		u16 ip_id;
+		u8 maj_rev;
+		u8 era;
+	} caam_eras[] = {
+		{0x0A10, 1, 1},
+		{0x0A10, 2, 2},
+		{0x0A12, 1, 3},
+		{0x0A14, 1, 3},
+		{0x0A14, 2, 4},
+		{0x0A16, 1, 4},
+		{0x0A10, 3, 4},
+		{0x0A11, 1, 4},
+		{0x0A18, 1, 4},
+		{0x0A11, 2, 5},
+		{0x0A12, 2, 5},
+		{0x0A13, 1, 5},
+		{0x0A1C, 1, 5}
+	};
+
+	ccsr_sec_t __iomem *sec = (void __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
+	u32 secvid_ms = sec_in32(&sec->secvid_ms);
+	u32 ccbvid = sec_in32(&sec->ccbvid);
+	u16 ip_id = (secvid_ms & SEC_SECVID_MS_IPID_MASK) >>
+				SEC_SECVID_MS_IPID_SHIFT;
+	u8 maj_rev = (secvid_ms & SEC_SECVID_MS_MAJ_REV_MASK) >>
+				SEC_SECVID_MS_MAJ_REV_SHIFT;
+	u8 era = (ccbvid & SEC_CCBVID_ERA_MASK) >> SEC_CCBVID_ERA_SHIFT;
+
+	int i;
+
+	if (era)	/* This is '0' prior to CAAM ERA-6 */
+		return era;
+
+	for (i = 0; i < ARRAY_SIZE(caam_eras); i++)
+		if (caam_eras[i].ip_id == ip_id &&
+		    caam_eras[i].maj_rev == maj_rev)
+			return caam_eras[i].era;
+
+	return 0;
+}
+
+static void fdt_fixup_crypto_era(void *blob, u32 era)
+{
+	int err;
+	int crypto_node;
+
+	crypto_node = fdt_path_offset(blob, "crypto");
+	if (crypto_node < 0) {
+		printf("WARNING: Missing crypto node\n");
+		return;
+	}
+
+	err = fdt_setprop(blob, crypto_node, "fsl,sec-era", &era,
+			  sizeof(era));
+	if (err < 0) {
+		printf("ERROR: could not set fsl,sec-era property: %s\n",
+		       fdt_strerror(err));
+	}
+}
+
+void fdt_fixup_crypto_node(void *blob, int sec_rev)
+{
+	u8 era;
+
+	if (!sec_rev) {
+		fdt_del_node_and_alias(blob, "crypto");
+		return;
+	}
+
+	/* Add SEC ERA information in compatible */
+	era = caam_get_era();
+	if (era) {
+		fdt_fixup_crypto_era(blob, era);
+	} else {
+		printf("WARNING: Unable to get ERA for CAAM rev: %d\n",
+		       sec_rev);
+	}
+}
+#endif
--- u-boot-2014.07/drivers/sec/rsa_sec.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/rsa_sec.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <rsa_sec.h>
+#include <jobdesc.h>
+#include <fsl_secboot_err.h>
+
+void rsa_done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *x = arg;
+	x->status = status;
+#ifdef DEBUG
+	x->err = caam_jr_strstatus(x->outstr, status);
+#else
+	if (status)
+		x->err = -1;
+#endif
+
+	x->done = 1;
+}
+
+/* This functionw ould return teh status returned by SEC .
+ * If non zero , means there was some error reported by SEC */
+int rsa_public_verif_sec(unsigned char *sign, uint8_t *to, uint8_t *rsa_pub_key,
+			int klen, struct rsa_context *ctx, struct jobring *jr)
+{
+	unsigned long long timeval;
+	unsigned long long timeout;
+	int ret = 0;
+	memset(ctx, 0, sizeof(struct rsa_context));
+
+	ctx->pkin.a = sign;
+	ctx->pkin.a_siz = klen;
+	ctx->pkin.n = rsa_pub_key;
+	ctx->pkin.n_siz = klen;
+	ctx->pkin.e = rsa_pub_key + klen;
+	ctx->pkin.e_siz = klen;
+
+	inline_cnstr_jobdesc_pkha_rsaexp(ctx->rsa_desc,
+					 &ctx->pkin, to, klen);
+
+	ret = jr_enqueue(jr, ctx->rsa_desc, rsa_done, &ctx->op);
+	if (ret)
+		return ret;
+
+	timeval = get_ticks();
+	timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+
+	while (ctx->op.done != 1) {
+		if (jr_dequeue(jr))
+			return ERROR_ESBC_SEC_DEQ;
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			return ERROR_ESBC_SEC_DEQ_TO;
+		}
+	}
+
+	if (ctx->op.err < 0)
+		return ctx->op.status;
+
+	return 0;
+}
--- u-boot-2014.07/drivers/sec/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/Makefile	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2007, 2012
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(CONFIG_SECURE_BOOT) += jr.o sha.o rsa_sec.o jobdesc.o error.o rng.o fsl_sfp_snvs.o
+obj-y += sec.o
--- u-boot-2014.07/drivers/sec/sha.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/sha.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <jobdesc.h>
+#include <sha.h>
+#include <fsl_secboot_err.h>
+
+void sha_done(uint32_t desc, uint32_t status, void *arg)
+{
+	struct result *x = arg;
+	x->status = status;
+	x->err = caam_jr_strstatus(x->outstr, status);
+	x->done = 1;
+}
+
+/* This function initializes the sha-256 context */
+void sha_init(struct sha_ctx *ctx, struct jobring *jr)
+{
+	memset(ctx, 0, sizeof(struct sha_ctx));
+	ctx->jr = jr;
+}
+
+void sha_update(struct sha_ctx *ctx, u8 *buffer, u32 length)
+{
+	dma_addr_t addr = virt_to_phys((void *)buffer);
+#ifdef CONFIG_PHYS_64BIT
+	ctx->sg_tbl[ctx->sg_num].addr_hi = addr >> 32;
+#else
+	ctx->sg_tbl[ctx->sg_num].addr_hi = 0x0;
+#endif
+	ctx->sg_tbl[ctx->sg_num].addr_lo = addr;
+	ctx->sg_tbl[ctx->sg_num].length = length;
+	ctx->sg_num++;
+}
+
+int sha_final(struct sha_ctx *ctx)
+{
+	int ret = 0, i = 0;
+	ctx->sg_tbl[ctx->sg_num - 1].final = 1;
+	uint32_t len = 0;
+
+	for (i = 0; i < ctx->sg_num; i++)
+		len +=  ctx->sg_tbl[i].length;
+
+	inline_cnstr_jobdesc_sha256(ctx->sha_desc, (uint8_t *)ctx->sg_tbl,
+				    len, ctx->hash);
+
+	ret = jr_enqueue(ctx->jr, ctx->sha_desc, sha_done, &ctx->op);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+
+/* This  function  completes the calulation of the sha-256 */
+int sha_digest(struct sha_ctx *ctx, uint8_t *digest)
+{
+	unsigned long long timeval = get_ticks();
+	unsigned long long timeout = usec2ticks(CONFIG_SEC_DEQ_TIMEOUT);
+	int ret = 0;
+
+	while (ctx->op.done != 1) {
+		ret = jr_dequeue(ctx->jr);
+		if (ret)
+			return ret;
+
+		if ((get_ticks() - timeval) > timeout) {
+			printf("SEC Dequeue timed out\n");
+			return ERROR_ESBC_SEC_DEQ_TO;
+		}
+	}
+
+	if (ctx->op.err < 0)
+		return ctx->op.status;
+
+	memcpy(digest, ctx->hash, sizeof(ctx->hash));
+
+	return 0;
+}
--- u-boot-2014.07/drivers/sec/error.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/error.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,219 @@
+/*
+ * CAAM Error Reporting
+ *
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <jr.h>
+#include <malloc.h>
+
+#define JRSTA_SSRC_SHIFT            28
+#define JRSTA_CCBERR_CHAID_MASK     0x00f0
+#define JRSTA_CCBERR_CHAID_SHIFT    4
+#define JRSTA_CCBERR_ERRID_MASK     0x000
+
+#define JRSTA_DECOERR_JUMP          0x08000000
+#define JRSTA_DECOERR_INDEX_SHIFT   8
+#define JRSTA_DECOERR_INDEX_MASK    0xff00
+#define JRSTA_DECOERR_ERROR_MASK    0x00ff
+
+#define SPRINTFCAT(str, format, param, max_alloc)		\
+{								\
+	char *tmp;						\
+								\
+	tmp = malloc(sizeof(format) + max_alloc);		\
+	sprintf(tmp, format, param);				\
+	strcat(str, tmp);					\
+	free(tmp);						\
+}
+
+static void report_jump_idx(u32 status, char *outstr)
+{
+	u8 idx = (status & JRSTA_DECOERR_INDEX_MASK) >>
+		  JRSTA_DECOERR_INDEX_SHIFT;
+
+	if (status & JRSTA_DECOERR_JUMP)
+		strcat(outstr, "jump tgt desc idx ");
+	else
+		strcat(outstr, "desc idx ");
+
+	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
+}
+
+static void report_ccb_status(u32 status, char *outstr)
+{
+	char *cha_id_list[] = {
+		"",
+		"AES",
+		"DES, 3DES",
+		"ARC4",
+		"MD5, SHA-1, SH-224, SHA-256, SHA-384, SHA-512",
+		"RNG",
+		"SNOW f8",
+		"Kasumi f8, f9",
+		"All Public Key Algorithms",
+		"CRC",
+		"SNOW f9",
+	};
+	char *err_id_list[] = {
+		"None. No error.",
+		"Mode error.",
+		"Data size error.",
+		"Key size error.",
+		"PKHA A memory size error.",
+		"PKHA B memory size error.",
+		"Data arrived out of sequence error.",
+		"PKHA divide-by-zero error.",
+		"PKHA modulus even error.",
+		"DES key parity error.",
+		"ICV check failed.",
+		"Hardware error.",
+		"Unsupported CCM AAD size.",
+		"Class 1 CHA is not reset",
+		"Invalid CHA combination was selected",
+		"Invalid CHA selected.",
+	};
+	u8 cha_id = (status & JRSTA_CCBERR_CHAID_MASK) >>
+		    JRSTA_CCBERR_CHAID_SHIFT;
+	u8 err_id = status & JRSTA_CCBERR_ERRID_MASK;
+
+	report_jump_idx(status, outstr);
+
+	if (cha_id < ARRAY_SIZE(cha_id_list)) {
+		SPRINTFCAT(outstr, "%s: ", cha_id_list[cha_id],
+			   strlen(cha_id_list[cha_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified cha_id value 0x%02x: ",
+			   cha_id, sizeof("ff"));
+	}
+
+	if (err_id < ARRAY_SIZE(err_id_list)) {
+		SPRINTFCAT(outstr, "%s", err_id_list[err_id],
+			   strlen(err_id_list[err_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified err_id value 0x%02x",
+			   err_id, sizeof("ff"));
+	}
+}
+
+static void report_jump_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+static void report_deco_status(u32 status, char *outstr)
+{
+	const struct {
+		u8 value;
+		char *error_text;
+	} desc_error_list[] = {
+		{ 0x00, "None. No error." },
+		{ 0x01, "SGT Length Error."},
+		{ 0x02, "Reserved." },
+		{ 0x03, "Job Ring Control Err. Bad value in JR Control reg." },
+		{ 0x04, "Invalid Descriptor Cmd. The Desc Cmd fld invalid." },
+		{ 0x05, "Reserved." },
+		{ 0x06, "Invalid KEY Command" },
+		{ 0x07, "Invalid LOAD Command" },
+		{ 0x08, "Invalid STORE Command" },
+		{ 0x09, "Invalid OPERATION Command" },
+		{ 0x0A, "Invalid FIFO LOAD Command" },
+		{ 0x0B, "Invalid FIFO STORE Command" },
+		{ 0x0C, "Invalid MOVE Command" },
+		{ 0x0D, "Invalid JUMP Command."},
+		{ 0x0E, "Invalid MATH Command" },
+		{ 0x0F, "Invalid SIGNATURE Command" },
+		{ 0x10, "Invalid Sequence Command."},
+		{ 0x11, "Skip data type invalid. The type must be 0xE or 0xF."},
+		{ 0x12, "Shared Descriptor Header Error" },
+		{ 0x13, "Header Error." },
+		{ 0x14, "Burster Error." },
+		{ 0x15, "Context Register Length Error."},
+		{ 0x16, "DMA Error" },
+		{ 0x17, "Reserved." },
+		{ 0x1A, "Job failed due to JR reset" },
+		{ 0x1B, "Job failed due to Fail Mode" },
+		{ 0x1C, "DECO Watchdog timer timeout error" },
+		{ 0x1D, "DECO Error" },
+		{ 0x1E, "DECO tried to copy from DECO having Desc error" },
+		{ 0x1F, "LIODN error" },
+		{ 0x20, "DECO completed a reset initiated via DRR register" },
+		{ 0x21, "Nonce error." },
+		{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap " },
+		{ 0x80, "DNR (do not run) error" },
+		{ 0x81, "undefined protocol command" },
+		{ 0x82, "invalid setting in PDB" },
+		{ 0x83, "Anti-replay LATE error" },
+		{ 0x84, "Anti-replay REPLAY error" },
+		{ 0x85, "Sequence number overflow" },
+		{ 0x86, "Sigver invalid signature" },
+		{ 0x87, "DSA Sign Illegal test descriptor" },
+		{ 0x88, "Protocol Format Error" },
+		{ 0x89, "Protocol Size Error" },
+		{ 0xC1, "Blob Command error: Undefined mode" },
+		{ 0xC2, "Blob Command error: Secure Memory Blob mode error" },
+		{ 0xC4, "Blob Command error: Black Blob key or input sz err" },
+		{ 0xC5, "Blob Command error: Invalid key destination" },
+		{ 0xC8, "Blob Command error: Trusted/Secure mode error" },
+		{ 0xF0, "IPsec TTL or hop limit field error" },
+		{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
+	};
+	u8 desc_error = status & JRSTA_DECOERR_ERROR_MASK;
+	int i;
+
+	report_jump_idx(status, outstr);
+
+	for (i = 0; i < ARRAY_SIZE(desc_error_list); i++)
+		if (desc_error_list[i].value == desc_error)
+			break;
+
+	if (i != ARRAY_SIZE(desc_error_list) && desc_error_list[i].error_text) {
+		SPRINTFCAT(outstr, "%s", desc_error_list[i].error_text,
+			   strlen(desc_error_list[i].error_text));
+	} else {
+		SPRINTFCAT(outstr, "unidentified error value 0x%02x",
+			   desc_error, sizeof("ff"));
+	}
+}
+
+static void report_jr_status(u32 status, char *outstr)
+{
+}
+
+static void report_cond_code_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+int caam_jr_strstatus(char *outstr, u32 status)
+{
+	int ret = 0;
+	struct stat_src {
+		void (*report_ssed)(u32 status, char *outstr);
+		char *error;
+	} status_src[] = {
+		{ NULL, "No error" },
+		{ NULL, NULL },
+		{ report_ccb_status, "CCB" },
+		{ report_jump_status, "Jump" },
+		{ report_deco_status, "DECO" },
+		{ NULL, NULL },
+		{ report_jr_status, "Job Ring" },
+		{ report_cond_code_status, "Condition Code" },
+	};
+	u32 ssrc = status >> JRSTA_SSRC_SHIFT;
+
+	sprintf(outstr, "%s: ", status_src[ssrc].error);
+
+	if (status_src[ssrc].report_ssed) {
+		status_src[ssrc].report_ssed(status, outstr);
+		ret = -1;
+	} else {
+		ret = 0;
+	}
+
+	return ret;
+}
--- u-boot-2014.07/drivers/sec/fsl_sfp_snvs.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/fsl_sfp_snvs.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_sec.h>
+
+int change_sec_mon_state(u32 initial_state, u32 final_state)
+{
+	struct ccsr_snvs_regs *snvs_regs = (void *)(CONFIG_SYS_SNVS_ADDR);
+	u32 sts = snvs_in32(&snvs_regs->hp_stat);
+	int timeout = 10;
+
+	if ((sts & HPSR_SSM_ST_MASK) != initial_state)
+		return -1;
+
+	if (initial_state == HPSR_SSM_ST_TRUST) {
+		switch (final_state) {
+		case HPSR_SSM_ST_NON_SECURE:
+			printf("SNVS state transitioning to Soft Fail.\n");
+			snvs_setbits32(&snvs_regs->hp_com, HPCOMR_SW_SV);
+
+			/*
+			 * poll till SNVS is in
+			 * Soft Fail state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_SOFT_FAIL)) {
+				while (timeout) {
+					sts = snvs_in32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_SOFT_FAIL)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				return -1;
+			}
+
+			timeout = 10;
+
+			printf("SNVS state transitioning to Non Secure.\n");
+			snvs_setbits32(&snvs_regs->hp_com, HPCOMR_SSM_ST);
+
+			/*
+			 * poll till SNVS is in
+			 * Non Secure state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_NON_SECURE)) {
+				while (timeout) {
+					sts = snvs_in32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_NON_SECURE)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				return -1;
+			}
+			break;
+		case HPSR_SSM_ST_SOFT_FAIL:
+			printf("SNVS state transitioning to Soft Fail.\n");
+			snvs_setbits32(&snvs_regs->hp_com, HPCOMR_SW_FSV);
+
+			/*
+			 * polling loop till SNVS is in
+			 * Soft Fail state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_SOFT_FAIL)) {
+				while (timeout) {
+					sts = snvs_in32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_SOFT_FAIL)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				return -1;
+			}
+			break;
+		default:
+			return -1;
+		}
+	} else if (initial_state == HPSR_SSM_ST_NON_SECURE) {
+		switch (final_state) {
+		case HPSR_SSM_ST_SOFT_FAIL:
+			printf("SNVS state transitioning to Soft Fail.\n");
+			snvs_setbits32(&snvs_regs->hp_com, HPCOMR_SW_FSV);
+
+			/*
+			 * polling loop till SNVS is in
+			 * Soft Fail state
+			 */
+			while (((sts & HPSR_SSM_ST_MASK) !=
+				HPSR_SSM_ST_SOFT_FAIL)) {
+				while (timeout) {
+					sts = snvs_in32(&snvs_regs->hp_stat);
+
+					if ((sts & HPSR_SSM_ST_MASK) ==
+						HPSR_SSM_ST_SOFT_FAIL)
+						break;
+
+					udelay(10);
+					timeout--;
+				}
+			}
+
+			if (timeout == 0) {
+				printf("SNVS state transition timeout.\n");
+				return -1;
+			}
+			break;
+		default:
+			return -1;
+		}
+	}
+
+	return 0;
+}
--- u-boot-2014.07/drivers/sec/jobdesc.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/sec/jobdesc.c	2022-05-09 14:06:23.757128175 -0700
@@ -0,0 +1,137 @@
+/*
+ * SEC Descriptor Construction Library
+ * Basic job descriptor construction
+ *
+ * Copyright (c) 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <desc_constr.h>
+#include <jobdesc.h>
+
+#define KEY_BLOB_SIZE			32
+#define MAC_SIZE			16
+
+void inline_cnstr_jobdesc_blob_encap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *plain_txt, uint8_t *enc_blob,
+				     uint32_t in_sz)
+{
+	dma_addr_t dma_addr_key_idnfr, dma_addr_in, dma_addr_out;
+	uint32_t key_sz = KEY_IDNFR_SZ_BYTES;
+	/* output blob will have 32 bytes key blob in beginning and
+	 * 16 byte HMAC identifier at end of data blob */
+	uint32_t out_sz = in_sz + KEY_BLOB_SIZE + MAC_SIZE;
+
+	dma_addr_key_idnfr = virt_to_phys((void *)key_idnfr);
+	dma_addr_in	= virt_to_phys((void *)plain_txt);
+	dma_addr_out	= virt_to_phys((void *)enc_blob);
+
+	init_job_desc(desc, 0);
+	append_key(desc, dma_addr_key_idnfr, key_sz, CLASS_2);
+
+	if (in_sz > 0xffff) {
+		append_seq_in_ptr(desc, dma_addr_in, 0, SQIN_EXT);
+		append_cmd(desc, in_sz);
+	} else {
+		append_seq_in_ptr(desc, dma_addr_in, in_sz, 0);
+	}
+
+	if (out_sz > 0xffff) {
+		append_seq_out_ptr(desc, dma_addr_out, 0, SQOUT_EXT);
+		append_cmd(desc, out_sz);
+	} else {
+		append_seq_out_ptr(desc, dma_addr_out, out_sz, 0);
+	}
+	append_operation(desc, OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB);
+}
+
+void inline_cnstr_jobdesc_blob_decap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *enc_blob, uint8_t *plain_txt,
+				     uint32_t out_sz)
+{
+	dma_addr_t dma_addr_key_idnfr, dma_addr_in, dma_addr_out;
+	uint32_t key_sz = KEY_IDNFR_SZ_BYTES;
+	uint32_t in_sz = out_sz + KEY_BLOB_SIZE + MAC_SIZE;
+
+	dma_addr_key_idnfr = virt_to_phys((void *)key_idnfr);
+	dma_addr_in	= virt_to_phys((void *)enc_blob);
+	dma_addr_out	= virt_to_phys((void *)plain_txt);
+
+	init_job_desc(desc, 0);
+	append_key(desc, dma_addr_key_idnfr, key_sz, CLASS_2);
+	if (in_sz > 0xffff) {
+		append_seq_in_ptr(desc, dma_addr_in, 0, SQIN_EXT);
+		append_cmd(desc, in_sz);
+	} else {
+		append_seq_in_ptr(desc, dma_addr_in, in_sz, 0);
+	}
+
+	if (out_sz > 0xffff) {
+		append_seq_out_ptr(desc, dma_addr_out, 0, SQOUT_EXT);
+		append_cmd(desc, out_sz);
+	} else {
+		append_seq_out_ptr(desc, dma_addr_out, out_sz, 0);
+	}
+
+	append_operation(desc, OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB);
+}
+
+
+/* Change key size to bytes form bits in calling function*/
+void inline_cnstr_jobdesc_pkha_rsaexp(uint32_t *desc,
+				      struct pk_in_params *pkin, uint8_t *out,
+				      uint32_t out_siz)
+{
+	dma_addr_t dma_addr_e, dma_addr_a, dma_addr_n, dma_addr_out;
+
+	dma_addr_e = virt_to_phys((void *)pkin->e);
+	dma_addr_a = virt_to_phys((void *)pkin->a);
+	dma_addr_n = virt_to_phys((void *)pkin->n);
+	dma_addr_out = virt_to_phys((void *)out);
+
+	init_job_desc(desc, 0);
+	append_key(desc, dma_addr_e, pkin->e_siz, KEY_DEST_PKHA_E | CLASS_1);
+
+	append_fifo_load(desc, dma_addr_a,
+			 pkin->a_siz, LDST_CLASS_1_CCB | FIFOLD_TYPE_PK_A);
+
+	append_fifo_load(desc, dma_addr_n,
+			 pkin->n_siz, LDST_CLASS_1_CCB | FIFOLD_TYPE_PK_N);
+
+	append_operation(desc, OP_TYPE_PK | OP_ALG_PK | OP_ALG_PKMODE_MOD_EXPO);
+
+	append_fifo_store(desc, dma_addr_out, out_siz,
+			  LDST_CLASS_1_CCB | FIFOST_TYPE_PKHA_B);
+}
+
+void inline_cnstr_jobdesc_sha256(uint32_t *desc,
+				 uint8_t *msg, uint32_t msgsz,
+				 uint8_t *digest)
+{
+	/* SHA 256 , output is of length 32 words */
+	uint32_t storelen = 32;
+	dma_addr_t dma_addr_in, dma_addr_out;
+
+	dma_addr_in = virt_to_phys((void *)msg);
+	dma_addr_out = virt_to_phys((void *)digest);
+
+	init_job_desc(desc, 0);
+	append_operation(desc,
+			 OP_TYPE_CLASS2_ALG | OP_ALG_ALGSEL_SHA256 |
+			 OP_ALG_AAI_HASH | OP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT
+			 | OP_ALG_ICV_OFF);
+	if (msgsz > 0xffff) {
+		append_fifo_load(desc, dma_addr_in, 0,
+				 LDST_CLASS_2_CCB | FIFOLDST_SGF |
+				 FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2 |
+				 FIFOLDST_EXT);
+		append_cmd(desc, msgsz);
+	} else
+		append_fifo_load(desc, dma_addr_in, msgsz,
+				 LDST_CLASS_2_CCB | FIFOLDST_SGF |
+				 FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2);
+	append_store(desc, dma_addr_out, storelen,
+		     LDST_CLASS_2_CCB | LDST_SRCDST_BYTE_CONTEXT);
+}
--- u-boot-2014.07/drivers/usb/host/xhci-fsl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/usb/host/xhci-fsl.c	2022-05-09 14:06:23.793126719 -0700
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * FSL USB HOST xHCI Controller
+ *
+ * Author: Ramneek Mehresh<ramneek.mehresh@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <usb.h>
+#include <asm-generic/errno.h>
+/*#include <asm/arch/cpu.h>*/
+/*#include <asm/arch/sys_proto.h>*/
+#include <linux/compat.h>
+#include <linux/usb/dwc3.h>
+#include <linux/usb/xhci-fsl.h>
+#include "xhci.h"
+
+/* Declare global data pointer */
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct fsl_xhci fsl_xhci;
+
+inline int __board_usb_init(int index, enum usb_init_type init)
+{
+	return 0;
+}
+int board_usb_init(int index, enum usb_init_type init)
+	__attribute__((weak, alias("__board_usb_init")));
+
+static void dwc3_set_mode(struct dwc3 *dwc3_reg, u32 mode)
+{
+	clrsetbits_le32(&dwc3_reg->g_ctl,
+			DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_OTG),
+			DWC3_GCTL_PRTCAPDIR(mode));
+}
+
+static void dwc3_core_soft_reset(struct dwc3 *dwc3_reg)
+{
+	/* Before Resetting PHY, put Core in Reset */
+	setbits_le32(&dwc3_reg->g_ctl, DWC3_GCTL_CORESOFTRESET);
+
+	/* After PHYs are stable we can take Core out of reset state */
+	clrbits_le32(&dwc3_reg->g_ctl, DWC3_GCTL_CORESOFTRESET);
+}
+
+static int dwc3_core_init(struct dwc3 *dwc3_reg)
+{
+	u32 reg;
+	u32 revision;
+	unsigned int dwc3_hwparams1;
+
+	revision = readl(&dwc3_reg->g_snpsid);
+	/* This should read as U3 followed by revision number */
+	if ((revision & DWC3_GSNPSID_MASK) != 0x55330000) {
+		puts("this is not a DesignWare USB3 DRD Core\n");
+		return -1;
+	}
+
+	dwc3_core_soft_reset(dwc3_reg);
+
+	dwc3_hwparams1 = readl(&dwc3_reg->g_hwparams1);
+
+	reg = readl(&dwc3_reg->g_ctl);
+	reg &= ~DWC3_GCTL_SCALEDOWN_MASK;
+	reg &= ~DWC3_GCTL_DISSCRAMBLE;
+	switch (DWC3_GHWPARAMS1_EN_PWROPT(dwc3_hwparams1)) {
+	case DWC3_GHWPARAMS1_EN_PWROPT_CLK:
+		reg &= ~DWC3_GCTL_DSBLCLKGTNG;
+		break;
+	default:
+		debug("No power optimization available\n");
+	}
+
+	/*
+	 * WORKAROUND: DWC3 revisions <1.90a have a bug
+	 * where the device can fail to connect at SuperSpeed
+	 * and falls back to high-speed mode which causes
+	 * the device to enter a Connect/Disconnect loop
+	 */
+	if ((revision & DWC3_REVISION_MASK) < 0x190a)
+		reg |= DWC3_GCTL_U2RSTECN;
+
+	writel(reg, &dwc3_reg->g_ctl);
+
+	return 0;
+}
+
+static int fsl_xhci_core_init(struct fsl_xhci *fsl_xhci)
+{
+	int ret = 0;
+
+	ret = dwc3_core_init(fsl_xhci->dwc3_reg);
+	if (ret) {
+		debug("%s:failed to initialize core\n", __func__);
+		return ret;
+	}
+
+	/* We are hard-coding DWC3 core to Host Mode */
+	dwc3_set_mode(fsl_xhci->dwc3_reg, DWC3_GCTL_PRTCAP_HOST);
+
+	return ret;
+}
+
+static void fsl_xhci_core_exit(struct fsl_xhci *fsl_xhci)
+{
+	return;
+}
+
+int xhci_hcd_init(int index, struct xhci_hccr **hccr, struct xhci_hcor **hcor)
+{
+	struct fsl_xhci *ctx = &fsl_xhci;
+	int ret = 0;
+
+	ctx->hcd = (struct xhci_hccr *)FSL_XHCI_BASE;
+	ctx->dwc3_reg = (struct dwc3 *)(FSL_XHCI_BASE + DWC3_REG_OFFSET);
+
+	ret = board_usb_init(index, USB_INIT_HOST);
+	if (ret != 0) {
+		puts("Failed to initialize board for USB\n");
+		return ret;
+	}
+
+	ret = fsl_xhci_core_init(ctx);
+	if (ret < 0) {
+		puts("Failed to initialize xhci\n");
+		return ret;
+	}
+
+	*hccr = (struct xhci_hccr *)(FSL_XHCI_BASE);
+	*hcor = (struct xhci_hcor *)((uint32_t) *hccr
+				+ HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
+
+	debug("fsl-xhci: init hccr %x and hcor %x hc_length %d\n",
+	      (uint32_t)*hccr, (uint32_t)*hcor,
+	      (uint32_t)HC_LENGTH(xhci_readl(&(*hccr)->cr_capbase)));
+
+	return ret;
+}
+
+void xhci_hcd_stop(int index)
+{
+	struct fsl_xhci *ctx = &fsl_xhci;
+
+	fsl_xhci_core_exit(ctx);
+}
--- u-boot-2014.07/drivers/video/fsl_dcu_fb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/video/fsl_dcu_fb.c	2022-05-09 14:06:23.809126072 -0700
@@ -0,0 +1,365 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * FSL DCU Framebuffer driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_dcu_fb.h>
+#include <linux/fb.h>
+#include <malloc.h>
+#include <video_fb.h>
+#include "videomodes.h"
+
+/* Convert the X,Y resolution pair into a single number */
+#define RESOLUTION(x, y) (((u32)(x) << 16) | (y))
+
+#ifdef CONFIG_SYS_FSL_DCU_LE
+#define	dcu_read32	in_le32
+#define	dcu_write32	out_le32
+#elif defined(CONFIG_SYS_FSL_DCU_BE)
+#define	dcu_read32	in_be32
+#define	dcu_write32	out_be32
+#endif
+
+#define DCU_MODE_BLEND_ITER(x)          ((x) << 20)
+#define DCU_MODE_RASTER_EN		(1 << 14)
+#define DCU_MODE_NORMAL			1
+#define DCU_MODE_COLORBAR               3
+#define DCU_BGND_R(x)			((x) << 16)
+#define DCU_BGND_G(x)			((x) << 8)
+#define DCU_BGND_B(x)			(x)
+#define DCU_DISP_SIZE_DELTA_Y(x)	((x) << 16)
+#define DCU_DISP_SIZE_DELTA_X(x)	(x)
+#define DCU_HSYN_PARA_BP(x)		((x) << 22)
+#define DCU_HSYN_PARA_PW(x)		((x) << 11)
+#define DCU_HSYN_PARA_FP(x)		(x)
+#define DCU_VSYN_PARA_BP(x)		((x) << 22)
+#define DCU_VSYN_PARA_PW(x)		((x) << 11)
+#define DCU_VSYN_PARA_FP(x)		(x)
+#define DCU_SYN_POL_INV_PXCK_FALL	(0 << 6)
+#define DCU_SYN_POL_NEG_REMAIN		(0 << 5)
+#define DCU_SYN_POL_INV_VS_LOW		(1 << 1)
+#define DCU_SYN_POL_INV_HS_LOW		(1)
+#define DCU_THRESHOLD_LS_BF_VS(x)	((x) << 16)
+#define DCU_THRESHOLD_OUT_BUF_HIGH(x)	((x) << 8)
+#define DCU_THRESHOLD_OUT_BUF_LOW(x)	(x)
+#define DCU_UPDATE_MODE_MODE            (1 << 31)
+#define DCU_UPDATE_MODE_READREG         (1 << 30)
+
+#define DCU_CTRLDESCLN_1_HEIGHT(x)	((x) << 16)
+#define DCU_CTRLDESCLN_1_WIDTH(x)	(x)
+#define DCU_CTRLDESCLN_2_POSY(x)	((x) << 16)
+#define DCU_CTRLDESCLN_2_POSX(x)	(x)
+#define DCU_CTRLDESCLN_4_EN		(1 << 31)
+#define DCU_CTRLDESCLN_4_TILE_EN	(1 << 30)
+#define DCU_CTRLDESCLN_4_DATA_SEL_CLUT	(1 << 29)
+#define DCU_CTRLDESCLN_4_SAFETY_EN	(1 << 28)
+#define DCU_CTRLDESCLN_4_TRANS(x)	((x) << 20)
+#define DCU_CTRLDESCLN_4_BPP(x)		((x) << 16)
+#define DCU_CTRLDESCLN_4_RLE_EN		(1 << 15)
+#define DCU_CTRLDESCLN_4_LUOFFS(x)	((x) << 4)
+#define DCU_CTRLDESCLN_4_BB_ON		(1 << 2)
+#define DCU_CTRLDESCLN_4_AB(x)		(x)
+#define DCU_CTRLDESCLN_5_CKMAX_R(x)	((x) << 16)
+#define DCU_CTRLDESCLN_5_CKMAX_G(x)	((x) << 8)
+#define DCU_CTRLDESCLN_5_CKMAX_B(x)	(x)
+#define DCU_CTRLDESCLN_6_CKMIN_R(x)	((x) << 16)
+#define DCU_CTRLDESCLN_6_CKMIN_G(x)	((x) << 8)
+#define DCU_CTRLDESCLN_6_CKMIN_B(x)	(x)
+#define DCU_CTRLDESCLN_7_TILE_VER(x)	((x) << 16)
+#define DCU_CTRLDESCLN_7_TILE_HOR(x)	(x)
+#define DCU_CTRLDESCLN_8_FG_FCOLOR(x)	(x)
+#define DCU_CTRLDESCLN_9_BG_BCOLOR(x)	(x)
+
+#define BPP_16_RGB565			4
+#define BPP_24_RGB888			5
+#define BPP_32_ARGB8888			6
+
+/*
+ * This setting is used for the TWR_LCD_RGB card
+ */
+static struct fb_videomode fsl_dcu_mode_480_272 = {
+	.name		= "480x272-60",
+	.refresh	= 60,
+	.xres		= 480,
+	.yres		= 272,
+	.pixclock	= 91996,
+	.left_margin	= 2,
+	.right_margin	= 2,
+	.upper_margin	= 1,
+	.lower_margin	= 1,
+	.hsync_len	= 41,
+	.vsync_len	= 2,
+	.sync		= FB_SYNC_COMP_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	.vmode		= FB_VMODE_NONINTERLACED
+};
+
+/*
+ * This setting is used for Siliconimage SiI9022A HDMI
+ */
+static struct fb_videomode fsl_dcu_mode_640_480 = {
+	.name		= "640x480-60",
+	.refresh	= 60,
+	.xres		= 640,
+	.yres		= 480,
+	.pixclock	= 39722,
+	.left_margin	= 48,
+	.right_margin	= 16,
+	.upper_margin	= 33,
+	.lower_margin	= 10,
+	.hsync_len	= 96,
+	.vsync_len	= 2,
+	.sync		= 0,
+	.vmode		= FB_VMODE_NONINTERLACED,
+};
+
+/*
+ * DCU register map
+ */
+struct dcu_reg {
+	u32 desc_cursor[4];
+	u32 mode;
+	u32 bgnd;
+	u32 disp_size;
+	u32 hsyn_para;
+	u32 vsyn_para;
+	u32 synpol;
+	u32 threshold;
+	u32 int_status;
+	u32 int_mask;
+	u32 colbar[8];
+	u32 div_ratio;
+	u32 sign_calc[2];
+	u32 crc_val;
+	u8 res_064[0x6c-0x64];
+	u32 parr_err_status1;
+	u8 res_070[0x7c-0x70];
+	u32 parr_err_status3;
+	u32 mparr_err_status1;
+	u8 res_084[0x90-0x84];
+	u32 mparr_err_status3;
+	u32 threshold_inp_buf[2];
+	u8 res_09c[0xa0-0x9c];
+	u32 luma_comp;
+	u32 chroma_red;
+	u32 chroma_green;
+	u32 chroma_blue;
+	u32 crc_pos;
+	u32 lyr_intpol_en;
+	u32 lyr_luma_comp;
+	u32 lyr_chrm_red;
+	u32 lyr_chrm_grn;
+	u32 lyr_chrm_blue;
+	u8 res_0c4[0xcc-0xc8];
+	u32 update_mode;
+	u32 underrun;
+	u8 res_0d4[0x100-0xd4];
+	u32 gpr;
+	u32 slr_l[2];
+	u32 slr_disp_size;
+	u32 slr_hvsync_para;
+	u32 slr_pol;
+	u32 slr_l_transp[2];
+	u8 res_120[0x200-0x120];
+	u32 ctrldescl[DCU_LAYER_MAX_NUM][16];
+};
+
+static struct fb_info info;
+
+static void reset_total_layers(void)
+{
+	struct dcu_reg *regs = (struct dcu_reg *)CONFIG_SYS_DCU_ADDR;
+	int i;
+
+	for (i = 0; i < DCU_LAYER_MAX_NUM; i++) {
+		dcu_write32(&regs->ctrldescl[i][0], 0);
+		dcu_write32(&regs->ctrldescl[i][1], 0);
+		dcu_write32(&regs->ctrldescl[i][2], 0);
+		dcu_write32(&regs->ctrldescl[i][3], 0);
+		dcu_write32(&regs->ctrldescl[i][4], 0);
+		dcu_write32(&regs->ctrldescl[i][5], 0);
+		dcu_write32(&regs->ctrldescl[i][6], 0);
+		dcu_write32(&regs->ctrldescl[i][7], 0);
+		dcu_write32(&regs->ctrldescl[i][8], 0);
+		dcu_write32(&regs->ctrldescl[i][9], 0);
+		dcu_write32(&regs->ctrldescl[i][10], 0);
+	}
+
+	dcu_write32(&regs->update_mode, DCU_UPDATE_MODE_READREG);
+}
+
+static int layer_ctrldesc_init(int index, u32 pixel_format)
+{
+	struct dcu_reg *regs = (struct dcu_reg *)CONFIG_SYS_DCU_ADDR;
+	unsigned int bpp = BPP_24_RGB888;
+
+	dcu_write32(&regs->ctrldescl[index][0],
+		    DCU_CTRLDESCLN_1_HEIGHT(info.var.yres) |
+		    DCU_CTRLDESCLN_1_WIDTH(info.var.xres));
+
+	dcu_write32(&regs->ctrldescl[index][1],
+		    DCU_CTRLDESCLN_2_POSY(0) |
+		    DCU_CTRLDESCLN_2_POSX(0));
+
+	dcu_write32(&regs->ctrldescl[index][2], (unsigned int)info.screen_base);
+
+	switch (pixel_format) {
+	case 16:
+		bpp = BPP_16_RGB565;
+		break;
+	case 24:
+		bpp = BPP_24_RGB888;
+		break;
+	case 32:
+		bpp = BPP_32_ARGB8888;
+		break;
+	default:
+		printf("unsupported color depth: %u\n", pixel_format);
+	}
+
+	dcu_write32(&regs->ctrldescl[index][3],
+		    DCU_CTRLDESCLN_4_EN |
+		    DCU_CTRLDESCLN_4_TRANS(0xff) |
+		    DCU_CTRLDESCLN_4_BPP(bpp) |
+		    DCU_CTRLDESCLN_4_AB(0));
+
+	dcu_write32(&regs->ctrldescl[index][4],
+		    DCU_CTRLDESCLN_5_CKMAX_R(0xff) |
+		    DCU_CTRLDESCLN_5_CKMAX_G(0xff) |
+		    DCU_CTRLDESCLN_5_CKMAX_B(0xff));
+	dcu_write32(&regs->ctrldescl[index][5],
+		    DCU_CTRLDESCLN_6_CKMIN_R(0) |
+		    DCU_CTRLDESCLN_6_CKMIN_G(0) |
+		    DCU_CTRLDESCLN_6_CKMIN_B(0));
+
+	dcu_write32(&regs->ctrldescl[index][6],
+		    DCU_CTRLDESCLN_7_TILE_VER(0) |
+		    DCU_CTRLDESCLN_7_TILE_HOR(0));
+
+	dcu_write32(&regs->ctrldescl[index][7], DCU_CTRLDESCLN_8_FG_FCOLOR(0));
+	dcu_write32(&regs->ctrldescl[index][8], DCU_CTRLDESCLN_9_BG_BCOLOR(0));
+
+	dcu_write32(&regs->update_mode, DCU_UPDATE_MODE_READREG);
+
+	return 0;
+}
+
+int fsl_dcu_init(unsigned int xres, unsigned int yres,
+		 unsigned int pixel_format)
+{
+	struct dcu_reg *regs = (struct dcu_reg *)CONFIG_SYS_DCU_ADDR;
+	unsigned int div, mode;
+
+	/* Memory allocation for framebuffer */
+	info.screen_size =
+		info.var.xres * info.var.yres * (info.var.bits_per_pixel / 8);
+	info.screen_base = (char *)memalign(ARCH_DMA_MINALIGN,
+			roundup(info.screen_size, ARCH_DMA_MINALIGN));
+	memset(info.screen_base, 0, info.screen_size);
+
+	reset_total_layers();
+	div = dcu_set_pixel_clock(info.var.pixclock);
+	dcu_write32(&regs->div_ratio, (div - 1));
+
+	dcu_write32(&regs->disp_size,
+		    DCU_DISP_SIZE_DELTA_Y(info.var.yres) |
+		    DCU_DISP_SIZE_DELTA_X(info.var.xres / 16));
+
+	dcu_write32(&regs->hsyn_para,
+		    DCU_HSYN_PARA_BP(info.var.left_margin) |
+		    DCU_HSYN_PARA_PW(info.var.hsync_len) |
+		    DCU_HSYN_PARA_FP(info.var.right_margin));
+
+	dcu_write32(&regs->vsyn_para,
+		    DCU_VSYN_PARA_BP(info.var.upper_margin) |
+		    DCU_VSYN_PARA_PW(info.var.vsync_len) |
+		    DCU_VSYN_PARA_FP(info.var.lower_margin));
+
+	dcu_write32(&regs->synpol,
+		    DCU_SYN_POL_INV_PXCK_FALL |
+		    DCU_SYN_POL_NEG_REMAIN |
+		    DCU_SYN_POL_INV_VS_LOW |
+		    DCU_SYN_POL_INV_HS_LOW);
+
+	dcu_write32(&regs->bgnd,
+		    DCU_BGND_R(0) | DCU_BGND_G(0) | DCU_BGND_B(0));
+
+	dcu_write32(&regs->mode,
+		    DCU_MODE_BLEND_ITER(DCU_LAYER_MAX_NUM) |
+		    DCU_MODE_RASTER_EN);
+
+	dcu_write32(&regs->threshold,
+		    DCU_THRESHOLD_LS_BF_VS(0x3) |
+		    DCU_THRESHOLD_OUT_BUF_HIGH(0x78) |
+		    DCU_THRESHOLD_OUT_BUF_LOW(0));
+
+	mode = dcu_read32(&regs->mode);
+	dcu_write32(&regs->mode, mode | DCU_MODE_NORMAL);
+
+	layer_ctrldesc_init(0, pixel_format);
+
+	return 0;
+}
+
+void *video_hw_init(void)
+{
+	static GraphicDevice ctfb;
+	const char *options;
+	unsigned int depth = 0, freq = 0;
+	struct fb_videomode *fsl_dcu_mode_db = &fsl_dcu_mode_480_272;
+
+	if (!video_get_video_mode(&ctfb.winSizeX, &ctfb.winSizeY, &depth, &freq,
+				  &options))
+		return NULL;
+
+	/* Find the monitor port, which is a required option */
+	if (!options)
+		return NULL;
+	if (strncmp(options, "monitor=", 8) != 0)
+		return NULL;
+
+	switch (RESOLUTION(ctfb.winSizeX, ctfb.winSizeY)) {
+	case RESOLUTION(480, 272):
+		fsl_dcu_mode_db = &fsl_dcu_mode_480_272;
+		break;
+	case RESOLUTION(640, 480):
+		fsl_dcu_mode_db = &fsl_dcu_mode_640_480;
+		break;
+	default:
+		printf("unsupported resolution %ux%u\n",
+		       ctfb.winSizeX, ctfb.winSizeY);
+	}
+
+	info.var.xres = fsl_dcu_mode_db->xres;
+	info.var.yres = fsl_dcu_mode_db->yres;
+	info.var.bits_per_pixel = 32;
+	info.var.pixclock = fsl_dcu_mode_db->pixclock;
+	info.var.left_margin = fsl_dcu_mode_db->left_margin;
+	info.var.right_margin = fsl_dcu_mode_db->right_margin;
+	info.var.upper_margin = fsl_dcu_mode_db->upper_margin;
+	info.var.lower_margin = fsl_dcu_mode_db->lower_margin;
+	info.var.hsync_len = fsl_dcu_mode_db->hsync_len;
+	info.var.vsync_len = fsl_dcu_mode_db->vsync_len;
+	info.var.sync = fsl_dcu_mode_db->sync;
+	info.var.vmode = fsl_dcu_mode_db->vmode;
+	info.fix.line_length = info.var.xres * info.var.bits_per_pixel / 8;
+
+	if (platform_dcu_init(ctfb.winSizeX, ctfb.winSizeY,
+			      options + 8, fsl_dcu_mode_db) < 0)
+		return NULL;
+
+	ctfb.frameAdrs = (unsigned int)info.screen_base;
+	ctfb.plnSizeX = ctfb.winSizeX;
+	ctfb.plnSizeY = ctfb.winSizeY;
+
+	ctfb.gdfBytesPP = 4;
+	ctfb.gdfIndex = GDF_32BIT_X888RGB;
+
+	ctfb.memSize = info.screen_size;
+
+	return &ctfb;
+}
--- u-boot-2014.07/drivers/spi/fsl_spi_interface.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/spi/fsl_spi_interface.c	2022-05-09 14:06:23.769127690 -0700
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Freescale Muti Serial Peripheral Interface (QSPI and DSPI) driver support
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include "fsl_spi_interface.h"
+
+struct fsl_spi_driver {
+	void (*init)(void);
+	int (*claim_bus)(struct spi_slave *slave);
+	int (*release_bus)(struct spi_slave *slave);
+	int (*cs_is_valid)(unsigned int bus, unsigned int cs);
+	struct spi_slave * (*setup_slave)(unsigned int bus, unsigned int cs,
+					unsigned int max_hz, unsigned int mode);
+	void (*free_slave)(struct spi_slave *slave);
+	void (*cs_activate)(struct spi_slave *slave);
+	void (*cs_deactivate)(struct spi_slave *slave);
+	int (*xfer)(struct spi_slave *slave, unsigned int bitlen,
+		    const void *data_out, void *data_in, unsigned long flags);
+};
+
+static struct fsl_spi_driver fsl_spi_drivers[] = {
+#ifdef CONFIG_FSL_DSPI
+	{
+		.init		= dspi_init,
+		.claim_bus	= dspi_claim_bus,
+		.cs_is_valid	= NULL,
+		.setup_slave	= dspi_setup_slave,
+		.free_slave	= dspi_free_slave,
+		.cs_activate	= NULL,
+		.cs_deactivate	= NULL,
+		.xfer		= dspi_xfer,
+	},
+#endif
+#ifdef CONFIG_FSL_QSPI
+	{
+		.init		= NULL,
+		.claim_bus	= qspi_claim_bus,
+		.cs_is_valid	= NULL,
+		.setup_slave	= qspi_setup_slave,
+		.free_slave	= qspi_free_slave,
+		.cs_activate	= NULL,
+		.cs_deactivate	= NULL,
+		.xfer		= qspi_xfer,
+	},
+#endif
+};
+
+enum fsl_spi_driver_sel {
+#ifdef CONFIG_FSL_DSPI
+	DSPI_DRIVER,
+#endif
+#ifdef CONFIG_FSL_QSPI
+	QSPI_DRIVER,
+#endif
+};
+
+struct fsl_spi_driver *find_fsl_spi_driver(unsigned int bus, unsigned int cs)
+{
+	unsigned int driver_sel;
+
+	if (board_spi_find_bus(bus, cs)) {
+		board_print_spi_device();
+		printf("can't find device on bus %d cs %d in board.\n",
+		       bus, cs);
+		return NULL;
+	}
+
+	switch (bus) {
+#if defined(CONFIG_FSL_DSPI) && defined(SPI_BUS_FSL_DSPI1)
+	case SPI_BUS_FSL_DSPI1:
+		driver_sel = DSPI_DRIVER;
+		break;
+#endif
+#if defined(CONFIG_FSL_DSPI) && defined(SPI_BUS_FSL_DSPI2)
+	case SPI_BUS_FSL_DSPI2:
+		driver_sel = DSPI_DRIVER;
+		break;
+#endif
+#if defined(CONFIG_FSL_DSPI) && defined(SPI_BUS_FSL_DSPI3)
+	case SPI_BUS_FSL_DSPI3:
+		driver_sel = DSPI_DRIVER;
+		break;
+#endif
+#if defined(CONFIG_FSL_DSPI) && defined(SPI_BUS_FSL_DSPI4)
+	case SPI_BUS_FSL_DSPI4:
+		driver_sel = DSPI_DRIVER;
+		break;
+#endif
+#if defined(CONFIG_FSL_QSPI) && defined(SPI_BUS_FSL_QSPI)
+	case SPI_BUS_FSL_QSPI:
+		driver_sel = QSPI_DRIVER;
+		break;
+#endif
+#if defined(CONFIG_FSL_QSPI) && defined(SPI_BUS_FSL_QSPI2)
+	case SPI_BUS_FSL_QSPI2:
+		driver_sel = QSPI_DRIVER;
+		break;
+#endif
+	default:
+		return NULL;
+	}
+
+	return &fsl_spi_drivers[driver_sel];
+}
+
+unsigned long get_spi_bus_base(unsigned int bus)
+{
+	switch (bus) {
+#ifdef SPI_BUS_FSL_DSPI1
+	case SPI_BUS_FSL_DSPI1:
+		return DSPI1_BASE_ADDR;
+#endif
+#ifdef SPI_BUS_FSL_DSPI2
+	case SPI_BUS_FSL_DSPI2:
+		return DSPI2_BASE_ADDR;
+#endif
+#ifdef SPI_BUS_FSL_DSPI3
+	case SPI_BUS_FSL_DSPI3:
+		return DSPI3_BASE_ADDR;
+#endif
+#ifdef SPI_BUS_FSL_DSPI4
+	case SPI_BUS_FSL_DSPI4:
+		return DSPI4_BASE_ADDR;
+#endif
+#ifdef SPI_BUS_FSL_QSPI
+	case SPI_BUS_FSL_QSPI:
+		return QSPI_BASE_ADDR;
+#endif
+#ifdef SPI_BUS_FSL_QSPI2
+	case SPI_BUS_FSL_QSPI2:
+		return QSPI2_BASE_ADDR;
+#endif
+	default:
+		printf("FSL SPL:get bus base error %d", bus);
+		return 0;
+	}
+}
+
+unsigned long get_qspi_amba_base(unsigned int bus)
+{
+	switch (bus) {
+#ifdef SPI_BUS_FSL_QSPI
+	case SPI_BUS_FSL_QSPI:
+		return QSPI_AMBA_BASE;
+#endif
+#ifdef SPI_BUS_FSL_QSPI2
+	case SPI_BUS_FSL_QSPI2:
+		return QSPI2_AMBA_BASE;
+#endif
+	default:
+		printf("FSL SPL:get qspi amba bus base error %d", bus);
+		return 0;
+	}
+
+	return 0;
+}
+
+void spi_init(void)
+{
+	int i;
+	struct fsl_spi_driver *driver;
+
+	for (i = 0; i < ARRAY_SIZE(fsl_spi_drivers); i++) {
+		driver = &fsl_spi_drivers[i];
+		if (driver && driver->init)
+			driver->init();
+	}
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct fsl_spi_driver *driver = find_fsl_spi_driver(bus, cs);
+
+	if (!driver || !driver->setup_slave)
+		return NULL;
+
+	return driver->setup_slave(bus, cs, max_hz, mode);
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct fsl_spi_driver *driver = find_fsl_spi_driver(slave->bus,
+								slave->cs);
+
+	if (!driver)
+		return 1;
+	if (!driver->claim_bus)
+		return 0;
+
+	return driver->claim_bus(slave);
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct fsl_spi_driver *driver = find_fsl_spi_driver(slave->bus,
+								slave->cs);
+
+	if (driver && driver->free_slave)
+		return driver->free_slave(slave);
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
+		const void *dout, void *din, unsigned long flags)
+{
+	struct fsl_spi_driver *driver = find_fsl_spi_driver(slave->bus,
+								slave->cs);
+
+	if (!driver || !driver->xfer)
+		return -1;
+
+	return driver->xfer(slave, bitlen, dout, din, flags);
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct fsl_spi_driver *driver = find_fsl_spi_driver(slave->bus,
+								slave->cs);
+
+	if (driver && driver->cs_activate)
+		driver->cs_activate(slave);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct fsl_spi_driver *driver = find_fsl_spi_driver(slave->bus,
+								slave->cs);
+
+	if (driver && driver->cs_deactivate)
+		driver->cs_deactivate(slave);
+}
--- u-boot-2014.07/drivers/spi/fsl_spi_interface.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/spi/fsl_spi_interface.h	2022-05-09 14:06:23.769127690 -0700
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Freescale Muti Serial Peripheral Interface (QSPI and DSPI) driver support
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+void dspi_init(void);
+int dspi_claim_bus(struct spi_slave *slave);
+void dspi_release_bus(struct spi_slave *slave);
+int dspi_cs_is_valid(unsigned int bus, unsigned int cs);
+struct spi_slave *dspi_setup_slave(unsigned int bus, unsigned int cs,
+				unsigned int max_hz, unsigned int mode);
+void dspi_free_slave(struct spi_slave *slave);
+void dspi_cs_activate(struct spi_slave *slave);
+void dspi_cs_deactivate(struct spi_slave *slave);
+int dspi_xfer(struct spi_slave *slave, unsigned int bitlen,
+	    const void *data_out, void *data_in, unsigned long flags);
+void qspi_init(void);
+int qspi_claim_bus(struct spi_slave *slave);
+void qspi_release_bus(struct spi_slave *slave);
+int qspi_cs_is_valid(unsigned int bus, unsigned int cs);
+struct spi_slave *qspi_setup_slave(unsigned int bus, unsigned int cs,
+				unsigned int max_hz, unsigned int mode);
+void qspi_free_slave(struct spi_slave *slave);
+void qspi_cs_activate(struct spi_slave *slave);
+void qspi_cs_deactivate(struct spi_slave *slave);
+int qspi_xfer(struct spi_slave *slave, unsigned int bitlen,
+	    const void *data_out, void *data_in, unsigned long flags);
+
+void board_print_spi_device(void);
+int board_spi_find_bus(unsigned int bus, unsigned int cs);
+
+unsigned long get_spi_bus_base(unsigned int bus);
+unsigned long get_qspi_amba_base(unsigned int bus);
--- u-boot-2014.07/drivers/spi/fsl_dspi.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/drivers/spi/fsl_dspi.c	2022-05-09 14:06:23.769127690 -0700
@@ -0,0 +1,343 @@
+/*
+ * (C) Copyright 2000-2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * Copyright (C) 2004-2009, 2013 Freescale Semiconductor, Inc.
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
+ * Chao Fu (B44548@freescale.com)
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <fsl_dspi.h>
+#include "fsl_spi_interface.h"
+
+#if defined(CONFIG_VF610) || defined(CONFIG_LS102XA)
+#include <asm/arch/clock.h>
+#endif
+
+#if !defined(CONFIG_VF610) && !defined(CONFIG_LS102XA)
+#include <asm/immap.h>
+#endif
+
+#ifdef CONFIG_SYS_FSL_DSPI_LE
+#define dspi_read32		in_le32
+#define dspi_write32		out_le32
+#elif defined(CONFIG_SYS_FSL_DSPI_BE)
+#define dspi_read32		in_be32
+#define dspi_write32		out_be32
+#else
+#error Neither CONFIG_SYS_FSL_DSPI_LE nor CONFIG_SYS_FSL_DSPI_BE is defined
+#endif
+
+struct dspi_slave {
+	struct spi_slave slave;
+	struct dspi *regs;
+	uint baudrate;
+	int charbit;
+};
+
+static inline struct dspi_slave *to_dspi_spi(struct spi_slave *slave)
+{
+	return container_of(slave, struct dspi_slave, slave);
+}
+
+#ifndef CONFIG_SPI_IDLE_VAL
+#if defined(CONFIG_SPI_MMC)
+#define CONFIG_SPI_IDLE_VAL	0xFFFF
+#else
+#define CONFIG_SPI_IDLE_VAL	0x0
+#endif
+#endif
+
+#if defined(CONFIG_FSL_DSPI)
+/* DSPI specific mode */
+#define SPI_MODE_MOD	0x00200000
+#define SPI_DBLRATE	0x00100000
+
+static void dspi_tx(struct dspi_slave *dspislave, u32 ctrl, u16 data)
+{
+	while ((dspi_read32(&dspislave->regs->sr) & 0x0000F000) >= 4)
+		;
+
+	dspi_write32(&dspislave->regs->tfr, (ctrl | data));
+}
+
+static u16 dspi_rx(struct dspi_slave *dspislave)
+{
+	while ((dspi_read32(&dspislave->regs->sr) & 0x000000F0) == 0)
+		;
+
+	return (u16)(dspi_read32(&dspislave->regs->rfr) & 0xFFFF);
+}
+
+int dspi_xfer(struct spi_slave *slave, uint bitlen, const void *dout,
+	       void *din, ulong flags)
+{
+	struct dspi_slave *dspislave = to_dspi_spi(slave);
+	u16 *spi_rd16 = NULL, *spi_wr16 = NULL;
+	u8 *spi_rd = NULL, *spi_wr = NULL;
+	static u32 ctrl = 0;
+	uint len = bitlen >> 3;
+
+	if (dspislave->charbit == 16) {
+		bitlen >>= 1;
+		spi_wr16 = (u16 *) dout;
+		spi_rd16 = (u16 *) din;
+	} else {
+		spi_wr = (u8 *) dout;
+		spi_rd = (u8 *) din;
+	}
+
+	if ((flags & SPI_XFER_BEGIN) == SPI_XFER_BEGIN)
+		ctrl |= DSPI_TFR_CONT;
+
+	ctrl = (ctrl & 0xFF000000) | ((1 << slave->cs) << 16);
+
+	if (len > 1) {
+		int tmp_len = len - 1;
+		while (tmp_len--) {
+			if (dout != NULL) {
+				if (dspislave->charbit == 16)
+					dspi_tx(dspislave, ctrl, *spi_wr16++);
+				else
+					dspi_tx(dspislave, ctrl, *spi_wr++);
+				dspi_rx(dspislave);
+			}
+
+			if (din != NULL) {
+				dspi_tx(dspislave, ctrl, CONFIG_SPI_IDLE_VAL);
+				if (dspislave->charbit == 16)
+					*spi_rd16++ = dspi_rx(dspislave);
+				else
+					*spi_rd++ = dspi_rx(dspislave);
+			}
+		}
+
+		len = 1;	/* remaining byte */
+	}
+
+	if ((flags & SPI_XFER_END) == SPI_XFER_END)
+		ctrl &= ~DSPI_TFR_CONT;
+
+	if (len) {
+		if (dout != NULL) {
+			if (dspislave->charbit == 16)
+				dspi_tx(dspislave, ctrl, *spi_wr16);
+			else
+				dspi_tx(dspislave, ctrl, *spi_wr);
+			dspi_rx(dspislave);
+		}
+
+		if (din != NULL) {
+			dspi_tx(dspislave, ctrl, CONFIG_SPI_IDLE_VAL);
+			if (dspislave->charbit == 16)
+				*spi_rd16 = dspi_rx(dspislave);
+			else
+				*spi_rd = dspi_rx(dspislave);
+		}
+	} else {
+		/* dummy read */
+		dspi_tx(dspislave, ctrl, CONFIG_SPI_IDLE_VAL);
+		dspi_rx(dspislave);
+	}
+
+	return 0;
+}
+
+struct spi_slave *dspi_setup_slave(unsigned int bus, unsigned int cs,
+				unsigned int max_hz, unsigned int mode)
+{
+	/*
+	 * bit definition for mode:
+	 * bit 31 - 28: Transfer size 3 to 16 bits
+	 *     27 - 26: PCS to SCK delay prescaler
+	 *     25 - 24: After SCK delay prescaler
+	 *     23 - 22: Delay after transfer prescaler
+	 *     21     : Allow overwrite for bit 31-22 and bit 20-8
+	 *     20     : Double baud rate
+	 *     19 - 16: PCS to SCK delay scaler
+	 *     15 - 12: After SCK delay scaler
+	 *     11 -  8: Delay after transfer scaler
+	 *      7 -  0: SPI_CPHA, SPI_CPOL, SPI_LSB_FIRST
+	 */
+	struct dspi_slave *dspislave;
+	int prescaler[] = { 2, 3, 5, 7 };
+	int scaler[] = {
+		2, 4, 6, 8,
+		16, 32, 64, 128,
+		256, 512, 1024, 2048,
+		4096, 8192, 16384, 32768
+	};
+	int i, j, pbrcnt, brcnt, diff, tmp, dbr = 0;
+	int best_i, best_j, bestmatch = 0x7FFFFFFF, baud_speed, bus_clk;
+	u32 bus_setup = 0;
+
+	dspislave = spi_alloc_slave(struct dspi_slave, bus, cs);
+	if (!dspislave)
+		return NULL;
+
+	dspislave->baudrate = max_hz;
+	dspislave->regs = (struct dspi *)get_spi_bus_base(bus);
+
+#if !defined(CONFIG_VF610) && !defined(CONFIG_LS102XA)
+	cfspi_port_conf();	/* port configuration */
+#endif
+
+	dspi_write32(&dspislave->regs->mcr,
+		     DSPI_MCR_MSTR | DSPI_MCR_CSIS7 | DSPI_MCR_CSIS6 |
+		     DSPI_MCR_CSIS5 | DSPI_MCR_CSIS4 | DSPI_MCR_CSIS3 |
+		     DSPI_MCR_CSIS2 | DSPI_MCR_CSIS1 | DSPI_MCR_CSIS0 |
+		     DSPI_MCR_CRXF | DSPI_MCR_CTXF);
+	/* Default setting in platform configuration */
+#ifdef CONFIG_SYS_DSPI_CTAR0
+	dspi_write32(&dspislave->regs->ctar[0], CONFIG_SYS_DSPI_CTAR0);
+#endif
+#ifdef CONFIG_SYS_DSPI_CTAR1
+	dspi_write32(&dspislave->regs->ctar[1], CONFIG_SYS_DSPI_CTAR1);
+#endif
+#ifdef CONFIG_SYS_DSPI_CTAR2
+	dspi_write32(&dspislave->regs->ctar[2], CONFIG_SYS_DSPI_CTAR2);
+#endif
+#ifdef CONFIG_SYS_DSPI_CTAR3
+	dspi_write32(&dspislave->regs->ctar[3], CONFIG_SYS_DSPI_CTAR3);
+#endif
+#ifdef CONFIG_SYS_DSPI_CTAR4
+	dspi_write32(&dspislave->regs->ctar[4], CONFIG_SYS_DSPI_CTAR4);
+#endif
+#ifdef CONFIG_SYS_DSPI_CTAR5
+	dspi_write32(&dspislave->regs->ctar[5], CONFIG_SYS_DSPI_CTAR5);
+#endif
+#ifdef CONFIG_SYS_DSPI_CTAR6
+	dspi_write32(&dspislave->regs->ctar[6], CONFIG_SYS_DSPI_CTAR6);
+#endif
+#ifdef CONFIG_SYS_DSPI_CTAR7
+	dspi_write32(&dspislave->regs->ctar[7], CONFIG_SYS_DSPI_CTAR7);
+#endif
+
+	tmp = (prescaler[3] * scaler[15]);
+#if defined(CONFIG_VF610) || defined(CONFIG_LS102XA)
+	bus_clk = mxc_get_clock(MXC_DSPI_CLK);
+#else
+	bus_clk = get_dspi_clk();
+#endif
+	/* Maximum and minimum baudrate it can handle */
+	if ((dspislave->baudrate > (bus_clk >> 1)) ||
+	    (dspislave->baudrate < (bus_clk / tmp))) {
+		printf("Exceed baudrate limitation: Max %d - Min %d\n",
+		       (int)(bus_clk >> 1), (int)(bus_clk / tmp));
+		return NULL;
+	}
+
+	/* Activate Double Baud when it exceed 1/4 the bus clk */
+	if ((CONFIG_SYS_DSPI_CTAR0 & DSPI_CTAR_DBR) ||
+	    (dspislave->baudrate > (bus_clk / (prescaler[0] * scaler[0])))) {
+		bus_setup |= DSPI_CTAR_DBR;
+		dbr = 1;
+	}
+
+	if (mode & SPI_CPOL)
+		bus_setup |= DSPI_CTAR_CPOL;
+	if (mode & SPI_CPHA)
+		bus_setup |= DSPI_CTAR_CPHA;
+	if (mode & SPI_LSB_FIRST)
+		bus_setup |= DSPI_CTAR_LSBFE;
+
+	/* Overwrite default value set in platform configuration file */
+	if (mode & SPI_MODE_MOD) {
+
+		if ((mode & 0xF0000000) == 0)
+			bus_setup |=
+			    dspi_read32(&dspislave->regs->
+				ctar[dspislave->slave.cs])
+			    & 0x78000000;
+		else
+			bus_setup |= ((mode & 0xF0000000) >> 1);
+
+		/*
+		 * Check to see if it is enabled by default in platform
+		 * config, or manual setting passed by mode parameter
+		 */
+		if (mode & SPI_DBLRATE) {
+			bus_setup |= DSPI_CTAR_DBR;
+			dbr = 1;
+		}
+		bus_setup |= (mode & 0x0FC00000) >> 4;	/* PSCSCK, PASC, PDT */
+		bus_setup |= (mode & 0x000FFF00) >> 4;	/* CSSCK, ASC, DT */
+	} else
+		bus_setup |=
+			dspi_read32(&dspislave->regs->ctar[dspislave->slave.cs])
+			& 0x78FCFFF0;
+
+	dspislave->charbit =
+	    ((dspi_read32(&dspislave->regs->ctar[dspislave->slave.cs])
+	    & 0x78000000)
+	    == 0x78000000) ? 16 : 8;
+
+	pbrcnt = sizeof(prescaler) / sizeof(int);
+	brcnt = sizeof(scaler) / sizeof(int);
+
+	/* baudrate calculation - to closer value, may not be exact match */
+	for (best_i = 0, best_j = 0, i = 0; i < pbrcnt; i++) {
+		baud_speed = bus_clk / prescaler[i];
+		for (j = 0; j < brcnt; j++) {
+			tmp = (baud_speed / scaler[j]) * (1 + dbr);
+
+			if (tmp > dspislave->baudrate)
+				diff = tmp - dspislave->baudrate;
+			else
+				diff = dspislave->baudrate - tmp;
+
+			if (diff < bestmatch) {
+				bestmatch = diff;
+				best_i = i;
+				best_j = j;
+			}
+		}
+	}
+
+	bus_setup |= (DSPI_CTAR_PBR(best_i) | DSPI_CTAR_BR(best_j));
+	dspi_write32(&dspislave->regs->ctar[dspislave->slave.cs], bus_setup);
+
+	return &dspislave->slave;
+}
+#endif				/* CONFIG_FSL_DSPI */
+
+void spi_init_f(void)
+{
+}
+
+void spi_init_r(void)
+{
+}
+
+void dspi_init(void)
+{
+}
+
+
+void dspi_free_slave(struct spi_slave *slave)
+{
+	free(slave);
+}
+
+int dspi_claim_bus(struct spi_slave *slave)
+{
+#if defined(CONFIG_VF610) || defined(CONFIG_LS102XA)
+	return 0;
+#else
+	return cfspi_claim_bus(slave->bus, slave->cs);
+#endif
+}
+
+void dspi_release_bus(struct spi_slave *slave)
+{
+#if !defined(CONFIG_VF610) && !defined(CONFIG_LS102XA)
+	cfspi_release_bus(slave->bus, slave->cs);
+#endif
+}
+
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_epu.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_epu.h	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_EPU_H
+#define __FSL_EPU_H
+
+#include <asm/types.h>
+
+#define FSL_STRIDE_4B	4
+#define FSL_STRIDE_8B	8
+
+/* Block offsets */
+#define EPU_BLOCK_OFFSET	0x00000000
+
+/* EPGCR (Event Processor Global Control Register) */
+#define EPGCR		0x000
+
+/* EPEVTCR0-9 (Event Processor EVT Pin Control Registers) */
+#define EPEVTCR0	0x050
+#define EPEVTCR9	0x074
+#define EPEVTCR_STRIDE	FSL_STRIDE_4B
+
+/* EPXTRIGCR (Event Processor Crosstrigger Control Register) */
+#define EPXTRIGCR	0x090
+
+/* EPIMCR0-31 (Event Processor Input Mux Control Registers) */
+#define EPIMCR0		0x100
+#define EPIMCR31	0x17C
+#define EPIMCR_STRIDE	FSL_STRIDE_4B
+
+/* EPSMCR0-15 (Event Processor SCU Mux Control Registers) */
+#define EPSMCR0		0x200
+#define EPSMCR15	0x278
+#define EPSMCR_STRIDE	FSL_STRIDE_8B
+
+/* EPECR0-15 (Event Processor Event Control Registers) */
+#define EPECR0		0x300
+#define EPECR15		0x33C
+#define EPECR_STRIDE	FSL_STRIDE_4B
+
+/* EPACR0-15 (Event Processor Action Control Registers) */
+#define EPACR0		0x400
+#define EPACR15		0x43C
+#define EPACR_STRIDE	FSL_STRIDE_4B
+
+/* EPCCRi0-15 (Event Processor Counter Control Registers) */
+#define EPCCR0		0x800
+#define EPCCR15		0x83C
+#define EPCCR31		0x87C
+#define EPCCR_STRIDE	FSL_STRIDE_4B
+
+/* EPCMPR0-15 (Event Processor Counter Compare Registers) */
+#define EPCMPR0		0x900
+#define EPCMPR15	0x93C
+#define EPCMPR31	0x97C
+#define EPCMPR_STRIDE	FSL_STRIDE_4B
+
+/* EPCTR0-31 (Event Processor Counter Register) */
+#define EPCTR0		0xA00
+#define EPCTR31		0xA7C
+#define EPCTR_STRIDE	FSL_STRIDE_4B
+
+void fsl_epu_clean(void *epu_base);
+
+#endif
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/ls102xa_serdes.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/ls102xa_serdes.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/immap_ls102xa.h>
+
+static u8 serdes_cfg_tbl[][SRDS_MAX_LANES] = {
+	[0x00] = {PCIE1, PCIE1, PCIE1, PCIE1},
+	[0x10] = {PCIE1, SATA1, PCIE2, PCIE2},
+	[0x20] = {PCIE1, SGMII_TSEC1, PCIE2, SGMII_TSEC2},
+	[0x30] = {PCIE1, SATA1, SGMII_TSEC1, SGMII_TSEC2},
+	[0x40] = {PCIE1, PCIE1, SATA1, SGMII_TSEC2},
+	[0x50] = {PCIE1, PCIE1, PCIE2, SGMII_TSEC2},
+	[0x60] = {PCIE1, PCIE1, SGMII_TSEC1, SGMII_TSEC2},
+	[0x70] = {PCIE1, SATA1, PCIE2, SGMII_TSEC2},
+	[0x80] = {PCIE2, PCIE2, PCIE2, PCIE2},
+};
+
+enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane)
+{
+	return serdes_cfg_tbl[cfg][lane];
+}
+
+int is_serdes_prtcl_valid(int serdes, u32 prtcl)
+{
+	int i;
+
+	if (prtcl >= ARRAY_SIZE(serdes_cfg_tbl))
+		return 0;
+
+	for (i = 0; i < SRDS_MAX_LANES; i++) {
+		if (serdes_cfg_tbl[prtcl][i] != NONE)
+			return 1;
+	}
+
+	return 0;
+}
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_ls1_serdes.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_ls1_serdes.h	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_LS1_SERDES_H
+#define __FSL_LS1_SERDES_H
+
+int is_serdes_prtcl_valid(int serdes, u32 prtcl);
+int serdes_lane_enabled(int lane);
+#endif /* __FSL_LS1_SERDES_H */
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fdt.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fdt.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <asm/arch/clock.h>
+#include <asm/nonsecure.h>
+#include <linux/ctype.h>
+#ifdef CONFIG_FSL_ESDHC
+#include <fsl_esdhc.h>
+#endif
+#include <tsec.h>
+#include <asm/arch/immap_ls102xa.h>
+#include <fsl_sec.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void ft_fixup_enet_phy_connect_type(void *fdt)
+{
+	struct eth_device *dev;
+	struct tsec_private *priv;
+	const char *enet_path, *phy_path;
+	char enet[16];
+	char phy[16];
+	int phy_node;
+	int i = 0;
+	int enet_id = 0;
+	uint32_t ph;
+
+	while ((dev = eth_get_dev_by_index(i++)) != NULL) {
+		if (strstr(dev->name, "eTSEC1"))
+			enet_id = 0;
+		else if (strstr(dev->name, "eTSEC2"))
+			enet_id = 1;
+		else if (strstr(dev->name, "eTSEC3"))
+			enet_id = 2;
+		else
+			continue;
+
+		priv = dev->priv;
+		if (priv->flags & TSEC_SGMII)
+			continue;
+
+		sprintf(enet, "ethernet%d", enet_id);
+		enet_path = fdt_get_alias(fdt, enet);
+		if (!enet_path)
+			continue;
+
+		sprintf(phy, "enet%d_rgmii_phy", enet_id);
+		phy_path = fdt_get_alias(fdt, phy);
+		if (!phy_path)
+			continue;
+
+		phy_node = fdt_path_offset(fdt, phy_path);
+		if (phy_node < 0)
+			continue;
+
+		ph = fdt_create_phandle(fdt, phy_node);
+		if (ph)
+			do_fixup_by_path_u32(fdt, enet_path,
+					     "phy-handle", ph, 1);
+
+		do_fixup_by_path(fdt, enet_path, "phy-connection-type",
+				 phy_string_for_interface(
+				 PHY_INTERFACE_MODE_RGMII_ID),
+				 sizeof(phy_string_for_interface(
+				 PHY_INTERFACE_MODE_RGMII_ID)),
+				 1);
+	}
+}
+
+void ft_cpu_setup(void *blob, bd_t *bd)
+{
+	int off;
+	int val;
+	const char *sysclk_path;
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	unsigned int svr;
+	svr = in_be32(&gur->svr);
+
+	unsigned long busclk = get_bus_freq(0);
+
+	/* delete crypto node if not on an E-processor */
+	if (!IS_E_PROCESSOR(svr))
+		fdt_fixup_crypto_node(blob, 0);
+#if CONFIG_SYS_FSL_SEC_COMPAT >= 4
+	else {
+		ccsr_sec_t __iomem *sec;
+
+		sec = (void __iomem *)CONFIG_SYS_FSL_SEC_ADDR;
+		fdt_fixup_crypto_node(blob, sec_in32(&sec->secvid_ms));
+	}
+#endif
+
+	fdt_fixup_ethernet(blob);
+
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
+	fdt_add_non_sec_mem_rsv(blob);
+#endif
+
+	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
+	while (off != -FDT_ERR_NOTFOUND) {
+		val = gd->cpu_clk;
+		fdt_setprop(blob, off, "clock-frequency", &val, 4);
+		off = fdt_node_offset_by_prop_value(blob, off,
+						    "device_type", "cpu", 4);
+	}
+
+	do_fixup_by_prop_u32(blob, "device_type", "soc",
+			     4, "bus-frequency", busclk, 1);
+
+	ft_fixup_enet_phy_connect_type(blob);
+
+#ifdef CONFIG_SYS_NS16550
+	do_fixup_by_compat_u32(blob, "fsl,16550-FIFO64",
+			       "clock-frequency", CONFIG_SYS_NS16550_CLK, 1);
+#endif
+
+	sysclk_path = fdt_get_alias(blob, "sysclk");
+	if (sysclk_path)
+		do_fixup_by_path_u32(blob, sysclk_path, "clock-frequency",
+				     CONFIG_SYS_CLK_FREQ, 1);
+	do_fixup_by_compat_u32(blob, "fsl,qoriq-sysclk-2.0",
+			       "clock-frequency", CONFIG_SYS_CLK_FREQ, 1);
+
+#if defined(CONFIG_FSL_ESDHC)
+	fdt_fixup_esdhc(blob, bd);
+#endif
+
+	/*
+	 * platform bus clock = system bus clock/2
+	 * Here busclk = system bus clock
+	 * We are using the platform bus clock as 1588 Timer reference
+	 * clock source select
+	 */
+	do_fixup_by_compat_u32(blob, "fsl, gianfar-ptp-timer",
+			       "timer-frequency", busclk / 2, 1);
+
+	/*
+	 * clock-freq should change to clock-frequency and
+	 * flexcan-v1.0 should change to p1010-flexcan respectively
+	 * in the future.
+	 */
+	do_fixup_by_compat_u32(blob, "fsl, flexcan-v1.0",
+			       "clock_freq", busclk / 2, 1);
+
+	do_fixup_by_compat_u32(blob, "fsl, flexcan-v1.0",
+			       "clock-frequency", busclk / 2, 1);
+
+	do_fixup_by_compat_u32(blob, "fsl, ls1021a-flexcan",
+			       "clock-frequency", busclk / 2, 1);
+}
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/timer.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/timer.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <div64.h>
+#include <asm/arch/immap_ls102xa.h>
+#include <asm/arch/clock.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * This function is intended for SHORT delays only.
+ * It will overflow at around 10 seconds @ 400MHz,
+ * or 20 seconds @ 200MHz.
+ */
+unsigned long usec2ticks(unsigned long usec)
+{
+	ulong ticks;
+
+	if (usec < 1000)
+		ticks = ((usec * (get_tbclk()/1000)) + 500) / 1000;
+	else
+		ticks = ((usec / 10) * (get_tbclk() / 100000));
+
+	return ticks;
+}
+
+static inline unsigned long long tick_to_time(unsigned long long tick)
+{
+	unsigned long freq;
+
+	asm volatile("mrc p15, 0, %0, c14, c0, 0" : "=r" (freq));
+
+	tick *= CONFIG_SYS_HZ;
+	do_div(tick, freq);
+
+	return tick;
+}
+
+static inline unsigned long long us_to_tick(unsigned long long usec)
+{
+	unsigned long freq;
+
+	asm volatile("mrc p15, 0, %0, c14, c0, 0" : "=r" (freq));
+
+	usec = usec * freq  + 999999;
+	do_div(usec, 1000000);
+
+	return usec;
+}
+
+int timer_init(void)
+{
+	struct sctr_regs *sctr = (struct sctr_regs *)SCTR_BASE_ADDR;
+	unsigned long ctrl, val, freq;
+
+	/* Enable System Counter */
+	writel(SYS_COUNTER_CTRL_ENABLE, &sctr->cntcr);
+
+	freq = GENERIC_TIMER_CLK;
+	asm("mcr p15, 0, %0, c14, c0, 0" : : "r" (freq));
+
+	/* Set PL1 Physical Timer Ctrl */
+	ctrl = ARCH_TIMER_CTRL_ENABLE;
+	asm("mcr p15, 0, %0, c14, c2, 1" : : "r" (ctrl));
+
+	/* Set PL1 Physical Comp Value */
+	val = TIMER_COMP_VAL;
+	asm("mcrr p15, 2, %Q0, %R0, c14" : : "r" (val));
+
+	gd->arch.tbl = 0;
+	gd->arch.tbu = 0;
+
+	return 0;
+}
+
+unsigned long long get_ticks(void)
+{
+	unsigned long long now;
+
+	asm("mrrc p15, 0, %Q0, %R0, c14" : "=r" (now));
+
+	gd->arch.tbl = (unsigned long)(now & 0xffffffff);
+	gd->arch.tbu = (unsigned long)(now >> 32);
+
+	return now;
+}
+
+unsigned long get_timer_masked(void)
+{
+	return tick_to_time(get_ticks());
+}
+
+unsigned long get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+/* delay x useconds and preserve advance timstamp value */
+void __udelay(unsigned long usec)
+{
+	unsigned long long start;
+	unsigned long tmo;
+
+	start = get_ticks();			/* get current timestamp */
+	tmo = us_to_tick(usec);			/* convert usecs to ticks */
+
+	while ((get_ticks() - start) < tmo)
+		;				/* loop till time has passed */
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+unsigned long get_tbclk(void)
+{
+	unsigned long freq;
+
+	asm volatile("mrc p15, 0, %0, c14, c0, 0" : "=r" (freq));
+
+	return freq;
+}
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_epu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_epu.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#include "fsl_epu.h"
+
+/**
+ * fsl_epu_clean - Clear EPU registers
+ */
+void fsl_epu_clean(void *epu_base)
+{
+	u32 offset;
+
+	/* follow the exact sequence to clear the registers */
+	/* Clear EPACRn */
+	for (offset = EPACR0; offset <= EPACR15; offset += EPACR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPEVTCRn */
+	for (offset = EPEVTCR0; offset <= EPEVTCR9; offset += EPEVTCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPGCR */
+	out_be32(epu_base + EPGCR, 0);
+
+	/* Clear EPSMCRn */
+	for (offset = EPSMCR0; offset <= EPSMCR15; offset += EPSMCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPCCRn */
+	for (offset = EPCCR0; offset <= EPCCR31; offset += EPCCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPCMPRn */
+	for (offset = EPCMPR0; offset <= EPCMPR31; offset += EPCMPR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPCTRn */
+	for (offset = EPCTR0; offset <= EPCTR31; offset += EPCTR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPIMCRn */
+	for (offset = EPIMCR0; offset <= EPIMCR31; offset += EPIMCR_STRIDE)
+		out_be32(epu_base + offset, 0);
+
+	/* Clear EPXTRIGCRn */
+	out_be32(epu_base + EPXTRIGCR, 0);
+
+	/* Clear EPECRn */
+	for (offset = EPECR0; offset <= EPECR15; offset += EPECR_STRIDE)
+		out_be32(epu_base + offset, 0);
+}
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/Makefile	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,14 @@
+#
+# Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y	+= cpu.o
+obj-y	+= clock.o
+obj-y	+= timer.o
+obj-y	+= fsl_epu.o
+
+obj-$(CONFIG_OF_LIBFDT) += fdt.o
+obj-$(CONFIG_SYS_HAS_SERDES) += fsl_ls1_serdes.o ls102xa_serdes.o
+obj-$(CONFIG_SPL) += spl.o
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/cpu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/cpu.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/clock.h>
+#include <asm/io.h>
+#include <asm/arch/immap_ls102xa.h>
+#include <tsec.h>
+#include <netdev.h>
+#include <fsl_esdhc.h>
+
+#include "fsl_epu.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_DISPLAY_CPUINFO)
+int print_cpuinfo(void)
+{
+	char buf1[32], buf2[32];
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	unsigned int svr, major, minor, ver, i;
+
+	svr = in_be32(&gur->svr);
+	major = SVR_MAJ(svr);
+	minor = SVR_MIN(svr);
+
+	puts("CPU:   Freescale LayerScape ");
+
+	ver = SVR_SOC_VER(svr);
+	switch (ver) {
+	case SOC_VER_SLS1020:
+		puts("SLS1020");
+		break;
+	case SOC_VER_LS1020:
+		puts("LS1020");
+		break;
+	case SOC_VER_LS1021:
+		puts("LS1021");
+		break;
+	case SOC_VER_LS1022:
+		puts("LS1022");
+		break;
+	default:
+		puts("Unknown");
+		break;
+	}
+
+	if (IS_E_PROCESSOR(svr) && (ver != SOC_VER_SLS1020))
+		puts("E");
+
+	printf(", Version: %d.%d, (0x%08x)\n", major, minor, svr);
+
+	puts("Clock Configuration:");
+
+	printf("\n       CPU0(ARMV7):%-4s MHz, ", strmhz(buf1, gd->cpu_clk));
+	printf("\n       Bus:%-4s MHz, ", strmhz(buf1, gd->bus_clk));
+	printf("DDR:%-4s MHz (%s MT/s data rate), ",
+	       strmhz(buf1, gd->mem_clk/2), strmhz(buf2, gd->mem_clk));
+	puts("\n");
+
+	/* Display the RCW, so that no one gets confused as to what RCW
+	 * we're actually using for this boot.
+	 */
+	puts("Reset Configuration Word (RCW):");
+	for (i = 0; i < ARRAY_SIZE(gur->rcwsr); i++) {
+		u32 rcw = in_be32(&gur->rcwsr[i]);
+
+		if ((i % 4) == 0)
+			printf("\n       %08x:", i * 4);
+		printf(" %08x", rcw);
+	}
+	puts("\n");
+
+	return 0;
+}
+#endif
+
+void enable_caches(void)
+{
+#ifndef CONFIG_SYS_ICACHE_OFF
+	icache_enable();
+#endif
+#ifndef CONFIG_SYS_DCACHE_OFF
+	dcache_enable();
+#endif
+}
+
+#ifdef CONFIG_FSL_ESDHC
+int cpu_mmc_init(bd_t *bis)
+{
+	return fsl_esdhc_mmc_init(bis);
+}
+#endif
+
+int cpu_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_TSEC_ENET
+	tsec_standard_init(bis);
+#endif
+
+	return 0;
+}
+
+#if defined(CONFIG_ARMV7_NONSEC) || defined(CONFIG_ARMV7_VIRT)
+/* Setting the address at which secondary cores start from.*/
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+
+	/* After setting the secondary cores start address, just release
+	 * them to boot.
+	 */
+	out_be32(&gur->scratchrw[0], addr);
+	out_be32(&gur->brrl, 0x2);
+}
+#endif
+
+int arch_cpu_init(void)
+{
+	void *epu_base = (void *)(CONFIG_SYS_DCSRBAR + EPU_BLOCK_OFFSET);
+
+	/*
+	 * After wakeup from deep sleep, Clear EPU registers
+	 * as early as possible to prevent from possible issue.
+	 * It's also safe to clear at normal boot.
+	 */
+	fsl_epu_clean(epu_base);
+
+	return 0;
+}
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/clock.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/clock.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/immap_ls102xa.h>
+#include <asm/arch/clock.h>
+#include <fsl_ifc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_SYS_FSL_NUM_CC_PLLS
+#define CONFIG_SYS_FSL_NUM_CC_PLLS      2
+#endif
+
+void get_sys_info(struct sys_info *sys_info)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+#ifdef CONFIG_FSL_IFC
+	struct fsl_ifc *ifc_regs = (void *)CONFIG_SYS_IFC_ADDR;
+	u32 ccr;
+#endif
+	struct ccsr_clk *clk = (void *)(CONFIG_SYS_FSL_LS1_CLK_ADDR);
+	unsigned int cpu;
+	const u8 core_cplx_pll[6] = {
+		[0] = 0,	/* CC1 PPL / 1 */
+		[1] = 0,	/* CC1 PPL / 2 */
+		[4] = 1,	/* CC2 PPL / 1 */
+		[5] = 1,	/* CC2 PPL / 2 */
+	};
+
+	const u8 core_cplx_pll_div[6] = {
+		[0] = 1,	/* CC1 PPL / 1 */
+		[1] = 2,	/* CC1 PPL / 2 */
+		[4] = 1,	/* CC2 PPL / 1 */
+		[5] = 2,	/* CC2 PPL / 2 */
+	};
+
+	uint i;
+	uint freq_c_pll[CONFIG_SYS_FSL_NUM_CC_PLLS];
+	uint ratio[CONFIG_SYS_FSL_NUM_CC_PLLS];
+	unsigned long sysclk = CONFIG_SYS_CLK_FREQ;
+
+	sys_info->freq_systembus = sysclk;
+#ifdef CONFIG_DDR_CLK_FREQ
+	sys_info->freq_ddrbus = CONFIG_DDR_CLK_FREQ;
+#else
+	sys_info->freq_ddrbus = sysclk;
+#endif
+
+	sys_info->freq_systembus *= (in_be32(&gur->rcwsr[0]) >>
+		RCWSR0_SYS_PLL_RAT_SHIFT) & RCWSR0_SYS_PLL_RAT_MASK;
+	sys_info->freq_ddrbus *= (in_be32(&gur->rcwsr[0]) >>
+		RCWSR0_MEM_PLL_RAT_SHIFT) & RCWSR0_MEM_PLL_RAT_MASK;
+
+	for (i = 0; i < CONFIG_SYS_FSL_NUM_CC_PLLS; i++) {
+		ratio[i] = (in_be32(&clk->pllcgsr[i].pllcngsr) >> 1) & 0x3f;
+		if (ratio[i] > 4)
+			freq_c_pll[i] = sysclk * ratio[i];
+		else
+			freq_c_pll[i] = sys_info->freq_systembus * ratio[i];
+	}
+
+	for (cpu = 0; cpu < CONFIG_MAX_CPUS; cpu++) {
+		u32 c_pll_sel = (in_be32(&clk->clkcsr[cpu].clkcncsr) >> 27)
+				& 0xf;
+		u32 cplx_pll = core_cplx_pll[c_pll_sel];
+
+		sys_info->freq_processor[cpu] =
+			freq_c_pll[cplx_pll] / core_cplx_pll_div[c_pll_sel];
+	}
+
+#if defined(CONFIG_FSL_IFC)
+	ccr = in_be32(&ifc_regs->ifc_ccr);
+	ccr = ((ccr & IFC_CCR_CLK_DIV_MASK) >> IFC_CCR_CLK_DIV_SHIFT) + 1;
+
+	sys_info->freq_localbus = sys_info->freq_systembus / ccr;
+#endif
+}
+
+int get_clocks(void)
+{
+	struct sys_info sys_info;
+
+	get_sys_info(&sys_info);
+	gd->cpu_clk = sys_info.freq_processor[0];
+	gd->bus_clk = sys_info.freq_systembus;
+	gd->mem_clk = sys_info.freq_ddrbus * 2;
+
+#if defined(CONFIG_FSL_ESDHC)
+	gd->arch.sdhc_clk = gd->bus_clk;
+#endif
+
+	return 0;
+}
+
+ulong get_bus_freq(ulong dummy)
+{
+	return gd->bus_clk;
+}
+
+ulong get_ddr_freq(ulong dummy)
+{
+	return gd->mem_clk;
+}
+
+int get_serial_clock(void)
+{
+	return gd->bus_clk / 2;
+}
+
+unsigned int mxc_get_clock(enum mxc_clock clk)
+{
+	switch (clk) {
+	case MXC_I2C_CLK:
+		return get_bus_freq(0) / 2;
+	case MXC_ESDHC_CLK:
+		return get_bus_freq(0);
+	case MXC_DSPI_CLK:
+		return get_bus_freq(0) / 2;
+	case MXC_UART_CLK:
+		return get_bus_freq(0) / 2;
+	default:
+		printf("Unsupported clock\n");
+	}
+	return 0;
+}
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_ls1_serdes.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/fsl_ls1_serdes.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/immap_ls102xa.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include "fsl_ls1_serdes.h"
+
+#ifdef CONFIG_SYS_FSL_SRDS_1
+static u64 serdes1_prtcl_map;
+#endif
+#ifdef CONFIG_SYS_FSL_SRDS_2
+static u64 serdes2_prtcl_map;
+#endif
+
+int is_serdes_configured(enum srds_prtcl device)
+{
+	u64 ret = 0;
+
+#ifdef CONFIG_SYS_FSL_SRDS_1
+	ret |= (1ULL << device) & serdes1_prtcl_map;
+#endif
+#ifdef CONFIG_SYS_FSL_SRDS_2
+	ret |= (1ULL << device) & serdes2_prtcl_map;
+#endif
+
+	return !!ret;
+}
+
+int serdes_get_first_lane(u32 sd, enum srds_prtcl device)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 cfg = in_be32(&gur->rcwsr[4]);
+	int i;
+
+	switch (sd) {
+#ifdef CONFIG_SYS_FSL_SRDS_1
+	case FSL_SRDS_1:
+		cfg &= RCWSR4_SRDS1_PRTCL_MASK;
+		cfg >>= RCWSR4_SRDS1_PRTCL_SHIFT;
+		break;
+#endif
+#ifdef CONFIG_SYS_FSL_SRDS_2
+	case FSL_SRDS_2:
+		cfg &= RCWSR4_SRDS2_PRTCL_MASK;
+		cfg >>= RCWSR4_SRDS2_PRTCL_SHIFT;
+		break;
+#endif
+	default:
+		printf("invalid SerDes%d\n", sd);
+		break;
+	}
+	/* Is serdes enabled at all? */
+	if (unlikely(cfg == 0))
+		return -ENODEV;
+
+	for (i = 0; i < SRDS_MAX_LANES; i++) {
+		if (serdes_get_prtcl(sd, cfg, i) == device)
+			return i;
+	}
+
+	return -ENODEV;
+}
+
+u64 serdes_init(u32 sd, u32 sd_addr, u32 sd_prctl_mask, u32 sd_prctl_shift)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u64 serdes_prtcl_map = 0;
+	u32 cfg;
+	int lane;
+
+	cfg = in_be32(&gur->rcwsr[4]) & sd_prctl_mask;
+	cfg >>= sd_prctl_shift;
+	printf("Using SERDES%d Protocol: %d (0x%x)\n", sd + 1, cfg, cfg);
+
+	if (!is_serdes_prtcl_valid(sd, cfg))
+		printf("SERDES%d[PRTCL] = 0x%x is not valid\n", sd + 1, cfg);
+
+	for (lane = 0; lane < SRDS_MAX_LANES; lane++) {
+		enum srds_prtcl lane_prtcl = serdes_get_prtcl(sd, cfg, lane);
+
+		serdes_prtcl_map |= (1ULL << lane_prtcl);
+	}
+
+	return serdes_prtcl_map;
+}
+
+void fsl_serdes_init(void)
+{
+#ifdef CONFIG_SYS_FSL_SRDS_1
+	serdes1_prtcl_map = serdes_init(FSL_SRDS_1,
+					CONFIG_SYS_FSL_SERDES_ADDR,
+					RCWSR4_SRDS1_PRTCL_MASK,
+					RCWSR4_SRDS1_PRTCL_SHIFT);
+#endif
+#ifdef CONFIG_SYS_FSL_SRDS_2
+	serdes2_prtcl_map = serdes_init(FSL_SRDS_2,
+					CONFIG_SYS_FSL_SERDES_ADDR +
+					FSL_SRDS_2 * 0x1000,
+					RCWSR4_SRDS2_PRTCL_MASK,
+					RCWSR4_SRDS2_PRTCL_SHIFT);
+#endif
+}
+
+const char *serdes_clock_to_string(u32 clock)
+{
+	switch (clock) {
+	case SRDS_PLLCR0_RFCK_SEL_100:
+		return "100";
+	case SRDS_PLLCR0_RFCK_SEL_125:
+		return "125";
+	default:
+		return "100";
+	}
+}
--- u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/spl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/cpu/armv7/ls102xa/spl.c	2022-05-09 14:06:22.641173312 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spl.h>
+
+u32 spl_boot_device(void)
+{
+#ifdef CONFIG_SPL_MMC_SUPPORT
+	return BOOT_DEVICE_MMC1;
+#endif
+	return BOOT_DEVICE_NAND;
+}
+
+u32 spl_boot_mode(void)
+{
+	switch (spl_boot_device()) {
+	case BOOT_DEVICE_MMC1:
+#ifdef CONFIG_SPL_FAT_SUPPORT
+		return MMCSD_MODE_FAT;
+#else
+		return MMCSD_MODE_RAW;
+#endif
+		break;
+	case BOOT_DEVICE_NAND:
+		return 0;
+		break;
+	default:
+		puts("spl: error: unsupported device\n");
+		hang();
+	}
+}
--- u-boot-2014.07/arch/arm/include/asm/nonsecure.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/nonsecure.h	2022-05-09 14:06:22.765168298 -0700
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ARM_NONSECURE_H_
+#define _ARM_NONSECURE_H_
+
+extern ulong non_sec_start;         /* start of image for smp spin table */
+extern ulong non_sec_end;         /* end of image for smp spin table */
+int fdt_add_non_sec_mem_rsv(void *blob);
+
+#endif /* _ARM_NONSECURE_H_ */
--- u-boot-2014.07/arch/arm/include/asm/fsl_secure_boot.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/fsl_secure_boot.h	2022-05-09 14:06:22.757168621 -0700
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_SECURE_BOOT_H
+#define __FSL_SECURE_BOOT_H
+
+#ifdef CONFIG_SECURE_BOOT
+
+/* The address needs to be modified according to NOR memory map */
+#define CONFIG_BOOTSCRIPT_HDR_ADDR	0x600a0000
+#define CONFIG_KEY_REVOCATION
+#define CONFIG_FSL_ISBC_KEY_EXT
+
+#include <config_fsl_secboot.h>
+#endif
+
+#endif
--- u-boot-2014.07/arch/arm/include/asm/pcie_layerscape.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/pcie_layerscape.h	2022-05-09 14:06:22.765168298 -0700
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __PCIE_LAYERSCAPE_H_
+#define __PCIE_LAYERSCAPE_H_
+
+void pci_init_board(void);
+void ft_pcie_setup(void *blob, bd_t *bd);
+
+#endif
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/imx-regs.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/imx-regs.h	2022-05-09 14:06:22.697171048 -0700
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+
+#ifndef __ASM_ARCH_IMX_REGS_H__
+#define __ASM_ARCH_IMX_REGS_H__
+
+#define I2C_QUIRK_REG	/* enable 8-bit driver */
+
+#ifdef CONFIG_LPUART_32B_REG
+struct lpuart_fsl {
+	u32 baud;
+	u32 stat;
+	u32 ctrl;
+	u32 data;
+	u32 match;
+	u32 modir;
+	u32 fifo;
+	u32 water;
+};
+#else
+struct lpuart_fsl {
+	u8 ubdh;
+	u8 ubdl;
+	u8 uc1;
+	u8 uc2;
+	u8 us1;
+	u8 us2;
+	u8 uc3;
+	u8 ud;
+	u8 uma1;
+	u8 uma2;
+	u8 uc4;
+	u8 uc5;
+	u8 ued;
+	u8 umodem;
+	u8 uir;
+	u8 reserved;
+	u8 upfifo;
+	u8 ucfifo;
+	u8 usfifo;
+	u8 utwfifo;
+	u8 utcfifo;
+	u8 urwfifo;
+	u8 urcfifo;
+	u8 rsvd[28];
+};
+#endif
+
+#endif /* __ASM_ARCH_IMX_REGS_H__ */
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/immap_ls102xa.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/immap_ls102xa.h	2022-05-09 14:06:22.697171048 -0700
@@ -0,0 +1,537 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_LS102XA_IMMAP_H_
+#define __ASM_ARCH_LS102XA_IMMAP_H_
+
+#define SVR_MAJ(svr)		(((svr) >>  4) & 0xf)
+#define SVR_MIN(svr)		(((svr) >>  0) & 0xf)
+#define SVR_SOC_VER(svr)	(((svr) >> 8) & 0x7ff)
+#define IS_E_PROCESSOR(svr)	(svr & 0x80000)
+
+#define SOC_VER_SLS1020		0x00
+#define SOC_VER_LS1020		0x10
+#define SOC_VER_LS1021		0x11
+#define SOC_VER_LS1022		0x12
+
+#define CCSR_BRR_OFFSET		0xe4
+#define CCSR_SCRATCHRW1_OFFSET	0x200
+
+#define RCWSR0_SYS_PLL_RAT_SHIFT	25
+#define RCWSR0_SYS_PLL_RAT_MASK		0x1f
+#define RCWSR0_MEM_PLL_RAT_SHIFT	16
+#define RCWSR0_MEM_PLL_RAT_MASK		0x3f
+
+#define RCWSR4_SRDS1_PRTCL_SHIFT	24
+#define RCWSR4_SRDS1_PRTCL_MASK		0xff000000
+
+#define TIMER_COMP_VAL			0xffffffff
+#define ARCH_TIMER_CTRL_ENABLE		(1 << 0)
+#define SYS_COUNTER_CTRL_ENABLE		(1 << 24)
+
+#define DCFG_CCSR_PORSR1_RCW_MASK	0xff800000
+
+/*
+ * Define default values for some CCSR macros to make header files cleaner*
+ *
+ * To completely disable CCSR relocation in a board header file, define
+ * CONFIG_SYS_CCSR_DO_NOT_RELOCATE.  This will force CONFIG_SYS_CCSRBAR_PHYS
+ * to a value that is the same as CONFIG_SYS_CCSRBAR.
+ */
+
+#ifdef CONFIG_SYS_CCSRBAR_PHYS
+#error "Do not define CONFIG_SYS_CCSRBAR_PHYS directly."
+#endif
+
+#ifdef CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#undef CONFIG_SYS_CCSRBAR_PHYS_HIGH
+#undef CONFIG_SYS_CCSRBAR_PHYS_LOW
+#define CONFIG_SYS_CCSRBAR_PHYS_HIGH	0
+#endif
+
+#ifndef CONFIG_SYS_CCSRBAR
+#define CONFIG_SYS_CCSRBAR		CONFIG_SYS_IMMR
+#endif
+
+#ifndef CONFIG_SYS_CCSRBAR_PHYS_HIGH
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_CCSRBAR_PHYS_HIGH	0xf
+#else
+#define CONFIG_SYS_CCSRBAR_PHYS_HIGH	0
+#endif
+#endif
+
+#ifndef CONFIG_SYS_CCSRBAR_PHYS_LOW
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW	CONFIG_SYS_IMMR
+#endif
+
+#define CONFIG_SYS_CCSRBAR_PHYS ((CONFIG_SYS_CCSRBAR_PHYS_HIGH * 1ull) << 32 | \
+				 CONFIG_SYS_CCSRBAR_PHYS_LOW)
+
+struct sys_info {
+	unsigned long freq_processor[CONFIG_MAX_CPUS];
+	unsigned long freq_systembus;
+	unsigned long freq_ddrbus;
+	unsigned long freq_localbus;
+};
+
+/* Device Configuration and Pin Control */
+struct ccsr_gur {
+	u32     porsr1;         /* POR status 1 */
+	u32     porsr2;         /* POR status 2 */
+	u8      res_008[0x20-0x8];
+	u32     gpporcr1;       /* General-purpose POR configuration */
+	u32	gpporcr2;
+	u32     dcfg_fusesr;    /* Fuse status register */
+	u8      res_02c[0x70-0x2c];
+	u32     devdisr;        /* Device disable control */
+	u32     devdisr2;       /* Device disable control 2 */
+	u32     devdisr3;       /* Device disable control 3 */
+	u32     devdisr4;       /* Device disable control 4 */
+	u32     devdisr5;       /* Device disable control 5 */
+	u8      res_084[0x94-0x84];
+	u32     coredisru;      /* uppper portion for support of 64 cores */
+	u32     coredisrl;      /* lower portion for support of 64 cores */
+	u8      res_09c[0xa4-0x9c];
+	u32     svr;            /* System version */
+	u8	res_0a8[0xb0-0xa8];
+	u32	rstcr;		/* Reset control */
+	u32	rstrqpblsr;	/* Reset request preboot loader status */
+	u8	res_0b8[0xc0-0xb8];
+	u32	rstrqmr1;	/* Reset request mask */
+	u8	res_0c4[0xc8-0xc4];
+	u32	rstrqsr1;	/* Reset request status */
+	u8	res_0cc[0xd4-0xcc];
+	u32	rstrqwdtmrl;	/* Reset request WDT mask */
+	u8	res_0d8[0xdc-0xd8];
+	u32	rstrqwdtsrl;	/* Reset request WDT status */
+	u8	res_0e0[0xe4-0xe0];
+	u32	brrl;		/* Boot release */
+	u8      res_0e8[0x100-0xe8];
+	u32     rcwsr[16];      /* Reset control word status */
+	u8      res_140[0x200-0x140];
+	u32     scratchrw[4];  /* Scratch Read/Write */
+	u8      res_210[0x300-0x210];
+	u32     scratchw1r[4];  /* Scratch Read (Write once) */
+	u8      res_310[0x400-0x310];
+	u32	crstsr;
+	u8      res_404[0x550-0x404];
+	u32	sataliodnr;
+	u8	res_554[0x604-0x554];
+	u32	pamubypenr;
+	u32	dmacr1;
+	u8      res_60c[0x740-0x60c];   /* add more registers when needed */
+	u32     tp_ityp[64];    /* Topology Initiator Type Register */
+	struct {
+		u32     upper;
+		u32     lower;
+	} tp_cluster[1];        /* Core Cluster n Topology Register */
+	u8	res_848[0xe60-0x848];
+	u32	ddrclkdr;
+	u8	res_e60[0xe68-0xe64];
+	u32	ifcclkdr;
+	u8	res_e68[0xe80-0xe6c];
+	u32	sdhcpcr;
+};
+
+#define SCFG_ETSECDMAMCR_LE_BD_FR	0xf8001a0f
+#define SCFG_ETSECCMCR_GE2_CLK125	0x04000000
+#define SCFG_PIXCLKCR_PXCKEN		0x80000000
+#define SCFG_QSPI_CLKSEL		0xc0100000
+
+/* Supplemental Configuration Unit */
+struct ccsr_scfg {
+	u32 dpslpcr;
+	u32 resv0[2];
+	u32 etsecclkdpslpcr;
+	u32 resv1[5];
+	u32 fuseovrdcr;
+	u32 pixclkcr;
+	u32 resv2[5];
+	u32 spimsicr;
+	u32 resv3[6];
+	u32 pex1pmwrcr;
+	u32 pex1pmrdsr;
+	u32 resv4[3];
+	u32 usb3prm1cr;
+	u32 usb4prm2cr;
+	u32 pex1rdmsgpldlsbsr;
+	u32 pex1rdmsgpldmsbsr;
+	u32 pex2rdmsgpldlsbsr;
+	u32 pex2rdmsgpldmsbsr;
+	u32 pex1rdmmsgrqsr;
+	u32 pex2rdmmsgrqsr;
+	u32 spimsiclrcr;
+	u32 pex1mscportsr;
+	u32 pex2mscportsr;
+	u32 pex2pmwrcr;
+	u32 resv5[24];
+	u32 mac1_streamid;
+	u32 mac2_streamid;
+	u32 mac3_streamid;
+	u32 pex1_streamid;
+	u32 pex2_streamid;
+	u32 dma_streamid;
+	u32 sata_streamid;
+	u32 usb3_streamid;
+	u32 qe_streamid;
+	u32 sdhc_streamid;
+	u32 adma_streamid;
+	u32 letechsftrstcr;
+	u32 core0_sft_rst;
+	u32 core1_sft_rst;
+	u32 resv6[1];
+	u32 usb_hi_addr;
+	u32 etsecclkadjcr;
+	u32 sai_clk;
+	u32 resv7[1];
+	u32 dcu_streamid;
+	u32 usb2_streamid;
+	u32 ftm_reset;
+	u32 altcbar;
+	u32 qspi_cfg;
+	u32 pmcintecr;
+	u32 pmcintlecr;
+	u32 pmcintsr;
+	u32 qos1;
+	u32 qos2;
+	u32 qos3;
+	u32 cci_cfg;
+	u32 resv8[1];
+	u32 etsecdmamcr;
+	u32 usb3prm3cr;
+	u32 resv9[1];
+	u32 debug_streamid;
+	u32 resv10[5];
+	u32 snpcnfgcr;
+	u32 resv11[1];
+	u32 intpcr;
+	u32 resv12[20];
+	u32 scfgrevcr;
+	u32 coresrencr;
+	u32 pex2pmrdsr;
+	u32 ddrc1cr;
+	u32 ddrc2cr;
+	u32 ddrc3cr;
+	u32 ddrc4cr;
+	u32 ddrgcr;
+	u32 resv13[120];
+	u32 qeioclkcr;
+	u32 etsecmcr;
+	u32 sdhciovserlcr;
+	u32 resv14[61];
+	u32 sparecr[8];
+};
+
+/* Clocking */
+struct ccsr_clk {
+	struct {
+		u32 clkcncsr;	/* core cluster n clock control status */
+		u8  res_004[0x1c];
+	} clkcsr[2];
+	u8	res_040[0x7c0]; /* 0x100 */
+	struct {
+		u32 pllcngsr;
+		u8 res_804[0x1c];
+	} pllcgsr[2];
+	u8	res_840[0x1c0];
+	u32	clkpcsr;	/* 0xa00 Platform clock domain control/status */
+	u8	res_a04[0x1fc];
+	u32	pllpgsr;	/* 0xc00 Platform PLL General Status */
+	u8	res_c04[0x1c];
+	u32	plldgsr;	/* 0xc20 DDR PLL General Status */
+	u8	res_c24[0x3dc];
+};
+
+/* System Counter */
+struct sctr_regs {
+	u32 cntcr;
+	u32 cntsr;
+	u32 cntcv1;
+	u32 cntcv2;
+	u32 resv1[4];
+	u32 cntfid0;
+	u32 cntfid1;
+	u32 resv2[1002];
+	u32 counterid[12];
+};
+
+#define MAX_SERDES			1
+#define SRDS_MAX_LANES			4
+#define SRDS_MAX_BANK			2
+
+#define SRDS_RSTCTL_RST			0x80000000
+#define SRDS_RSTCTL_RSTDONE		0x40000000
+#define SRDS_RSTCTL_RSTERR		0x20000000
+#define SRDS_RSTCTL_SWRST		0x10000000
+#define SRDS_RSTCTL_SDEN		0x00000020
+#define SRDS_RSTCTL_SDRST_B		0x00000040
+#define SRDS_RSTCTL_PLLRST_B		0x00000080
+#define SRDS_PLLCR0_POFF		0x80000000
+#define SRDS_PLLCR0_RFCK_SEL_MASK	0x70000000
+#define SRDS_PLLCR0_RFCK_SEL_100	0x00000000
+#define SRDS_PLLCR0_RFCK_SEL_125	0x10000000
+#define SRDS_PLLCR0_RFCK_SEL_156_25	0x20000000
+#define SRDS_PLLCR0_RFCK_SEL_150	0x30000000
+#define SRDS_PLLCR0_RFCK_SEL_161_13	0x40000000
+#define SRDS_PLLCR0_RFCK_SEL_122_88	0x50000000
+#define SRDS_PLLCR0_PLL_LCK		0x00800000
+#define SRDS_PLLCR0_FRATE_SEL_MASK	0x000f0000
+#define SRDS_PLLCR0_FRATE_SEL_5		0x00000000
+#define SRDS_PLLCR0_FRATE_SEL_3_75	0x00050000
+#define SRDS_PLLCR0_FRATE_SEL_5_15	0x00060000
+#define SRDS_PLLCR0_FRATE_SEL_4		0x00070000
+#define SRDS_PLLCR0_FRATE_SEL_3_12	0x00090000
+#define SRDS_PLLCR0_FRATE_SEL_3		0x000a0000
+#define SRDS_PLLCR1_PLL_BWSEL		0x08000000
+
+struct ccsr_serdes {
+	struct {
+		u32	rstctl;	/* Reset Control Register */
+
+		u32	pllcr0; /* PLL Control Register 0 */
+
+		u32	pllcr1; /* PLL Control Register 1 */
+		u32	res_0c;	/* 0x00c */
+		u32	pllcr3;
+		u32	pllcr4;
+		u8	res_18[0x20-0x18];
+	} bank[2];
+	u8	res_40[0x90-0x40];
+	u32	srdstcalcr;	/* 0x90 TX Calibration Control */
+	u8	res_94[0xa0-0x94];
+	u32	srdsrcalcr;	/* 0xa0 RX Calibration Control */
+	u8	res_a4[0xb0-0xa4];
+	u32	srdsgr0;	/* 0xb0 General Register 0 */
+	u8	res_b4[0xe0-0xb4];
+	u32	srdspccr0;	/* 0xe0 Protocol Converter Config 0 */
+	u32	srdspccr1;	/* 0xe4 Protocol Converter Config 1 */
+	u32	srdspccr2;	/* 0xe8 Protocol Converter Config 2 */
+	u32	srdspccr3;	/* 0xec Protocol Converter Config 3 */
+	u32	srdspccr4;	/* 0xf0 Protocol Converter Config 4 */
+	u8	res_f4[0x100-0xf4];
+	struct {
+		u32	lnpssr;	/* 0x100, 0x120, ..., 0x1e0 */
+		u8	res_104[0x120-0x104];
+	} srdslnpssr[4];
+	u8	res_180[0x300-0x180];
+	u32	srdspexeqcr;
+	u32	srdspexeqpcr[11];
+	u8	res_330[0x400-0x330];
+	u32	srdspexapcr;
+	u8	res_404[0x440-0x404];
+	u32	srdspexbpcr;
+	u8	res_444[0x800-0x444];
+	struct {
+		u32	gcr0;	/* 0x800 General Control Register 0 */
+		u32	gcr1;	/* 0x804 General Control Register 1 */
+		u32	gcr2;	/* 0x808 General Control Register 2 */
+		u32	sscr0;
+		u32	recr0;	/* 0x810 Receive Equalization Control */
+		u32	recr1;
+		u32	tecr0;	/* 0x818 Transmit Equalization Control */
+		u32	sscr1;
+		u32	ttlcr0;	/* 0x820 Transition Tracking Loop Ctrl 0 */
+		u8	res_824[0x83c-0x824];
+		u32	tcsr3;
+	} lane[4];	/* Lane A, B, C, D, E, F, G, H */
+	u8	res_a00[0x1000-0xa00];	/* from 0xa00 to 0xfff */
+};
+
+#define DDR_SDRAM_CFG			0x470c0008
+#define DDR_CS0_BNDS			0x008000bf
+#define DDR_CS0_CONFIG			0x80014302
+#define DDR_TIMING_CFG_0		0x50550004
+#define DDR_TIMING_CFG_1		0xbcb38c56
+#define DDR_TIMING_CFG_2		0x0040d120
+#define DDR_TIMING_CFG_3		0x010e1000
+#define DDR_TIMING_CFG_4		0x00000001
+#define DDR_TIMING_CFG_5		0x03401400
+#define DDR_SDRAM_CFG_2			0x00401010
+#define DDR_SDRAM_MODE			0x00061c60
+#define DDR_SDRAM_MODE_2		0x00180000
+#define DDR_SDRAM_INTERVAL		0x18600618
+#define DDR_DDR_WRLVL_CNTL		0x8655f605
+#define DDR_DDR_WRLVL_CNTL_2		0x05060607
+#define DDR_DDR_WRLVL_CNTL_3		0x05050505
+#define DDR_DDR_CDR1			0x80040000
+#define DDR_DDR_CDR2			0x00000001
+#define DDR_SDRAM_CLK_CNTL		0x02000000
+#define DDR_DDR_ZQ_CNTL			0x89080600
+#define DDR_CS0_CONFIG_2		0
+#define DDR_SDRAM_CFG_MEM_EN		0x80000000
+
+/* DDR memory controller registers */
+struct ccsr_ddr {
+	u32 cs0_bnds;			/* Chip Select 0 Memory Bounds */
+	u32 resv1[1];
+	u32 cs1_bnds;			/* Chip Select 1 Memory Bounds */
+	u32 resv2[1];
+	u32 cs2_bnds;			/* Chip Select 2 Memory Bounds */
+	u32 resv3[1];
+	u32 cs3_bnds;			/* Chip Select 3 Memory Bounds */
+	u32 resv4[25];
+	u32 cs0_config;			/* Chip Select Configuration */
+	u32 cs1_config;			/* Chip Select Configuration */
+	u32 cs2_config;			/* Chip Select Configuration */
+	u32 cs3_config;			/* Chip Select Configuration */
+	u32 resv5[12];
+	u32 cs0_config_2;		/* Chip Select Configuration 2 */
+	u32 cs1_config_2;		/* Chip Select Configuration 2 */
+	u32 cs2_config_2;		/* Chip Select Configuration 2 */
+	u32 cs3_config_2;		/* Chip Select Configuration 2 */
+	u32 resv6[12];
+	u32 timing_cfg_3;		/* SDRAM Timing Configuration 3 */
+	u32 timing_cfg_0;		/* SDRAM Timing Configuration 0 */
+	u32 timing_cfg_1;		/* SDRAM Timing Configuration 1 */
+	u32 timing_cfg_2;		/* SDRAM Timing Configuration 2 */
+	u32 sdram_cfg;			/* SDRAM Control Configuration */
+	u32 sdram_cfg_2;		/* SDRAM Control Configuration 2 */
+	u32 sdram_mode;			/* SDRAM Mode Configuration */
+	u32 sdram_mode_2;		/* SDRAM Mode Configuration 2 */
+	u32 sdram_md_cntl;		/* SDRAM Mode Control */
+	u32 sdram_interval;		/* SDRAM Interval Configuration */
+	u32 sdram_data_init;		/* SDRAM Data initialization */
+	u32 resv7[1];
+	u32 sdram_clk_cntl;		/* SDRAM Clock Control */
+	u32 resv8[5];
+	u32 init_addr;			/* training init addr */
+	u32 init_ext_addr;		/* training init extended addr */
+	u32 resv9[4];
+	u32 timing_cfg_4;		/* SDRAM Timing Configuration 4 */
+	u32 timing_cfg_5;		/* SDRAM Timing Configuration 5 */
+	u32 timing_cfg_6;		/* SDRAM Timing Configuration 6 */
+	u32 timing_cfg_7;		/* SDRAM Timing Configuration 7 */
+	u32 ddr_zq_cntl;		/* ZQ calibration control*/
+	u32 ddr_wrlvl_cntl;		/* write leveling control*/
+	u32 resv10[1];
+	u32 ddr_sr_cntr;		/* self refresvh counter */
+	u32 ddr_sdram_rcw_1;		/* Control Words 1 */
+	u32 ddr_sdram_rcw_2;		/* Control Words 2 */
+	u32 resv11[2];
+	u32 ddr_wrlvl_cntl_2;		/* write leveling control 2 */
+	u32 ddr_wrlvl_cntl_3;		/* write leveling control 3 */
+	u32 resv12[2];
+	u32 ddr_sdram_rcw_3;		/* Control Words 3 */
+	u32 ddr_sdram_rcw_4;		/* Control Words 4 */
+	u32 ddr_sdram_rcw_5;		/* Control Words 5 */
+	u32 ddr_sdram_rcw_6;		/* Control Words 6 */
+	u32 resv13[20];
+	u32 sdram_mode_3;		/* SDRAM Mode Configuration 3 */
+	u32 sdram_mode_4;		/* SDRAM Mode Configuration 4 */
+	u32 sdram_mode_5;		/* SDRAM Mode Configuration 5 */
+	u32 sdram_mode_6;		/* SDRAM Mode Configuration 6 */
+	u32 sdram_mode_7;		/* SDRAM Mode Configuration 7 */
+	u32 sdram_mode_8;		/* SDRAM Mode Configuration 8 */
+	u32 sdram_mode_9;		/* SDRAM Mode Configuration 9 */
+	u32 sdram_mode_10;		/* SDRAM Mode Configuration 10 */
+	u32 sdram_mode_11;		/* SDRAM Mode Configuration 11 */
+	u32 sdram_mode_12;		/* SDRAM Mode Configuration 12 */
+	u32 sdram_mode_13;		/* SDRAM Mode Configuration 13 */
+	u32 sdram_mode_14;		/* SDRAM Mode Configuration 14 */
+	u32 sdram_mode_15;		/* SDRAM Mode Configuration 15 */
+	u32 sdram_mode_16;		/* SDRAM Mode Configuration 16 */
+	u32 resv14[4];
+	u32 timing_cfg_8;		/* SDRAM Timing Configuration 8 */
+	u32 timing_cfg_9;		/* SDRAM Timing Configuration 9 */
+	u32 resv15[2];
+	u32 sdram_cfg_3;		/* SDRAM Control Configuration 3 */
+	u32 resv16[15];
+	u32 deskew_cntl;		/* SDRAM Deskew Control */
+	u32 resv17[545];
+	u32 ddr_dsr1;			/* Debug Status 1 */
+	u32 ddr_dsr2;			/* Debug Status 2 */
+	u32 ddr_cdr1;			/* Control Driver 1 */
+	u32 ddr_cdr2;			/* Control Driver 2 */
+	u32 resv18[50];
+	u32 ip_rev1;			/* IP Block Revision 1 */
+	u32 ip_rev2;			/* IP Block Revision 2 */
+	u32 eor;			/* Enhanced Optimization Register */
+	u32 resv19[63];
+	u32 mtcr;			/* Memory Test Control Register */
+	u32 resv20[7];
+	u32 mtp1;			/* Memory Test Pattern 1 */
+	u32 mtp2;			/* Memory Test Pattern 2 */
+	u32 mtp3;			/* Memory Test Pattern 3 */
+	u32 mtp4;			/* Memory Test Pattern 4 */
+	u32 mtp5;			/* Memory Test Pattern 5 */
+	u32 mtp6;			/* Memory Test Pattern 6 */
+	u32 mtp7;			/* Memory Test Pattern 7 */
+	u32 mtp8;			/* Memory Test Pattern 8 */
+	u32 mtp9;			/* Memory Test Pattern 9 */
+	u32 mtp10;			/* Memory Test Pattern 10 */
+	u32 resv21[6];
+	u32 ddr_mt_st_ext_addr;		/* Memory Test Start Extended Address */
+	u32 ddr_mt_st_addr;		/* Memory Test Start Address */
+	u32 ddr_mt_end_ext_addr;	/* Memory Test End Extended Address */
+	u32 ddr_mt_end_addr;		/* Memory Test End Address */
+	u32 resv22[36];
+	u32 data_err_inject_hi;		/* Data Path Err Injection Mask High */
+	u32 data_err_inject_lo;		/* Data Path Err Injection Mask Low */
+	u32 ecc_err_inject;		/* Data Path Err Injection Mask ECC */
+	u32 resv23[5];
+	u32 capture_data_hi;		/* Data Path Read Capture High */
+	u32 capture_data_lo;		/* Data Path Read Capture Low */
+	u32 capture_ecc;		/* Data Path Read Capture ECC */
+	u32 resv24[5];
+	u32 err_detect;			/* Error Detect */
+	u32 err_disable;		/* Error Disable */
+	u32 err_int_en;
+	u32 capture_attributes;		/* Error Attrs Capture */
+	u32 capture_address;		/* Error Addr Capture */
+	u32 capture_ext_address;	/* Error Extended Addr Capture */
+	u32 err_sbe;			/* Single-Bit ECC Error Management */
+	u32 resv25[105];
+};
+
+#define CCI400_CTRLORD_TERM_BARRIER	0x00000008
+#define CCI400_CTRLORD_EN_BARRIER	0
+#define CCI400_SHAORD_NON_SHAREABLE	0x00000002
+#define CCI400_DVM_MESSAGE_REQ_EN	0x00000002
+#define CCI400_SNOOP_REQ_EN		0x00000001
+
+/* CCI-400 registers */
+struct ccsr_cci400 {
+	u32 ctrl_ord;			/* Control Override */
+	u32 spec_ctrl;			/* Speculation Control */
+	u32 secure_access;		/* Secure Access */
+	u32 status;			/* Status */
+	u32 impr_err;			/* Imprecise Error */
+	u8 res_14[0x100 - 0x14];
+	u32 pmcr;			/* Performance Monitor Control */
+	u8 res_104[0xfd0 - 0x104];
+	u32 pid[8];			/* Peripheral ID */
+	u32 cid[4];			/* Component ID */
+	struct {
+		u32 snoop_ctrl;		/* Snoop Control */
+		u32 sha_ord;		/* Shareable Override */
+		u8 res_1008[0x1100 - 0x1008];
+		u32 rc_qos_ord;		/* read channel QoS Value Override */
+		u32 wc_qos_ord;		/* read channel QoS Value Override */
+		u8 res_1108[0x110c - 0x1108];
+		u32 qos_ctrl;		/* QoS Control */
+		u32 max_ot;		/* Max OT */
+		u8 res_1114[0x1130 - 0x1114];
+		u32 target_lat;		/* Target Latency */
+		u32 latency_regu;	/* Latency Regulation */
+		u32 qos_range;		/* QoS Range */
+		u8 res_113c[0x2000 - 0x113c];
+	} slave[5];			/* Slave Interface */
+	u8 res_6000[0x9004 - 0x6000];
+	u32 cycle_counter;		/* Cycle counter */
+	u32 count_ctrl;			/* Count Control */
+	u32 overflow_status;		/* Overflow Flag Status */
+	u8 res_9010[0xa000 - 0x9010];
+	struct {
+		u32 event_select;	/* Event Select */
+		u32 event_count;	/* Event Count */
+		u32 counter_ctrl;	/* Counter Control */
+		u32 overflow_status;	/* Overflow Flag Status */
+		u8 res_a010[0xb000 - 0xa010];
+	} pcounter[4];			/* Performance Counter */
+	u8 res_e004[0x10000 - 0xe004];
+};
+#endif	/* __ASM_ARCH_LS102XA_IMMAP_H_ */
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/config.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/config.h	2022-05-09 14:06:22.697171048 -0700
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2014, Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ASM_ARMV7_LS102XA_CONFIG_
+#define _ASM_ARMV7_LS102XA_CONFIG_
+
+#define CONFIG_SYS_CACHELINE_SIZE		64
+
+#define OCRAM_BASE_ADDR				0x10000000
+#define OCRAM_SIZE				0x00020000
+
+#define CONFIG_SYS_IMMR				0x01000000
+#define CONFIG_SYS_DCSRBAR			0x20000000
+
+#define CONFIG_SYS_FSL_DDR_ADDR			(CONFIG_SYS_IMMR + 0x00080000)
+#define CONFIG_SYS_CCI400_ADDR			(CONFIG_SYS_IMMR + 0x00180000)
+#define CONFIG_SYS_FSL_CSU_ADDR                 (CONFIG_SYS_IMMR + 0x00510000)
+#define CONFIG_SYS_IFC_ADDR			(CONFIG_SYS_IMMR + 0x00530000)
+#define CONFIG_SYS_FSL_ESDHC_ADDR		(CONFIG_SYS_IMMR + 0x00560000)
+#define CONFIG_SYS_FSL_SCFG_ADDR		(CONFIG_SYS_IMMR + 0x00570000)
+#define CONFIG_SYS_FSL_SEC_ADDR			(CONFIG_SYS_IMMR + 0x00700000)
+#define CONFIG_SYS_FSL_JR0_ADDR			(CONFIG_SYS_IMMR + 0x00710000)
+#define CONFIG_SYS_SFP_ADDR			(CONFIG_SYS_IMMR + 0x00e80200)
+#define CONFIG_SYS_SNVS_ADDR			(CONFIG_SYS_IMMR + 0x00e90000)
+#define CONFIG_SYS_FSL_SERDES_ADDR		(CONFIG_SYS_IMMR + 0x00ea0000)
+#define CONFIG_SYS_FSL_GUTS_ADDR		(CONFIG_SYS_IMMR + 0x00ee0000)
+#define CONFIG_SYS_FSL_LS1_CLK_ADDR		(CONFIG_SYS_IMMR + 0x00ee1000)
+#define CONFIG_SYS_NS16550_COM1			(CONFIG_SYS_IMMR + 0x011c0500)
+#define CONFIG_SYS_NS16550_COM2			(CONFIG_SYS_IMMR + 0x011d0500)
+#define CONFIG_SYS_DCU_ADDR			(CONFIG_SYS_IMMR + 0x01ce0000)
+#define CONFIG_SYS_SMMU3_ADDR			(CONFIG_SYS_IMMR + 0x300000)
+#define CONFIG_SYS_LS102XA_USB1_ADDR \
+	(CONFIG_SYS_IMMR + CONFIG_SYS_LS102XA_USB1_OFFSET)
+
+#define CONFIG_SYS_FSL_SEC_OFFSET		0x00700000
+#define CONFIG_SYS_LS102XA_USB1_OFFSET		0x07600000
+#define CONFIG_SYS_TSEC1_OFFSET			0x01d10000
+#define CONFIG_SYS_TSEC2_OFFSET			0x01d50000
+#define CONFIG_SYS_TSEC3_OFFSET			0x01d90000
+#define CONFIG_SYS_MDIO1_OFFSET			0x01d24000
+
+#define TSEC_BASE_ADDR	(CONFIG_SYS_IMMR + CONFIG_SYS_TSEC1_OFFSET)
+#define MDIO_BASE_ADDR	(CONFIG_SYS_IMMR + CONFIG_SYS_MDIO1_OFFSET)
+
+#define SCTR_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01b00000)
+
+#define I2C1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01180000)
+#define I2C2_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01190000)
+#define I2C3_BASE_ADDR				(CONFIG_SYS_IMMR + 0x011a0000)
+
+#define WDOG1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01ad0000)
+
+#define QSPI_BASE_ADDR				(CONFIG_SYS_IMMR + 0x00550000)
+#define DSPI1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01100000)
+#define DSPI2_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01110000)
+
+#define LPUART_BASE				(CONFIG_SYS_IMMR + 0x01950000)
+
+#define CONFIG_SYS_PCIE1_ADDR			(CONFIG_SYS_IMMR + 0x2400000)
+#define CONFIG_SYS_PCIE2_ADDR			(CONFIG_SYS_IMMR + 0x2500000)
+
+#ifdef CONFIG_DDR_SPD
+#define CONFIG_SYS_FSL_DDR_BE
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_FSL_DDRC_ARM_GEN3
+#define CONFIG_SYS_FSL_DDR
+#define CONFIG_SYS_LS1_DDR_BLOCK1_SIZE		((phys_size_t)2 << 30)
+#define CONFIG_MAX_MEM_MAPPED			CONFIG_SYS_LS1_DDR_BLOCK1_SIZE
+#endif
+
+#define CONFIG_SYS_FSL_IFC_BE
+#define CONFIG_SYS_FSL_ESDHC_BE
+#define CONFIG_SYS_FSL_WDOG_BE
+#define CONFIG_SYS_FSL_DSPI_BE
+#define CONFIG_SYS_FSL_QSPI_BE
+#define CONFIG_SYS_FSL_DCU_BE
+
+#define SPI_BUS_FSL_QSPI                               0
+#define SPI_BUS_FSL_DSPI1                              1
+#define SPI_BUS_FSL_DSPI2                              2
+
+#define DCU_LAYER_MAX_NUM			16
+
+#define CONFIG_SYS_FSL_SRDS_1
+
+#ifdef CONFIG_LS102XA
+#define CONFIG_MAX_CPUS				2
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT		8
+#define CONFIG_NUM_DDR_CONTROLLERS		1
+#define CONFIG_SYS_FSL_SEC_OFFSET		0x00700000
+#define CONFIG_SYS_FSL_SEC_COMPAT		5
+#define CONFIG_USB_MAX_CONTROLLER_COUNT		1
+#else
+#error SoC not defined
+#endif
+
+#define CONFIG_SYS_FSL_SFP_VER_3_2
+#define CONFIG_SYS_FSL_SEC_LE
+#define CONFIG_SYS_FSL_SNVS_LE
+#define CONFIG_SYS_FSL_SFP_BE
+#define CONFIG_SYS_FSL_SRK_LE
+#define CONFIG_KEY_REVOCATION
+
+#endif /* _ASM_ARMV7_LS102XA_CONFIG_ */
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/fsl_serdes.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/fsl_serdes.h	2022-05-09 14:06:22.697171048 -0700
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_SERDES_H
+#define __FSL_SERDES_H
+
+#include <config.h>
+
+enum srds_prtcl {
+	NONE = 0,
+	PCIE1,
+	PCIE2,
+	SATA1,
+	SGMII_TSEC1,
+	SGMII_TSEC2,
+};
+
+enum srds {
+	FSL_SRDS_1  = 0,
+	FSL_SRDS_2  = 1,
+};
+
+int is_serdes_configured(enum srds_prtcl device);
+void fsl_serdes_init(void);
+const char *serdes_clock_to_string(u32 clock);
+
+int serdes_get_first_lane(u32 sd, enum srds_prtcl device);
+enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane);
+
+#endif /* __FSL_SERDES_H */
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/ns_access.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/ns_access.h	2022-05-09 14:06:22.697171048 -0700
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_NS_ACCESS_H_
+#define __FSL_NS_ACCESS_H_
+
+enum csu_cslx_access {
+	CSU_NS_SUP_R = 0x08,
+	CSU_NS_SUP_W = 0x80,
+	CSU_NS_SUP_RW = 0x88,
+	CSU_NS_USER_R = 0x04,
+	CSU_NS_USER_W = 0x40,
+	CSU_NS_USER_RW = 0x44,
+	CSU_S_SUP_R = 0x02,
+	CSU_S_SUP_W = 0x20,
+	CSU_S_SUP_RW = 0x22,
+	CSU_S_USER_R = 0x01,
+	CSU_S_USER_W = 0x10,
+	CSU_S_USER_RW = 0x11,
+	CSU_ALL_RW = 0xff,
+};
+
+enum csu_cslx_ind {
+	CSU_CSLX_PCIE2_IO = 0,
+	CSU_CSLX_PCIE1_IO,
+	CSU_CSLX_MG2TPR_IP,
+	CSU_CSLX_IFC_MEM,
+	CSU_CSLX_OCRAM,
+	CSU_CSLX_GIC,
+	CSU_CSLX_PCIE1,
+	CSU_CSLX_OCRAM2,
+	CSU_CSLX_QSPI_MEM,
+	CSU_CSLX_PCIE2,
+	CSU_CSLX_SATA,
+	CSU_CSLX_USB3,
+	CSU_CSLX_SERDES = 32,
+	CSU_CSLX_QDMA,
+	CSU_CSLX_LPUART2,
+	CSU_CSLX_LPUART1,
+	CSU_CSLX_LPUART4,
+	CSU_CSLX_LPUART3,
+	CSU_CSLX_LPUART6,
+	CSU_CSLX_LPUART5,
+	CSU_CSLX_DSPI2 = 40,
+	CSU_CSLX_DSPI1,
+	CSU_CSLX_QSPI,
+	CSU_CSLX_ESDHC,
+	CSU_CSLX_2D_ACE,
+	CSU_CSLX_IFC,
+	CSU_CSLX_I2C1,
+	CSU_CSLX_USB2,
+	CSU_CSLX_I2C3,
+	CSU_CSLX_I2C2,
+	CSU_CSLX_DUART2 = 50,
+	CSU_CSLX_DUART1,
+	CSU_CSLX_WDT2,
+	CSU_CSLX_WDT1,
+	CSU_CSLX_EDMA,
+	CSU_CSLX_SYS_CNT,
+	CSU_CSLX_DMA_MUX2,
+	CSU_CSLX_DMA_MUX1,
+	CSU_CSLX_DDR,
+	CSU_CSLX_QUICC,
+	CSU_CSLX_DCFG_CCU_RCPM = 60,
+	CSU_CSLX_SECURE_BOOTROM,
+	CSU_CSLX_SFP,
+	CSU_CSLX_TMU,
+	CSU_CSLX_SECURE_MONITOR,
+	CSU_CSLX_RESERVED0,
+	CSU_CSLX_ETSEC1,
+	CSU_CSLX_SEC5_5,
+	CSU_CSLX_ETSEC3,
+	CSU_CSLX_ETSEC2,
+	CSU_CSLX_GPIO2 = 70,
+	CSU_CSLX_GPIO1,
+	CSU_CSLX_GPIO4,
+	CSU_CSLX_GPIO3,
+	CSU_CSLX_PLATFORM_CONT,
+	CSU_CSLX_CSU,
+	CSU_CSLX_ASRC,
+	CSU_CSLX_SPDIF,
+	CSU_CSLX_FLEXCAN2,
+	CSU_CSLX_FLEXCAN1,
+	CSU_CSLX_FLEXCAN4 = 80,
+	CSU_CSLX_FLEXCAN3,
+	CSU_CSLX_SAI2,
+	CSU_CSLX_SAI1,
+	CSU_CSLX_SAI4,
+	CSU_CSLX_SAI3,
+	CSU_CSLX_FTM2,
+	CSU_CSLX_FTM1,
+	CSU_CSLX_FTM4,
+	CSU_CSLX_FTM3,
+	CSU_CSLX_FTM6 = 90,
+	CSU_CSLX_FTM5,
+	CSU_CSLX_FTM8,
+	CSU_CSLX_FTM7,
+	CSU_CSLX_COP_DCSR,
+	CSU_CSLX_EPU,
+	CSU_CSLX_GDI,
+	CSU_CSLX_DDI,
+	CSU_CSLX_RESERVED1,
+	CSU_CSLX_USB3_PHY = 117,
+	CSU_CSLX_RESERVED2,
+	CSU_CSLX_MAX,
+};
+
+struct csu_ns_dev {
+	unsigned long ind;
+	uint32_t val;
+};
+
+void enable_devices_ns_access(struct csu_ns_dev *ns_dev, uint32_t num);
+
+#endif
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/clock.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/clock.h	2022-05-09 14:06:22.697171048 -0700
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+
+#ifndef __ASM_ARCH_LS102XA_CLOCK_H_
+#define __ASM_ARCH_LS102XA_CLOCK_H_
+
+#include <common.h>
+
+enum mxc_clock {
+	MXC_ARM_CLK = 0,
+	MXC_UART_CLK,
+	MXC_ESDHC_CLK,
+	MXC_I2C_CLK,
+	MXC_DSPI_CLK,
+};
+
+unsigned int mxc_get_clock(enum mxc_clock clk);
+
+#endif /* __ASM_ARCH_LS102XA_CLOCK_H_ */
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/ls102xa_stream_id.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/ls102xa_stream_id.h	2022-05-09 14:06:22.697171048 -0700
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_LS102XA_STREAM_ID_H_
+#define __FSL_LS102XA_STREAM_ID_H_
+
+#include <fsl_sec.h>
+
+#define CONFIG_SMMU_NSCR_OFFSET		0x400
+#define CONFIG_SMMU_SMR_OFFSET		0x800
+#define CONFIG_SMMU_S2CR_OFFSET		0xc00
+
+#define SMMU_NSCR_CLIENTPD_SHIFT	0
+#define SMMU_NSCR_MTCFG_SHIFT		20
+
+#define SMR_SMR_VALID_SHIFT		31
+#define SMR_ID_MASK			0x7fff
+#define SMR_MASK_SHIFT			16
+
+#define S2CR_WACFG_SHIFT		22
+#define S2CR_WACFG_MASK			0x3
+#define S2CR_WACFG_WRITE_ALLOCATE	0x2
+
+#define S2CR_RACFG_SHIFT		20
+#define S2CR_RACFG_MASK			0x3
+#define S2CR_RACFG_READ_ALLOCATE	0x2
+
+#define S2CR_TYPE_SHIFT			16
+#define S2CR_TYPE_MASK			0x3
+#define S2CR_TYPE_BYPASS		0x01
+
+#define S2CR_MEM_ATTR_SHIFT		12
+#define S2CR_MEM_ATTR_MASK		0xf
+#define S2CR_MEM_ATTR_CACHEABLE		0xa
+
+#define S2CR_MTCFG			0x00000800
+
+#define S2CR_SHCFG_SHIFT		8
+#define S2CR_SHCFG_MASK			0x3
+#define S2CR_SHCFG_OUTER_CACHEABLE	0x1
+#define S2CR_SHCFG_INNER_CACHEABLE	0x2
+
+#define SET_LIODN_ENTRY_1(name, idA, off, compatoff) \
+	{ .compat = name, \
+	  .id = { idA }, .num_ids = 1, \
+	  .reg_offset = off + CONFIG_SYS_IMMR, \
+	  .compat_offset = compatoff + CONFIG_SYS_CCSRBAR_PHYS, \
+	}
+
+#define SET_LIODN_ENTRY_2(name, idA, idB, off, compatoff) \
+	{ .compat = name, \
+	  .id = { idA, idB }, .num_ids = 2, \
+	  .reg_offset = off + CONFIG_SYS_IMMR, \
+	  .compat_offset = compatoff + CONFIG_SYS_CCSRBAR_PHYS, \
+	}
+
+/*
+ * handle both old and new versioned SEC properties:
+ * "fsl,secX.Y" became "fsl,sec-vX.Y" during development
+ */
+#define SET_SEC_JR_LIODN_ENTRY(jrnum, liodnA, liodnB) \
+	SET_LIODN_ENTRY_2("fsl,sec4.0-job-ring", liodnA, liodnB, \
+		offsetof(ccsr_sec_t, jrliodnr[jrnum].ls) + \
+		CONFIG_SYS_FSL_SEC_OFFSET, \
+		CONFIG_SYS_FSL_SEC_OFFSET + 0x1000 + 0x1000 * jrnum), \
+	SET_LIODN_ENTRY_2("fsl,sec-v4.0-job-ring", liodnA, liodnB,\
+		offsetof(ccsr_sec_t, jrliodnr[jrnum].ls) + \
+		CONFIG_SYS_FSL_SEC_OFFSET, \
+		CONFIG_SYS_FSL_SEC_OFFSET + 0x1000 + 0x1000 * jrnum)
+
+/* This is a bit evil since we treat rtic param as both a string & hex value */
+#define SET_SEC_RTIC_LIODN_ENTRY(rtic, liodnA) \
+	SET_LIODN_ENTRY_1("fsl,sec4.0-rtic-memory", \
+		liodnA,	\
+		offsetof(ccsr_sec_t, rticliodnr[0x##rtic-0xa].ls) + \
+		CONFIG_SYS_FSL_SEC_OFFSET, \
+		CONFIG_SYS_FSL_SEC_OFFSET + 0x6100 + 0x20 * (0x##rtic-0xa)), \
+	SET_LIODN_ENTRY_1("fsl,sec-v4.0-rtic-memory", \
+		liodnA,	\
+		offsetof(ccsr_sec_t, rticliodnr[0x##rtic-0xa].ls) + \
+		CONFIG_SYS_FSL_SEC_OFFSET, \
+		CONFIG_SYS_FSL_SEC_OFFSET + 0x6100 + 0x20 * (0x##rtic-0xa))
+
+#define SET_SEC_DECO_LIODN_ENTRY(num, liodnA, liodnB) \
+	SET_LIODN_ENTRY_2(NULL, liodnA, liodnB, \
+		offsetof(ccsr_sec_t, decoliodnr[num].ls) + \
+		CONFIG_SYS_FSL_SEC_OFFSET, 0)
+
+struct liodn_id_table {
+	const char *compat;
+	u32 id[2];
+	u8 num_ids;
+	phys_addr_t compat_offset;
+	unsigned long reg_offset;
+};
+
+struct smmu_stream_id {
+	uint16_t offset;
+	uint16_t stream_id;
+	char dev_name[32];
+};
+
+void ls1021x_config_caam_stream_id(struct liodn_id_table *tbl, int size);
+void ls102xa_config_smmu_stream_id(struct smmu_stream_id *id, uint32_t num);
+void ls1021x_config_smmu3(uint32_t liodn);
+#endif
--- u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/spl.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/include/asm/arch-ls102xa/spl.h	2022-05-09 14:06:22.701170886 -0700
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_SPL_H__
+#define __ASM_ARCH_SPL_H__
+
+#define BOOT_DEVICE_NONE	0
+#define BOOT_DEVICE_XIP		1
+#define BOOT_DEVICE_XIPWAIT	2
+#define BOOT_DEVICE_NAND	3
+#define BOOT_DEVICE_ONENAND	4
+#define BOOT_DEVICE_MMC1	5
+#define BOOT_DEVICE_MMC2	6
+#define BOOT_DEVICE_MMC2_2	7
+#define BOOT_DEVICE_SPI		10
+
+#endif	/* __ASM_ARCH_SPL_H__ */
--- u-boot-2014.07/arch/arm/lib/nonsecure.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/arm/lib/nonsecure.c	2022-05-09 14:06:22.773167974 -0700
@@ -0,0 +1,29 @@
+#include <common.h>
+#include <asm/nonsecure.h>
+#include <libfdt.h>
+
+#define PG_4K_ALING ~((1 << 12) - 1)
+#define PG_4K (1 << 12)
+
+int fdt_add_non_sec_mem_rsv(void *blob)
+{
+	unsigned long rsv_start = non_sec_start & PG_4K_ALING;
+	unsigned long rsv_end = non_sec_end & PG_4K_ALING;
+	unsigned long rsv_size;
+	int off;
+
+	if (non_sec_end == non_sec_start + 0x4)
+		return 0;
+
+	if (rsv_start != rsv_end)
+		rsv_size = 2 * PG_4K;
+	else
+		rsv_size = PG_4K;
+
+	off = fdt_add_mem_rsv(blob, rsv_start, (u64)rsv_size);
+	if (off < 0)
+		printf("Failed to reserve memory for spin table: %s\n",
+		       fdt_strerror(off));
+
+	return off;
+}
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t1024_serdes.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t1024_serdes.c	2022-05-09 14:06:22.981159561 -0700
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_serdes.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+
+
+static u8 serdes_cfg_tbl[][4] = {
+	[0xD5] = {QSGMII_FM1_A, PCIE3, PCIE2, PCIE1},
+	[0xD6] = {QSGMII_FM1_A, PCIE3, PCIE2, SATA1},
+	[0x95] = {XFI_FM1_MAC1, PCIE3, PCIE2, PCIE1},
+	[0x99] = {XFI_FM1_MAC1, PCIE3, SGMII_FM1_DTSEC2, PCIE1},
+	[0x46] = {PCIE1, PCIE1, PCIE2, SATA1},
+	[0x47] = {PCIE1, PCIE1, PCIE2, SGMII_FM1_DTSEC1},
+	[0x56] = {PCIE1, PCIE3, PCIE2, SATA1},
+	[0x5A] = {PCIE1, PCIE3, SGMII_FM1_DTSEC2, SATA1},
+	[0x5B] = {PCIE1, PCIE3, SGMII_FM1_DTSEC2, SGMII_FM1_DTSEC1},
+	[0x6A] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC2, SATA1},
+	[0x6B] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_FM1_DTSEC2, SGMII_FM1_DTSEC1},
+	[0x6F] = {PCIE1, SGMII_FM1_DTSEC3, SGMII_2500_FM1_DTSEC2,
+		  SGMII_2500_FM1_DTSEC1},
+	[0x77] = {PCIE1, SGMII_2500_FM1_DTSEC3, PCIE2, SGMII_FM1_DTSEC1},
+	[0x7F] = {PCIE1, SGMII_2500_FM1_DTSEC3, SGMII_2500_FM1_DTSEC2,
+		  SGMII_2500_FM1_DTSEC1},
+};
+
+enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane)
+{
+	return serdes_cfg_tbl[cfg][lane];
+}
+
+int is_serdes_prtcl_valid(int serdes, u32 prtcl)
+{
+	int i;
+
+	if (prtcl >= ARRAY_SIZE(serdes_cfg_tbl))
+		return 0;
+
+	for (i = 0; i < 4; i++) {
+		if (serdes_cfg_tbl[prtcl][i] != NONE)
+			return 1;
+	}
+
+	return 0;
+}
--- u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t1024_ids.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/powerpc/cpu/mpc85xx/t1024_ids.c	2022-05-09 14:06:22.981159561 -0700
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+
+#ifdef CONFIG_SYS_DPAA_QBMAN
+struct qportal_info qp_info[CONFIG_SYS_QMAN_NUM_PORTALS] = {
+	/* dqrr liodn, frame data liodn, liodn off, sdest */
+	SET_QP_INFO(1, 27, 1, 0),
+	SET_QP_INFO(2, 28, 1, 0),
+	SET_QP_INFO(3, 29, 1, 1),
+	SET_QP_INFO(4, 30, 1, 1),
+	SET_QP_INFO(5, 31, 1, 2),
+	SET_QP_INFO(6, 32, 1, 2),
+	SET_QP_INFO(7, 33, 1, 3),
+	SET_QP_INFO(8, 34, 1, 3),
+	SET_QP_INFO(9, 35, 1, 0),
+	SET_QP_INFO(10, 36, 1, 0),
+};
+#endif
+
+struct liodn_id_table liodn_tbl[] = {
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	SET_QMAN_LIODN(62),
+	SET_BMAN_LIODN(63),
+#endif
+
+	SET_SDHC_LIODN(1, 552),
+
+	SET_USB_LIODN(1, "fsl-usb2-mph", 553),
+	SET_USB_LIODN(2, "fsl-usb2-dr", 554),
+
+	SET_SATA_LIODN(1, 555),
+
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 1, 148),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 2, 228),
+	SET_PCI_LIODN_BASE(CONFIG_SYS_FSL_PCIE_COMPAT, 3, 308),
+
+	SET_DMA_LIODN(1, "fsl,elo3-dma", 147),
+	SET_DMA_LIODN(2, "fsl,elo3-dma", 227),
+	/* SET_NEXUS_LIODN(557), -- not yet implemented */
+	SET_QE_LIODN(559),
+	SET_TDM_LIODN(560),
+};
+int liodn_tbl_sz = ARRAY_SIZE(liodn_tbl);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+struct liodn_id_table fman1_liodn_tbl[] = {
+	SET_FMAN_RX_1G_LIODN(1, 0, 88),
+	SET_FMAN_RX_1G_LIODN(1, 1, 89),
+	SET_FMAN_RX_1G_LIODN(1, 2, 90),
+	SET_FMAN_RX_1G_LIODN(1, 3, 91),
+	SET_FMAN_RX_10G_LIODN(1, 0, 94),
+};
+int fman1_liodn_tbl_sz = ARRAY_SIZE(fman1_liodn_tbl);
+#endif
+
+struct liodn_id_table sec_liodn_tbl[] = {
+	SET_SEC_JR_LIODN_ENTRY(0, 454, 458),
+	SET_SEC_JR_LIODN_ENTRY(1, 455, 459),
+	SET_SEC_JR_LIODN_ENTRY(2, 456, 460),
+	SET_SEC_JR_LIODN_ENTRY(3, 457, 461),
+	SET_SEC_RTIC_LIODN_ENTRY(a, 453),
+	SET_SEC_RTIC_LIODN_ENTRY(b, 549),
+	SET_SEC_RTIC_LIODN_ENTRY(c, 550),
+	SET_SEC_RTIC_LIODN_ENTRY(d, 551),
+	SET_SEC_DECO_LIODN_ENTRY(0, 541, 610),
+	SET_SEC_DECO_LIODN_ENTRY(1, 542, 611),
+};
+int sec_liodn_tbl_sz = ARRAY_SIZE(sec_liodn_tbl);
+
+struct liodn_id_table liodn_bases[] = {
+	[FSL_HW_PORTAL_SEC]  = SET_LIODN_BASE_2(462, 558),
+#ifdef CONFIG_SYS_DPAA_FMAN
+	[FSL_HW_PORTAL_FMAN1] = SET_LIODN_BASE_1(973),
+#endif
+};
--- u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/fsl_pamu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/fsl_pamu.c	2022-05-09 14:06:22.993159076 -0700
@@ -0,0 +1,448 @@
+/*
+ * FSL PAMU driver
+ *
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/fsl_pamu.h>
+
+struct paace *ppaact;
+struct paace *sec;
+unsigned long fspi;
+
+static inline int __ilog2_roundup_64(uint64_t val)
+{
+	if ((val & (val - 1)) == 0)
+		return __ilog2_u64(val);
+	else
+		return  __ilog2_u64(val) + 1;
+}
+
+
+static inline int count_lsb_zeroes(unsigned long val)
+{
+	return ffs(val) - 1;
+}
+
+static unsigned int map_addrspace_size_to_wse(uint64_t addrspace_size)
+{
+	/* window size is 2^(WSE+1) bytes */
+	return count_lsb_zeroes(addrspace_size >> PAMU_PAGE_SHIFT) +
+		PAMU_PAGE_SHIFT - 1;
+}
+
+static unsigned int map_subwindow_cnt_to_wce(uint32_t subwindow_cnt)
+{
+       /* window count is 2^(WCE+1) bytes */
+	return count_lsb_zeroes(subwindow_cnt) - 1;
+}
+
+static void pamu_setup_default_xfer_to_host_ppaace(struct paace *ppaace)
+{
+	set_bf(ppaace->addr_bitfields, PAACE_AF_PT, PAACE_PT_PRIMARY);
+	set_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,
+	       PAACE_M_COHERENCE_REQ);
+}
+
+static void pamu_setup_default_xfer_to_host_spaace(struct paace *spaace)
+{
+	set_bf(spaace->addr_bitfields, PAACE_AF_PT, PAACE_PT_SECONDARY);
+	set_bf(spaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,
+	       PAACE_M_COHERENCE_REQ);
+}
+
+/** Sets up PPAACE entry for specified liodn
+ *
+ * @param[in] liodn      Logical IO device number
+ * @param[in] win_addr   starting address of DSA window
+ * @param[in] win-size   size of DSA window
+ * @param[in] omi        Operation mapping index -- if ~omi == 0 then omi
+				not defined
+ * @param[in] stashid    cache stash id for associated cpu -- if ~stashid == 0
+				then stashid not defined
+ * @param[in] snoopid    snoop id for hardware coherency -- if ~snoopid == 0
+				then snoopid not defined
+ * @param[in] subwin_cnt number of sub-windows
+ *
+ * @return Returns 0 upon success else error code < 0 returned
+ */
+static int pamu_config_ppaace(uint32_t liodn, uint64_t win_addr,
+	uint64_t win_size, uint32_t omi,
+	uint32_t snoopid, uint32_t stashid,
+	uint32_t subwin_cnt)
+{
+	struct paace *ppaace;
+
+	if ((win_size & (win_size - 1)) || win_size < PAMU_PAGE_SIZE)
+		return -1;
+
+	if (win_addr & (win_size - 1))
+		return -2;
+
+	if (liodn > NUM_PPAACT_ENTRIES) {
+		printf("Entries in PPACT not sufficient\n");
+		return -3;
+	}
+
+	ppaace = &ppaact[liodn];
+
+	/* window size is 2^(WSE+1) bytes */
+	set_bf(ppaace->addr_bitfields, PPAACE_AF_WSE,
+	       map_addrspace_size_to_wse(win_size));
+
+	pamu_setup_default_xfer_to_host_ppaace(ppaace);
+
+	if (sizeof(phys_addr_t) > 4)
+		ppaace->wbah = (u64)win_addr >> (PAMU_PAGE_SHIFT + 20);
+	else
+		ppaace->wbah = 0;
+
+	set_bf(ppaace->addr_bitfields, PPAACE_AF_WBAL,
+	       (win_addr >> PAMU_PAGE_SHIFT));
+
+	/* set up operation mapping if it's configured */
+	if (omi < OME_NUMBER_ENTRIES) {
+		set_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);
+		ppaace->op_encode.index_ot.omi = omi;
+	} else if (~omi != 0) {
+		return -3;
+	}
+
+	/* configure stash id */
+	if (~stashid != 0)
+		set_bf(ppaace->impl_attr, PAACE_IA_CID, stashid);
+
+	/* configure snoop id */
+	if (~snoopid != 0)
+		ppaace->domain_attr.to_host.snpid = snoopid;
+
+	if (subwin_cnt) {
+		/* window count is 2^(WCE+1) bytes */
+		set_bf(ppaace->impl_attr, PAACE_IA_WCE,
+		       map_subwindow_cnt_to_wce(subwin_cnt));
+		set_bf(ppaace->addr_bitfields, PPAACE_AF_MW, 0x1);
+		ppaace->fspi = fspi;
+		fspi = fspi + DEFAULT_NUM_SUBWINDOWS - 1;
+	} else {
+		set_bf(ppaace->addr_bitfields, PAACE_AF_AP, PAACE_AP_PERMS_ALL);
+	}
+
+	asm volatile("sync" : : : "memory");
+	/* Mark the ppace entry valid */
+	ppaace->addr_bitfields |= PAACE_V_VALID;
+	asm volatile("sync" : : : "memory");
+
+	return 0;
+}
+
+static int pamu_config_spaace(uint32_t liodn,
+	uint64_t subwin_size, uint64_t subwin_addr, uint64_t size,
+	uint32_t omi, uint32_t snoopid, uint32_t stashid)
+{
+	struct paace *paace;
+	/* Align start addr of subwin to subwindoe size */
+	uint64_t sec_addr = subwin_addr & ~(subwin_size - 1);
+	uint64_t end_addr = subwin_addr + size;
+	int size_shift = __ilog2_u64(subwin_size);
+	uint64_t win_size = 0;
+	uint32_t index, swse;
+	unsigned long fspi_idx;
+
+	/* Recalculate the size */
+	size = end_addr - sec_addr;
+
+	if (!subwin_size)
+		return -1;
+
+	if (liodn > NUM_PPAACT_ENTRIES) {
+		printf("LIODN No programmed %d > no. of PPAACT entries %d\n",
+		       liodn, NUM_PPAACT_ENTRIES);
+		return -1;
+	}
+
+	while (sec_addr < end_addr) {
+#ifdef DEBUG
+		printf("sec_addr < end_addr is %llx < %llx\n", sec_addr,
+		       end_addr);
+#endif
+		paace = &ppaact[liodn];
+		if (!paace)
+			return -1;
+		fspi_idx = paace->fspi;
+
+		/* Calculating the win_size here as if we map in index 0,
+			paace entry woudl need to  be programmed for SWSE */
+		win_size = end_addr - sec_addr;
+		win_size = 1 << __ilog2_roundup_64(win_size);
+
+		if (win_size > subwin_size)
+			win_size = subwin_size;
+		else if (win_size < PAMU_PAGE_SIZE)
+			win_size = PAMU_PAGE_SIZE;
+
+#ifdef DEBUG
+		printf("win_size is %x\n", win_size);
+#endif
+
+		swse = map_addrspace_size_to_wse(win_size);
+		index = sec_addr >> size_shift;
+
+		if (index == 0) {
+			set_bf(paace->win_bitfields, PAACE_WIN_SWSE, swse);
+			set_bf(paace->addr_bitfields, PAACE_AF_AP,
+			       PAACE_AP_PERMS_ALL);
+			sec_addr += subwin_size;
+			continue;
+		}
+
+		paace = sec + fspi_idx + index - 1;
+
+#ifdef DEBUG
+		printf("SPAACT:Writing at location %p, index %d\n", paace,
+		       index);
+#endif
+
+		pamu_setup_default_xfer_to_host_spaace(paace);
+		set_bf(paace->addr_bitfields, SPAACE_AF_LIODN, liodn);
+		set_bf(paace->addr_bitfields, PAACE_AF_AP, PAACE_AP_PERMS_ALL);
+
+		/* configure snoop id */
+		if (~snoopid != 0)
+			paace->domain_attr.to_host.snpid = snoopid;
+
+		if (paace->addr_bitfields & PAACE_V_VALID) {
+#ifdef DEBUG
+			printf("Reached overlap condition\n");
+			printf("%d < %d\n", get_bf(paace->win_bitfields,
+						   PAACE_WIN_SWSE), swse);
+#endif
+			if (get_bf(paace->win_bitfields, PAACE_WIN_SWSE) < swse)
+				set_bf(paace->win_bitfields, PAACE_WIN_SWSE,
+				       swse);
+		} else {
+			set_bf(paace->win_bitfields, PAACE_WIN_SWSE, swse);
+		}
+
+		paace->addr_bitfields |= PAACE_V_VALID;
+		sec_addr += subwin_size;
+	}
+
+	return 0;
+}
+
+int pamu_init(void)
+{
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+	struct ccsr_pamu *regs;
+	u32 i = 0;
+	u64 ppaact_phys, ppaact_lim, ppaact_size;
+	u64 spaact_phys, spaact_lim, spaact_size;
+
+	ppaact_size = sizeof(struct paace) * NUM_PPAACT_ENTRIES;
+	spaact_size = sizeof(struct paace) * NUM_SPAACT_ENTRIES;
+
+	/* Allocate space for Primary PAACT Table */
+	ppaact = memalign(PAMU_TABLE_ALIGNMENT, ppaact_size);
+	if (!ppaact)
+		return -1;
+	memset(ppaact, 0, ppaact_size);
+
+	/* Allocate space for Secondary PAACT Table */
+	sec = memalign(PAMU_TABLE_ALIGNMENT, spaact_size);
+	if (!sec)
+		return -1;
+	memset(sec, 0, spaact_size);
+
+	ppaact_phys = virt_to_phys((void *)ppaact);
+	ppaact_lim = ppaact_phys + ppaact_size;
+
+	spaact_phys = (uint64_t)virt_to_phys((void *)sec);
+	spaact_lim = spaact_phys + spaact_size;
+
+	/* Configure all PAMU's */
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		regs = (struct ccsr_pamu *)base_addr;
+
+		out_be32(&regs->ppbah, ppaact_phys >> 32);
+		out_be32(&regs->ppbal, (uint32_t)ppaact_phys);
+
+		out_be32(&regs->pplah, (ppaact_lim) >> 32);
+		out_be32(&regs->pplal, (uint32_t)ppaact_lim);
+
+		if (sec != NULL) {
+			out_be32(&regs->spbah, spaact_phys >> 32);
+			out_be32(&regs->spbal, (uint32_t)spaact_phys);
+			out_be32(&regs->splah, spaact_lim >> 32);
+			out_be32(&regs->splal, (uint32_t)spaact_lim);
+		}
+		asm volatile("sync" : : : "memory");
+
+		base_addr += PAMU_OFFSET;
+	}
+
+	return 0;
+}
+
+void pamu_enable(void)
+{
+	u32 i = 0;
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		setbits_be32((void *)base_addr + PAMU_PCR_OFFSET,
+			     PAMU_PCR_PE);
+		asm volatile("sync" : : : "memory");
+		base_addr += PAMU_OFFSET;
+	}
+}
+
+void pamu_reset(void)
+{
+	u32 i  = 0;
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+	struct ccsr_pamu *regs;
+
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		regs = (struct ccsr_pamu *)base_addr;
+	/* Clear PPAACT Base register */
+		out_be32(&regs->ppbah, 0);
+		out_be32(&regs->ppbal, 0);
+		out_be32(&regs->pplah, 0);
+		out_be32(&regs->pplal, 0);
+		out_be32(&regs->spbah, 0);
+		out_be32(&regs->spbal, 0);
+		out_be32(&regs->splah, 0);
+		out_be32(&regs->splal, 0);
+
+		clrbits_be32((void *)regs + PAMU_PCR_OFFSET, PAMU_PCR_PE);
+		asm volatile("sync" : : : "memory");
+		base_addr += PAMU_OFFSET;
+	}
+}
+
+void pamu_disable(void)
+{
+	u32 i  = 0;
+	u32 base_addr = CONFIG_SYS_PAMU_ADDR;
+
+
+	for (i = 0; i < CONFIG_NUM_PAMU; i++) {
+		clrbits_be32((void *)base_addr + PAMU_PCR_OFFSET, PAMU_PCR_PE);
+		asm volatile("sync" : : : "memory");
+		base_addr += PAMU_OFFSET;
+	}
+}
+
+
+static uint64_t find_max(uint64_t arr[], int num)
+{
+	int i = 0;
+	int max = 0;
+	for (i = 1 ; i < num; i++)
+		if (arr[max] < arr[i])
+			max = i;
+
+	return arr[max];
+}
+
+static uint64_t find_min(uint64_t arr[], int num)
+{
+	int i = 0;
+	int min = 0;
+	for (i = 1 ; i < num; i++)
+		if (arr[min] > arr[i])
+			min = i;
+
+	return arr[min];
+}
+
+static uint32_t get_win_cnt(uint64_t size)
+{
+	uint32_t win_cnt = DEFAULT_NUM_SUBWINDOWS;
+
+	while (win_cnt && (size/win_cnt) < PAMU_PAGE_SIZE)
+		win_cnt >>= 1;
+
+	return win_cnt;
+}
+
+int config_pamu(struct pamu_addr_tbl *tbl, int num_entries, uint32_t liodn)
+{
+	int i = 0;
+	int ret = 0;
+	uint32_t num_sec_windows = 0;
+	uint32_t num_windows = 0;
+	uint64_t min_addr, max_addr;
+	uint64_t size;
+	uint64_t subwin_size;
+	int sizebit;
+
+	min_addr = find_min(tbl->start_addr, num_entries);
+	max_addr = find_max(tbl->end_addr, num_entries);
+	size = max_addr - min_addr + 1;
+
+	if (!size)
+		return -1;
+
+	sizebit = __ilog2_roundup_64(size);
+	size = 1 << sizebit;
+#ifdef DEBUG
+	printf("min start_addr is %llx\n", min_addr);
+	printf("max end_addr is %llx\n", max_addr);
+	printf("size found is  %llx\n", size);
+#endif
+
+	if (size < PAMU_PAGE_SIZE)
+		size = PAMU_PAGE_SIZE;
+
+	while (1) {
+		min_addr = min_addr & ~(size - 1);
+		if (min_addr + size > max_addr)
+			break;
+		size <<= 1;
+		if (!size)
+			return -1;
+	}
+#ifdef DEBUG
+	printf("PAACT :Base addr is %llx\n", min_addr);
+	printf("PAACT : Size is %llx\n", size);
+#endif
+	num_windows = get_win_cnt(size);
+	/* For a single window, no spaact entries are required
+	 * sec_sub_window count = 0 */
+	if (num_windows > 1)
+		num_sec_windows = num_windows;
+	else
+		num_sec_windows = 0;
+
+	ret = pamu_config_ppaace(liodn, min_addr,
+			size , -1, -1, -1, num_sec_windows);
+
+	if (ret < 0)
+		return ret;
+
+#ifdef DEBUG
+	printf("configured ppace\n");
+#endif
+
+	if (num_sec_windows) {
+		subwin_size = size >> count_lsb_zeroes(num_sec_windows);
+#ifdef DEBUG
+		printf("subwin_size is %llx\n", subwin_size);
+#endif
+
+		for (i = 0; i < num_entries; i++) {
+			ret = pamu_config_spaace(liodn,
+				subwin_size, tbl->start_addr[i] - min_addr,
+				tbl->size[i], -1, -1, -1);
+
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return ret;
+}
--- u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/pamu_table.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/powerpc/cpu/mpc8xxx/pamu_table.c	2022-05-09 14:06:22.993159076 -0700
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_pamu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void construct_pamu_addr_table(struct pamu_addr_tbl *tbl, int *num_entries)
+{
+	int i  = 0;
+
+	tbl->start_addr[i] =
+			(uint64_t)virt_to_phys((void *)CONFIG_SYS_SDRAM_BASE);
+	tbl->size[i] = (phys_size_t)(min(gd->ram_size, CONFIG_MAX_MEM_MAPPED));
+	tbl->end_addr[i] = tbl->start_addr[i] +  tbl->size[i] - 1;
+
+	i++;
+#ifdef CONFIG_SYS_FLASH_BASE_PHYS
+	tbl->start_addr[i] =
+		(uint64_t)virt_to_phys((void *)CONFIG_SYS_FLASH_BASE_PHYS);
+	tbl->size[i] = 256 * 1024 * 1024; /* 256MB flash */
+	tbl->end_addr[i] = tbl->start_addr[i] +  tbl->size[i] - 1;
+
+	i++;
+#endif
+#ifdef DEBUG
+	int j;
+	printf("address\t\t\tsize\n");
+	for (j = 0; j < i ; j++)
+		printf("%llx \t\t\t%llx\n",  tbl->start_addr[j],  tbl->size[j]);
+#endif
+
+	*num_entries = i;
+}
+
+int sec_config_pamu_table(uint32_t liodn_ns, uint32_t liodn_s)
+{
+	struct pamu_addr_tbl tbl;
+	int num_entries = 0;
+	int ret = 0;
+
+	construct_pamu_addr_table(&tbl, &num_entries);
+
+	ret = config_pamu(&tbl, num_entries, liodn_ns);
+	if (ret)
+		return ret;
+
+	ret = config_pamu(&tbl, num_entries, liodn_s);
+	if (ret)
+		return ret;
+
+	return ret;
+}
--- u-boot-2014.07/arch/powerpc/include/asm/fsl_pamu.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/arch/powerpc/include/asm/fsl_pamu.h	2022-05-09 14:06:23.013158267 -0700
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __PAMU_H
+#define __PAMU_H
+
+#define CONFIG_NUM_PAMU		16
+#define NUM_PPAACT_ENTRIES	512
+#define NUM_SPAACT_ENTRIES	256
+
+/* PAMU_OFFSET to the next pamu space in ccsr */
+#define PAMU_OFFSET 0x1000
+
+#define PAMU_TABLE_ALIGNMENT 0x00001000
+
+#define PAMU_PAGE_SHIFT 12
+#define PAMU_PAGE_SIZE  4096U
+
+#define PAACE_M_COHERENCE_REQ   0x01
+
+#define PAACE_DA_HOST_CR                0x80
+#define PAACE_DA_HOST_CR_SHIFT          7
+
+#define PAACE_AF_PT                     0x00000002
+#define PAACE_AF_PT_SHIFT               1
+
+#define PAACE_PT_PRIMARY       0x0
+#define PAACE_PT_SECONDARY     0x1
+
+#define PPAACE_AF_WBAL			0xfffff000
+#define PPAACE_AF_WBAL_SHIFT		12
+
+#define	OME_NUMBER_ENTRIES      16   /* based on P4080 2.0 silicon plan */
+
+#define PAACE_IA_CID			0x00FF0000
+#define PAACE_IA_CID_SHIFT		16
+#define PAACE_IA_WCE			0x000000F0
+#define PAACE_IA_WCE_SHIFT		4
+#define PAACE_IA_ATM			0x0000000C
+#define PAACE_IA_ATM_SHIFT		2
+#define PAACE_IA_OTM			0x00000003
+#define PAACE_IA_OTM_SHIFT		0
+
+#define PAACE_OTM_NO_XLATE      0x00
+#define PAACE_OTM_IMMEDIATE     0x01
+#define PAACE_OTM_INDEXED       0x02
+#define PAACE_OTM_RESERVED      0x03
+#define PAACE_ATM_NO_XLATE      0x00
+#define PAACE_ATM_WINDOW_XLATE  0x01
+#define PAACE_ATM_PAGE_XLATE    0x02
+#define PAACE_ATM_WIN_PG_XLATE  \
+	(PAACE_ATM_WINDOW_XLATE | PAACE_ATM_PAGE_XLATE)
+#define PAACE_WIN_TWBAL			0xfffff000
+#define PAACE_WIN_TWBAL_SHIFT		12
+#define PAACE_WIN_SWSE			0x00000fc0
+#define PAACE_WIN_SWSE_SHIFT		6
+
+#define PAACE_AF_AP			0x00000018
+#define PAACE_AF_AP_SHIFT		3
+#define PAACE_AF_DD			0x00000004
+#define PAACE_AF_DD_SHIFT		2
+#define PAACE_AF_PT			0x00000002
+#define PAACE_AF_PT_SHIFT		1
+#define PAACE_AF_V			0x00000001
+#define PAACE_AF_V_SHIFT		0
+#define PPAACE_AF_WSE			0x00000fc0
+#define PPAACE_AF_WSE_SHIFT		6
+#define PPAACE_AF_MW			0x00000020
+#define PPAACE_AF_MW_SHIFT		5
+
+#define PAACE_AP_PERMS_DENIED  0x0
+#define PAACE_AP_PERMS_QUERY   0x1
+#define PAACE_AP_PERMS_UPDATE  0x2
+#define PAACE_AP_PERMS_ALL     0x3
+
+#define SPAACE_AF_LIODN			0xffff0000
+#define SPAACE_AF_LIODN_SHIFT		16
+#define PAACE_V_VALID          0x1
+
+#define set_bf(v, m, x)             (v = ((v) & ~(m)) | (((x) << \
+					(m##_SHIFT)) & (m)))
+#define get_bf(v, m)            (((v) & (m)) >> (m##_SHIFT))
+
+#define DEFAULT_NUM_SUBWINDOWS		128
+#define PAMU_PCR_OFFSET 0xc10
+#define PAMU_PCR_PE	0x40000000
+
+struct pamu_addr_tbl {
+	phys_addr_t start_addr[10];
+	phys_addr_t end_addr[10];
+	phys_size_t size[10];
+};
+
+struct paace {
+	/* PAACE Offset 0x00 */
+	uint32_t wbah;			/* only valid for Primary PAACE */
+	uint32_t addr_bitfields;	/* See P/S PAACE_AF_* */
+
+	/* PAACE Offset 0x08 */
+	/* Interpretation of first 32 bits dependent on DD above */
+	union {
+		struct {
+			/* Destination ID, see PAACE_DID_* defines */
+			uint8_t did;
+			/* Partition ID */
+			uint8_t pid;
+			/* Snoop ID */
+			uint8_t snpid;
+			/* coherency_required : 1 reserved : 7 */
+			uint8_t coherency_required; /* See PAACE_DA_* */
+		} to_host;
+		struct {
+			/* Destination ID, see PAACE_DID_* defines */
+			uint8_t  did;
+			uint8_t  reserved1;
+			uint16_t reserved2;
+		} to_io;
+	} domain_attr;
+
+	/* Implementation attributes + window count + address & operation
+	 * translation modes
+	 */
+	uint32_t impl_attr;			/* See PAACE_IA_* */
+
+	/* PAACE Offset 0x10 */
+	/* Translated window base address */
+	uint32_t twbah;
+	uint32_t win_bitfields;			/* See PAACE_WIN_* */
+
+	/* PAACE Offset 0x18 */
+	/* first secondary paace entry */
+	uint32_t fspi;			/* only valid for Primary PAACE */
+	union {
+		struct {
+			uint8_t ioea;
+			uint8_t moea;
+			uint8_t ioeb;
+			uint8_t moeb;
+		} immed_ot;
+		struct {
+			uint16_t reserved;
+			uint16_t omi;
+		} index_ot;
+	} op_encode;
+
+	/* PAACE Offset 0x20 */
+	uint32_t reserved1[2];			/* not currently implemented */
+
+	/* PAACE Offset 0x28 */
+	uint32_t reserved2[2];			/* not currently implemented */
+
+	/* PAACE Offset 0x30 */
+	uint32_t reserved3[2];			/* not currently implemented */
+
+	/* PAACE Offset 0x38 */
+	uint32_t reserved4[2];			/* not currently implemented */
+
+};
+
+int pamu_init(void);
+void pamu_enable(void);
+void pamu_disable(void);
+int config_pamu(struct pamu_addr_tbl *tbl, int num_entries, uint32_t liodn);
+int sec_config_pamu_table(uint32_t liodn_ns, uint32_t liodn_s);
+
+#endif
--- u-boot-2014.07/include/wgmenu.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/wgmenu.h	2022-05-09 14:06:24.101114262 -0700
@@ -0,0 +1,11 @@
+#ifndef _WGMENU_H
+#define _WGMENU_H
+
+int wgmenu_hook(int key);
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user);
+void wgmenu_show(void);
+int wgmenu_selected(void);
+int wgmenu_inmenu(void);
+void wgmenu_exit(void);
+
+#endif /* _WGMENU_H */
--- u-boot-2014.07/include/random.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/random.h	2022-05-09 14:06:24.085114909 -0700
@@ -0,0 +1,9 @@
+/* concatenation of following two 16-bit multiply with carry generators */
+/* x(n)=a*x(n-1)+carry mod 2^16 and y(n)=b*y(n-1)+carry mod 2^16, */
+/* number and carry packed within the same 32 bit integer.        */
+/******************************************************************/
+
+unsigned int rand_test( void );           /* returns a random 32-bit integer */
+void  rand_seed( unsigned int, unsigned int );      /* seed the generator */
+
+
--- u-boot-2014.07/include/configs/m300.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/configs/m300.h	2022-05-09 14:06:23.945120572 -0700
@@ -0,0 +1,856 @@
+/*
+ * Copyright 2011-2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*
+ * T2080/T2081 QDS board configuration file
+ */
+
+#ifndef __T208xQDS_H
+#define __T208xQDS_H
+
+#define CONFIG_ICS307_REFCLK_HZ 25000000  /* ICS307 ref clk freq */
+#define CONFIG_MMC
+#define CONFIG_SPI_FLASH
+#define CONFIG_USB_EHCI
+
+/* High Level Configuration Options */
+#define CONFIG_PHYS_64BIT
+#define CONFIG_BOOKE
+#define CONFIG_E500		/* BOOKE e500 family */
+#define CONFIG_E500MC		/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV	/* Category E.HV supported */
+#define CONFIG_MP		/* support multiple processors */
+#define CONFIG_ENABLE_36BIT_PHYS
+#define CONFIG_LANNER_BURN
+#define CONFIG_DISPLAY_BOARDINFO
+#define CONFIG_SYS_GENERIC_BOARD 
+
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP 1
+#define CONFIG_SYS_NUM_ADDR_MAP 64 /* number of TLB1 entries */
+#endif
+
+#define CONFIG_SYS_FSL_CPC	/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC	CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_IFC		/* Enable IFC Support */
+#define CONFIG_FSL_LAW		/* Use common FSL init code */
+#define CONFIG_ENV_OVERWRITE
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI $(SRCTREE)/board/freescale/m300/m300_pbi.cfg
+#define CONFIG_SYS_FSL_PBL_RCW $(SRCTREE)/board/freescale/m300/m300_rcw.cfg
+
+#define CONFIG_SPL
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SPL_TEXT_BASE		0xFFFD0000
+#define CONFIG_SPL_PAD_TO		0x40000
+#define CONFIG_SPL_MAX_SIZE		0x30000
+#define RESET_VECTOR_OFFSET		0x2FFFC
+#define BOOT_PAGE_OFFSET		0x2F000
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_SKIP_RELOCATE
+#define CONFIG_SPL_COMMON_INIT_DDR
+#define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifdef CONFIG_NAND
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_START	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
+#define CONFIG_SPL_NAND_BOOT
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define	CONFIG_RESET_VECTOR_ADDRESS		0x200FFC
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_MINIMAL
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_DST		(0x00200000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define	CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_SPI_BOOT
+#endif
+
+#ifdef CONFIG_SDCARD
+#define	CONFIG_RESET_VECTOR_ADDRESS		0x200FFC
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_MMC_MINIMAL
+#define CONFIG_SYS_MMC_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_MMC_U_BOOT_DST	(0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_OFFS	(260 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define	CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_MMC_BOOT
+#endif
+
+#endif /* CONFIG_RAMBOOT_PBL */
+
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+/* Set 1M boot space */
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR)
+#define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff40000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BTB		/* toggle branch predition */
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS	0
+#define CONFIG_ENV_SPI_CS	0
+#define CONFIG_ENV_SPI_MAX_HZ	10000000
+#define CONFIG_ENV_SPI_MODE	0
+#define CONFIG_ENV_SIZE		0x2000	   /* 8KB */
+#define CONFIG_ENV_OFFSET	0x100000   /* 1MB */
+#define CONFIG_ENV_SECT_SIZE	0x10000
+#elif defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV	0
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_OFFSET	(512 * 0x800)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_OFFSET	(10 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+#define CONFIG_ENV_IS_IN_REMOTE
+#define CONFIG_ENV_ADDR		0xffe20000
+#define CONFIG_ENV_SIZE		0x2000
+#elif defined(CONFIG_ENV_IS_NOWHERE)
+#define CONFIG_ENV_SIZE		0x2000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		0xeff30000
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x10000 /* 64K (one sector) */
+#endif
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	100000000
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+
+/*
+ * Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		0xFFFC0000
+#define CONFIG_SYS_L3_SIZE		(256 << 10)
+#define CONFIG_SPL_GD_ADDR		CONFIG_SYS_INIT_L3_ADDR
+#ifdef CONFIG_NAND
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_INIT_L3_ADDR + 4 * 1024)
+#endif
+#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SYS_INIT_L3_ADDR + 10 * 1024)
+#define CONFIG_SPL_RELOC_MALLOC_SIZE	(50 << 10)
+#define CONFIG_SPL_RELOC_STACK		(CONFIG_SYS_INIT_L3_ADDR + 64 * 1024)
+#define CONFIG_SPL_RELOC_STACK_SIZE	(20 << 10)
+
+#define CONFIG_SYS_DCSRBAR	0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS	0xf00000000ull
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x56
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(2 * CONFIG_DIMM_SLOTS_PER_CTLR)
+#define CONFIG_FSL_DDR_FIRST_SLOT_QUAD_CAPABLE
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_FSL_DDR3
+#undef CONFIG_FSL_DDR_INTERACTIVE
+#define CONFIG_SYS_SPD_BUS_NUM	0
+#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
+#define CTRL_INTLV_PREFERED	cacheline
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE		0xefc00000
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(4*1024*1024)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR	CSOR_NAND_TRHZ_80
+
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1A) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	71	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS } 
+
+/* NAND Flash on IFC */
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_MAX_OOBFREE	2
+#define CONFIG_SYS_NAND_MAX_ECCPOS	256
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#define CONFIG_SYS_NAND_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_NAND_BASE)
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	 /* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+
+#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4	/* 4-bit ECC */	    \
+				| CSOR_NAND_RAL_3	/* RAL = 2Byes */   \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */\
+				| CSOR_NAND_SPRZ_64	/* Spare size = 64 */\
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)    | \
+					FTIM0_NAND_TWCHT(0x07)  | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)   | \
+					FTIM1_NAND_TRR(0x0e)    | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f)  | \
+					FTIM2_NAND_TREH(0x0a)   | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#if defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000 /* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+			((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+						GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+#define CONFIG_SYS_MONITOR_LEN		(768 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(4 * 1024 * 1024)
+
+/*
+ * Serial Port
+ */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+#define CONFIG_SYS_NS16550_COM1 (CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2 (CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3 (CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4 (CONFIG_SYS_CCSRBAR+0x11D600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/*
+ * I2C
+ */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_FSL
+#define CONFIG_SYS_FSL_I2C_SLAVE   0x7F
+#define CONFIG_SYS_FSL_I2C2_SLAVE  0x7F
+#define CONFIG_SYS_FSL_I2C3_SLAVE  0x7F
+#define CONFIG_SYS_FSL_I2C4_SLAVE  0x7F
+#define CONFIG_SYS_FSL_I2C_OFFSET  0x118000
+#define CONFIG_SYS_FSL_I2C2_OFFSET 0x118100
+#define CONFIG_SYS_FSL_I2C3_OFFSET 0x119000
+#define CONFIG_SYS_FSL_I2C4_OFFSET 0x119100
+#define CONFIG_SYS_FSL_I2C_SPEED   100000
+#define CONFIG_SYS_FSL_I2C2_SPEED  100000
+#define CONFIG_SYS_FSL_I2C3_SPEED  100000
+#define CONFIG_SYS_FSL_I2C4_SPEED  100000
+
+#define RTC
+#define CONFIG_RTC_RS5C372A               1
+
+
+
+/*
+ * RapidIO
+ */
+#define CONFIG_SYS_SRIO1_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_SRIO1_MEM_PHYS	0xc20000000ull
+#define CONFIG_SYS_SRIO1_MEM_SIZE	0x10000000 /* 256M */
+#define CONFIG_SYS_SRIO2_MEM_VIRT	0xb0000000
+#define CONFIG_SYS_SRIO2_MEM_PHYS	0xc30000000ull
+#define CONFIG_SYS_SRIO2_MEM_SIZE	0x10000000 /* 256M */
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef200000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff00000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE     0x100000 /* 1M */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff00000ull
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef100000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS 0x3ffe00000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE    0x40000	/* 256K */
+
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
+
+/*
+ * SRIO_PCIE_BOOT - SLAVE
+ */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+#endif
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#ifdef CONFIG_SPI_FLASH
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_WINBOND
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_SPI_FLASH_EON
+#endif
+
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SF_DEFAULT_SPEED	 10000000
+#define CONFIG_SF_DEFAULT_MODE	  0
+#endif
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE3		/* PCIE controler 3 */
+#define CONFIG_PCIE4		/* PCIE controler 4 */
+#define CONFIG_FSL_PCI_INIT	/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000      /* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x10000000 /* 256M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xb0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc30000000ull
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 4, Base address 203000 */
+#define CONFIG_SYS_PCIE4_MEM_VIRT       0xc0000000
+#define CONFIG_SYS_PCIE4_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE4_MEM_PHYS	0xc40000000ull
+#define CONFIG_SYS_PCIE4_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE4_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE4_IO_PHYS	0xff8030000ull
+#define CONFIG_SYS_PCIE4_IO_SIZE	0x00010000	/* 64k */
+
+#ifdef CONFIG_PCI
+#define CONFIG_PCI_INDIRECT_BRIDGE
+#define CONFIG_FSL_PCIE_RESET	   /* need PCIe reset errata */
+#define CONFIG_NET_MULTI
+#define CONFIG_E1000
+#define CONFIG_PCI_PNP		/* do pci plug-and-play */
+#define CONFIG_PCI_SCAN_SHOW	/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* Qman/Bman */
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+#define CONFIG_SYS_DPAA_QBMAN           /* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS     18
+#define CONFIG_SYS_BMAN_MEM_BASE        0xf4000000
+#define CONFIG_SYS_BMAN_MEM_PHYS        0xff4000000ull
+#define CONFIG_SYS_BMAN_MEM_SIZE        0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+                                        CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS     18
+#define CONFIG_SYS_QMAN_MEM_BASE        0xf6000000
+#define CONFIG_SYS_QMAN_MEM_PHYS        0xff6000000ull
+#define CONFIG_SYS_QMAN_MEM_SIZE        0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+                                        CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG    0xE08
+
+
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+#define CONFIG_SYS_PMAN
+#define CONFIG_SYS_DPAA_DCE
+#define CONFIG_SYS_DPAA_RMAN		/* RMan */
+#define CONFIG_SYS_INTERLAKEN
+
+/* Default address of microcode for the Linux Fman driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_FMAN_FW_ADDR	0x110000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 1MB (2048 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 2048 + 16 = 2072, enlarge it to 2080.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_FMAN_FW_ADDR	(512 * 0x820)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_FMAN_FW_ADDR	(11 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+/*
+ * Slave has no ucode locally, it can fetch this from remote. When implementing
+ * in two corenet boards, slave's ucode could be stored in master's memory
+ * space, the address can be mapped from slave TLB->slave LAW->
+ * slave SRIO or PCIE outbound window->master inbound window->
+ * master LAW->the ucode address in master's memory space.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+#define CONFIG_SYS_FMAN_FW_ADDR	0xFFE00000
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_FMAN_FW_ADDR		0xEFF20000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MARVELL
+#define RGMII_PHY1_ADDR	0x10
+#define RGMII_PHY2_ADDR	0x4
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC3"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+
+/*
+ * USB
+ */
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#define CONFIG_HAS_FSL_DR_USB
+#endif
+
+/*
+ * SDHC
+ */
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+
+
+/*
+ * Environment
+ */
+#define CONFIG_LOADS_ECHO	/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_BDI
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_CMDLINE_EDITING		/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE		/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000 /* default load address */
+#define CONFIG_SYS_PROMPT	"MB-M300 => "	  /* Monitor Command Prompt */
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024	  /* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256	  /* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000	/* decrementer freq: 1ms ticks*/
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH	 "/opt/nfsroot"
+#define CONFIG_BOOTFILE	 "uImage"
+#define CONFIG_UBOOTPATH "u-boot.bin"	/* U-Boot image on TFTP server */
+
+/* WatchGuard BootMenu */
+#define CONFIG_WG_BOOTMENU
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+#define __USB_PHY_TYPE		utmi
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:"					\
+	"ctlr_intlv=" __stringify(CTRL_INTLV_PREFERED) ","	\
+	"bank_intlv=auto;"					\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"	\
+	"bootloader_flash_update=protect off 0xeff40000 0xefffffff &&" \
+	"erase 0xeff40000 0xefffffff && "			\
+	"cp.b 0x100000 0xeff40000 0xc0000 && "		\
+	"protect on 0xeff40000 0xefffffff && "			\
+	"cmp.b 0xeff40000 0x100000 0xc0000 \0"		\
+	"nuke_env=protect off 0xeff30000 0xeff3ffff && " \
+	"erase 0xeff30000 0xeff3ffff \0" \
+	"lannerboot=setenv bootargs root=/dev/ram rw " \
+	"rootdelay=10 console=ttyS0,115200 ramdisk_size=2800000 &&" \
+	"usb start && " \
+	"fatload mmc 0:1 1000000 uImage && " \
+	"fatload mmc 0:1 c00000  m300.dtb && " \
+	"fatload mmc 0:1 2000000 lanner/rootfs.ext2.gz.u-boot.lanner && " \
+	"bootm 1000000 2000000 c00000 \0 " \
+	"lannerboots=setenv bootargs root=/dev/ram rw " \
+	"rootdelay=10 console=ttyS0,115200 ramdisk_size=2800000 &&" \
+	"usb start && " \
+	"fatload usb 0:1 1000000 uImage && " \
+	"fatload usb 0:1 c00000  m300.dtb && " \
+	"fatload usb 0:1 2000000 lanner/rootfs.ext2.gz.u-boot.lanner.usb && " \
+	"bootm 1000000 2000000 c00000 \0 " \
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=rootfs.ext2.gz.u-boot\0"			\
+	"fdtaddr=fc0000\0"                                      \
+	"loadaddr=1000000\0"			                \
+	"fdtfile=m300.dtb\0"                                    \
+	"WGKernelfile=uImage_m300\0"                                \
+	"bdev=sda3\0"                                           \
+	"SysARoot=mmcblk0p3\0"	\
+	"SysBRoot=mmcblk0p2\0"	\
+	"wgBootBoot=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:1 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:1 $loadaddr $WGKernelfile; " \
+	"usb start; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"usb start; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:2 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:2 $loadaddr $WGKernelfile; " \
+	"usb start; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"usb start; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"c=ffe\0"
+
+#define CONFIG_NFSBOOTCOMMAND		\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_HDBOOT			\
+	"setenv bootargs root=/dev/$bdev rw rootdelay=30 "	\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"usb start;"			\
+	"ext2load usb 0:1 $loadaddr /boot/$bootfile;"		\
+	"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __CONFIG_H */
--- u-boot-2014.07/include/configs/T102xQDS.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/configs/T102xQDS.h	2022-05-09 14:06:23.885122998 -0700
@@ -0,0 +1,955 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*
+ * T1024/T1023 QDS board configuration file
+ */
+
+#ifndef __T1024QDS_H
+#define __T1024QDS_H
+
+/* High Level Configuration Options */
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+#define CONFIG_BOOKE
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_E500MC			/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
+#define CONFIG_MP			/* support multiple processors */
+#define CONFIG_PHYS_64BIT
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP		1
+#define CONFIG_SYS_NUM_ADDR_MAP	64	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_SYS_FSL_CPC		/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC		CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_DEEP_SLEEP
+#define CONFIG_SILENT_CONSOLE
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI board/freescale/t102xqds/t1024_pbi.cfg
+#define CONFIG_SYS_FSL_PBL_RCW board/freescale/t102xqds/t1024_rcw.cfg
+#define CONFIG_SPL
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SPL_TEXT_BASE		0xFFFD8000
+#define CONFIG_SPL_PAD_TO		0x40000
+#define CONFIG_SPL_MAX_SIZE		0x28000
+#define RESET_VECTOR_OFFSET		0x27FFC
+#define BOOT_PAGE_OFFSET		0x27000
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_SKIP_RELOCATE
+#define CONFIG_SPL_COMMON_INIT_DDR
+#define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifdef CONFIG_NAND
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_START	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
+#define CONFIG_SPL_NAND_BOOT
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define CONFIG_RESET_VECTOR_ADDRESS		0x200FFC
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_MINIMAL
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_DST		(0x00200000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT		"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_SPI_BOOT
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RESET_VECTOR_ADDRESS		0x200FFC
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_MMC_MINIMAL
+#define CONFIG_SYS_MMC_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_MMC_U_BOOT_DST	(0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_OFFS	(260 << 10)
+#define CONFIG_SYS_LDSCRIPT		"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_MMC_BOOT
+#endif
+
+#endif /* CONFIG_RAMBOOT_PBL */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff40000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+/* PCIe Boot - Master */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff00000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE     0x100000 /* 1M */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef200000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff00000ull
+#else
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xef200000
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0xfff00000
+#endif
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef100000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS	 0x3ffe00000ull
+#else
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xef100000
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS  0xffe00000
+#endif
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE     0x40000 /* 256K */
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET 0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK 0x00000001 /* release core 0 */
+
+/* PCIe Boot - Slave */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+/* Set 1M boot space for PCIe boot */
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS       \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR)
+#define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#define CONFIG_ENV_SPI_MAX_HZ		10000000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SIZE			0x2000		/* 8KB */
+#define CONFIG_ENV_OFFSET		0x100000	/* 1MB */
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#elif defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(512 * 0x800)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(10 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+#define CONFIG_ENV_IS_IN_REMOTE
+#define CONFIG_ENV_ADDR		0xffe20000
+#define CONFIG_ENV_SIZE		0x2000
+#elif defined(CONFIG_ENV_IS_NOWHERE)
+#define CONFIG_ENV_SIZE		0x2000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk()
+#define CONFIG_DDR_CLK_FREQ	get_board_ddr_clk()
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BACKSIDE_L2_CACHE
+#define CONFIG_SYS_INIT_L2CSR0		L2CSR0_L2E
+#define CONFIG_BTB			/* toggle branch predition */
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000 /* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/*
+ *  Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		0xFFFC0000
+#define CONFIG_SYS_L3_SIZE		(256 << 10)
+#define CONFIG_SPL_GD_ADDR		(CONFIG_SYS_INIT_L3_ADDR + 32 * 1024)
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_ENV_ADDR			(CONFIG_SPL_GD_ADDR + 4 * 1024)
+#endif
+#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SPL_GD_ADDR + 12 * 1024)
+#define CONFIG_SPL_RELOC_MALLOC_SIZE	(30 << 10)
+#define CONFIG_SPL_RELOC_STACK		(CONFIG_SPL_GD_ADDR + 64 * 1024)
+#define CONFIG_SPL_RELOC_STACK_SIZE	(22 << 10)
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_DCSRBAR		0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
+#endif
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(4 * CONFIG_DIMM_SLOTS_PER_CTLR)
+#define CONFIG_DDR_SPD
+#ifndef CONFIG_SYS_FSL_DDR4
+#define CONFIG_SYS_FSL_DDR3
+#endif
+
+#define CONFIG_SYS_SPD_BUS_NUM	0
+#define SPD_EEPROM_ADDRESS	0x51
+
+#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE	0xe0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				+ 0x8000000) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR1_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR	CSOR_NAND_TRHZ_80
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1A) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS \
+					+ 0x8000000, CONFIG_SYS_FLASH_BASE_PHYS}
+#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
+#define QIXIS_BASE		0xffdf0000
+#ifdef CONFIG_PHYS_64BIT
+#define QIXIS_BASE_PHYS		(0xf00000000ull | QIXIS_BASE)
+#else
+#define QIXIS_BASE_PHYS		QIXIS_BASE
+#endif
+#define QIXIS_LBMAP_SWITCH		0x06
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define	QIXIS_RST_FORCE_MEM		0x01
+
+#define CONFIG_SYS_CSPR3_EXT	(0xf)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_AMASK3	IFC_AMASK(4*1024)
+#define CONFIG_SYS_CSOR3	0x0
+/* QIXIS Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x8) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_NAND_BASE)
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS       CONFIG_SYS_NAND_BASE
+#endif
+#define CONFIG_SYS_NAND_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#if defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+#endif
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000	/* Initial L1 address */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#else
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	0xfe0ec000 /* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+#endif
+#define CONFIG_SYS_INIT_RAM_SIZE		0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(768 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(10 * 1024 * 1024)
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR+0x11D600)
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+
+/* Video */
+#ifdef CONFIG_PPC_T1024		/* no DIU on T1023 */
+#define CONFIG_FSL_DIU_FB
+#ifdef CONFIG_FSL_DIU_FB
+#define CONFIG_SYS_DIU_ADDR	(CONFIG_SYS_CCSRBAR + 0x180000)
+#define CONFIG_VIDEO
+#define CONFIG_CMD_BMP
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+/*
+ * With CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS, flash I/O is really slow, so
+ * disable empty flash sector detection, which is I/O-intensive.
+ */
+#undef CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+#endif
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_FSL		/* Use FSL common I2C driver */
+#define CONFIG_SYS_FSL_I2C_SPEED	50000	/* I2C speed in Hz */
+#define CONFIG_SYS_FSL_I2C_SLAVE	0x7F
+#define CONFIG_SYS_FSL_I2C2_SPEED	50000	/* I2C speed in Hz */
+#define CONFIG_SYS_FSL_I2C2_SLAVE	0x7F
+#define CONFIG_SYS_FSL_I2C_OFFSET	0x118000
+#define CONFIG_SYS_FSL_I2C2_OFFSET	0x118100
+
+#define I2C_MUX_PCA_ADDR		0x77
+#define I2C_MUX_PCA_ADDR_PRI		0x77 /* Primary Mux*/
+#define I2C_MUX_PCA_ADDR_SEC		0x76 /* Secondary multiplexer */
+#define I2C_RETIMER_ADDR		0x18
+
+/* I2C bus multiplexer */
+#define I2C_MUX_CH_DEFAULT      0x8
+#define I2C_MUX_CH_DIU		0xC
+#define I2C_MUX_CH5		0xD
+#define I2C_MUX_CH7		0xF
+
+/* LDI/DVI Encoder for display */
+#define CONFIG_SYS_I2C_LDI_ADDR	 0x38
+#define CONFIG_SYS_I2C_DVI_ADDR	 0x75
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_DS3231	1
+#define CONFIG_SYS_I2C_RTC_ADDR	0x68
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_SPI_FLASH_EON
+#endif
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SF_DEFAULT_SPEED	 10000000
+#define CONFIG_SF_DEFAULT_MODE	  0
+
+/*
+ * General PCIe
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE3		/* PCIE controler 3 */
+#define CONFIG_FSL_PCI_INIT	/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+#define CONFIG_PCI_INDIRECT_BRIDGE
+
+#ifdef CONFIG_PCI
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#ifdef CONFIG_PCIE1
+#define	CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define	CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define	CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xf8000000
+#endif
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#ifdef CONFIG_PCIE2
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0x90000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc10000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0x90000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0x90000000
+#endif
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
+#else
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xf8010000
+#endif
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#ifdef CONFIG_PCIE3
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
+#else
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xf8020000
+#endif
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_E1000
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif	/* CONFIG_PCI */
+
+/*
+ *SATA
+ */
+#define CONFIG_FSL_SATA_V2
+#ifdef CONFIG_FSL_SATA_V2
+#define CONFIG_LIBATA
+#define CONFIG_FSL_SATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_LBA48
+#define CONFIG_CMD_SATA
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
+ * USB
+ */
+#define CONFIG_HAS_FSL_DR_USB
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
+ * SDHC
+ */
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#else
+#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
+#else
+#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
+
+#define CONFIG_SYS_DPAA_FMAN
+
+#define CONFIG_QE
+#define CONFIG_U_QE
+/* Default address of microcode for the Linux FMan driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_FMAN_FW_ADDR	0x110000
+#define CONFIG_SYS_QE_FW_ADDR	0x130000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 1MB (2048 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 2048 + 16 = 2072, enlarge it to 2080(0x820).
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_FMAN_FW_ADDR		(512 * 0x820)
+#define CONFIG_SYS_QE_FW_ADDR		(512 * 0x920)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_FMAN_FW_ADDR		(11 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#define CONFIG_SYS_QE_FW_ADDR		(12 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+/*
+ * Slave has no ucode locally, it can fetch this from remote. When implementing
+ * in two corenet boards, slave's ucode could be stored in master's memory
+ * space, the address can be mapped from slave TLB->slave LAW->
+ * slave SRIO or PCIE outbound window->master inbound window->
+ * master LAW->the ucode address in master's memory space.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+#define CONFIG_SYS_FMAN_FW_ADDR 0xFFE00000
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_FMAN_FW_ADDR		0xEFF00000
+#define CONFIG_SYS_QE_FW_ADDR		0xEFE00000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB_10G
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_REALTEK
+#define CONFIG_PHY_TERANETICS
+#define RGMII_PHY1_ADDR		0x1
+#define RGMII_PHY2_ADDR		0x2
+#define SGMII_CARD_AQ_PHY_ADDR_S3 0x3
+#define SGMII_CARD_AQ_PHY_ADDR_S4 0x4
+#define SGMII_CARD_AQ_PHY_ADDR_S5 0x5
+#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
+#define SGMII_CARD_PORT2_PHY_ADDR 0x1D
+#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
+#define SGMII_CARD_PORT4_PHY_ADDR 0x1F
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC4"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+ * Dynamic MTD Partition support with mtdparts
+ */
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_FLASH_CFI_MTD
+#define MTDIDS_DEFAULT    "nor0=fe8000000.nor,nand0=fff800000.flash," \
+			  "spi0=spife110000.0"
+#define MTDPARTS_DEFAULT  "mtdparts=fe8000000.nor:1m(uboot),5m(kernel)," \
+			  "128k(dtb),96m(fs),-(user);"\
+			  "fff800000.flash:2m(uboot),9m(kernel),"\
+			  "128k(dtb),96m(fs),-(user);spife110000.0:" \
+			  "2m(uboot),9m(kernel),128k(dtb),-(user)"
+#endif
+
+/*
+ * Environment
+ */
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE  CONFIG_SYS_CBSIZE  /* Boot Argument Buffer Size */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	"u-boot.bin" /* U-Boot image on TFTP server */
+#define CONFIG_LOADADDR		1000000 /* default location for tftp, bootm */
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+#define CONFIG_BAUDRATE		115200
+#define __USB_PHY_TYPE		utmi
+
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,bank_intlv=cs0_cs1;\0"  \
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0" \
+	"bootargs=root=/dev/ram rw console=ttyS0,115200\0" \
+	"ramdiskfile=t1024qds/ramdisk.uboot\0"			\
+	"fdtfile=t1024qds/t1024qds.dtb\0"			\
+	"netdev=eth0\0"						\
+	"video-mode=fslfb:1024x768-32@60,monitor=dvi\0"		\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"	\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"fdtaddr=d00000\0"					\
+	"bdev=sda3\0"
+
+#define CONFIG_LINUX					\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"setenv ramdiskaddr 0x02000000;"		\
+	"setenv fdtaddr 0x00c00000;"			\
+	"setenv loadaddr 0x1000000;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND	CONFIG_LINUX
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __T1024QDS_H */
--- u-boot-2014.07/include/configs/ls1021atwr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/configs/ls1021atwr.h	2022-05-09 14:06:23.933121057 -0700
@@ -0,0 +1,450 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <config_cmd_default.h>
+
+#define CONFIG_LS102XA
+
+#define CONFIG_SYS_GENERIC_BOARD
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_BOARD_EARLY_INIT_F
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 16 * 1024 * 1024)
+
+#define CONFIG_ARMV7_NONSEC
+#define CONFIG_ARMV7_VIRT
+#define CONFIG_PEN_ADDR_BIG_ENDIAN
+#define CONFIG_LS102XA_NS_ACESS
+#define CONFIG_SMP_PEN_ADDR		0x01ee0200
+#define CONFIG_TIMER_CLK_FREQ		12500000
+
+#define CONFIG_SYS_INIT_RAM_ADDR	OCRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	OCRAM_SIZE
+
+/*
+ * USB
+ */
+/*EHCI Support*/
+/*#define CONFIG_HAS_FSL_DR_USB*/
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#endif
+
+/*XHCI Support*/
+#define CONFIG_HAS_FSL_XHCI_USB
+
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+#define CONFIG_USB_XHCI
+#define CONFIG_USB_XHCI_FSL
+#define CONFIG_USB_MAX_CONTROLLER_COUNT        1
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS     2
+#endif
+
+#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_XHCI_USB)
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
+ * Generic Timer Definitions
+ */
+#define GENERIC_TIMER_CLK		12500000
+
+#define CONFIG_SYS_CLK_FREQ		100000000
+#define CONFIG_DDR_CLK_FREQ		100000000
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI	board/freescale/ls1021atwr/ls102xa_pbi.cfg
+#endif
+
+#ifdef CONFIG_SD_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW	board/freescale/ls1021atwr/ls102xa_rcw_sd.cfg
+#define CONFIG_SPL
+#define CONFIG_SPL_PBL_PAD
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_LDSCRIPT	"arch/$(ARCH)/cpu/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_WATCHDOG_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR		0xe8
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS		0x400
+
+#define CONFIG_SPL_TEXT_BASE		0x10000000
+#define CONFIG_SPL_MAX_SIZE		0x1a000
+#define CONFIG_SPL_STACK		0x1001d000
+#define CONFIG_SPL_PAD_TO		0x1c000
+#define CONFIG_SYS_TEXT_BASE		0x82000000
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+#define CONFIG_SPL_BSS_START_ADDR	0x80100000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000
+#define CONFIG_SYS_MONITOR_LEN		0x80000
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#if defined(CONFIG_QSPI_BOOT)
+#define CONFIG_SYS_TEXT_BASE		0x40010000
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0x67f80000
+#endif
+
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			0x80000000
+#define PHYS_SDRAM_SIZE			(1u * 1024 * 1024 * 1024)
+
+#define CONFIG_SYS_DDR_SDRAM_BASE      0x80000000UL
+#define CONFIG_SYS_SDRAM_BASE          CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_SYS_HAS_SERDES
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_NAND_BOOT) && \
+	!defined(CONFIG_QSPI_BOOT)
+#define CONFIG_U_QE
+#endif
+
+/*
+ * IFC Definitions
+ */
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+#define CONFIG_FSL_IFC
+#define CONFIG_SYS_FLASH_BASE		0x60000000
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128 * 1024 * 1024)
+
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
+					CSOR_NOR_TRHZ_80)
+#define CONFIG_SYS_NOR_FTIM0		(FTIM0_NOR_TACSE(0x4) | \
+					FTIM0_NOR_TEADC(0x5) | \
+					FTIM0_NOR_TAVDS(0x0) | \
+					FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1		(FTIM1_NOR_TACO(0x35) | \
+					FTIM1_NOR_TRAD_NOR(0x1A) | \
+					FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2		(FTIM2_NOR_TCS(0x4) | \
+					FTIM2_NOR_TCH(0x4) | \
+					FTIM2_NOR_TWP(0x1c) | \
+					FTIM2_NOR_TWPH(0x0e))
+#define CONFIG_SYS_NOR_FTIM3		0
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45	/* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE_PHYS }
+
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+#define CONFIG_SYS_WRITE_SWAPPED_DATA
+#endif
+
+/* CPLD */
+
+#define CONFIG_SYS_CPLD_BASE	0x7fb00000
+#define CPLD_BASE_PHYS		CONFIG_SYS_CPLD_BASE
+
+#define CONFIG_SYS_FPGA_CSPR_EXT        (0x0)
+#define CONFIG_SYS_FPGA_CSPR		(CSPR_PHYS_ADDR(CPLD_BASE_PHYS) | \
+					CSPR_PORT_SIZE_8 | \
+					CSPR_MSEL_GPCM | \
+					CSPR_V)
+#define CONFIG_SYS_FPGA_AMASK		IFC_AMASK(64 * 1024)
+#define CONFIG_SYS_FPGA_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
+					CSOR_NOR_NOR_MODE_AVD_NOR | \
+					CSOR_NOR_TRHZ_80)
+
+/* CPLD Timing parameters for IFC GPCM */
+#define CONFIG_SYS_FPGA_FTIM0		(FTIM0_GPCM_TACSE(0xf) | \
+					FTIM0_GPCM_TEADC(0xf) | \
+					FTIM0_GPCM_TEAHC(0xf))
+#define CONFIG_SYS_FPGA_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define CONFIG_SYS_FPGA_FTIM2		(FTIM2_GPCM_TCS(0xf) | \
+					FTIM2_GPCM_TCH(0xf) | \
+					FTIM2_GPCM_TWP(0xff))
+#define CONFIG_SYS_FPGA_FTIM3           0x0
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_FPGA_FTIM3
+
+/*
+ * Serial Port
+ */
+#ifdef CONFIG_LPUART
+#define CONFIG_FSL_LPUART
+#define CONFIG_LPUART_32B_REG
+#else
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_serial_clock()
+#endif
+
+#define CONFIG_BAUDRATE			115200
+
+/*
+ * I2C
+ */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+
+/* EEPROM */
+#ifndef CONFIG_SD_BOOT
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM		1
+#define CONFIG_SYS_I2C_EEPROM_ADDR		0x53
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS	3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	5
+#endif
+
+/*
+ * MMC
+ */
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_GENERIC_MMC
+
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+/*SPI device */
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_FSL_SPI_INTERFACE
+#define CONFIG_SPI_FLASH_STMICRO
+
+/* QSPI */
+#define CONFIG_FSL_QSPI
+#ifdef CONFIG_FSL_QSPI
+#define QSPI_AMBA_BASE			0x40000000
+#define FSL_QSPI_FLASH_SIZE            (1 << 24)
+#define FSL_QSPI_FLASH_NUM             2
+#endif
+
+/*
+ * Video
+ */
+#define CONFIG_FSL_DCU_FB
+
+#ifdef CONFIG_FSL_DCU_FB
+#define CONFIG_VIDEO
+#define CONFIG_CMD_BMP
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+
+#define CONFIG_FSL_DCU_SII9022A
+#define CONFIG_SYS_I2C_DVI_BUS_NUM	1
+#define CONFIG_SYS_I2C_DVI_ADDR		0x39
+#endif
+
+/*
+ * eTSEC
+ */
+#define CONFIG_TSEC_ENET
+
+#ifdef CONFIG_TSEC_ENET
+#define CONFIG_MII
+#define CONFIG_MII_DEFAULT_TSEC		1
+#define CONFIG_TSEC1			1
+#define CONFIG_TSEC1_NAME		"eTSEC1"
+#define CONFIG_TSEC2			1
+#define CONFIG_TSEC2_NAME		"eTSEC2"
+#define CONFIG_TSEC3			1
+#define CONFIG_TSEC3_NAME		"eTSEC3"
+
+#define TSEC1_PHY_ADDR			2
+#define TSEC2_PHY_ADDR			0
+#define TSEC3_PHY_ADDR			1
+
+#define TSEC1_FLAGS			(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS			(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS			(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define TSEC1_PHYIDX			0
+#define TSEC2_PHYIDX			0
+#define TSEC3_PHYIDX			0
+
+#define CONFIG_ETHPRIME			"eTSEC1"
+
+#define CONFIG_PHY_GIGE
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#endif
+
+/* PCIe */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
+#define FSL_PCIE_COMPAT "fsl,ls1021a-pcie"
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_CMDLINE_EDITING
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+#define CONFIG_CMD_IMLS
+#else
+#undef CONFIG_CMD_IMLS
+#endif
+
+#define CONFIG_HWCONFIG
+#define HWCONFIG_BUFFER_SIZE		128
+
+#define CONFIG_BOOTDELAY		3
+
+#ifdef CONFIG_LPUART
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"bootargs=root=/dev/ram0 rw console=ttyLP0,115200\0" \
+	"initrd_high=0xcfffffff\0"      \
+	"fdt_high=0xcfffffff\0"
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"bootargs=root=/dev/ram0 rw console=ttyS0,115200\0" \
+	"initrd_high=0xcfffffff\0"      \
+	"fdt_high=0xcfffffff\0"
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		\
+		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_ENV_EXISTS
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_MEMINFO
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		0x9fffffff
+
+#define CONFIG_SYS_LOAD_ADDR		0x82000000
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_LS102XA_STREAM_ID
+
+/*
+ * Stack sizes
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE		(30 * 1024)
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+#define CONFIG_SYS_QE_FW_ADDR     0x67f40000
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#if defined(CONFIG_SD_BOOT)
+#define CONFIG_ENV_OFFSET		(1024 * 1024)
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x20000
+#elif defined(CONFIG_QSPI_BOOT)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		0x100000
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE			0x20000
+#define CONFIG_ENV_SECT_SIZE		0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_MISC_INIT_R
+
+#include <asm/fsl_secure_boot.h>
+
+#endif
--- u-boot-2014.07/include/configs/T102xRDB.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/configs/T102xRDB.h	2022-05-09 14:06:23.885122998 -0700
@@ -0,0 +1,913 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+/*
+ * T1024/T1023 RDB board configuration file
+ */
+
+#ifndef __T1024RDB_H
+#define __T1024RDB_H
+
+/* High Level Configuration Options */
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+#define CONFIG_BOOKE
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_E500MC			/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
+#define CONFIG_MP			/* support multiple processors */
+#define CONFIG_PHYS_64BIT
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP		1
+#define CONFIG_SYS_NUM_ADDR_MAP	64	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_SYS_FSL_CPC		/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC		CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_ENV_OVERWRITE
+
+/* support deep sleep */
+#define CONFIG_FSL_DEEP_SLEEP
+#define CONFIG_SILENT_CONSOLE
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI board/freescale/t102xrdb/t1024_pbi.cfg
+#define CONFIG_SYS_FSL_PBL_RCW board/freescale/t102xrdb/t1024_rcw.cfg
+#define CONFIG_SPL
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SPL_TEXT_BASE		0xFFFD8000
+#define CONFIG_SPL_PAD_TO		0x40000
+#define CONFIG_SPL_MAX_SIZE		0x28000
+#define RESET_VECTOR_OFFSET		0x27FFC
+#define BOOT_PAGE_OFFSET		0x27000
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_SKIP_RELOCATE
+#define CONFIG_SPL_COMMON_INIT_DDR
+#define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifdef CONFIG_NAND
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_START	0x00200000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
+#define CONFIG_SPL_NAND_BOOT
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define CONFIG_RESET_VECTOR_ADDRESS		0x200FFC
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_MINIMAL
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_DST		(0x00200000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT		"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_SPI_BOOT
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RESET_VECTOR_ADDRESS	0x200FFC
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_MMC_MINIMAL
+#define CONFIG_SYS_MMC_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_MMC_U_BOOT_DST	(0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_START	(0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_OFFS	(260 << 10)
+#define CONFIG_SYS_LDSCRIPT		"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_MMC_BOOT
+#endif
+
+#endif /* CONFIG_RAMBOOT_PBL */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff40000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+/* PCIe Boot - Master */
+#define CONFIG_SRIO_PCIE_BOOT_MASTER
+/*
+ * for slave u-boot IMAGE instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS1 0xfff00000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_SIZE     0x100000 /* 1M */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xfef200000ull
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0x3fff00000ull
+#else
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_PHYS 0xef200000
+#define CONFIG_SRIO_PCIE_BOOT_IMAGE_MEM_BUS2 0xfff00000
+#endif
+/*
+ * for slave UCODE and ENV instored in master memory space,
+ * PHYS must be aligned based on the SIZE
+ */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xfef100000ull
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS	 0x3ffe00000ull
+#else
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_PHYS 0xef100000
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_MEM_BUS  0xffe00000
+#endif
+#define CONFIG_SRIO_PCIE_BOOT_UCODE_ENV_SIZE	0x40000 /* 256K */
+/* slave core release by master*/
+#define CONFIG_SRIO_PCIE_BOOT_BRR_OFFSET	0xe00e4
+#define CONFIG_SRIO_PCIE_BOOT_RELEASE_MASK	0x00000001 /* release core 0 */
+
+/* PCIe Boot - Slave */
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR 0xFFE00000
+#define CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS \
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR)
+/* Set 1M boot space for PCIe boot */
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR (CONFIG_SYS_TEXT_BASE & 0xfff00000)
+#define CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS	\
+		(0x300000000ull | CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR)
+#define CONFIG_RESET_VECTOR_ADDRESS 0xfffffffc
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#define CONFIG_ENV_SPI_MAX_HZ		10000000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SIZE			0x2000		/* 8KB */
+#define CONFIG_ENV_OFFSET		0x100000	/* 1MB */
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#elif defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(512 * 0x800)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(2 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+#define CONFIG_ENV_IS_IN_REMOTE
+#define CONFIG_ENV_ADDR		0xffe20000
+#define CONFIG_ENV_SIZE		0x2000
+#elif defined(CONFIG_ENV_IS_NOWHERE)
+#define CONFIG_ENV_SIZE		0x2000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	66660000
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BACKSIDE_L2_CACHE
+#define CONFIG_SYS_INIT_L2CSR0		L2CSR0_L2E
+#define CONFIG_BTB			/* toggle branch predition */
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000 /* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/*
+ *  Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		0xFFFC0000
+#define CONFIG_SYS_L3_SIZE		(256 << 10)
+#define CONFIG_SPL_GD_ADDR		(CONFIG_SYS_INIT_L3_ADDR + 32 * 1024)
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_ENV_ADDR			(CONFIG_SPL_GD_ADDR + 4 * 1024)
+#endif
+#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SPL_GD_ADDR + 12 * 1024)
+#define CONFIG_SPL_RELOC_MALLOC_SIZE	(30 << 10)
+#define CONFIG_SPL_RELOC_STACK		(CONFIG_SPL_GD_ADDR + 64 * 1024)
+#define CONFIG_SPL_RELOC_STACK_SIZE	(22 << 10)
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_DCSRBAR		0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
+#endif
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	2
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(4 * CONFIG_DIMM_SLOTS_PER_CTLR)
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_FSL_DDR3
+
+#define CONFIG_SYS_SPD_BUS_NUM	0
+#define SPD_EEPROM_ADDRESS	0x51
+
+#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE	0xe8000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR	CSOR_NAND_TRHZ_80
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1A) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS}
+
+/* CPLD on IFC */
+#define CONFIG_SYS_CPLD_BASE		0xffdf0000
+#define CONFIG_SYS_CPLD_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_CPLD_BASE)
+#define CONFIG_SYS_CSPR2_EXT		(0xf)
+#define CONFIG_SYS_CSPR2		(CSPR_PHYS_ADDR(CONFIG_SYS_CPLD_BASE) \
+						| CSPR_PORT_SIZE_8 \
+						| CSPR_MSEL_GPCM \
+						| CSPR_V)
+#define CONFIG_SYS_AMASK2		IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR2		0x0
+
+/* CPLD Timing parameters for IFC CS2 */
+#define CONFIG_SYS_CS2_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+						FTIM0_GPCM_TEADC(0x0e) | \
+						FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS2_FTIM1		(FTIM1_GPCM_TACO(0x0e) | \
+						FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS2_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+						FTIM2_GPCM_TCH(0x8) | \
+						FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS2_FTIM3		0x0
+
+/* NAND Flash on IFC */
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_NAND_BASE)
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+#define CONFIG_SYS_NAND_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+
+#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_4K	/* Page Size = 4K */ \
+				| CSOR_NAND_SPRZ_224	/* Spare size = 224 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(512 * 1024)
+
+#if defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE
+#endif
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000	/* Initial L1 address */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#else
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	0xfe0ec000 /* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+#endif
+#define CONFIG_SYS_INIT_RAM_SIZE		0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(768 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(10 * 1024 * 1024)
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR+0x11D600)
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+
+/* Video */
+#undef CONFIG_FSL_DIU_FB	/* RDB doesn't support DIU */
+#ifdef CONFIG_FSL_DIU_FB
+#define CONFIG_SYS_DIU_ADDR	(CONFIG_SYS_CCSRBAR + 0x180000)
+#define CONFIG_VIDEO
+#define CONFIG_CMD_BMP
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VIDEO_SW_CURSOR
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+/*
+ * With CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS, flash I/O is really slow, so
+ * disable empty flash sector detection, which is I/O-intensive.
+ */
+#undef CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_FSL		/* Use FSL common I2C driver */
+#define CONFIG_SYS_FSL_I2C_SPEED	50000	/* I2C speed in Hz */
+#define CONFIG_SYS_FSL_I2C_SLAVE	0x7F
+#define CONFIG_SYS_FSL_I2C2_SPEED	50000	/* I2C speed in Hz */
+#define CONFIG_SYS_FSL_I2C2_SLAVE	0x7F
+#define CONFIG_SYS_FSL_I2C_OFFSET	0x118000
+#define CONFIG_SYS_FSL_I2C2_OFFSET	0x118100
+
+#define I2C_MUX_PCA_ADDR		0x77
+#define I2C_MUX_PCA_ADDR_PRI		0x77 /* Primary Mux*/
+
+
+/* I2C bus multiplexer */
+#define I2C_MUX_CH_DEFAULT	0x8
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_DS1337	1
+#define CONFIG_SYS_I2C_RTC_ADDR	0x68
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SF_DEFAULT_SPEED	10000000
+#define CONFIG_SF_DEFAULT_MODE	0
+
+/*
+ * General PCIe
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE3		/* PCIE controler 3 */
+#ifdef CONFIG_PPC_T1040
+#define CONFIG_PCIE4		/* PCIE controler 4 */
+#endif
+#define CONFIG_FSL_PCI_INIT	/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+#define CONFIG_PCI_INDIRECT_BRIDGE
+
+#ifdef CONFIG_PCI
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#ifdef CONFIG_PCIE1
+#define	CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define	CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define	CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xf8000000
+#endif
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#ifdef CONFIG_PCIE2
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0x90000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc10000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0x90000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0x90000000
+#endif
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
+#else
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xf8010000
+#endif
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#ifdef CONFIG_PCIE3
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
+#else
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xf8020000
+#endif
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 4, Base address 203000, to be removed */
+#ifdef CONFIG_PCIE4
+#define CONFIG_SYS_PCIE4_MEM_VIRT       0xb0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE4_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE4_MEM_PHYS       0xc30000000ull
+#else
+#define CONFIG_SYS_PCIE4_MEM_BUS	0xb0000000
+#define CONFIG_SYS_PCIE4_MEM_PHYS	0xb0000000
+#endif
+#define CONFIG_SYS_PCIE4_MEM_SIZE       0x10000000      /* 256M */
+#define CONFIG_SYS_PCIE4_IO_VIRT	0xf8030000
+#define CONFIG_SYS_PCIE4_IO_BUS		0x00000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE4_IO_PHYS	0xff8030000ull
+#else
+#define CONFIG_SYS_PCIE4_IO_PHYS	0xf8030000
+#endif
+#define CONFIG_SYS_PCIE4_IO_SIZE	0x00010000      /* 64k */
+#endif
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_E1000
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif	/* CONFIG_PCI */
+
+/*
+ * USB
+ */
+#define CONFIG_HAS_FSL_DR_USB
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
+ * SDHC
+ */
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	10
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#else
+#define CONFIG_SYS_BMAN_MEM_PHYS	CONFIG_SYS_BMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	10
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
+#else
+#define CONFIG_SYS_QMAN_MEM_PHYS	CONFIG_SYS_QMAN_MEM_BASE
+#endif
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
+
+#define CONFIG_SYS_DPAA_FMAN
+
+#define CONFIG_QE
+#define CONFIG_U_QE
+/* Default address of microcode for the Linux FMan driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_FMAN_FW_ADDR	0x110000
+#define CONFIG_SYS_QE_FW_ADDR	0x130000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 1MB (2048 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 2048 + 16 = 2072, enlarge it to 2080(0x820).
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_FMAN_FW_ADDR		(512 * 0x820)
+#define CONFIG_SYS_QE_FW_ADDR		(512 * 0x920)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_FMAN_FW_ADDR		(3 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#define CONFIG_SYS_QE_FW_ADDR		(4 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+/*
+ * Slave has no ucode locally, it can fetch this from remote. When implementing
+ * in two corenet boards, slave's ucode could be stored in master's memory
+ * space, the address can be mapped from slave TLB->slave LAW->
+ * slave SRIO or PCIE outbound window->master inbound window->
+ * master LAW->the ucode address in master's memory space.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_REMOTE
+#define CONFIG_SYS_FMAN_FW_ADDR		0xFFE00000
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_FMAN_FW_ADDR		0xEFF00000
+#define CONFIG_SYS_QE_FW_ADDR		0xEFE00000
+#endif
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHYLIB_10G
+#define CONFIG_PHY_REALTEK
+#define RGMII_PHY1_ADDR		0x2
+#define RGMII_PHY2_ADDR		0x6
+#define FM1_10GEC1_PHY_ADDR	0x1
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC4"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+ * Dynamic MTD Partition support with mtdparts
+ */
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_FLASH_CFI_MTD
+#define MTDIDS_DEFAULT "nor0=fe8000000.nor,nand0=fff800000.flash," \
+			"spi0=spife110000.1"
+#define MTDPARTS_DEFAULT "mtdparts=fe8000000.nor:1m(uboot),5m(kernel)," \
+			"128k(dtb),96m(fs),-(user);fff800000.flash:1m(uboot)," \
+			"5m(kernel),128k(dtb),96m(fs),-(user);spife110000.0:" \
+			"1m(uboot),5m(kernel),128k(dtb),-(user)"
+#endif
+
+/*
+ * Environment
+ */
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_ECHO
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_BDI
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE  CONFIG_SYS_CBSIZE  /* Boot Argument Buffer Size */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	"u-boot.bin" /* U-Boot image on TFTP server */
+#define CONFIG_LOADADDR		1000000 /* default location for tftp, bootm */
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+#define CONFIG_BAUDRATE		115200
+#define __USB_PHY_TYPE		utmi
+
+#ifdef CONFIG_PPC_T1024
+#define CONFIG_BOARDNAME "t1024rdb"
+#else
+#define CONFIG_BOARDNAME "t1023rdb"
+#endif
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
+	"bank_intlv=cs0_cs1\0"					\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"  \
+	"ramdiskfile=" __stringify(CONFIG_BOARDNAME) "/ramdisk.uboot\0" \
+	"fdtfile=" __stringify(CONFIG_BOARDNAME) "/"		\
+	__stringify(CONFIG_BOARDNAME) ".dtb\0"			\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"	\
+	"bootargs=root=/dev/ram rw console=$consoledev,115200\0" \
+	"netdev=eth0\0"						\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"fdtaddr=c00000\0"					\
+	"bdev=sda3\0"
+
+#define CONFIG_LINUX					\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"setenv ramdiskaddr 0x02000000;"		\
+	"setenv fdtaddr 0x00c00000;"			\
+	"setenv loadaddr 0x1000000;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND	CONFIG_LINUX
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __T1024RDB_H */
--- u-boot-2014.07/include/configs/m200.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/configs/m200.h	2022-05-09 14:06:23.933121057 -0700
@@ -0,0 +1,816 @@
+/*
++ * Copyright 2014 Freescale Semiconductor, Inc.
++ *
++ * SPDX-License-Identifier:     GPL-2.0+
++ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * T104x RDB board configuration file
+ */
+#define CONFIG_PHYS_64BIT
+#define CONFIG_LANNER_BURN
+#define CONFIG_DISPLAY_BOARDINFO
+#define CONFIG_SYS_GENERIC_BOARD 
+#define CONFIG_E500
+#include <asm/config_mpc85xx.h>
+
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI $(SRCTREE)/board/freescale/m200/m200_pbi.cfg
+#define CONFIG_SYS_FSL_PBL_RCW $(SRCTREE)/board/freescale/m200/m200_rcw.cfg
+
+#define CONFIG_SPL
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+#define CONFIG_FSL_LAW                 /* Use common FSL init code */
+#define CONFIG_SYS_TEXT_BASE		0x30001000
+#define CONFIG_SPL_TEXT_BASE		0xFFFD8000
+#define CONFIG_SPL_PAD_TO		0x40000
+#define CONFIG_SPL_MAX_SIZE		0x2800
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_SKIP_RELOCATE
+#define CONFIG_SPL_COMMON_INIT_DDR
+#define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#define CONFIG_SYS_NO_FLASH
+#endif
+#define RESET_VECTOR_OFFSET		0x27FFC
+#define BOOT_PAGE_OFFSET		0x27000
+
+#ifdef CONFIG_NAND
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	0x30000000
+#define CONFIG_SYS_NAND_U_BOOT_START	0x30000000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
+#define CONFIG_SPL_NAND_BOOT
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define	CONFIG_RESET_VECTOR_ADDRESS		0x30000FFC
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_MINIMAL
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_DST		(0x30000000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_START	(0x30000000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS	(256 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define	CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_SPI_BOOT
+#endif
+
+#ifdef CONFIG_SDCARD
+#define	CONFIG_RESET_VECTOR_ADDRESS		0x30000FFC
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_MMC_MINIMAL
+#define CONFIG_SYS_MMC_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_MMC_U_BOOT_DST	(0x30000000)
+#define CONFIG_SYS_MMC_U_BOOT_START	(0x30000000)
+#define CONFIG_SYS_MMC_U_BOOT_OFFS	(260 << 10)
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define	CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif
+#define CONFIG_SPL_MMC_BOOT
+#endif
+
+#endif
+
+/* support deep sleep */
+/* #define CONFIG_DEEP_SLEEP */
+#define CONFIG_SILENT_CONSOLE
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE
+#define CONFIG_E500MC			/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV		/* Category E.HV supported */
+#define CONFIG_MP			/* support multiple processors */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff40000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#define CONFIG_SYS_FSL_CPC		/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC		CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#define CONFIG_PCI_INDIRECT_BRIDGE
+#define CONFIG_PCIE1			/* PCIE controler 1 */
+#define CONFIG_PCIE2			/* PCIE controler 2 */
+#define CONFIG_PCIE3			/* PCIE controler 3 */
+#define CONFIG_PCIE4			/* PCIE controler 4 */
+
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+
+#define CONFIG_ENV_OVERWRITE
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#if defined(CONFIG_SPIFLASH)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE                 0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET               0x100000        /* 1MB */
+#define CONFIG_ENV_SECT_SIZE            0x10000
+#elif defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV          0
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(512 * 0x800)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(3 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		0xeff30000
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x10000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	66666666
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BACKSIDE_L2_CACHE
+#define CONFIG_SYS_INIT_L2CSR0		L2CSR0_L2E
+#define CONFIG_BTB			/* toggle branch predition */
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#define CONFIG_ADDR_MAP
+#define CONFIG_SYS_NUM_ADDR_MAP		64	/* number of TLB1 entries */
+
+#define CONFIG_SYS_MEMTEST_START	0x00200000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+/*
+ *  Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		0xFFFC0000
+#define CONFIG_SYS_L3_SIZE		256 << 10
+#define CONFIG_SPL_GD_ADDR		CONFIG_SYS_INIT_L3_ADDR
+#ifdef CONFIG_NAND
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_INIT_L3_ADDR + 4 * 1024)
+#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SYS_INIT_L3_ADDR + 10 * 1024)
+#define CONFIG_SPL_RELOC_MALLOC_SIZE	(34 << 10)
+#else
+#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SYS_INIT_L3_ADDR + 4 * 1024)
+#define CONFIG_SPL_RELOC_MALLOC_SIZE	(40 << 10)
+#endif
+#define CONFIG_SPL_RELOC_STACK		(CONFIG_SYS_INIT_L3_ADDR + 64 * 1024)
+#define CONFIG_SPL_RELOC_STACK_SIZE	(18 << 10)
+
+#define CONFIG_SYS_DCSRBAR		0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS		0xf00000000ull
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+/* CONFIG_NUM_DDR_CONTROLLERS is defined in include/asm/config_mpc85xx.h */
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(2 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_DDR_RAW_TIMING
+#define CONFIG_SYS_FSL_DDR3
+
+#define CONFIG_SYS_SPD_BUS_NUM	0
+#define SPD_EEPROM_ADDRESS	0x51
+
+#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x56
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE	0xefc00000
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+
+#define CONFIG_SYS_NOR_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(4*1024*1024)
+
+/*
+ * TDM Definition
+ */
+#define T1040_TDM_QUIRK_CCSR_BASE	0xfe000000
+
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR	CSOR_NAND_TRHZ_80
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1A) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	71	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS}
+
+/* CPLD on IFC */
+/* CPLD Timing parameters for IFC CS2 */
+/* NAND Flash on IFC */
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#define CONFIG_SYS_NAND_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_NAND_BASE)
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 4K */ \
+				| CSOR_NAND_SPRZ_64 /* Spare size = 224 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(512 * 1024)
+
+#if defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000	/* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#define CONFIG_SYS_INIT_RAM_SIZE		0x00004000
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+					GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(768 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(4 * 1024 * 1024)
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3	(CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4	(CONFIG_SYS_CCSRBAR+0x11D600)
+#define CONFIG_SERIAL_MULTI		/* Enable both serial ports */
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+#endif
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_FSL		/* Use FSL common I2C driver */
+#define CONFIG_SYS_FSL_I2C_SPEED	400000	/* I2C speed in Hz */
+#define CONFIG_SYS_FSL_I2C_SLAVE	0x7F
+#define CONFIG_SYS_FSL_I2C2_SPEED	400000	/* I2C speed in Hz */
+#define CONFIG_SYS_FSL_I2C2_SLAVE	0x7F
+#define CONFIG_SYS_FSL_I2C_OFFSET	0x118000
+#define CONFIG_SYS_FSL_I2C2_OFFSET	0x119000
+
+
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_RS5C372A               1
+
+
+/*
+ * eSPI - Enhanced SPI
+ */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED         10000000
+#define CONFIG_SF_DEFAULT_MODE          0
+#define CONFIG_ENV_SPI_BUS              0
+#define CONFIG_ENV_SPI_CS               0
+#define CONFIG_ENV_SPI_MAX_HZ           10000000
+#define CONFIG_ENV_SPI_MODE             0
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+#ifdef CONFIG_PCI
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#ifdef CONFIG_PCIE1
+#define	CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#define	CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define	CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#ifdef CONFIG_PCIE2
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0x90000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc10000000ull
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#ifdef CONFIG_PCIE3
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc20000000ull
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+/* controller 4, Base address 203000 */
+#ifdef CONFIG_PCIE4
+#define CONFIG_SYS_PCIE4_MEM_VIRT	0xb0000000
+#define CONFIG_SYS_PCIE4_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE4_MEM_PHYS	0xc30000000ull
+#define CONFIG_SYS_PCIE4_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE4_IO_VIRT	0xf8030000
+#define CONFIG_SYS_PCIE4_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE4_IO_PHYS	0xff8030000ull
+#define CONFIG_SYS_PCIE4_IO_SIZE	0x00010000	/* 64k */
+#endif
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif	/* CONFIG_PCI */
+
+/* SATA */
+#define CONFIG_FSL_SATA_V2
+#ifdef CONFIG_FSL_SATA_V2
+#define CONFIG_LIBATA
+#define CONFIG_FSL_SATA
+
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+
+#define CONFIG_LBA48
+#define CONFIG_CMD_SATA
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
+* USB
+*/
+#define CONFIG_HAS_FSL_DR_USB
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#endif
+#endif
+
+#define CONFIG_MMC
+
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR       CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+
+#define CONFIG_SYS_DPAA_QBMAN           /* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS     10
+#define CONFIG_SYS_BMAN_MEM_BASE        0xf4000000
+#define CONFIG_SYS_BMAN_MEM_PHYS        0xff4000000ull
+#define CONFIG_SYS_BMAN_MEM_SIZE        0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+                                        CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG    0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS     10
+#define CONFIG_SYS_QMAN_MEM_BASE        0xf6000000
+#define CONFIG_SYS_QMAN_MEM_PHYS        0xff6000000ull
+#define CONFIG_SYS_QMAN_MEM_SIZE        0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+                                        CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG    0xE08
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+
+/* Default address of microcode for the Linux Fman driver */
+#if defined(CONFIG_SPIFLASH)
+/*
+ * env is stored at 0x100000, sector size is 0x10000, ucode is stored after
+ * env, so we got 0x110000.
+ */
+#define CONFIG_SYS_QE_FW_IN_SPIFLASH
+#define CONFIG_SYS_FMAN_FW_ADDR	0x110000
+#elif defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 1MB (2048 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 2048 + 16 = 2072, enlarge it to 2080.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_FMAN_FW_ADDR	(512 * 0x820)
+#elif defined(CONFIG_NAND)
+#define CONFIG_SYS_QE_FMAN_FW_IN_NAND
+#define CONFIG_SYS_FMAN_FW_ADDR	(4 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_FMAN_FW_ADDR		0xEFF20000
+#endif
+
+
+
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHY_MARVELL
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_SYS_SGMII1_PHY_ADDR		0x00
+#define CONFIG_SYS_RGMII1_PHY_ADDR		0x010
+#define CONFIG_SYS_RGMII2_PHY_ADDR		0x04
+
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC4"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+ * Environment
+ */
+#define CONFIG_LOADS_ECHO		/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#define CONFIG_CMD_NET
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"MB-M200 => "		/* Monitor Command Prompt */
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks*/
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	"u-boot.bin"	/* U-Boot image on TFTP server*/
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+/* WatchGuard BootMenu */
+#define CONFIG_WG_BOOTMENU
+
+#define CONFIG_BOOTDELAY	10	/*-1 disables auto-boot*/
+
+#define CONFIG_BAUDRATE	115200
+
+#define __USB_PHY_TYPE	utmi
+
+
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:bank_intlv=cs0_cs1;"			\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) ";"\
+	"usb2:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"             \
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"     \
+	"bootloader_flash_update=protect off 0xeff40000 0xefffffff &&" \
+	"erase 0xeff40000 0xefffffff && "			\
+	"cp.b 0x100000 0xeff40000 0xc0000 && "		\
+	"protect on 0xeff40000 0xefffffff && "			\
+	"cmp.b 0xeff40000 0x100000 0xc0000 \0"		\
+	"nuke_env=protect off 0xeff30000 0xeff3ffff && " \
+	"erase 0xeff30000 0xeff3ffff \0" \
+	"lannerboot=setenv bootargs root=/dev/ram rw " \
+	"rootdelay=10 console=ttyS0,115200 ramdisk_size=2800000 &&" \
+	"usb start && " \
+	"fatload mmc 0:1 1000000 uImage && " \
+	"fatload mmc 0:1 fc0000  m200.dtb && " \
+	"fatload mmc 0:1 2000000 lanner/rootfs.ext2.gz.u-boot.lanner && " \
+	"bootm 1000000 2000000 fc0000 \0 " \
+	"lannerboots=setenv bootargs root=/dev/ram rw " \
+	"rootdelay=10 console=ttyS0,115200 ramdisk_size=2800000 &&" \
+	"usb start && " \
+	"fatload usb 0:1 1000000 uImage && " \
+	"fatload usb 0:1 fc0000  m200.dtb && " \
+	"fatload usb 0:1 2000000 lanner/rootfs.ext2.gz.u-boot.lanner.usb && " \
+	"bootm 1000000 2000000 fc0000 \0 " \
+	"consoledev=ttyS0\0"                                    \
+	"ramdiskaddr=2000000\0"                                 \
+	"ramdiskfile=rootfs.ext2.gz.u-boot\0"                    \
+	"fdtaddr=fc0000\0"                                      \
+	"loadaddr=1000000\0"			                \
+	"fdtfile=m200.dtb\0"                                    \
+	"WGKernelfile=uImage_m200\0"                                \
+	"bdev=sda3\0"                                           \
+	"SysARoot=mmcblk0p3\0"	\
+	"SysBRoot=mmcblk0p2\0"	\
+	"wgBootBoot=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:1 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:1 $loadaddr $WGKernelfile; " \
+	"usb start; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"usb start; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:2 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:2 $loadaddr $WGKernelfile; " \
+	"usb start; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"usb start ;" \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"c=ffe\0"
+
+#define CONFIG_NFSBOOTCOMMAND		\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_HDBOOT			\
+	"setenv bootargs root=/dev/$bdev rw rootdelay=30 "	\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"usb start;"			\
+	"ext2load usb 0:1 $loadaddr /boot/$bootfile;"		\
+	"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __CONFIG_H */
--- u-boot-2014.07/include/configs/WGXTM_BOREN.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/configs/WGXTM_BOREN.h	2022-05-09 14:06:23.897122513 -0700
@@ -0,0 +1,975 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * P1 P2 RDB board configuration file
+ * This file is intended to address a set of Low End and Ultra Low End
+ * Freescale SOCs of QorIQ series(RDB platforms).
+ * Currently only P2020RDB
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* XTM3x , error-out if WGXTM_BOREN  not in the ENV */
+#ifndef CONFIG_WGXTM_BOREN
+#error
+#endif
+
+#ifdef CONFIG_WGXTM_BOREN /* XTM3x , not using VSC chip, Marvell instead */
+#define CONFIG_MV88E61XX_SWITCH
+#define CONFIG_MV88E61XX_CMD
+#define CONFIG_RESET_PHY_R
+#define CONFIG_MV88E61XX_MULTICHIP_ADRMODE
+#define CONFIG_PHY_GIGE     1
+
+/* define bare minimal stuff for PHLIB and marvell phy drivers */
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MARVELL
+#else
+#error
+#endif
+
+#ifdef CONFIG_36BIT
+#define CONFIG_PHYS_64BIT
+#endif
+
+#ifdef CONFIG_P1011RDB
+#define CONFIG_P1011
+#define CONFIG_SYS_L2_SIZE	(256 << 10)
+#endif
+#ifdef CONFIG_P1020RDB
+#define CONFIG_P1020
+#define CONFIG_SYS_L2_SIZE	(256 << 10)
+#endif
+#ifdef CONFIG_P2010RDB
+#define CONFIG_P2010
+#define CONFIG_SYS_L2_SIZE	(512 << 10)
+#endif
+#ifdef CONFIG_P2020RDB
+#define CONFIG_P2020
+#define CONFIG_SYS_L2_SIZE	(512 << 10)
+#endif
+
+#ifdef CONFIG_WGXTM_T50_BOREN
+#define CONFIG_P1020
+#define CONFIG_SYS_L2_SIZE	(256 << 10)
+#endif
+#ifdef CONFIG_WGXTM_T30_BOREN
+#define CONFIG_P1011
+#define CONFIG_SYS_L2_SIZE	(256 << 10)
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_SPL
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_MMC_MINIMAL
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SYS_TEXT_BASE		0x11001000
+#define CONFIG_SPL_TEXT_BASE		0xf8f81000
+#define CONFIG_SPL_PAD_TO		0x20000
+#define CONFIG_SPL_MAX_SIZE		(128 * 1024)
+#define CONFIG_SYS_MMC_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_MMC_U_BOOT_DST	(0x11000000)
+#define CONFIG_SYS_MMC_U_BOOT_START	(0x11000000)
+#define CONFIG_SYS_MMC_U_BOOT_OFFS	(129 << 10)
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#define CONFIG_SPL_MMC_BOOT
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_COMMON_INIT_DDR
+#endif
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define CONFIG_SPL
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_SUPPORT
+#define CONFIG_SPL_SPI_FLASH_MINIMAL
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SYS_TEXT_BASE		0x11001000
+#define CONFIG_SPL_TEXT_BASE		0xf8f81000
+#define CONFIG_SPL_PAD_TO		0x20000
+#define CONFIG_SPL_MAX_SIZE		(128 * 1024)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_SIZE	(768 << 10)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_DST		(0x11000000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_START	(0x11000000)
+#define CONFIG_SYS_SPI_FLASH_U_BOOT_OFFS	(128 << 10)
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#define CONFIG_SPL_SPI_BOOT
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_COMMON_INIT_DDR
+#endif
+#endif
+
+#ifdef CONFIG_NAND
+#define CONFIG_SPL
+#define CONFIG_TPL
+#ifdef CONFIG_TPL_BUILD
+#define CONFIG_SPL_NAND_BOOT
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_NAND_INIT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_COMMON_INIT_DDR
+#define CONFIG_SPL_MAX_SIZE		(128 << 10)
+#define CONFIG_SPL_TEXT_BASE		0xf8f81000
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(832 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(0x11000000)
+#define CONFIG_SYS_NAND_U_BOOT_START	(0x11000000)
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	((128 + 128) << 10)
+#elif defined(CONFIG_SPL_BUILD)
+#define CONFIG_SPL_INIT_MINIMAL
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_TEXT_BASE		0xff800000
+#define CONFIG_SPL_MAX_SIZE		4096
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(128 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	0xf8f80000
+#define CONFIG_SYS_NAND_U_BOOT_START	0xf8f80000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(128 << 10)
+#endif /* not CONFIG_TPL_BUILD */
+
+#define CONFIG_SPL_PAD_TO		0x20000
+#define CONFIG_TPL_PAD_TO		0x20000
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SYS_TEXT_BASE		0x11001000
+#define CONFIG_SYS_LDSCRIPT	"arch/powerpc/cpu/mpc85xx/u-boot-nand.lds"
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_FSL_ELBC		1	/* Enable eLBC Support */
+
+#define CONFIG_PCI		1	/* Enable PCI/PCIE */
+#if defined(CONFIG_PCI)
+#define CONFIG_PCIE1		1	/* PCIE controler 1 (slot 1) */
+#define CONFIG_PCIE2		1	/* PCIE controler 2 (slot 2) */
+#define CONFIG_FSL_PCI_INIT	1	/* Use common FSL init code */
+#define CONFIG_PCI_INDIRECT_BRIDGE 1	/* indirect PCI bridge support */
+#define CONFIG_FSL_PCIE_RESET	1	/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT	1	/* enable 64-bit PCI resources */
+#endif /* #if defined(CONFIG_PCI) */
+#define CONFIG_FSL_LAW		1	/* Use common FSL init code */
+#define CONFIG_TSEC_ENET		/* tsec ethernet support */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BOREN_ETHNET_SETUP	/* WG:MJ - All debug stuff for Boren */
+/* #define CONFIG_DEBUG_BOREN		*/ /* WG:MJ - All debug stuff for Boren */
+
+#if defined(CONFIG_PCI)
+#define CONFIG_E1000		1	/*  E1000 pci Ethernet card*/
+#endif
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_board_sys_clk(unsigned long dummy);
+#endif
+#define CONFIG_DDR_CLK_FREQ	66666666 /* DDRCLK on P1_P2 RDB */
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk(0) /*sysclk for P1_P2 RDB */
+
+#if defined(CONFIG_P2020) || defined(CONFIG_P1020)
+#define CONFIG_MP
+#endif
+
+#define CONFIG_HWCONFIG
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ADDR_STREAMING		/* toggle addr streaming */
+
+#define CONFIG_ENABLE_36BIT_PHYS	1
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP			1
+#define CONFIG_SYS_NUM_ADDR_MAP		16	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_SYS_MEMTEST_START	0x00000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x1fffffff
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+ /*
+  * Config the L2 Cache as L2 SRAM
+  */
+#define CONFIG_SYS_INIT_L2_ADDR		0xf8f80000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_L2_ADDR_PHYS	0xff8f80000ull
+#else
+#define CONFIG_SYS_INIT_L2_ADDR_PHYS	CONFIG_SYS_INIT_L2_ADDR
+#endif
+
+#define CONFIG_SYS_INIT_L2_END		(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_L2_SIZE)
+
+							/* CCSRBAR */
+#define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses */
+							/* CONFIG_SYS_IMMR */
+/* DDR Setup */
+#define CONFIG_SYS_FSL_DDR2
+#undef CONFIG_FSL_DDR_INTERACTIVE
+#undef CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup */
+
+#define CONFIG_MEM_INIT_VALUE	0xDeadBeef
+
+#ifdef CONFIG_WGXTM_T30_BOREN /* Is it a T30 unit, DDR size is 1024 */
+#define CONFIG_SYS_SDRAM_SIZE	1024 	/* DDR size on AP331IB */
+#elif CONFIG_WGXTM_T50_BOREN /* Is it a T50 unit, DDR size is 2048 */
+#define CONFIG_SYS_SDRAM_SIZE	2048 	/* DDR size on AP331IB */
+#else
+#define CONFIG_SYS_SDRAM_SIZE	1024 	/* DDR size : Fallback */
+#endif /* END_OF CONFIG_WGXTM_T*_BOREN */
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+#define CONFIG_SYS_DDR_ERR_INT_EN	0x0000000d
+#define CONFIG_SYS_DDR_ERR_DIS		0x00000000
+#define CONFIG_SYS_DDR_SBE		0x00FF0000
+
+/*
+ * Memory map
+ *
+ * 0x0000_0000	0x3fff_ffff	DDR			1G cacheablen
+ * 0x8000_0000  0xbfff_ffff	PCI Express Mem		1G non-cacheable
+ * 0xffc0_0000  0xffc3_ffff	PCI IO range		256k non-cacheable
+ *
+ * Localbus cacheable (TBD)
+ * 0xXXXX_XXXX	0xXXXX_XXXX	SRAM			YZ M Cacheable
+ *
+ * Localbus non-cacheable
+ * 0xef00_0000	0xefff_ffff	FLASH			16M non-cacheable
+ * 0xffa0_0000	0xffaf_ffff	NAND			1M non-cacheable
+ * 0xffb0_0000	0xffbf_ffff	VSC7385 switch		1M non-cacheable
+ * 0xffd0_0000	0xffd0_3fff	L1 for stack		16K Cacheable TLB0
+ * 0xffe0_0000	0xffef_ffff	CCSR			1M non-cacheable
+ */
+
+/*
+ * Local Bus Definitions
+ */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_FLASH_BASE		0xefc00000	/* start of FLASH 4M */
+#endif
+
+#ifdef CONFIG_PHYS_64BIT
+#error
+#define CONFIG_SYS_FLASH_BASE_PHYS	0xfef000000ull
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_FLASH_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+					BR_PS_16 | BR_V)
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_FLASH_OR_PRELIM		0xffc00831//4MB to check cpu datasheet table12-7
+#else
+#error
+#define CONFIG_FLASH_OR_PRELIM		0xff000ff7 //16MB
+#endif
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS}
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS 45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_MAX_FLASH_SECT	256	/* sectors per device */
+#else
+#define CONFIG_SYS_MAX_FLASH_SECT	128	/* sectors per device */
+#endif
+#undef	CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#if defined(CONFIG_RAMBOOT_NAND) || defined(CONFIG_RAMBOOT_SDCARD) || \
+    defined(CONFIG_RAMBOOT_SPIFLASH)
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#else
+#undef CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_AMD_CHECK_DQ7
+
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_HWCONFIG
+
+#define CONFIG_SYS_INIT_RAM_LOCK	1
+#define CONFIG_SYS_INIT_RAM_ADDR      0xffd00000	/* stack in RAM */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+	((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+	  CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#else
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS	CONFIG_SYS_INIT_RAM_ADDR /* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+#endif
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000	/* Size of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE \
+						- GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon*/
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_MALLOC_LEN		(8 * 1024 * 1024)	/* Reserved for malloc*/
+#else
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc*/
+#endif
+#ifndef CONFIG_NAND_SPL
+#define CONFIG_SYS_NAND_BASE		0xffa00000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfffa00000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+#else
+#define CONFIG_SYS_NAND_BASE		0xfff00000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xffff00000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+#endif
+
+#define CONFIG_SYS_NAND_BASE_LIST	{CONFIG_SYS_NAND_BASE}
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS			1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND			1
+#define CONFIG_NAND_FSL_ELBC		1
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+#else
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(16 * 1024)
+#endif
+
+/* NAND boot: 4K NAND loader config */
+#define CONFIG_SYS_NAND_SPL_SIZE	0x1000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	((512 << 10) - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(CONFIG_SYS_INIT_L2_ADDR)
+#define CONFIG_SYS_NAND_U_BOOT_START	(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_NAND_SPL_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(0)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC	(CONFIG_SYS_INIT_L2_END - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC_SP		((CONFIG_SYS_INIT_L2_END - 1) & ~0xF)
+
+/* NAND flash config */
+#define CONFIG_NAND_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+				| BR_PS_8	/* Port Size = 8 bit */ \
+				| BR_MS_FCM		/* MSEL = FCM */ \
+				| BR_V)			/* valid */
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+#else
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_PGS /* for big page */\
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+#endif
+#ifdef CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#endif
+
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_VSC7385_BASE	0xffb00000
+
+	#ifdef CONFIG_PHYS_64BIT
+	#define CONFIG_SYS_VSC7385_BASE_PHYS	0xfffb00000ull
+	#else
+	#define CONFIG_SYS_VSC7385_BASE_PHYS	CONFIG_SYS_VSC7385_BASE
+	#endif
+
+#define CONFIG_SYS_BR2_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_VSC7385_BASE) \
+							| BR_PS_8 | BR_V)
+#define CONFIG_SYS_OR2_PRELIM	(OR_AM_128KB | OR_GPCM_CSNT | OR_GPCM_XACS | \
+				OR_GPCM_SCY_15 | OR_GPCM_SETA | OR_GPCM_TRLX | \
+				OR_GPCM_EHTR | OR_GPCM_EAD)
+#endif /* END_OF CONFIG_WGXTM_T*_BOREN */
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN) /* eTSEC1's clk source register */
+#define CONFIG_GUT_PMUXCR_OFFSET    (0xE0060)
+#define CONFIG_GUT_PMUXCR           (CONFIG_SYS_CCSRBAR + CONFIG_GUT_PMUXCR_OFFSET)
+#endif /* END_OF CONFIG_WGXTM_T*_BOREN */
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_CONS_INDEX	1//colin test
+#else
+#define CONFIG_CONS_INDEX	1
+#endif /* END_OF CONFIG_WGXTM_T*0_BOREN */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_NS16550_MIN_FUNCTIONS
+#endif
+
+#define CONFIG_SERIAL_MULTI	1 /* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN)
+#define CONFIG_SYS_HUSH_PARSER
+#endif
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT		1
+#define CONFIG_OF_BOARD_SETUP		1
+#define CONFIG_OF_STDOUT_VIA_ALIAS	1
+
+/* new uImage format support */
+#define CONFIG_FIT		1
+#define CONFIG_FIT_VERBOSE	1 /* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_FSL
+#define CONFIG_SYS_FSL_I2C_OFFSET	0x3000
+#define CONFIG_SYS_FSL_I2C_SPEED	400000
+#define CONFIG_SYS_FSL_I2C_SLAVE	0x7F
+#define CONFIG_SYS_FSL_I2C2_OFFSET	0x3100
+#define CONFIG_SYS_FSL_I2C2_SPEED	400000
+#define CONFIG_SYS_FSL_I2C2_SLAVE	0x7F
+#define CONFIG_SYS_I2C_NOPROBES		{ {0, 0x29} }
+
+/*
+ * I2C2 EEPROM
+ */
+#define CONFIG_ID_EEPROM
+#ifdef CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#endif
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0xac
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_BUS_NUM	1
+
+#define CONFIG_SYS_I2C_PCA9557_ADDR	0x18
+
+#define CONFIG_RTC_DS1337
+#define CONFIG_SYS_RTC_DS1337_NOOSC
+#define CONFIG_SYS_I2C_RTC_ADDR                0x68
+
+/* eSPI - Enhanced SPI */
+#define CONFIG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#if 0
+#define CONFIG_SPI_FLASH_SPANSION
+#endif
+/* #define CONFIG_SPI_FLASH_MACRONIX */
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		10000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/* controller 2, Slot 2, tgtid 2, Base address 9000 */
+#if defined(CONFIG_PCI)
+#define CONFIG_SYS_PCIE2_NAME		"Slot 1"
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xfffc10000ull
+#else
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#endif
+
+/* controller 1, Slot 1, tgtid 1, Base address a000 */
+#define CONFIG_SYS_PCIE1_NAME		"Slot 2"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc00000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
+#endif
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#undef CONFIG_EEPRO100
+#undef CONFIG_TULIP
+#undef CONFIG_RTL8139
+
+#ifdef CONFIG_RTL8139
+/* This macro is used by RTL8139 but not defined in PPC architecture */
+#define KSEG1ADDR(x)		(x)
+#define _IO_BASE	0x00000000
+#endif
+
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+
+#endif	/* CONFIG_PCI */
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN) /* TONY_FOR_AP331IB */
+#define CONFIG_NET_MULTI	1
+#endif
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_MII		1	/* MII PHY management */
+#define CONFIG_MII_DEFAULT_TSEC	1	/* Allow unregistered phys */
+
+#define CONFIG_TSEC1	1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#define CONFIG_TSEC2	1
+#define CONFIG_TSEC2_NAME	"eTSEC2"
+#define CONFIG_TSEC3	1
+#define CONFIG_TSEC3_NAME	"eTSEC3"
+
+#if defined(CONFIG_WGXTM_T30_BOREN) || defined(CONFIG_WGXTM_T50_BOREN) /* TONY_FOR_AP331IB */
+#define TSEC1_PHY_ADDR		2
+#define TSEC2_PHY_ADDR		1
+#define TSEC3_PHY_ADDR		0
+#undef CONFIG_VSC7385_ENET
+#else 
+
+#define TSEC1_PHY_ADDR		2
+#define TSEC2_PHY_ADDR		0
+#define TSEC3_PHY_ADDR		1
+
+#define CONFIG_VSC7385_ENET
+#endif /* END_OF_WGXTM_T*_BOREN */
+
+#define TSEC1_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+#define TSEC3_PHYIDX		0
+
+/* Vitesse 7385 */
+
+#ifdef CONFIG_VSC7385_ENET
+/* The size of the VSC7385 firmware image */
+#define CONFIG_VSC7385_IMAGE_SIZE	8192
+#endif
+
+#define CONFIG_ETHPRIME		"eTSEC1"
+
+#define CONFIG_PHY_GIGE		1	/* Include GbE speed/duplex detection */
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_RAMBOOT_NAND)
+	#define CONFIG_ENV_IS_IN_NAND	1
+	#define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+	#define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_RAMBOOT_SDCARD)
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_RAMBOOT_SPIFLASH)
+	#define CONFIG_ENV_IS_IN_SPI_FLASH
+	#define CONFIG_ENV_SPI_BUS	0
+	#define CONFIG_ENV_SPI_CS	0
+	#define CONFIG_ENV_SPI_MAX_HZ	10000000
+	#define CONFIG_ENV_SPI_MODE	0
+	#define CONFIG_ENV_OFFSET	0x100000	/* 1MB */
+	#define CONFIG_ENV_SECT_SIZE	0x10000
+	#define CONFIG_ENV_SIZE		0x2000
+#endif
+#else
+	#define CONFIG_ENV_IS_IN_FLASH	1
+	#if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+	#define CONFIG_ENV_ADDR		0xfff80000
+	#else
+	#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+	#endif
+	#define CONFIG_ENV_SIZE		0x2000
+	#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#if defined(CONFIG_PCI)
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PCI
+#endif
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+#define CONFIG_MMC 1
+
+#ifdef CONFIG_MMC
+#define CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init */
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_FSL_ESDHC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#ifdef CONFIG_P2020
+#define CONFIG_SYS_FSL_ESDHC_USE_PIO /* P2020 eSDHC DMA is not functional*/
+#endif
+#endif
+
+#define CONFIG_HAS_FSL_DR_USB
+
+#if defined(CONFIG_HAS_FSL_DR_USB)
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#endif
+#endif
+
+#if defined(CONFIG_MMC) || defined(CONFIG_USB_EHCI)
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"=> "		/* Monitor Command Prompt */
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+						/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 16 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(16 << 20)/* Initial Memory map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(16 << 20)	/* Increase max gunzip size */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#endif
+
+#define CONFIG_HOSTNAME		P2020RDB
+#define CONFIG_ROOTPATH		"/opt/nfsroot"
+#define CONFIG_BOOTFILE		"uImage"
+#define CONFIG_UBOOTPATH	u-boot.bin/* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY 10	/* -1 disables auto-boot */
+#undef  CONFIG_BOOTARGS		/* the boot command will set bootargs */
+
+#define CONFIG_BAUDRATE	115200
+
+#if defined(CONFIG_WGXTM_T30_BOREN)
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_FDT \
+	fdtfile=t30.dtb
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_WGKERNEL \
+	WGKernelfile=uImage_t30
+#elif defined(CONFIG_WGXTM_T50_BOREN)
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_FDT \
+	fdtfile=t50.dtb
+#define	CONFIG_BOREN_BOARD_SPECIFIC_ENV_WGKERNEL \
+	WGKernelfile=uImage_t50
+#else
+#error
+#endif
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"loadaddr=1000000\0"					\
+	"tftpflash=tftpboot $loadaddr $uboot; "			\
+		"protect off " __stringify(CONFIG_SYS_TEXT_BASE)	\
+			" +$filesize; "	\
+		"erase " __stringify(CONFIG_SYS_TEXT_BASE)		\
+			" +$filesize; "	\
+		"cp.b $loadaddr " __stringify(CONFIG_SYS_TEXT_BASE)	\
+			" $filesize; "	\
+		"protect on " __stringify(CONFIG_SYS_TEXT_BASE)		\
+			" +$filesize; "	\
+		"cmp.b $loadaddr " __stringify(CONFIG_SYS_TEXT_BASE)	\
+			" $filesize\0"	\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=p2020rdb.dtb\0"		\
+	"bdev=sda1\0"	\
+	"jffs2nor=mtdblock3\0"	\
+	"norbootaddr=ef080000\0"	\
+	"norfdtaddr=ef040000\0"	\
+	"jffs2nand=mtdblock9\0"	\
+	"nandbootaddr=100000\0"	\
+	"nandkerneladdr=0\0"	\
+	"nandrootfsaddr=1400000\0"	\
+	"nanddtbaddr= 6400000\0"	\
+	"nandfdtaddr=80000\0"		\
+	"nandimgsize=400000\0"		\
+	"nandrernelsize=400000\0"		\
+	"nandrootfssize=400000\0"		\
+	"nanddtbsize=400000\0"		\
+	"nandfdtsize=80000\0"		\
+	"hwconfig=usb1:dr_mode=host,phy_type=ulpi\0"	\
+	"vscfw_addr=ef000000\0"	\
+	"othbootargs=ramdisk_size=102400\0" \
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+        "ethaddr=00:c0:02:12:35:88\0"  \
+	"eth1addr=00:c0:02:12:35:89\0"  \
+	"eth2addr=00:c0:02:12:35:90\0"  \
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"norboot=setenv bootargs root=/dev/$jffs2nor rw "	\
+	"console=$consoledev,$baudrate rootfstype=jffs2 $othbootargs;"	\
+	"bootm $norbootaddr - $norfdtaddr\0"		\
+	"nandboot=setenv bootargs root=/dev/$jffs2nand rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read 2000000 $nandbootaddr $nandimgsize;"	\
+	"nand read 3000000 $nandfdtaddr $nandfdtsize;"	\
+	"bootm 2000000 - 3000000;\0"			\
+	"ethact=eTSEC1\0 "	\
+	"serverip=10.0.1.13\0 "	\
+	"gatewayip=10.0.1.13\0 "	\
+	"ipaddr=10.0.1.1\0 "	\
+	"netmask=255.255.255.0\0 "	\
+	__stringify(CONFIG_BOREN_BOARD_SPECIFIC_ENV_FDT) "\0"	\
+	__stringify(CONFIG_BOREN_BOARD_SPECIFIC_ENV_WGKERNEL) "\0"	\
+	"SysARoot=mmcblk0p3\0"	\
+	"SysBRoot=mmcblk0p2\0"	\
+	"wgBootBoot=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:1 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:1 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:2 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:2 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"mmcinfo; " \
+	"ext2load mmc 0:3 $fdtaddr $fdtfile; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0" \
+	"nuke_env=protect off 0xeff60000 0xeff6ffff && " \
+	"erase 0xeff60000 0xeff6ffff \0" \
+
+#define CONFIG_NFSBOOTCOMMAND		\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_HDBOOT			\
+	"setenv bootargs root=/dev/$bdev rw rootdelay=30 "	\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"usb start;"			\
+	"ext2load usb 0:1 $loadaddr /boot/$bootfile;"		\
+	"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_NANDBOOT			\
+	"setenv bootargs root=/dev/ram rw" \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read 0x1000000 0x0 0x800000;"	\
+	"nand read 0x2000000 0x1400000 0x1400000;"	\
+	"nand read 0xc00000 0x6400000 0x100000;"	\
+	"bootm 0x1000000  0x2000000 0xc00000;"
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#endif	/* __CONFIG_H */
--- u-boot-2014.07/include/configs/ls1021aqds.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/configs/ls1021aqds.h	2022-05-09 14:06:23.933121057 -0700
@@ -0,0 +1,635 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <config_cmd_default.h>
+
+#define CONFIG_LS102XA
+
+#define CONFIG_SYS_GENERIC_BOARD
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_BOARD_EARLY_INIT_F
+
+#define CONFIG_FSL_DEEP_SLEEP
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#define CONFIG_SILENT_CONSOLE
+#endif
+
+#define CONFIG_ARMV7_NONSEC
+#define CONFIG_ARMV7_VIRT
+#define CONFIG_PEN_ADDR_BIG_ENDIAN
+#define CONFIG_LS102XA_NS_ACESS
+#define CONFIG_SMP_PEN_ADDR		0x01ee0200
+#define CONFIG_TIMER_CLK_FREQ		12500000
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 16 * 1024 * 1024)
+
+#define CONFIG_SYS_INIT_RAM_ADDR	OCRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	OCRAM_SIZE
+
+/*
+ * Generic Timer Definitions
+ */
+#define GENERIC_TIMER_CLK		12500000
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#if defined(CONFIG_SD_BOOT) || defined(CONFIG_QSPI_BOOT)
+#define CONFIG_SYS_CLK_FREQ            100000000
+#define CONFIG_DDR_CLK_FREQ            100000000
+#define CONFIG_QIXIS_I2C_ACCESS
+#else
+#define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
+#define CONFIG_DDR_CLK_FREQ		get_board_ddr_clk()
+#endif
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI	board/freescale/ls1021aqds/ls102xa_pbi.cfg
+#endif
+
+#ifdef CONFIG_SD_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW	board/freescale/ls1021aqds/ls102xa_rcw_sd.cfg
+#define CONFIG_SPL
+#define CONFIG_SPL_PBL_PAD
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_LDSCRIPT	"arch/$(ARCH)/cpu/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_WATCHDOG_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR		0xe8
+#define CONFIG_SYS_U_BOOT_MAX_SIZE_SECTORS		0x400
+
+#define CONFIG_SPL_TEXT_BASE		0x10000000
+#define CONFIG_SPL_MAX_SIZE		0x1a000
+#define CONFIG_SPL_STACK		0x1001d000
+#define CONFIG_SPL_PAD_TO		0x1c000
+#define CONFIG_SYS_TEXT_BASE		0x82000000
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+#define CONFIG_SPL_BSS_START_ADDR	0x80100000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000
+#define CONFIG_SYS_MONITOR_LEN		0x80000
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW	board/freescale/ls1021aqds/ls102xa_rcw_nand.cfg
+#define CONFIG_SPL
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_LDSCRIPT	"arch/$(ARCH)/cpu/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_WATCHDOG_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+
+#define CONFIG_SPL_TEXT_BASE		0x10000000
+#define CONFIG_SPL_MAX_SIZE		0x1a000
+#define CONFIG_SPL_STACK		0x1001d000
+#define CONFIG_SPL_PAD_TO		0x1c000
+#define CONFIG_SYS_TEXT_BASE		0x82000000
+
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(400 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	CONFIG_SPL_PAD_TO
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+#define CONFIG_SYS_NAND_U_BOOT_DST	CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_TEXT_BASE
+
+#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x100000
+#define CONFIG_SPL_BSS_START_ADDR	0x80100000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x80000
+#define CONFIG_SYS_MONITOR_LEN		0x80000
+#endif
+
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_SYS_TEXT_BASE		0x40010000
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0x67f80000
+#endif
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_DDR_SPD
+#define SPD_EEPROM_ADDRESS		0x51
+#define CONFIG_SYS_SPD_BUS_NUM		0
+#define CONFIG_SYS_DDR_RAW_TIMING
+
+#define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
+#define CONFIG_SYS_FSL_DDR3		/* Use DDR3 memory */
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	4
+
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x80000000UL
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE           0xdeadbeef
+#endif
+
+#define CONFIG_SYS_HAS_SERDES
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_NAND_BOOT) && \
+	!defined(CONFIG_QSPI_BOOT)
+#define CONFIG_U_QE
+#endif
+/*
+ * IFC Definitions
+ */
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+#define CONFIG_FSL_IFC
+#define CONFIG_SYS_FLASH_BASE		0x60000000
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR1_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				+ 0x8000000) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128 * 1024 * 1024)
+
+#define CONFIG_SYS_NOR_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
+					CSOR_NOR_TRHZ_80)
+#define CONFIG_SYS_NOR_FTIM0		(FTIM0_NOR_TACSE(0x4) | \
+					FTIM0_NOR_TEADC(0x5) | \
+					FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1		(FTIM1_NOR_TACO(0x35) | \
+					FTIM1_NOR_TRAD_NOR(0x1a) | \
+					FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2		(FTIM2_NOR_TCS(0x4) | \
+					FTIM2_NOR_TCH(0x4) | \
+					FTIM2_NOR_TWPH(0xe) | \
+					FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3		0
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+#define CONFIG_SYS_WRITE_SWAPPED_DATA
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS, \
+					CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000}
+
+/*
+ * NAND Flash Definitions
+ */
+#define CONFIG_NAND_FSL_IFC
+
+#define CONFIG_SYS_NAND_BASE		0x7e800000
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
+
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8	\
+				| CSPR_MSEL_NAND	\
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4	/* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3 Bytes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64	/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/* 64 Pages Per Block */
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x7) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x7) | \
+					FTIM0_NAND_TWH(0xa))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0xe)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0xf) | \
+					FTIM2_NAND_TREH(0xa) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3           0x0
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+#endif
+
+/*
+ * QIXIS Definitions
+ */
+#define CONFIG_FSL_QIXIS
+
+#ifdef CONFIG_FSL_QIXIS
+#define QIXIS_BASE			0x7fb00000
+#define QIXIS_BASE_PHYS			QIXIS_BASE
+#define CONFIG_SYS_I2C_FPGA_ADDR	0x66
+#define QIXIS_LBMAP_SWITCH		6
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_RST_CTL_RESET		0x44
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+
+#define CONFIG_SYS_FPGA_CSPR_EXT	(0x0)
+#define CONFIG_SYS_FPGA_CSPR		(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) | \
+					CSPR_PORT_SIZE_8 | \
+					CSPR_MSEL_GPCM | \
+					CSPR_V)
+#define CONFIG_SYS_FPGA_AMASK		IFC_AMASK(64 * 1024)
+#define CONFIG_SYS_FPGA_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
+					CSOR_NOR_NOR_MODE_AVD_NOR | \
+					CSOR_NOR_TRHZ_80)
+
+/*
+ * QIXIS Timing parameters for IFC GPCM
+ */
+#define CONFIG_SYS_FPGA_FTIM0		(FTIM0_GPCM_TACSE(0xe) | \
+					FTIM0_GPCM_TEADC(0xe) | \
+					FTIM0_GPCM_TEAHC(0xe))
+#define CONFIG_SYS_FPGA_FTIM1		(FTIM1_GPCM_TACO(0xe) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_FPGA_FTIM2		(FTIM2_GPCM_TCS(0xe) | \
+					FTIM2_GPCM_TCH(0xe) | \
+					FTIM2_GPCM_TWP(0xf0))
+#define CONFIG_SYS_FPGA_FTIM3		0x0
+#endif
+
+#if defined(CONFIG_NAND_BOOT)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#endif
+
+/*
+ * Serial Port
+ */
+#ifdef CONFIG_LPUART
+#define CONFIG_FSL_LPUART
+#define CONFIG_LPUART_32B_REG
+#else
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_serial_clock()
+#endif
+
+#define CONFIG_BAUDRATE			115200
+
+/*
+ * I2C
+ */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+
+/*
+ * I2C bus multiplexer
+ */
+#define I2C_MUX_PCA_ADDR_PRI		0x77
+#define I2C_MUX_CH_DEFAULT		0x8
+
+/*
+ * MMC
+ */
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_GENERIC_MMC
+
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+/*SPI device */
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_ATMEL
+#define CONFIG_SPI_FLASH
+#define CONFIG_FSL_SPI_INTERFACE
+#define CONFIG_SF_DATAFLASH
+
+/* QSPI */
+#define CONFIG_FSL_QSPI
+#ifdef CONFIG_FSL_QSPI
+#define QSPI_AMBA_BASE			0x40000000
+#define FSL_QSPI_FLASH_SIZE            (1 << 24)
+#define FSL_QSPI_FLASH_NUM             2
+#endif
+/* DSPI */
+#define CONFIG_FSL_DSPI
+#ifdef CONFIG_FSL_DSPI
+#define MMAP_DSPI		DSPI1_BASE_ADDR
+#define CONFIG_SYS_DSPI_CTAR0   (DSPI_CTAR_TRSZ(7) | DSPI_CTAR_PCSSCK_1CLK |\
+				DSPI_CTAR_PASC(0) | DSPI_CTAR_PDT(0) | \
+				DSPI_CTAR_CSSCK(0) | DSPI_CTAR_ASC(0) | \
+				DSPI_CTAR_DT(0))
+#endif
+
+/*
+ * USB
+ */
+/*EHCI Support*/
+/*#define CONFIG_HAS_FSL_DR_USB*/
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#endif
+
+/*XHCI Support*/
+#define CONFIG_HAS_FSL_XHCI_USB
+
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+#define CONFIG_USB_XHCI
+#define CONFIG_USB_XHCI_FSL
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	1
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS	2
+#endif
+
+#if defined(CONFIG_HAS_FSL_DR_USB) || defined(CONFIG_HAS_FSL_XHCI_USB)
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
+ * eTSEC
+ */
+#define CONFIG_TSEC_ENET
+
+#ifdef CONFIG_TSEC_ENET
+#define CONFIG_MII
+#define CONFIG_MII_DEFAULT_TSEC		3
+#define CONFIG_TSEC1			1
+#define CONFIG_TSEC1_NAME		"eTSEC1"
+#define CONFIG_TSEC2			1
+#define CONFIG_TSEC2_NAME		"eTSEC2"
+#define CONFIG_TSEC3			1
+#define CONFIG_TSEC3_NAME		"eTSEC3"
+
+#define TSEC1_PHY_ADDR			1
+#define TSEC2_PHY_ADDR			2
+#define TSEC3_PHY_ADDR			3
+
+#define TSEC1_FLAGS			(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS			(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS			(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define TSEC1_PHYIDX			0
+#define TSEC2_PHYIDX			0
+#define TSEC3_PHYIDX			0
+
+#define CONFIG_ETHPRIME			"eTSEC1"
+
+#define CONFIG_PHY_GIGE
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_REALTEK
+
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+
+#define CONFIG_FSL_SGMII_RISER		1
+#define SGMII_RISER_PHY_OFFSET		0x1b
+
+#ifdef CONFIG_FSL_SGMII_RISER
+#define CONFIG_SYS_TBIPA_VALUE		8
+#endif
+
+#endif
+
+/* PCIe */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
+#define FSL_PCIE_COMPAT "fsl,ls1021a-pcie"
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_CMDLINE_EDITING
+
+#if !defined(CONFIG_SD_BOOT) && !defined(CONFIG_QSPI_BOOT)
+#define CONFIG_CMD_IMLS
+#else
+#undef CONFIG_CMD_IMLS
+#endif
+
+#define CONFIG_MISC_INIT_R
+#define CONFIG_HWCONFIG
+#define HWCONFIG_BUFFER_SIZE		128
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_SYS_QE_FW_ADDR     0x67f40000
+
+#ifdef CONFIG_LPUART
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"bootargs=root=/dev/ram0 rw console=ttyLP0,115200\0" \
+	"fdt_high=0xcfffffff\0"		\
+	"initrd_high=0xcfffffff\0"      \
+	"hwconfig=fsl_ddr:ctlr_intlv=null,bank_intlv=null\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+	"bootargs=root=/dev/ram0 rw console=ttyS0,115200\0" \
+	"fdt_high=0xcfffffff\0"		\
+	"initrd_high=0xcfffffff\0"      \
+	"hwconfig=fsl_ddr:ctlr_intlv=null,bank_intlv=null\0"
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_HUSH_PARSER		/* use "hush" command parser */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		\
+		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_ENV_EXISTS
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_MEMINFO
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		0x9fffffff
+
+#define CONFIG_SYS_LOAD_ADDR		0x82000000
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_LS102XA_STREAM_ID
+
+/*
+ * Stack sizes
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE		(30 * 1024)
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#if defined(CONFIG_SD_BOOT)
+#define CONFIG_ENV_OFFSET		(1024 * 1024)
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x2000
+#elif defined(CONFIG_NAND_BOOT)
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(10 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_QSPI_BOOT)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE			0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET		0x100000        /* 1MB */
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_SECT_SIZE		0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_MISC_INIT_R
+
+#include <asm/fsl_secure_boot.h>
+
+#endif
--- u-boot-2014.07/include/fsl_sfp.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_sfp.h	2022-05-09 14:06:24.049116365 -0700
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _FSL_SFP_SNVS_
+#define _FSL_SFP_SNVS_
+
+#include <common.h>
+#include <config.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_SYS_FSL_SRK_LE
+#define srk_in32(a)       in_le32(a)
+#else
+#define srk_in32(a)       in_be32(a)
+#endif
+
+#ifdef CONFIG_SYS_FSL_SFP_LE
+#define sfp_in32(a)       in_le32(a)
+#define sfp_out32(a, v)   out_le32(a, v)
+#define sfp_in16(a)       in_le16(a)
+#elif defined(CONFIG_SYS_FSL_SFP_BE)
+#define sfp_in32(a)       in_be32(a)
+#define sfp_out32(a, v)   out_be32(a, v)
+#define sfp_in16(a)       in_be16(a)
+#else
+#error Neither CONFIG_SYS_FSL_SFP_LE nor CONFIG_SYS_FSL_SFP_BE is defined
+#endif
+
+/* Number of SRKH registers */
+#define NUM_SRKH_REGS	8
+
+#ifdef CONFIG_SYS_FSL_SFP_VER_3_2
+struct ccsr_sfp_regs {
+	u32 ospr;		/* 0x200 */
+	u32 ospr1;		/* 0x204 */
+	u32 reserved1[4];
+	u32 fswpr;		/* 0x218 FSL Section Write Protect */
+	u32 fsl_uid;		/* 0x21c FSL UID 0 */
+	u32 fsl_uid_1;		/* 0x220 FSL UID 0 */
+	u32 reserved2[12];
+	u32 srk_hash[8];	/* 0x254 Super Root Key Hash */
+	u32 oem_uid;		/* 0x274 OEM UID 0*/
+	u32 oem_uid_1;		/* 0x278 OEM UID 1*/
+	u32 oem_uid_2;		/* 0x27c OEM UID 2*/
+	u32 oem_uid_3;		/* 0x280 OEM UID 3*/
+	u32 oem_uid_4;		/* 0x284 OEM UID 4*/
+	u32 reserved3[8];
+};
+#elif defined(CONFIG_SYS_FSL_SFP_VER_3_0)
+struct ccsr_sfp_regs {
+	u32 ospr;		/* 0x200 */
+	u32 reserved0[14];
+	u32 srk_hash[NUM_SRKH_REGS];	/* 0x23c Super Root Key Hash */
+	u32 oem_uid;		/* 0x9c OEM Unique ID */
+	u8 reserved2[0x04];
+	u32 ovpr;			/* 0xA4  Intent To Secure */
+	u8 reserved4[0x08];
+	u32 fsl_uid;		/* 0xB0  FSL Unique ID */
+	u8 reserved5[0x04];
+	u32 fsl_spfr0;		/* Scratch Pad Fuse Register 0 */
+	u32 fsl_spfr1;		/* Scratch Pad Fuse Register 1 */
+
+};
+#else
+struct ccsr_sfp_regs {
+	u8 reserved0[0x40];
+	u32 ospr;	/* 0x40  OEM Security Policy Register */
+	u8 reserved2[0x38];
+	u32 srk_hash[8];	/* 0x7c  Super Root Key Hash */
+	u32 oem_uid;	/* 0x9c  OEM Unique ID */
+	u8 reserved4[0x4];
+	u32 ovpr;	/* 0xA4  OEM Validation Policy Register */
+	u8 reserved8[0x8];
+	u32 fsl_uid;	/* 0xB0  FSL Unique ID */
+};
+#endif
+#define ITS_MASK	0x00000004
+#define ITS_BIT		2
+#define OSPR_KEY_REVOC_SHIFT	13
+#define OSPR_KEY_REVOC_MASK	0x0000e000
+
+void generate_reset_req(void);
+
+#endif
--- u-boot-2014.07/include/jobdesc.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/jobdesc.h	2022-05-09 14:06:24.053116203 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __JOBDESC_H
+#define __JOBDESC_H
+
+#include <common.h>
+#include <asm/io.h>
+#include <sha.h>
+#include <rsa_sec.h>
+
+#define KEY_IDNFR_SZ_BYTES		16
+
+void inline_cnstr_jobdesc_pkha_rsaexp(uint32_t *desc,
+			      struct pk_in_params *pkin, uint8_t *out,
+			      uint32_t out_siz);
+
+void inline_cnstr_jobdesc_sha256(uint32_t *desc,
+	uint8_t *msg, uint32_t msgsz, uint8_t *digest);
+
+void inline_cnstr_jobdesc_blob_encap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *plain_txt, uint8_t *enc_blob,
+				     uint32_t in_sz);
+
+void inline_cnstr_jobdesc_blob_decap(uint32_t *desc, uint8_t *key_idnfr,
+				     uint8_t *enc_blob, uint8_t *plain_txt,
+				     uint32_t out_sz);
+
+#endif
--- u-boot-2014.07/include/linux/immap_qe.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/linux/immap_qe.h	2022-05-09 14:06:24.061115880 -0700
@@ -0,0 +1,589 @@
+/*
+ * QUICC Engine (QE) Internal Memory Map.
+ * The Internal Memory Map for devices with QE on them. This
+ * is the superset of all QE devices (8360, etc.).
+ *
+ * Copyright (c) 2006-2009, 2011 Freescale Semiconductor, Inc.
+ * Author: Shlomi Gridih <gridish@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __IMMAP_QE_H__
+#define __IMMAP_QE_H__
+
+#ifdef CONFIG_MPC83xx
+#if defined(CONFIG_MPC8360)
+#define QE_MURAM_SIZE		0xc000UL
+#define MAX_QE_RISC		2
+#define QE_NUM_OF_SNUM		28
+#elif defined(CONFIG_MPC832x) || defined(CONFIG_MPC8309)
+#define QE_MURAM_SIZE		0x4000UL
+#define MAX_QE_RISC		1
+#define QE_NUM_OF_SNUM		28
+#endif
+#endif
+
+#ifdef CONFIG_LS102XA
+#define QE_MURAM_SIZE          0x6000UL
+#define MAX_QE_RISC            1
+#define QE_NUM_OF_SNUM         28
+#endif
+
+/* QE I-RAM */
+typedef struct qe_iram {
+	u32 iadd;		/* I-RAM Address Register */
+	u32 idata;		/* I-RAM Data Register    */
+	u8 res0[0x4];
+	u32 iready;
+	u8 res1[0x70];
+} __attribute__ ((packed)) qe_iram_t;
+
+/* QE Interrupt Controller */
+typedef struct qe_ic {
+	u32 qicr;
+	u32 qivec;
+	u32 qripnr;
+	u32 qipnr;
+	u32 qipxcc;
+	u32 qipycc;
+	u32 qipwcc;
+	u32 qipzcc;
+	u32 qimr;
+	u32 qrimr;
+	u32 qicnr;
+	u8 res0[0x4];
+	u32 qiprta;
+	u32 qiprtb;
+	u8 res1[0x4];
+	u32 qricr;
+	u8 res2[0x20];
+	u32 qhivec;
+	u8 res3[0x1C];
+} __attribute__ ((packed)) qe_ic_t;
+
+/* Communications Processor */
+typedef struct cp_qe {
+	u32 cecr;		/* QE command register */
+	u32 ceccr;		/* QE controller configuration register */
+	u32 cecdr;		/* QE command data register */
+	u8 res0[0xA];
+	u16 ceter;		/* QE timer event register */
+	u8 res1[0x2];
+	u16 cetmr;		/* QE timers mask register */
+	u32 cetscr;		/* QE time-stamp timer control register */
+	u32 cetsr1;		/* QE time-stamp register 1 */
+	u32 cetsr2;		/* QE time-stamp register 2 */
+	u8 res2[0x8];
+	u32 cevter;		/* QE virtual tasks event register */
+	u32 cevtmr;		/* QE virtual tasks mask register */
+	u16 cercr;		/* QE RAM control register */
+	u8 res3[0x2];
+	u8 res4[0x24];
+	u16 ceexe1;		/* QE external request 1 event register */
+	u8 res5[0x2];
+	u16 ceexm1;		/* QE external request 1 mask register */
+	u8 res6[0x2];
+	u16 ceexe2;		/* QE external request 2 event register */
+	u8 res7[0x2];
+	u16 ceexm2;		/* QE external request 2 mask register */
+	u8 res8[0x2];
+	u16 ceexe3;		/* QE external request 3 event register */
+	u8 res9[0x2];
+	u16 ceexm3;		/* QE external request 3 mask register */
+	u8 res10[0x2];
+	u16 ceexe4;		/* QE external request 4 event register */
+	u8 res11[0x2];
+	u16 ceexm4;		/* QE external request 4 mask register */
+	u8 res12[0x3A];
+	__be32  ceurnr;		/* QE microcode revision number register */
+	u8 res13[0x244];
+} __attribute__ ((packed)) cp_qe_t;
+
+/* QE Multiplexer */
+typedef struct qe_mux {
+	u32 cmxgcr;		/* CMX general clock route register    */
+	u32 cmxsi1cr_l;		/* CMX SI1 clock route low register    */
+	u32 cmxsi1cr_h;		/* CMX SI1 clock route high register   */
+	u32 cmxsi1syr;		/* CMX SI1 SYNC route register         */
+	u32 cmxucr1;		/* CMX UCC1, UCC3 clock route register */
+	u32 cmxucr2;		/* CMX UCC5, UCC7 clock route register */
+	u32 cmxucr3;		/* CMX UCC2, UCC4 clock route register */
+	u32 cmxucr4;		/* CMX UCC6, UCC8 clock route register */
+	u32 cmxupcr;		/* CMX UPC clock route register        */
+	u8 res0[0x1C];
+} __attribute__ ((packed)) qe_mux_t;
+
+/* QE Timers */
+typedef struct qe_timers {
+	u8 gtcfr1;		/* Timer 1 2 global configuration register */
+	u8 res0[0x3];
+	u8 gtcfr2;		/* Timer 3 4 global configuration register */
+	u8 res1[0xB];
+	u16 gtmdr1;		/* Timer 1 mode register */
+	u16 gtmdr2;		/* Timer 2 mode register */
+	u16 gtrfr1;		/* Timer 1 reference register */
+	u16 gtrfr2;		/* Timer 2 reference register */
+	u16 gtcpr1;		/* Timer 1 capture register */
+	u16 gtcpr2;		/* Timer 2 capture register */
+	u16 gtcnr1;		/* Timer 1 counter */
+	u16 gtcnr2;		/* Timer 2 counter */
+	u16 gtmdr3;		/* Timer 3 mode register */
+	u16 gtmdr4;		/* Timer 4 mode register */
+	u16 gtrfr3;		/* Timer 3 reference register */
+	u16 gtrfr4;		/* Timer 4 reference register */
+	u16 gtcpr3;		/* Timer 3 capture register */
+	u16 gtcpr4;		/* Timer 4 capture register */
+	u16 gtcnr3;		/* Timer 3 counter */
+	u16 gtcnr4;		/* Timer 4 counter */
+	u16 gtevr1;		/* Timer 1 event register */
+	u16 gtevr2;		/* Timer 2 event register */
+	u16 gtevr3;		/* Timer 3 event register */
+	u16 gtevr4;		/* Timer 4 event register */
+	u16 gtps;		/* Timer 1 prescale register */
+	u8 res2[0x46];
+} __attribute__ ((packed)) qe_timers_t;
+
+/* BRG */
+typedef struct qe_brg {
+	u32 brgc1;		/* BRG1 configuration register  */
+	u32 brgc2;		/* BRG2 configuration register  */
+	u32 brgc3;		/* BRG3 configuration register  */
+	u32 brgc4;		/* BRG4 configuration register  */
+	u32 brgc5;		/* BRG5 configuration register  */
+	u32 brgc6;		/* BRG6 configuration register  */
+	u32 brgc7;		/* BRG7 configuration register  */
+	u32 brgc8;		/* BRG8 configuration register  */
+	u32 brgc9;		/* BRG9 configuration register  */
+	u32 brgc10;		/* BRG10 configuration register */
+	u32 brgc11;		/* BRG11 configuration register */
+	u32 brgc12;		/* BRG12 configuration register */
+	u32 brgc13;		/* BRG13 configuration register */
+	u32 brgc14;		/* BRG14 configuration register */
+	u32 brgc15;		/* BRG15 configuration register */
+	u32 brgc16;		/* BRG16 configuration register */
+	u8 res0[0x40];
+} __attribute__ ((packed)) qe_brg_t;
+
+/* SPI */
+typedef struct spi {
+	u8 res0[0x20];
+	u32 spmode;		/* SPI mode register */
+	u8 res1[0x2];
+	u8 spie;		/* SPI event register */
+	u8 res2[0x1];
+	u8 res3[0x2];
+	u8 spim;		/* SPI mask register */
+	u8 res4[0x1];
+	u8 res5[0x1];
+	u8 spcom;		/* SPI command register  */
+	u8 res6[0x2];
+	u32 spitd;		/* SPI transmit data register (cpu mode) */
+	u32 spird;		/* SPI receive data register (cpu mode) */
+	u8 res7[0x8];
+} __attribute__ ((packed)) spi_t;
+
+/* SI */
+typedef struct si1 {
+	u16 siamr1;		/* SI1 TDMA mode register */
+	u16 sibmr1;		/* SI1 TDMB mode register */
+	u16 sicmr1;		/* SI1 TDMC mode register */
+	u16 sidmr1;		/* SI1 TDMD mode register */
+	u8 siglmr1_h;		/* SI1 global mode register high */
+	u8 res0[0x1];
+	u8 sicmdr1_h;		/* SI1 command register high */
+	u8 res2[0x1];
+	u8 sistr1_h;		/* SI1 status register high */
+	u8 res3[0x1];
+	u16 sirsr1_h;		/* SI1 RAM shadow address register high */
+	u8 sitarc1;		/* SI1 RAM counter Tx TDMA */
+	u8 sitbrc1;		/* SI1 RAM counter Tx TDMB */
+	u8 sitcrc1;		/* SI1 RAM counter Tx TDMC */
+	u8 sitdrc1;		/* SI1 RAM counter Tx TDMD */
+	u8 sirarc1;		/* SI1 RAM counter Rx TDMA */
+	u8 sirbrc1;		/* SI1 RAM counter Rx TDMB */
+	u8 sircrc1;		/* SI1 RAM counter Rx TDMC */
+	u8 sirdrc1;		/* SI1 RAM counter Rx TDMD */
+	u8 res4[0x8];
+	u16 siemr1;		/* SI1 TDME mode register 16 bits */
+	u16 sifmr1;		/* SI1 TDMF mode register 16 bits */
+	u16 sigmr1;		/* SI1 TDMG mode register 16 bits */
+	u16 sihmr1;		/* SI1 TDMH mode register 16 bits */
+	u8 siglmg1_l;		/* SI1 global mode register low 8 bits */
+	u8 res5[0x1];
+	u8 sicmdr1_l;		/* SI1 command register low 8 bits */
+	u8 res6[0x1];
+	u8 sistr1_l;		/* SI1 status register low 8 bits */
+	u8 res7[0x1];
+	u16 sirsr1_l;		/* SI1 RAM shadow address register low 16 bits */
+	u8 siterc1;		/* SI1 RAM counter Tx TDME 8 bits */
+	u8 sitfrc1;		/* SI1 RAM counter Tx TDMF 8 bits */
+	u8 sitgrc1;		/* SI1 RAM counter Tx TDMG 8 bits */
+	u8 sithrc1;		/* SI1 RAM counter Tx TDMH 8 bits */
+	u8 sirerc1;		/* SI1 RAM counter Rx TDME 8 bits */
+	u8 sirfrc1;		/* SI1 RAM counter Rx TDMF 8 bits */
+	u8 sirgrc1;		/* SI1 RAM counter Rx TDMG 8 bits */
+	u8 sirhrc1;		/* SI1 RAM counter Rx TDMH 8 bits */
+	u8 res8[0x8];
+	u32 siml1;		/* SI1 multiframe limit register */
+	u8 siedm1;		/* SI1 extended diagnostic mode register */
+	u8 res9[0xBB];
+} __attribute__ ((packed)) si1_t;
+
+/* SI Routing Tables */
+typedef struct sir {
+	u8 tx[0x400];
+	u8 rx[0x400];
+	u8 res0[0x800];
+} __attribute__ ((packed)) sir_t;
+
+/* USB Controller.  */
+typedef struct usb_ctlr {
+	u8 usb_usmod;
+	u8 usb_usadr;
+	u8 usb_uscom;
+	u8 res1[1];
+	u16 usb_usep1;
+	u16 usb_usep2;
+	u16 usb_usep3;
+	u16 usb_usep4;
+	u8 res2[4];
+	u16 usb_usber;
+	u8 res3[2];
+	u16 usb_usbmr;
+	u8 res4[1];
+	u8 usb_usbs;
+	u16 usb_ussft;
+	u8 res5[2];
+	u16 usb_usfrn;
+	u8 res6[0x22];
+} __attribute__ ((packed)) usb_t;
+
+/* MCC */
+typedef struct mcc {
+	u32 mcce;		/* MCC event register */
+	u32 mccm;		/* MCC mask register */
+	u32 mccf;		/* MCC configuration register */
+	u32 merl;		/* MCC emergency request level register */
+	u8 res0[0xF0];
+} __attribute__ ((packed)) mcc_t;
+
+/* QE UCC Slow */
+typedef struct ucc_slow {
+	u32 gumr_l;		/* UCCx general mode register (low) */
+	u32 gumr_h;		/* UCCx general mode register (high) */
+	u16 upsmr;		/* UCCx protocol-specific mode register */
+	u8 res0[0x2];
+	u16 utodr;		/* UCCx transmit on demand register */
+	u16 udsr;		/* UCCx data synchronization register */
+	u16 ucce;		/* UCCx event register */
+	u8 res1[0x2];
+	u16 uccm;		/* UCCx mask register */
+	u8 res2[0x1];
+	u8 uccs;		/* UCCx status register */
+	u8 res3[0x24];
+	u16 utpt;
+	u8 guemr;		/* UCC general extended mode register */
+	u8 res4[0x200 - 0x091];
+} __attribute__ ((packed)) ucc_slow_t;
+
+typedef struct ucc_mii_mng {
+	u32 miimcfg;		/* MII management configuration reg    */
+	u32 miimcom;		/* MII management command reg          */
+	u32 miimadd;		/* MII management address reg          */
+	u32 miimcon;		/* MII management control reg          */
+	u32 miimstat;		/* MII management status reg           */
+	u32 miimind;		/* MII management indication reg       */
+	u32 ifctl;		/* interface control reg               */
+	u32 ifstat;		/* interface statux reg                */
+} __attribute__ ((packed))uec_mii_t;
+
+typedef struct ucc_ethernet {
+	u32 maccfg1;		/* mac configuration reg. 1            */
+	u32 maccfg2;		/* mac configuration reg. 2            */
+	u32 ipgifg;		/* interframe gap reg.                 */
+	u32 hafdup;		/* half-duplex reg.                    */
+	u8 res1[0x10];
+	u32 miimcfg;		/* MII management configuration reg    */
+	u32 miimcom;		/* MII management command reg          */
+	u32 miimadd;		/* MII management address reg          */
+	u32 miimcon;		/* MII management control reg          */
+	u32 miimstat;		/* MII management status reg           */
+	u32 miimind;		/* MII management indication reg       */
+	u32 ifctl;		/* interface control reg               */
+	u32 ifstat;		/* interface statux reg                */
+	u32 macstnaddr1;	/* mac station address part 1 reg      */
+	u32 macstnaddr2;	/* mac station address part 2 reg      */
+	u8 res2[0x8];
+	u32 uempr;		/* UCC Ethernet Mac parameter reg      */
+	u32 utbipar;		/* UCC tbi address reg                 */
+	u16 uescr;		/* UCC Ethernet statistics control reg */
+	u8 res3[0x180 - 0x15A];
+	u32 tx64;		/* Total number of frames (including bad
+				 * frames) transmitted that were exactly
+				 * of the minimal length (64 for un tagged,
+				 * 68 for tagged, or with length exactly
+				 * equal to the parameter MINLength */
+	u32 tx127;		/* Total number of frames (including bad
+				 * frames) transmitted that were between
+				 * MINLength (Including FCS length==4)
+				 * and 127 octets */
+	u32 tx255;		/* Total number of frames (including bad
+				 * frames) transmitted that were between
+				 * 128 (Including FCS length==4) and 255
+				 * octets */
+	u32 rx64;		/* Total number of frames received including
+				 * bad frames that were exactly of the
+				 * mninimal length (64 bytes) */
+	u32 rx127;		/* Total number of frames (including bad
+				 * frames) received that were between
+				 * MINLength (Including FCS length==4)
+				 * and 127 octets */
+	u32 rx255;		/* Total number of frames (including
+				 * bad frames) received that were between
+				 * 128 (Including FCS length==4) and 255
+				 * octets */
+	u32 txok;		/* Total number of octets residing in frames
+				 * that where involved in succesfull
+				 * transmission */
+	u16 txcf;		/* Total number of PAUSE control frames
+				 *  transmitted by this MAC */
+	u8 res4[0x2];
+	u32 tmca;		/* Total number of frames that were transmitted
+				 * succesfully with the group address bit set
+				 * that are not broadcast frames */
+	u32 tbca;		/* Total number of frames transmitted
+				 * succesfully that had destination address
+				 * field equal to the broadcast address */
+	u32 rxfok;		/* Total number of frames received OK */
+	u32 rxbok;		/* Total number of octets received OK */
+	u32 rbyt;		/* Total number of octets received including
+				 * octets in bad frames. Must be implemented
+				 * in HW because it includes octets in frames
+				 * that never even reach the UCC */
+	u32 rmca;		/* Total number of frames that were received
+				 * succesfully with the group address bit set
+				 * that are not broadcast frames */
+	u32 rbca;		/* Total number of frames received succesfully
+				 * that had destination address equal to the
+				 * broadcast address */
+	u32 scar;		/* Statistics carry register */
+	u32 scam;		/* Statistics caryy mask register */
+	u8 res5[0x200 - 0x1c4];
+} __attribute__ ((packed)) uec_t;
+
+/* QE UCC Fast */
+typedef struct ucc_fast {
+	u32 gumr;		/* UCCx general mode register */
+	u32 upsmr;		/* UCCx protocol-specific mode register  */
+	u16 utodr;		/* UCCx transmit on demand register  */
+	u8 res0[0x2];
+	u16 udsr;		/* UCCx data synchronization register  */
+	u8 res1[0x2];
+	u32 ucce;		/* UCCx event register */
+	u32 uccm;		/* UCCx mask register.  */
+	u8 uccs;		/* UCCx status register */
+	u8 res2[0x7];
+	u32 urfb;		/* UCC receive FIFO base */
+	u16 urfs;		/* UCC receive FIFO size */
+	u8 res3[0x2];
+	u16 urfet;		/* UCC receive FIFO emergency threshold */
+	u16 urfset;		/* UCC receive FIFO special emergency
+				 * threshold */
+	u32 utfb;		/* UCC transmit FIFO base */
+	u16 utfs;		/* UCC transmit FIFO size */
+	u8 res4[0x2];
+	u16 utfet;		/* UCC transmit FIFO emergency threshold */
+	u8 res5[0x2];
+	u16 utftt;		/* UCC transmit FIFO transmit threshold */
+	u8 res6[0x2];
+	u16 utpt;		/* UCC transmit polling timer */
+	u8 res7[0x2];
+	u32 urtry;		/* UCC retry counter register */
+	u8 res8[0x4C];
+	u8 guemr;		/* UCC general extended mode register */
+	u8 res9[0x100 - 0x091];
+	uec_t ucc_eth;
+} __attribute__ ((packed)) ucc_fast_t;
+
+/* QE UCC */
+typedef struct ucc_common {
+	u8 res1[0x90];
+	u8 guemr;
+	u8 res2[0x200 - 0x091];
+} __attribute__ ((packed)) ucc_common_t;
+
+typedef struct ucc {
+	union {
+		ucc_slow_t slow;
+		ucc_fast_t fast;
+		ucc_common_t common;
+	};
+} __attribute__ ((packed)) ucc_t;
+
+/* MultiPHY UTOPIA POS Controllers (UPC) */
+typedef struct upc {
+	u32 upgcr;		/* UTOPIA/POS general configuration register */
+	u32 uplpa;		/* UTOPIA/POS last PHY address */
+	u32 uphec;		/* ATM HEC register */
+	u32 upuc;		/* UTOPIA/POS UCC configuration */
+	u32 updc1;		/* UTOPIA/POS device 1 configuration */
+	u32 updc2;		/* UTOPIA/POS device 2 configuration  */
+	u32 updc3;		/* UTOPIA/POS device 3 configuration */
+	u32 updc4;		/* UTOPIA/POS device 4 configuration  */
+	u32 upstpa;		/* UTOPIA/POS STPA threshold  */
+	u8 res0[0xC];
+	u32 updrs1_h;		/* UTOPIA/POS device 1 rate select  */
+	u32 updrs1_l;		/* UTOPIA/POS device 1 rate select  */
+	u32 updrs2_h;		/* UTOPIA/POS device 2 rate select  */
+	u32 updrs2_l;		/* UTOPIA/POS device 2 rate select */
+	u32 updrs3_h;		/* UTOPIA/POS device 3 rate select */
+	u32 updrs3_l;		/* UTOPIA/POS device 3 rate select */
+	u32 updrs4_h;		/* UTOPIA/POS device 4 rate select */
+	u32 updrs4_l;		/* UTOPIA/POS device 4 rate select */
+	u32 updrp1;		/* UTOPIA/POS device 1 receive priority low  */
+	u32 updrp2;		/* UTOPIA/POS device 2 receive priority low  */
+	u32 updrp3;		/* UTOPIA/POS device 3 receive priority low  */
+	u32 updrp4;		/* UTOPIA/POS device 4 receive priority low  */
+	u32 upde1;		/* UTOPIA/POS device 1 event */
+	u32 upde2;		/* UTOPIA/POS device 2 event */
+	u32 upde3;		/* UTOPIA/POS device 3 event */
+	u32 upde4;		/* UTOPIA/POS device 4 event */
+	u16 uprp1;
+	u16 uprp2;
+	u16 uprp3;
+	u16 uprp4;
+	u8 res1[0x8];
+	u16 uptirr1_0;		/* Device 1 transmit internal rate 0 */
+	u16 uptirr1_1;		/* Device 1 transmit internal rate 1 */
+	u16 uptirr1_2;		/* Device 1 transmit internal rate 2 */
+	u16 uptirr1_3;		/* Device 1 transmit internal rate 3 */
+	u16 uptirr2_0;		/* Device 2 transmit internal rate 0 */
+	u16 uptirr2_1;		/* Device 2 transmit internal rate 1 */
+	u16 uptirr2_2;		/* Device 2 transmit internal rate 2 */
+	u16 uptirr2_3;		/* Device 2 transmit internal rate 3 */
+	u16 uptirr3_0;		/* Device 3 transmit internal rate 0 */
+	u16 uptirr3_1;		/* Device 3 transmit internal rate 1 */
+	u16 uptirr3_2;		/* Device 3 transmit internal rate 2 */
+	u16 uptirr3_3;		/* Device 3 transmit internal rate 3 */
+	u16 uptirr4_0;		/* Device 4 transmit internal rate 0 */
+	u16 uptirr4_1;		/* Device 4 transmit internal rate 1 */
+	u16 uptirr4_2;		/* Device 4 transmit internal rate 2 */
+	u16 uptirr4_3;		/* Device 4 transmit internal rate 3 */
+	u32 uper1;		/* Device 1 port enable register */
+	u32 uper2;		/* Device 2 port enable register */
+	u32 uper3;		/* Device 3 port enable register */
+	u32 uper4;		/* Device 4 port enable register */
+	u8 res2[0x150];
+} __attribute__ ((packed)) upc_t;
+
+/* SDMA */
+typedef struct sdma {
+	u32 sdsr;		/* Serial DMA status register */
+	u32 sdmr;		/* Serial DMA mode register */
+	u32 sdtr1;		/* SDMA system bus threshold register */
+	u32 sdtr2;		/* SDMA secondary bus threshold register */
+	u32 sdhy1;		/* SDMA system bus hysteresis register */
+	u32 sdhy2;		/* SDMA secondary bus hysteresis register */
+	u32 sdta1;		/* SDMA system bus address register */
+	u32 sdta2;		/* SDMA secondary bus address register */
+	u32 sdtm1;		/* SDMA system bus MSNUM register */
+	u32 sdtm2;		/* SDMA secondary bus MSNUM register */
+	u8 res0[0x10];
+	u32 sdaqr;		/* SDMA address bus qualify register */
+	u32 sdaqmr;		/* SDMA address bus qualify mask register */
+	u8 res1[0x4];
+	u32 sdwbcr;		/* SDMA CAM entries base register */
+	u8 res2[0x38];
+} __attribute__ ((packed)) sdma_t;
+
+/* Debug Space */
+typedef struct dbg {
+	u32 bpdcr;		/* Breakpoint debug command register */
+	u32 bpdsr;		/* Breakpoint debug status register */
+	u32 bpdmr;		/* Breakpoint debug mask register */
+	u32 bprmrr0;		/* Breakpoint request mode risc register 0 */
+	u32 bprmrr1;		/* Breakpoint request mode risc register 1 */
+	u8 res0[0x8];
+	u32 bprmtr0;		/* Breakpoint request mode trb register 0 */
+	u32 bprmtr1;		/* Breakpoint request mode trb register 1 */
+	u8 res1[0x8];
+	u32 bprmir;		/* Breakpoint request mode immediate register */
+	u32 bprmsr;		/* Breakpoint request mode serial register */
+	u32 bpemr;		/* Breakpoint exit mode register */
+	u8 res2[0x48];
+} __attribute__ ((packed)) dbg_t;
+
+/*
+ * RISC Special Registers (Trap and Breakpoint).  These are described in
+ * the QE Developer's Handbook.
+*/
+typedef struct rsp {
+	u32 tibcr[16];	/* Trap/instruction breakpoint control regs */
+	u8 res0[64];
+	u32 ibcr0;
+	u32 ibs0;
+	u32 ibcnr0;
+	u8 res1[4];
+	u32 ibcr1;
+	u32 ibs1;
+	u32 ibcnr1;
+	u32 npcr;
+	u32 dbcr;
+	u32 dbar;
+	u32 dbamr;
+	u32 dbsr;
+	u32 dbcnr;
+	u8 res2[12];
+	u32 dbdr_h;
+	u32 dbdr_l;
+	u32 dbdmr_h;
+	u32 dbdmr_l;
+	u32 bsr;
+	u32 bor;
+	u32 bior;
+	u8 res3[4];
+	u32 iatr[4];
+	u32 eccr;		/* Exception control configuration register */
+	u32 eicr;
+	u8 res4[0x100-0xf8];
+} __attribute__ ((packed)) rsp_t;
+
+typedef struct qe_immap {
+	qe_iram_t iram;		/* I-RAM */
+	qe_ic_t ic;		/* Interrupt Controller */
+	cp_qe_t cp;		/* Communications Processor */
+	qe_mux_t qmx;		/* QE Multiplexer */
+	qe_timers_t qet;	/* QE Timers */
+	spi_t spi[0x2];		/* spi  */
+	mcc_t mcc;		/* mcc */
+	qe_brg_t brg;		/* brg */
+	usb_t usb;		/* USB */
+	si1_t si1;		/* SI */
+	u8 res11[0x800];
+	sir_t sir;		/* SI Routing Tables  */
+	ucc_t ucc1;		/* ucc1 */
+	ucc_t ucc3;		/* ucc3 */
+	ucc_t ucc5;		/* ucc5 */
+	ucc_t ucc7;		/* ucc7 */
+	u8 res12[0x600];
+	upc_t upc1;		/* MultiPHY UTOPIA POS Controller 1 */
+	ucc_t ucc2;		/* ucc2 */
+	ucc_t ucc4;		/* ucc4 */
+	ucc_t ucc6;		/* ucc6 */
+	ucc_t ucc8;		/* ucc8 */
+	u8 res13[0x600];
+	upc_t upc2;		/* MultiPHY UTOPIA POS Controller 2 */
+	sdma_t sdma;		/* SDMA */
+	dbg_t dbg;		/* Debug Space */
+	rsp_t rsp[0x2];		/* RISC Special Registers
+				 * (Trap and Breakpoint) */
+	u8 res14[0x300];
+	u8 res15[0x3A00];
+	u8 res16[0x8000];	/* 0x108000 -  0x110000 */
+	u8 muram[QE_MURAM_SIZE];
+} __attribute__ ((packed)) qe_map_t;
+
+extern qe_map_t *qe_immr;
+
+#endif				/* __IMMAP_QE_H__ */
--- u-boot-2014.07/include/linux/compiler-gcc6.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/linux/compiler-gcc6.h	2022-05-09 14:06:24.057116042 -0700
@@ -0,0 +1,61 @@
+#ifdef CONFIG_WG_PLATFORM_BACKPORT /* FBX-9469 */
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc6.h> directly, include <linux/compiler.h> instead."
+#endif
+
+#define __used				__attribute__((__used__))
+#define __must_check			__attribute__((warn_unused_result))
+#define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+
+/* Mark functions as cold. gcc will assume any path leading to a call
+   to them will be unlikely.  This means a lot of manual unlikely()s
+   are unnecessary now for any paths leading to the usual suspects
+   like BUG(), printk(), panic() etc. [but let's keep them for now for
+   older compilers]
+
+   gcc also has a __attribute__((__hot__)) to move hot functions into
+   a special section, but I don't see any sense in this right now in
+   the kernel context */
+#define __cold			__attribute__((__cold__))
+
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+
+/*
+ * Mark a position in code as unreachable.  This can be used to
+ * suppress control flow warnings after asm blocks that transfer
+ * control elsewhere.
+ */
+#define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__))
+
+/*
+ * Tell the optimizer that something else uses this function or variable.
+ */
+#define __visible __attribute__((externally_visible))
+
+/*
+ * GCC 'asm goto' miscompiles certain code sequences:
+ *
+ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+ *
+ * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+ *
+ * (asm goto is automatically volatile - the naming reflects this.)
+ */
+#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+
+#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+#define __HAVE_BUILTIN_BSWAP32__
+#define __HAVE_BUILTIN_BSWAP64__
+#define __HAVE_BUILTIN_BSWAP16__
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
+
+#define KASAN_ABI_VERSION 4
+#endif /* CONFIG_WG_PLATFORM_BACKPORT */
--- u-boot-2014.07/include/linux/usb/xhci-fsl.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/linux/usb/xhci-fsl.h	2022-05-09 14:06:24.065115718 -0700
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * FSL USB HOST xHCI Controller
+ *
+ * Author: Ramneek Mehresh<ramneek.mehresh@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ASM_ARCH_XHCI_FSL_H_
+#define _ASM_ARCH_XHCI_FSL_H_
+
+/* Default to the FSL XHCI defines */
+#define FSL_XHCI_BASE 0x3100000
+#define FSL_OCP1_SCP_BASE 0x4a084c00
+#define FSL_OTG_WRAPPER_BASE 0x4A020000
+
+#define USB3_PWRCTL_CLK_CMD_MASK	0x3FE000
+#define USB3_PWRCTL_CLK_FREQ_MASK	0xFFC
+#define USB3_PHY_PARTIAL_RX_POWERON     (1 << 6)
+#define USB3_PHY_RX_POWERON		(1 << 14)
+#define USB3_PHY_TX_POWERON		(1 << 15)
+#define USB3_PHY_TX_RX_POWERON	(USB3_PHY_RX_POWERON | USB3_PHY_TX_POWERON)
+#define USB3_PWRCTL_CLK_CMD_SHIFT   14
+#define USB3_PWRCTL_CLK_FREQ_SHIFT	22
+
+/* USBOTGSS_WRAPPER definitions */
+#define USBOTGSS_WRAPRESET	(1 << 17)
+#define USBOTGSS_DMADISABLE (1 << 16)
+#define USBOTGSS_STANDBYMODE_NO_STANDBY (1 << 4)
+#define USBOTGSS_STANDBYMODE_SMRT		(1 << 5)
+#define USBOTGSS_STANDBYMODE_SMRT_WKUP (0x3 << 4)
+#define USBOTGSS_IDLEMODE_NOIDLE (1 << 2)
+#define USBOTGSS_IDLEMODE_SMRT (1 << 3)
+#define USBOTGSS_IDLEMODE_SMRT_WKUP (0x3 << 2)
+
+/* USBOTGSS_IRQENABLE_SET_0 bit */
+#define USBOTGSS_COREIRQ_EN	(1 << 0)
+
+/* USBOTGSS_IRQENABLE_SET_1 bits */
+#define USBOTGSS_IRQ_SET_1_IDPULLUP_FALL_EN	(1 << 0)
+#define USBOTGSS_IRQ_SET_1_DISCHRGVBUS_FALL_EN	(1 << 3)
+#define USBOTGSS_IRQ_SET_1_CHRGVBUS_FALL_EN	(1 << 4)
+#define USBOTGSS_IRQ_SET_1_DRVVBUS_FALL_EN	(1 << 5)
+#define USBOTGSS_IRQ_SET_1_IDPULLUP_RISE_EN	(1 << 8)
+#define USBOTGSS_IRQ_SET_1_DISCHRGVBUS_RISE_EN	(1 << 11)
+#define USBOTGSS_IRQ_SET_1_CHRGVBUS_RISE_EN	(1 << 12)
+#define USBOTGSS_IRQ_SET_1_DRVVBUS_RISE_EN	(1 << 13)
+#define USBOTGSS_IRQ_SET_1_OEVT_EN	(1 << 16)
+#define USBOTGSS_IRQ_SET_1_DMADISABLECLR_EN	(1 << 17)
+
+struct fsl_xhci {
+	struct xhci_hccr *hcd;
+	struct dwc3 *dwc3_reg;
+};
+
+#endif /* _ASM_ARCH_XHCI_FSL_H_ */
--- u-boot-2014.07/include/fsl_dcu_fb.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_dcu_fb.h	2022-05-09 14:06:24.045116527 -0700
@@ -0,0 +1,16 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * FSL DCU Framebuffer driver
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <linux/fb.h>
+
+int fsl_dcu_init(unsigned int xres, unsigned int yres,
+		 unsigned int pixel_format);
+
+/* Prototypes for external board-specific functions */
+int platform_dcu_init(unsigned int xres, unsigned int yres,
+		      const char *port, struct fb_videomode *dcu_fb_videomode);
+unsigned int dcu_set_pixel_clock(unsigned int pixclock);
--- u-boot-2014.07/include/sha.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/sha.h	2022-05-09 14:06:24.085114909 -0700
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SHA_H
+#define _SHA_H
+
+#include <jr.h>
+
+/* number of bytes in the SHA256-256 digest */
+#define SHA256_DIGEST_SIZE 32
+
+/*
+ * number of words in the digest - Digest is kept internally
+ * as 8 32-bit words
+ */
+#define _SHA256_DIGEST_LENGTH 8
+
+/*
+ * block length - A block, treated as a sequence of
+ * 32-bit words
+ */
+#define SHA256_BLOCK_LENGTH 16
+
+/* number of bytes in the block */
+#define SHA256_DATA_SIZE 64
+
+#define MAX_SG		12
+
+/*
+ * Scatter Gather Entry - Speicifies the the Scatter Gather Format
+ * related information
+ */
+#ifdef CONFIG_SYS_FSL_SEC_LE
+struct sg_entry {
+	uint32_t addr_lo;	/* Memory Address - lo */
+	uint16_t addr_hi;	/* Memory Address of the start of the
+				 * buffer - hi
+				 */
+	uint16_t reserved_zero;
+	unsigned int length:30;	/* Length of the data in the frame */
+	unsigned int final:1;
+	unsigned int extension:1;
+	unsigned int offset:13;
+	unsigned int reserved_offset:3;
+	uint8_t bpid;		/* Buffer Pool Id */
+	uint8_t reserved_zero2;
+};
+#else
+struct sg_entry {
+	uint16_t reserved_zero;
+	uint16_t addr_hi;	/* Memory Address of the start of the
+				 * buffer - hi
+				 */
+	uint32_t addr_lo;	/* Memory Address - lo */
+	unsigned int extension:1;
+	unsigned int final:1;
+	unsigned int length:30;	/* Length of the data in the frame */
+	uint8_t reserved_zero2;
+	uint8_t bpid;		/* Buffer Pool Id */
+	unsigned int reserved_offset:3;
+	unsigned int offset:13;
+};
+#endif
+
+/*
+ * SHA256-256 context
+ * contain the following fields
+ * State
+ * count low
+ * count high
+ * block data buffer
+ * index to the buffer
+ */
+struct sha_ctx {
+	struct sg_entry sg_tbl[MAX_SG];
+	uint32_t sha_desc[64];
+	u8 hash[SHA256_DIGEST_SIZE];
+	struct result op;
+	uint32_t sg_num;
+	uint32_t len;
+	struct jobring *jr;
+};
+
+void sha_init(struct sha_ctx *ctx, struct jobring *jr);
+void sha_update(struct sha_ctx *ctx, uint8_t *data, uint32_t length);
+int sha_final(struct sha_ctx *ctx);
+int sha_digest(struct sha_ctx *ctx, uint8_t *digest);
+
+#endif
--- u-boot-2014.07/include/fsl_sec.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_sec.h	2022-05-09 14:06:24.049116365 -0700
@@ -0,0 +1,220 @@
+/*
+ * Common internal memory map for some Freescale SoCs
+ *
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_SEC_H
+#define __FSL_SEC_H
+
+#include <common.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_SYS_FSL_SEC_LE
+#define sec_in32(a)       in_le32(a)
+#define sec_out32(a, v)   out_le32(a, v)
+#define sec_in16(a)       in_le16(a)
+#define sec_clrbits32     clrbits_le32
+#define sec_setbits32     setbits_le32
+#define snvs_in32(a)       in_le32(a)
+#define snvs_out32(a, v)   out_le32(a, v)
+#define snvs_in16(a)       in_le16(a)
+#define snvs_clrbits32     clrbits_le32
+#define snvs_setbits32     setbits_le32
+#elif defined(CONFIG_SYS_FSL_SEC_BE)
+#define sec_in32(a)       in_be32(a)
+#define sec_out32(a, v)   out_be32(a, v)
+#define sec_in16(a)       in_be16(a)
+#define sec_clrbits32     clrbits_be32
+#define sec_setbits32     setbits_be32
+#define snvs_in32(a)       in_be32(a)
+#define snvs_out32(a, v)   out_be32(a, v)
+#define snvs_in16(a)       in_be16(a)
+#define snvs_clrbits32     clrbits_be32
+#define snvs_setbits32     setbits_be32
+#else
+#error Neither CONFIG_SYS_FSL_SEC_LE nor CONFIG_SYS_FSL_SEC_BE is defined
+#endif
+
+/* Security Engine Block (MS = Most Sig., LS = Least Sig.) */
+#if CONFIG_SYS_FSL_SEC_COMPAT >= 4
+/* RNG4 TRNG test registers */
+struct rng4tst {
+#define RTMCTL_PRGM 0x00010000	/* 1 -> program mode, 0 -> run mode */
+	u32 rtmctl;		/* misc. control register */
+	u32 rtscmisc;		/* statistical check misc. register */
+	u32 rtpkrrng;		/* poker range register */
+#define RTSDCTL_ENT_DLY_MIN	1200
+#define RTSDCTL_ENT_DLY_MAX	12800
+	union {
+		u32 rtpkrmax;	/* PRGM=1: poker max. limit register */
+		u32 rtpkrsq;	/* PRGM=0: poker square calc. result register */
+	};
+#define RTSDCTL_ENT_DLY_SHIFT 16
+#define RTSDCTL_ENT_DLY_MASK (0xffff << RTSDCTL_ENT_DLY_SHIFT)
+	u32 rtsdctl;		/* seed control register */
+	union {
+		u32 rtsblim;	/* PRGM=1: sparse bit limit register */
+		u32 rttotsam;	/* PRGM=0: total samples register */
+	};
+	u32 rtfreqmin;		/* frequency count min. limit register */
+	union {
+		u32 rtfreqmax;	/* PRGM=1: freq. count max. limit register */
+		u32 rtfreqcnt;	/* PRGM=0: freq. count register */
+	};
+	u32 rsvd1[40];
+#define RNG_STATE0_HANDLE_INSTANTIATED	0x00000001
+	u32 rdsta;		/*RNG DRNG Status Register*/
+	u32 rsvd2[15];
+};
+
+typedef struct ccsr_sec {
+	u32	res0;
+	u32	mcfgr;		/* Master CFG Register */
+	u8	res1[0x4];
+	u32	scfgr;
+	struct {
+		u32	ms;	/* Job Ring LIODN Register, MS */
+		u32	ls;	/* Job Ring LIODN Register, LS */
+	} jrliodnr[4];
+	u8	res2[0x2c];
+	u32	jrstartr;	/* Job Ring Start Register */
+	struct {
+		u32	ms;	/* RTIC LIODN Register, MS */
+		u32	ls;	/* RTIC LIODN Register, LS */
+	} rticliodnr[4];
+	u8	res3[0x1c];
+	u32	decorr;		/* DECO Request Register */
+	struct {
+		u32	ms;	/* DECO LIODN Register, MS */
+		u32	ls;	/* DECO LIODN Register, LS */
+	} decoliodnr[8];
+	u8	res4[0x40];
+	u32	dar;		/* DECO Avail Register */
+	u32	drr;		/* DECO Reset Register */
+	u8	res5[0x4d8];
+	struct rng4tst rng;	/* RNG Registers */
+	u8	res6[0x8a0];
+	u32	crnr_ms;	/* CHA Revision Number Register, MS */
+	u32	crnr_ls;	/* CHA Revision Number Register, LS */
+	u32	ctpr_ms;	/* Compile Time Parameters Register, MS */
+	u32	ctpr_ls;	/* Compile Time Parameters Register, LS */
+	u8	res7[0x10];
+	u32	far_ms;		/* Fault Address Register, MS */
+	u32	far_ls;		/* Fault Address Register, LS */
+	u32	falr;		/* Fault Address LIODN Register */
+	u32	fadr;		/* Fault Address Detail Register */
+	u8	res8[0x4];
+	u32	csta;		/* CAAM Status Register */
+	u8	res9[0x8];
+	u32	rvid;		/* Run Time Integrity Checking Version ID Reg.*/
+	u32	ccbvid;		/* CHA Cluster Block Version ID Register */
+	u32	chavid_ms;	/* CHA Version ID Register, MS */
+	u32	chavid_ls;	/* CHA Version ID Register, LS */
+	u32	chanum_ms;	/* CHA Number Register, MS */
+	u32	chanum_ls;	/* CHA Number Register, LS */
+	u32	secvid_ms;	/* SEC Version ID Register, MS */
+	u32	secvid_ls;	/* SEC Version ID Register, LS */
+	u8	res10[0x6020];
+	u32	qilcr_ms;	/* Queue Interface LIODN CFG Register, MS */
+	u32	qilcr_ls;	/* Queue Interface LIODN CFG Register, LS */
+	u8	res11[0x8fd8];
+} ccsr_sec_t;
+
+#define SEC_CTPR_MS_AXI_LIODN		0x08000000
+#define SEC_CTPR_MS_QI			0x02000000
+#define SEC_CTPR_MS_VIRT_EN_INCL	0x00000001
+#define SEC_CTPR_MS_VIRT_EN_POR		0x00000002
+#define SEC_RVID_MA			0x0f000000
+#define SEC_CHANUM_MS_JRNUM_MASK	0xf0000000
+#define SEC_CHANUM_MS_JRNUM_SHIFT	28
+#define SEC_CHANUM_MS_DECONUM_MASK	0x0f000000
+#define SEC_CHANUM_MS_DECONUM_SHIFT	24
+#define SEC_SECVID_MS_IPID_MASK	0xffff0000
+#define SEC_SECVID_MS_IPID_SHIFT	16
+#define SEC_SECVID_MS_MAJ_REV_MASK	0x0000ff00
+#define SEC_SECVID_MS_MAJ_REV_SHIFT	8
+#define SEC_CCBVID_ERA_MASK		0xff000000
+#define SEC_CCBVID_ERA_SHIFT		24
+#define SEC_SCFGR_RDBENABLE		0x00000400
+#define SEC_SCFGR_VIRT_EN		0x00008000
+#define SEC_CHAVID_LS_RNG_SHIFT		16
+#define SEC_CHAVID_RNG_LS_MASK		0x000f0000
+
+#define CONFIG_JRSTARTR_JR0		0x00000001
+#endif
+
+
+struct jr_regs {
+#ifdef CONFIG_SYS_FSL_SEC_LE
+	u32 irba_l;
+	u32 irba_h;
+#else
+	u32 irba_h;
+	u32 irba_l;
+#endif
+	u32 rsvd1;
+	u32 irs;
+	u32 rsvd2;
+	u32 irsa;
+	u32 rsvd3;
+	u32 irja;
+#ifdef CONFIG_SYS_FSL_SEC_LE
+	u32 orba_l;
+	u32 orba_h;
+#else
+	u32 orba_h;
+	u32 orba_l;
+#endif
+	u32 rsvd4;
+	u32 ors;
+	u32 rsvd5;
+	u32 orjr;
+	u32 rsvd6;
+	u32 orsf;
+	u32 rsvd7;
+	u32 jrsta;
+	u32 rsvd8;
+	u32 jrint;
+	u32 jrcfg0;
+	u32 jrcfg1;
+	u32 rsvd9;
+	u32 irri;
+	u32 rsvd10;
+	u32 orwi;
+	u32 rsvd11;
+	u32 jrcr;
+};
+
+
+struct ccsr_snvs_regs {
+	u8 reserved0[0x04];
+	u32 hp_com;	/* 0x04 SNVS_HP Command Register */
+	u8 reserved2[0x0c];
+	u32 hp_stat;	/* 0x08 SNVS_HP Status Register */
+};
+
+#define HPCOMR_SW_SV 0x100		/* Security Violation bit */
+#define HPCOMR_SW_FSV 0x200		/* Fatal Security Violation bit */
+#define HPCOMR_SSM_ST 0x1		/* SSM_ST field in SNVS command reg */
+#define HPSR_SSM_ST_CHECK	0x900	/* SNVS is in check state */
+#define HPSR_SSM_ST_NON_SECURE	0xb00	/* SNVS is in non secure state */
+#define HPSR_SSM_ST_TRUST	0xd00	/* SNVS is in trusted state */
+#define HPSR_SSM_ST_SOFT_FAIL	0x300	/* SNVS is in soft fail state */
+#define HPSR_SSM_ST_MASK	0xf00	/* Mask for SSM_ST field */
+
+/*
+ * SNVS read. This specifies the possible reads
+ * from the SNVS
+ */
+enum {
+	SNVS_SSM_ST,
+	SNVS_SW_FSV,
+	SNVS_SW_SV,
+};
+
+int change_sec_mon_state(uint32_t initial_state, uint32_t final_state);
+
+#endif /* __FSL_SEC_H */
--- u-boot-2014.07/include/jr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/jr.h	2022-05-09 14:06:24.053116203 -0700
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __JR_H
+#define __JR_H
+
+#include <linux/compiler.h>
+
+#define JR_SIZE 4
+/* Timeout currently defined as 90 sec */
+#define CONFIG_SEC_DEQ_TIMEOUT	90000000U
+
+#define DEFAULT_JR_ID		0
+#define DEFAULT_JR_LIODN	0
+#define DEFAULT_IRQ		0	/* Interrupts not to be configured */
+
+#define MCFGR_SWRST       ((uint32_t)(1)<<31) /* Software Reset */
+#define MCFGR_DMA_RST     ((uint32_t)(1)<<28) /* DMA Reset */
+#define MCFGR_PS_SHIFT          16
+#define JR_INTMASK	  0x00000001
+#define JRCR_RESET                  0x01
+#define JRINT_ERR_HALT_INPROGRESS   0x4
+#define JRINT_ERR_HALT_MASK         0xc
+#define JRNSLIODN_SHIFT		16
+#define JRNSLIODN_MASK		0x0fff0000
+#define JRSLIODN_SHIFT		0
+#define JRSLIODN_MASK		0x00000fff
+
+#define JQ_DEQ_ERR		-1
+#define JQ_DEQ_TO_ERR		-2
+#define JQ_ENQ_ERR		-3
+
+struct op_ring {
+	dma_addr_t desc;
+	uint32_t status;
+} __packed;
+
+struct jr_info {
+	void (*callback)(dma_addr_t desc, uint32_t status, void *arg);
+	dma_addr_t desc_phys_addr;
+	uint32_t desc_addr;
+	uint32_t desc_len;
+	uint32_t op_done;
+	void *arg;
+};
+
+struct jobring {
+	int jq_id;
+	int irq;
+	int liodn;
+	/* Head is the index where software would enq the descriptor in
+	 * the i/p ring
+	 */
+	int head;
+	/* Tail index would be used by s/w ehile enqueuing to determine if
+	 * there is any space left in the s/w maintained i/p rings
+	 */
+	/* Also in case of deq tail will be incremented only in case of
+	 * in-order job completion
+	 */
+	int tail;
+	/* Read index of the output ring. It may not match with tail in case
+	 * of out of order completetion
+	 */
+	int read_idx;
+	/* Write index to input ring. Would be always equal to head */
+	int write_idx;
+	/* Size of the rings. */
+	int size;
+	/* The ip and output rings have to be accessed by SEC. So the
+	 * pointers will ahve to point to the housekeeping region provided
+	 * by SEC
+	 */
+	/*Circular  Ring of i/p descriptors */
+	dma_addr_t *input_ring;
+	/* Circular Ring of o/p descriptors */
+	/* Circula Ring containing info regarding descriptors in i/p
+	 * and o/p ring
+	 */
+	/* This ring can be on the stack */
+	struct jr_info info[JR_SIZE];
+	struct op_ring *output_ring;
+};
+
+struct result {
+	int done;
+	int err;
+	uint32_t status;
+	char outstr[256];
+};
+
+int sec_init(struct jobring *jr);
+u8 get_rng_vid(void);
+int rng_init(struct jobring *jr);
+int jr_enqueue(struct jobring *jr, uint32_t *desc_addr,
+		void (*callback)(uint32_t desc, uint32_t status, void *arg),
+		void *arg);
+int jr_dequeue(struct jobring *jr);
+int caam_jr_strstatus(char *outstr, u32 status);
+int jr_reset(struct jobring *jr);
+
+#endif
--- u-boot-2014.07/include/cortina.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/cortina.h	2022-05-09 14:06:24.037116850 -0700
@@ -0,0 +1,75 @@
+/*
+ * Cortina PHY drivers
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ *
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ */
+
+#ifndef _CORTINA_H_
+#define _CORTINA_H_
+
+#define VILLA_GLOBAL_CHIP_ID_LSB     0x000
+#define VILLA_GLOBAL_CHIP_ID_MSB     0x001
+#define VILLA_GLOBAL_BIST_CONTROL    0x002
+#define VILLA_GLOBAL_BIST_STATUS     0x003
+#define VILLA_GLOBAL_LINE_SOFT_RESET 0x007
+#define VILLA_GLOBAL_HOST_SOFT_RESET 0x008
+#define VILLA_GLOBAL_DWNLD_CHECKSUM_CTRL 0x00A
+#define VILLA_GLOBAL_DWNLD_CHECKSUM_STATUS 0x00B
+#define VILLA_GLOBAL_MSEQCLKCTRL 0x00E
+#define VILLA_MSEQ_OPTIONS       0x1D0
+#define VILLA_MSEQ_PC		 0x1D3
+#define VILLA_MSEQ_BANKSELECT    0x1DF
+#define VILLA_DSP_SDS_DSP_COEF_DFE0_SELECT     0x2DB
+#define VILLA_DSP_SDS_SERDES_SRX_DFE0_SELECT   0x36E
+#define VILLA_LINE_SDS_COMMON_SRX0_RX_LOOP_FILTER   0x403
+#define VILLA_LINE_SDS_COMMON_SRX0_RX_CPA	0x404
+#define VILLA_LINE_SDS_COMMON_SRX0_RX_CPB	0x405
+#define VILLA_DSP_SDS_SERDES_SRX_FFE_DELAY_CTRL	0x369
+#define VILLA_MSEQ_ENABLE_MSB	0x194
+#define VILLA_MSEQ_SPARE21_LSB	0x226
+#define VILLA_MSEQ_RESET_COUNT_LSB  0x1E0
+#define VILLA_MSEQ_SPARE12_MSB  0x215
+#define VILLA_MSEQ_SPARE2_LSB   0x200
+#define VILLA_MSEQ_SPARE7_LSB   0x20A
+#define VILLA_MSEQ_SPARE9_LSB   0x20E
+#define VILLA_MSEQ_SPARE3_LSB   0x202
+#define VILLA_MSEQ_SPARE3_MSB   0x203
+#define VILLA_MSEQ_SPARE8_LSB   0x20C
+#define VILLA_MSEQ_SPARE8_MSB   0x20D
+#define VILLA_MSEQ_COEF8_FFE0_LSB 0x1E2
+#define VILLA_MSEQ_COEF8_FFE1_LSB 0x1E4
+#define VILLA_MSEQ_COEF8_FFE2_LSB 0x1E6
+#define VILLA_MSEQ_COEF8_FFE3_LSB 0x1E8
+#define VILLA_MSEQ_COEF8_FFE4_LSB 0x1EA
+#define VILLA_MSEQ_COEF8_FFE5_LSB 0x1EC
+#define VILLA_MSEQ_COEF8_DFE0_LSB 0x1F0
+#define VILLA_MSEQ_COEF8_DFE0N_LSB 0x1EE
+#define VILLA_MSEQ_COEF8_DFE1_LSB  0x1F2
+#define VILLA_DSP_SDS_DSP_COEF_LARGE_LEAK 0x2E2
+#define VILLA_DSP_SDS_SERDES_SRX_DAC_ENABLEB_LSB 0x360
+#define VILLA_MSEQ_POWER_DOWN_LSB  0x198
+#define VILLA_MSEQ_POWER_DOWN_MSB  0x199
+#define VILLA_MSEQ_CAL_RX_SLICER   0x1B8
+#define VILLA_DSP_SDS_SERDES_SRX_DAC_BIAS_SELECT1_MSB 0x365
+#define VILLA_MSEQ_COEF_INIT_SEL  0x1AE
+#define VILLA_DSP_SDS_DSP_PRECODEDINITFFE21 0x26A
+#define VILLA_MSEQ_SERDES_PARAM_LSB 0x195
+#define VILLA_MSEQ_SPARE25_LSB	0x22E
+#define VILLA_MSEQ_SPARE23_LSB	0x22A
+#define VILLA_MSEQ_CAL_RX_DFE_EQ 0x1BA
+#define VILLA_GLOBAL_VILLA2_COMPATIBLE      0x030
+#define VILLA_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLA  0x812
+#define VILLA_HOST_SDS_COMMON_STX0_TX_OUTPUT_CTRLB  0x813
+#define VILLA_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLA 0x427
+#define VILLA_LINE_SDS_COMMON_STX0_TX_OUTPUT_CTRLB 0x428
+
+#define mseq_edc_bist_done (0x1<<0)
+#define mseq_edc_bist_fail (0x1<<8)
+
+struct cortina_reg_config {
+	unsigned short reg_addr;
+	unsigned short reg_value;
+};
+#endif
--- u-boot-2014.07/include/fsl_validate.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_validate.h	2022-05-09 14:06:24.049116365 -0700
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _FSL_VALIDATE_H_
+#define _FSL_VALIDATE_H_
+
+#include <fsl_secboot_types.h>
+#include <fsl_sec.h>
+#include <command.h>
+
+extern struct jobring jr;
+
+#ifdef CONFIG_KEY_REVOCATION
+/* Srk table and key revocation check */
+#define SRK_FLAG	0x01
+#define UNREVOCABLE_KEY	4
+#define ALIGN_REVOC_KEY 3
+#define MAX_KEY_ENTRIES 4
+#endif
+
+/* Barker code size in bytes */
+#define ESBC_BARKER_LEN	4	/* barker code length in ESBC uboot client */
+				/* header */
+
+/* No-error return values */
+#define ESBC_VALID_HDR	0	/* header is valid */
+
+/* Maximum number of SG entries allowed */
+#define MAX_SG_ENTRIES	8
+
+/*
+ * ESBC uboot client header structure.
+ * The struct contain the following fields
+ * barker code
+ * public key offset
+ * pub key length
+ * signature offset
+ * length of the signature
+ * ptr to SG table
+ * no of entries in SG table
+ * esbc ptr
+ * size of esbc
+ * esbc entry point
+ * Scatter gather flag
+ * UID flag
+ * FSL UID
+ * OEM UID
+ * Here, pub key is modulus concatenated with exponent
+ * of equal length
+ */
+struct fsl_secboot_img_hdr {
+	u8 barker[ESBC_BARKER_LEN];	/* barker code */
+	union {
+		u32 pkey;		/* public key offset */
+#ifdef CONFIG_KEY_REVOCATION
+		u32 srk_tbl_off;
+#endif
+	};
+
+	union {
+		u32 key_len;		/* pub key length in bytes */
+#ifdef CONFIG_KEY_REVOCATION
+		struct {
+			u32 srk_table_flag:8;
+			u32 srk_sel:8;
+			u32 num_srk:16;
+		} len_kr;
+#endif
+	};
+
+	u32 psign;		/* signature offset */
+	u32 sign_len;		/* length of the signature in bytes */
+	union {
+		struct fsl_secboot_sg_table *psgtable;	/* ptr to SG table */
+		u8 *pimg;	/* ptr to ESBC client image */
+	};
+	union {
+		u32 sg_entries;	/* no of entries in SG table */
+		u32 img_size;	/* ESBC client image size in bytes */
+	};
+	ulong img_start;		/* ESBC client entry point */
+	u32 sg_flag;		/* Scatter gather flag */
+	u32 uid_flag;
+	u32 fsl_uid_0;
+	u32 oem_uid_0;
+	u32 reserved1[2];
+	u32 fsl_uid_1;
+	u32 oem_uid_1;
+	u32 reserved2[2];
+	u32 ie_flag;
+	u32 ie_key_sel;
+};
+
+#if defined(CONFIG_FSL_ISBC_KEY_EXT)
+struct ie_key_table {
+	u32 key_len;
+	u8 pkey[2 * KEY_SIZE_BYTES];
+};
+
+struct ie_key_info {
+	uint32_t key_revok;
+	uint32_t num_keys;
+	struct ie_key_table ie_key_tbl[32];
+};
+#endif
+
+#ifdef CONFIG_KEY_REVOCATION
+struct srk_table {
+	u32 key_len;
+	u8 pkey[2 * KEY_SIZE_BYTES];
+};
+#endif
+
+/*
+ * SG table.
+ */
+#if defined(CONFIG_FSL_TRUST_ARCH_v1) && defined(CONFIG_FSL_CORENET)
+/*
+ * This struct contains the following fields
+ * length of the segment
+ * source address
+ */
+struct fsl_secboot_sg_table {
+	u32 len;		/* length of the segment in bytes */
+	ulong src_addr;		/* ptr to the data segment */
+};
+#else
+/*
+ * This struct contains the following fields
+ * length of the segment
+ * Destination Target ID
+ * source address
+ * destination address
+ */
+struct fsl_secboot_sg_table {
+	u32 len;
+	u32 trgt_id;
+	ulong src_addr;
+	ulong dst_addr;
+};
+#endif
+
+/*
+ * ESBC private structure.
+ * Private structure used by ESBC to store following fields
+ * ESBC client key
+ * ESBC client key hash
+ * ESBC client Signature
+ * Encoded hash recovered from signature
+ * Encoded hash of ESBC client header plus ESBC client image
+ */
+struct fsl_secboot_img_priv {
+	uint32_t hdr_location;
+	ulong ie_addr;
+	u32 key_len;
+	struct fsl_secboot_img_hdr hdr;
+
+	u8 img_key[2 * KEY_SIZE_BYTES];	/* ESBC client key */
+	u8 img_key_hash[32];	/* ESBC client key hash */
+
+#ifdef CONFIG_KEY_REVOCATION
+	struct srk_table srk_tbl[MAX_KEY_ENTRIES];
+#endif
+	u8 img_sign[KEY_SIZE_BYTES];		/* ESBC client signature */
+
+	u8 img_encoded_hash[KEY_SIZE_BYTES];	/* EM wrt RSA PKCSv1.5  */
+						/* Includes hash recovered after
+						 * signature verification
+						 */
+
+	u8 img_encoded_hash_second[KEY_SIZE_BYTES];/* EM' wrt RSA PKCSv1.5 */
+						/* Includes hash of
+						 * ESBC client header plus
+						 * ESBC client image
+						 */
+
+	struct fsl_secboot_sg_table sgtbl[MAX_SG_ENTRIES];	/* SG table */
+	u32 ehdrloc;		/* ESBC client location */
+};
+
+int fsl_secboot_validate(cmd_tbl_t *cmdtp, int flag, int argc,
+		char * const argv[]);
+int fsl_secboot_blob_encap(cmd_tbl_t *cmdtp, int flag, int argc,
+	char * const argv[]);
+int fsl_secboot_blob_decap(cmd_tbl_t *cmdtp, int flag, int argc,
+	char * const argv[]);
+
+#endif
--- u-boot-2014.07/include/desc_constr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/desc_constr.h	2022-05-09 14:06:24.037116850 -0700
@@ -0,0 +1,200 @@
+/*
+ * caam descriptor construction helper functions
+ *
+ * Copyright 2008-2011, 2012 Freescale Semiconductor, Inc.
+ */
+
+#include "desc.h"
+
+#define IMMEDIATE (1 << 23)
+#define CAAM_CMD_SZ sizeof(u32)
+#define CAAM_PTR_SZ sizeof(dma_addr_t)
+#define CAAM_DESC_BYTES_MAX (CAAM_CMD_SZ * 64)
+
+#define PRINT_POS
+
+#define DISABLE_AUTO_INFO_FIFO (IMMEDIATE | LDST_CLASS_DECO | \
+				LDST_SRCDST_WORD_DECOCTRL | \
+				(LDOFF_DISABLE_AUTO_NFIFO << LDST_OFFSET_SHIFT))
+#define ENABLE_AUTO_INFO_FIFO (IMMEDIATE | LDST_CLASS_DECO | \
+			       LDST_SRCDST_WORD_DECOCTRL | \
+			       (LDOFF_ENABLE_AUTO_NFIFO << LDST_OFFSET_SHIFT))
+
+static inline int desc_len(u32 *desc)
+{
+	return *desc & HDR_DESCLEN_MASK;
+}
+
+static inline int desc_bytes(void *desc)
+{
+	return desc_len(desc) * CAAM_CMD_SZ;
+}
+
+static inline u32 *desc_end(u32 *desc)
+{
+	return desc + desc_len(desc);
+}
+
+static inline void *sh_desc_pdb(u32 *desc)
+{
+	return desc + 1;
+}
+
+static inline void init_desc(u32 *desc, u32 options)
+{
+	*desc = options | HDR_ONE | 1;
+}
+
+static inline void init_sh_desc(u32 *desc, u32 options)
+{
+	PRINT_POS;
+	init_desc(desc, CMD_SHARED_DESC_HDR | options);
+}
+
+static inline void init_sh_desc_pdb(u32 *desc, u32 options, size_t pdb_bytes)
+{
+	u32 pdb_len = pdb_bytes / CAAM_CMD_SZ + 1;
+
+	init_sh_desc(desc, ((pdb_len << HDR_START_IDX_SHIFT) + pdb_len) |
+		     options);
+}
+
+static inline void init_job_desc(u32 *desc, u32 options)
+{
+	init_desc(desc, CMD_DESC_HDR | options);
+}
+
+static inline void append_ptr(u32 *desc, dma_addr_t ptr)
+{
+	dma_addr_t *offset = (dma_addr_t *)desc_end(desc);
+
+	*offset = ptr;
+
+	(*desc) += CAAM_PTR_SZ / CAAM_CMD_SZ;
+}
+
+static inline void init_job_desc_shared(u32 *desc, dma_addr_t ptr, int len,
+					u32 options)
+{
+	PRINT_POS;
+	init_job_desc(desc, HDR_SHARED | options |
+		      (len << HDR_START_IDX_SHIFT));
+	append_ptr(desc, ptr);
+}
+
+static inline void append_data(u32 *desc, void *data, int len)
+{
+	u32 *offset = desc_end(desc);
+
+	if (len) /* avoid sparse warning: memcpy with byte count of 0 */
+		memcpy(offset, data, len);
+
+	(*desc) += (len + CAAM_CMD_SZ - 1) / CAAM_CMD_SZ;
+}
+
+static inline void append_cmd(u32 *desc, u32 command)
+{
+	u32 *cmd = desc_end(desc);
+
+	*cmd = command;
+
+	(*desc)++;
+}
+
+static inline void append_cmd_ptr(u32 *desc, dma_addr_t ptr, int len,
+				  u32 command)
+{
+	append_cmd(desc, command | len);
+	append_ptr(desc, ptr);
+}
+
+static inline void append_cmd_data(u32 *desc, void *data, int len,
+				   u32 command)
+{
+	append_cmd(desc, command | IMMEDIATE | len);
+	append_data(desc, data, len);
+}
+
+static inline u32 *append_jump(u32 *desc, u32 options)
+{
+	u32 *cmd = desc_end(desc);
+
+	PRINT_POS;
+	append_cmd(desc, CMD_JUMP | options);
+
+	return cmd;
+}
+
+static inline void set_jump_tgt_here(u32 *desc, u32 *jump_cmd)
+{
+	*jump_cmd = *jump_cmd | (desc_len(desc) - (jump_cmd - desc));
+}
+
+#define APPEND_CMD(cmd, op) \
+static inline void append_##cmd(u32 *desc, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | options); \
+}
+APPEND_CMD(operation, OPERATION)
+APPEND_CMD(move, MOVE)
+
+#define APPEND_CMD_LEN(cmd, op) \
+static inline void append_##cmd(u32 *desc, unsigned int len, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | len | options); \
+}
+APPEND_CMD_LEN(seq_store, SEQ_STORE)
+APPEND_CMD_LEN(seq_fifo_load, SEQ_FIFO_LOAD)
+APPEND_CMD_LEN(seq_fifo_store, SEQ_FIFO_STORE)
+
+#define APPEND_CMD_PTR(cmd, op) \
+static inline void append_##cmd(u32 *desc, dma_addr_t ptr, unsigned int len, \
+				u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd_ptr(desc, ptr, len, CMD_##op | options); \
+}
+APPEND_CMD_PTR(key, KEY)
+APPEND_CMD_PTR(seq_in_ptr, SEQ_IN_PTR)
+APPEND_CMD_PTR(seq_out_ptr, SEQ_OUT_PTR)
+APPEND_CMD_PTR(load, LOAD)
+APPEND_CMD_PTR(store, STORE)
+APPEND_CMD_PTR(fifo_load, FIFO_LOAD)
+APPEND_CMD_PTR(fifo_store, FIFO_STORE)
+
+#define APPEND_CMD_PTR_TO_IMM(cmd, op) \
+static inline void append_##cmd##_as_imm(u32 *desc, void *data, \
+					 unsigned int len, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd_data(desc, data, len, CMD_##op | options); \
+}
+APPEND_CMD_PTR_TO_IMM(load, LOAD);
+APPEND_CMD_PTR_TO_IMM(fifo_load, FIFO_LOAD);
+
+/*
+ * 2nd variant for commands whose specified immediate length differs
+ * from length of immediate data provided, e.g., split keys
+ */
+#define APPEND_CMD_PTR_TO_IMM2(cmd, op) \
+static inline void append_##cmd##_as_imm(u32 *desc, void *data, \
+					 unsigned int data_len, \
+					 unsigned int len, u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | IMMEDIATE | len | options); \
+	append_data(desc, data, data_len); \
+}
+APPEND_CMD_PTR_TO_IMM2(key, KEY);
+
+#define APPEND_CMD_RAW_IMM(cmd, op, type) \
+static inline void append_##cmd##_imm_##type(u32 *desc, type immediate, \
+					     u32 options) \
+{ \
+	PRINT_POS; \
+	append_cmd(desc, CMD_##op | IMMEDIATE | options | sizeof(type)); \
+	append_cmd(desc, immediate); \
+}
+APPEND_CMD_RAW_IMM(load, LOAD, u32);
--- u-boot-2014.07/include/rsa_sec.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/rsa_sec.h	2022-05-09 14:06:24.085114909 -0700
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __RSA_SEC_H
+#define __RSA_SEC_H
+
+#include <common.h>
+#include <jr.h>
+
+struct pk_in_params {
+	uint8_t *e;
+	uint32_t e_siz;
+	uint8_t *n;
+	uint32_t n_siz;
+	uint8_t *a;
+	uint32_t a_siz;
+	uint8_t *b;
+	uint32_t b_siz;
+};
+
+struct rsa_context {
+	struct pk_in_params pkin;
+	uint32_t rsa_desc[64];
+	struct result op;
+};
+
+int rsa_public_verif_sec(unsigned char *sign, uint8_t *to, uint8_t *rsa_pub_key,
+			int klen, struct rsa_context *ctx, struct jobring *jr);
+
+#endif
--- u-boot-2014.07/include/fsl_secboot_err.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_secboot_err.h	2022-05-09 14:06:24.049116365 -0700
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _FSL_SECBOOT_ERR_H
+#define _FSL_SECBOOT_ERR_H
+
+#define ERROR_ESBC_PAMU_INIT					0x100000
+#define ERROR_ESBC_SEC_RESET					0x200000
+#define ERROR_ESBC_SEC_INIT					0x400000
+#define ERROR_ESBC_SEC_DEQ					0x800000
+#define ERROR_ESBC_SEC_DEQ_TO					0x1000000
+#define ERROR_ESBC_SEC_ENQ					0x2000000
+#define ERROR_ESBC_SEC_JOBQ_STATUS				0x4000000
+#define ERROR_ESBC_CLIENT_CPUID_NO_MATCH			0x1
+#define ERROR_ESBC_CLIENT_HDR_LOC				0x2
+#define ERROR_ESBC_CLIENT_HEADER_BARKER				0x4
+#define ERROR_ESBC_CLIENT_HEADER_KEY_LEN			0x8
+#define ERROR_ESBC_CLIENT_HEADER_SIG_LEN			0x10
+#define ERROR_ESBC_CLIENT_HEADER_KEY_REVOKED			0x11
+#define ERROR_ESBC_CLIENT_HEADER_INVALID_SRK_NUM_ENTRY		0x12
+#define ERROR_ESBC_CLIENT_HEADER_INVALID_KEY_NUM		0x13
+#define ERROR_ESBC_CLIENT_HEADER_INV_SRK_ENTRY_KEYLEN		0x14
+#define ERROR_ESBC_CLIENT_HEADER_IE_KEY_REVOKED			0x15
+#define ERROR_ESBC_CLIENT_HEADER_INVALID_IE_NUM_ENTRY		0x16
+#define ERROR_ESBC_CLIENT_HEADER_INVALID_IE_KEY_NUM		0x17
+#define ERROR_ESBC_CLIENT_HEADER_INV_IE_ENTRY_KEYLEN		0x18
+#define ERROR_IE_TABLE_NOT_FOUND				0x19
+#define ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN	0x20
+#define ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1			0x40
+#define ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2			0x80
+#define ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD			0x100
+#define ERROR_ESBC_CLIENT_HEADER_SG_ESBC_EP			0x200
+#define ERROR_ESBC_CLIENT_HASH_COMPARE_KEY			0x400
+#define ERROR_ESBC_CLIENT_HASH_COMPARE_EM			0x800
+#define ERROR_ESBC_CLIENT_SSM_TRUSTSTS				0x1000
+#define ERROR_ESBC_CLIENT_BAD_ADDRESS				0x2000
+#define ERROR_ESBC_CLIENT_MISC					0x4000
+#define ERROR_ESBC_CLIENT_HEADER_SG_ENTIRES_BAD			0x8000
+#define ERROR_ESBC_CLIENT_HEADER_SG				0x10000
+#define ERROR_ESBC_CLIENT_HEADER_IMG_SIZE			0x20000
+#define ERROR_ESBC_WRONG_CMD					0x40000
+#define ERROR_ESBC_MISSING_BOOTM				0x80000
+#define ERROR_ESBC_CLIENT_MAX					0x0
+
+struct fsl_secboot_errcode {
+	int errcode;
+	const char *name;
+};
+
+static const struct fsl_secboot_errcode fsl_secboot_errcodes[] = {
+	{ ERROR_ESBC_PAMU_INIT,
+		"Error in initializing PAMU"},
+	{ ERROR_ESBC_SEC_RESET,
+		"Error in resetting Job ring of SEC"},
+	{ ERROR_ESBC_SEC_INIT,
+		"Error in initializing SEC"},
+	{ ERROR_ESBC_SEC_ENQ,
+		"Error in enqueue operation by SEC"},
+	{ ERROR_ESBC_SEC_DEQ_TO,
+		"Dequeue operation by SEC is timed out"},
+	{ ERROR_ESBC_SEC_DEQ,
+		"Error in dequeue operation by SEC"},
+	{ ERROR_ESBC_SEC_JOBQ_STATUS,
+		"Error in status of the job submitted to SEC"},
+	{ ERROR_ESBC_CLIENT_CPUID_NO_MATCH,
+		"Current core is not boot core i.e core0" },
+	{ ERROR_ESBC_CLIENT_HDR_LOC,
+		"Header address not in allowed memory range" },
+	{ ERROR_ESBC_CLIENT_HEADER_BARKER,
+		"Wrong barker code in header" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_LEN,
+		"Wrong public key length in header" },
+	{ ERROR_ESBC_CLIENT_HEADER_SIG_LEN,
+		"Wrong signature length in header" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_LEN_NOT_TWICE_SIG_LEN,
+		"Public key length not twice of signature length" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_MOD_1,
+		"Public key Modulus most significant bit not set" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_MOD_2,
+		"Public key Modulus in header not odd" },
+	{ ERROR_ESBC_CLIENT_HEADER_SIG_KEY_MOD,
+		"Signature not less than modulus" },
+	{ ERROR_ESBC_CLIENT_HEADER_SG_ESBC_EP,
+		"Entry point not in allowed space or one of the SG entries" },
+	{ ERROR_ESBC_CLIENT_HASH_COMPARE_KEY,
+		"Public key hash comparison failed" },
+	{ ERROR_ESBC_CLIENT_HASH_COMPARE_EM,
+		"RSA verification failed" },
+	{ ERROR_ESBC_CLIENT_SSM_TRUSTSTS,
+		"SNVS not in TRUSTED state" },
+	{ ERROR_ESBC_CLIENT_BAD_ADDRESS,
+		"Bad address error" },
+	{ ERROR_ESBC_CLIENT_MISC,
+		"Miscallaneous error" },
+	{ ERROR_ESBC_CLIENT_HEADER_SG,
+		"No SG support"  },
+	{ ERROR_ESBC_WRONG_CMD,
+		"Unknown cmd/Wrong arguments. Core in infinite loop"},
+	{ ERROR_ESBC_MISSING_BOOTM,
+		"Bootm command missing from bootscript" },
+	{ ERROR_ESBC_CLIENT_HEADER_KEY_REVOKED,
+		"Selected key is revoked" },
+	{ ERROR_ESBC_CLIENT_HEADER_INVALID_SRK_NUM_ENTRY,
+		"Wrong key entry" },
+	{ ERROR_ESBC_CLIENT_HEADER_INVALID_KEY_NUM,
+		"Wrong key is selected" },
+	{ ERROR_ESBC_CLIENT_HEADER_INV_SRK_ENTRY_KEYLEN,
+		"Wrong srk public key len in header" },
+	{ ERROR_ESBC_CLIENT_HEADER_IE_KEY_REVOKED,
+		"Selected IE key is revoked" },
+	{ ERROR_ESBC_CLIENT_HEADER_INVALID_IE_NUM_ENTRY,
+		"Wrong key entry in IE Table" },
+	{ ERROR_ESBC_CLIENT_HEADER_INVALID_IE_KEY_NUM,
+		"Wrong IE key is selected" },
+	{ ERROR_ESBC_CLIENT_HEADER_INV_IE_ENTRY_KEYLEN,
+		"Wrong IE public key len in header" },
+	{ ERROR_IE_TABLE_NOT_FOUND,
+		"Information about IE Table missing" },
+	{ ERROR_ESBC_CLIENT_MAX, "NULL" }
+};
+
+void fsl_secboot_handle_error(int error);
+#endif
--- u-boot-2014.07/include/config_fsl_secboot.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/config_fsl_secboot.h	2022-05-09 14:06:23.853124292 -0700
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_FSL_SECBOOT_H
+#define __CONFIG_FSL_SECBOOT_H
+
+#ifdef CONFIG_SECURE_BOOT
+
+#define CONFIG_CMD_ESBC_VALIDATE
+
+/*
+ * Control should not reach back to uboot after validation of images
+ * for secure boot flow and therefore bootscript should have
+ * the bootm command. If control reaches back to uboot anyhow
+ * after validating images, core should just spin.
+ */
+#ifdef CONFIG_BOOTSCRIPT_KEY_HASH
+#define CONFIG_SECBOOT \
+	"setenv bs_hdraddr " __stringify(CONFIG_BOOTSCRIPT_HDR_ADDR)";" \
+	"setenv bootargs \'root=/dev/ram rw console=ttyS0,115200 "	\
+	"ramdisk_size=600000\';"	\
+	"esbc_validate $bs_hdraddr " \
+	  __stringify(CONFIG_BOOTSCRIPT_KEY_HASH)";" \
+	"source $img_addr;"					\
+	"esbc_halt\0"
+#else
+#define CONFIG_SECBOOT \
+	"setenv bs_hdraddr " __stringify(CONFIG_BOOTSCRIPT_HDR_ADDR)";"	 \
+	"setenv bootargs \'root=/dev/ram rw console=ttyS0,115200 "	\
+	"ramdisk_size=600000\';"	\
+	"esbc_validate $bs_hdraddr;"		\
+	"source $img_addr;"				\
+	"esbc_halt\0"
+#endif
+
+/* For secure boot flow, default environment used will be used */
+#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_RAMBOOT_SPIFLASH)
+#undef CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined(CONFIG_RAMBOOT_NAND)
+#undef CONFIG_ENV_IS_IN_NAND
+#elif defined(CONFIG_RAMBOOT_SDCARD)
+#undef CONFIG_ENV_IS_IN_MMC
+#endif
+#else /*CONFIG_SYS_RAMBOOT*/
+#undef CONFIG_ENV_IS_IN_FLASH
+#endif
+
+#define CONFIG_ENV_IS_NOWHERE
+
+/*
+ * We don't want boot delay for secure boot flow
+ * before autoboot starts
+ */
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY	0
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND		CONFIG_SECBOOT
+
+/*
+ * CONFIG_ZERO_BOOTDELAY_CHECK should not be defined for
+ * secure boot flow as defining this would enable a user to
+ * reach uboot prompt by pressing some key before start of
+ * autoboot
+ */
+#undef CONFIG_ZERO_BOOTDELAY_CHECK
+
+#endif
+#endif
--- u-boot-2014.07/include/fsl_sleep.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_sleep.h	2022-05-09 14:06:24.049116365 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __DEEP_SLEEP_H
+#define __DEEP_SLEEP_H
+
+/*
+ * Functions prototype for sleep.
+ * Each platform that supports deep sleep needs to
+ * implement them on their own.
+ */
+
+/* determine if it is a wakeup from deep sleep */
+bool is_warm_boot(void);
+
+/* board specific memory setup, like CKE isolation */
+void fsl_dp_mem_setup(void);
+
+/* clean up everything and jump to kernel */
+int fsl_dp_resume(void);
+
+/*
+ * When wakeup from deep sleep, the first 128 bytes space
+ * will be used to do DDR training which corrupts the data
+ * in there. This function will restore them.
+ */
+void fsl_dp_ddr_restore(void);
+
+#endif
--- u-boot-2014.07/include/fsl_secboot_types.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_secboot_types.h	2022-05-09 14:06:24.049116365 -0700
@@ -0,0 +1,19 @@
+/*
+ * Portions Copyrighted by Freescale Semiconductor, Inc., 2010-2012
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_SECBOOT_TYPES_H_
+#define __FSL_SECBOOT_TYPES_H_
+
+#include <linux/types.h>
+
+#define WORD_SIZE 4
+
+/* Minimum and maximum size of RSA signature length in bits */
+#define KEY_SIZE       4096
+#define KEY_SIZE_BYTES (KEY_SIZE/8)
+#define KEY_SIZE_WORDS (KEY_SIZE_BYTES/(WORD_SIZE))
+
+#endif
--- u-boot-2014.07/include/desc.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/desc.h	2022-05-09 14:06:24.037116850 -0700
@@ -0,0 +1,1609 @@
+/*
+ * CAAM descriptor composition header
+ * Definitions to support CAAM descriptor instruction generation
+ *
+ * Copyright 2008-2011, 2012 Freescale Semiconductor, Inc.
+ */
+
+#ifndef DESC_H
+#define DESC_H
+
+/* Max size of any CAAM descriptor in 32-bit words, inclusive of header */
+#define MAX_CAAM_DESCSIZE       64
+
+/* Block size of any entity covered/uncovered with a KEK/TKEK */
+#define KEK_BLOCKSIZE		16
+
+/*
+ * Supported descriptor command types as they show up
+ * inside a descriptor command word.
+ */
+#define CMD_SHIFT               27
+#define CMD_MASK                0xf8000000
+
+#define CMD_KEY                 (0x00 << CMD_SHIFT)
+#define CMD_SEQ_KEY             (0x01 << CMD_SHIFT)
+#define CMD_LOAD                (0x02 << CMD_SHIFT)
+#define CMD_SEQ_LOAD            (0x03 << CMD_SHIFT)
+#define CMD_FIFO_LOAD           (0x04 << CMD_SHIFT)
+#define CMD_SEQ_FIFO_LOAD       (0x05 << CMD_SHIFT)
+#define CMD_STORE               (0x0a << CMD_SHIFT)
+#define CMD_SEQ_STORE           (0x0b << CMD_SHIFT)
+#define CMD_FIFO_STORE          (0x0c << CMD_SHIFT)
+#define CMD_SEQ_FIFO_STORE      (0x0d << CMD_SHIFT)
+#define CMD_MOVE_LEN            (0x0e << CMD_SHIFT)
+#define CMD_MOVE                (0x0f << CMD_SHIFT)
+#define CMD_OPERATION           (0x10 << CMD_SHIFT)
+#define CMD_SIGNATURE           (0x12 << CMD_SHIFT)
+#define CMD_JUMP                (0x14 << CMD_SHIFT)
+#define CMD_MATH                (0x15 << CMD_SHIFT)
+#define CMD_DESC_HDR            (0x16 << CMD_SHIFT)
+#define CMD_SHARED_DESC_HDR     (0x17 << CMD_SHIFT)
+#define CMD_SEQ_IN_PTR          (0x1e << CMD_SHIFT)
+#define CMD_SEQ_OUT_PTR         (0x1f << CMD_SHIFT)
+
+/* General-purpose class selector for all commands */
+#define CLASS_SHIFT             25
+#define CLASS_MASK              (0x03 << CLASS_SHIFT)
+
+#define CLASS_NONE              (0x00 << CLASS_SHIFT)
+#define CLASS_1                 (0x01 << CLASS_SHIFT)
+#define CLASS_2                 (0x02 << CLASS_SHIFT)
+#define CLASS_BOTH              (0x03 << CLASS_SHIFT)
+
+/*
+ * Descriptor header command constructs
+ * Covers shared, job, and trusted descriptor headers
+ */
+
+/*
+ * Do Not Run - marks a descriptor inexecutable if there was
+ * a preceding error somewhere
+ */
+#define HDR_DNR                 0x01000000
+
+/*
+ * ONE - should always be set. Combination of ONE (always
+ * set) and ZRO (always clear) forms an endianness sanity check
+ */
+#define HDR_ONE                 0x00800000
+#define HDR_ZRO                 0x00008000
+
+/* Start Index or SharedDesc Length */
+#define HDR_START_IDX_MASK      0x3f
+#define HDR_START_IDX_SHIFT     16
+
+/* If shared descriptor header, 6-bit length */
+#define HDR_DESCLEN_SHR_MASK  0x3f
+
+/* If non-shared header, 7-bit length */
+#define HDR_DESCLEN_MASK      0x7f
+
+/* This is a TrustedDesc (if not SharedDesc) */
+#define HDR_TRUSTED             0x00004000
+
+/* Make into TrustedDesc (if not SharedDesc) */
+#define HDR_MAKE_TRUSTED        0x00002000
+
+/* Save context if self-shared (if SharedDesc) */
+#define HDR_SAVECTX             0x00001000
+
+/* Next item points to SharedDesc */
+#define HDR_SHARED              0x00001000
+
+/*
+ * Reverse Execution Order - execute JobDesc first, then
+ * execute SharedDesc (normally SharedDesc goes first).
+ */
+#define HDR_REVERSE             0x00000800
+
+/* Propogate DNR property to SharedDesc */
+#define HDR_PROP_DNR            0x00000800
+
+/* JobDesc/SharedDesc share property */
+#define HDR_SD_SHARE_MASK       0x03
+#define HDR_SD_SHARE_SHIFT      8
+#define HDR_JD_SHARE_MASK       0x07
+#define HDR_JD_SHARE_SHIFT      8
+
+#define HDR_SHARE_NEVER         (0x00 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_WAIT          (0x01 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_SERIAL        (0x02 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_ALWAYS        (0x03 << HDR_SD_SHARE_SHIFT)
+#define HDR_SHARE_DEFER         (0x04 << HDR_SD_SHARE_SHIFT)
+
+/* JobDesc/SharedDesc descriptor length */
+#define HDR_JD_LENGTH_MASK      0x7f
+#define HDR_SD_LENGTH_MASK      0x3f
+
+/*
+ * KEY/SEQ_KEY Command Constructs
+ */
+
+/* Key Destination Class: 01 = Class 1, 02 - Class 2  */
+#define KEY_DEST_CLASS_SHIFT    25  /* use CLASS_1 or CLASS_2 */
+#define KEY_DEST_CLASS_MASK     (0x03 << KEY_DEST_CLASS_SHIFT)
+
+/* Scatter-Gather Table/Variable Length Field */
+#define KEY_SGF                 0x01000000
+#define KEY_VLF                 0x01000000
+
+/* Immediate - Key follows command in the descriptor */
+#define KEY_IMM                 0x00800000
+
+/*
+ * Encrypted - Key is encrypted either with the KEK, or
+ * with the TDKEK if TK is set
+ */
+#define KEY_ENC                 0x00400000
+
+/*
+ * No Write Back - Do not allow key to be FIFO STOREd
+ */
+#define KEY_NWB			0x00200000
+
+/*
+ * Enhanced Encryption of Key
+ */
+#define KEY_EKT			0x00100000
+
+/*
+ * Encrypted with Trusted Key
+ */
+#define KEY_TK			0x00008000
+
+/*
+ * KDEST - Key Destination: 0 - class key register,
+ * 1 - PKHA 'e', 2 - AFHA Sbox, 3 - MDHA split-key
+ */
+#define KEY_DEST_SHIFT          16
+#define KEY_DEST_MASK           (0x03 << KEY_DEST_SHIFT)
+
+#define KEY_DEST_CLASS_REG      (0x00 << KEY_DEST_SHIFT)
+#define KEY_DEST_PKHA_E         (0x01 << KEY_DEST_SHIFT)
+#define KEY_DEST_AFHA_SBOX      (0x02 << KEY_DEST_SHIFT)
+#define KEY_DEST_MDHA_SPLIT     (0x03 << KEY_DEST_SHIFT)
+
+/* Length in bytes */
+#define KEY_LENGTH_MASK         0x000003ff
+
+/*
+ * LOAD/SEQ_LOAD/STORE/SEQ_STORE Command Constructs
+ */
+
+/*
+ * Load/Store Destination: 0 = class independent CCB,
+ * 1 = class 1 CCB, 2 = class 2 CCB, 3 = DECO
+ */
+#define LDST_CLASS_SHIFT        25
+#define LDST_CLASS_MASK         (0x03 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_IND_CCB      (0x00 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_1_CCB        (0x01 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_2_CCB        (0x02 << LDST_CLASS_SHIFT)
+#define LDST_CLASS_DECO         (0x03 << LDST_CLASS_SHIFT)
+
+/* Scatter-Gather Table/Variable Length Field */
+#define LDST_SGF                0x01000000
+#define LDST_VLF		LDST_SGF
+
+/* Immediate - Key follows this command in descriptor    */
+#define LDST_IMM_MASK           1
+#define LDST_IMM_SHIFT          23
+#define LDST_IMM                (LDST_IMM_MASK << LDST_IMM_SHIFT)
+
+/* SRC/DST - Destination for LOAD, Source for STORE   */
+#define LDST_SRCDST_SHIFT       16
+#define LDST_SRCDST_MASK        (0x7f << LDST_SRCDST_SHIFT)
+
+#define LDST_SRCDST_BYTE_CONTEXT	(0x20 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_KEY		(0x40 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_INFIFO		(0x7c << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_BYTE_OUTFIFO	(0x7e << LDST_SRCDST_SHIFT)
+
+#define LDST_SRCDST_WORD_MODE_REG	(0x00 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_KEYSZ_REG	(0x01 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DATASZ_REG	(0x02 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_ICVSZ_REG	(0x03 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CHACTRL	(0x06 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECOCTRL       (0x06 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_IRQCTRL	(0x07 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_PCLOVRD   (0x07 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CLRW		(0x08 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH0     (0x08 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_STAT		(0x09 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH1     (0x09 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH2     (0x0a << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_AAD_SZ    (0x0b << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DECO_MATH3     (0x0b << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_CLASS1_ICV_SZ  (0x0c << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_ALTDS_CLASS1   (0x0f << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_A_SZ      (0x10 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_B_SZ      (0x11 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_N_SZ      (0x12 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_PKHA_E_SZ      (0x13 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_DESCBUF        (0x40 << LDST_SRCDST_SHIFT)
+#define LDST_SRCDST_WORD_INFO_FIFO      (0x7a << LDST_SRCDST_SHIFT)
+
+/* Offset in source/destination                        */
+#define LDST_OFFSET_SHIFT       8
+#define LDST_OFFSET_MASK        (0xff << LDST_OFFSET_SHIFT)
+
+/* LDOFF definitions used when DST = LDST_SRCDST_WORD_DECOCTRL */
+/* These could also be shifted by LDST_OFFSET_SHIFT - this reads better */
+#define LDOFF_CHG_SHARE_SHIFT        0
+#define LDOFF_CHG_SHARE_MASK         (0x3 << LDOFF_CHG_SHARE_SHIFT)
+#define LDOFF_CHG_SHARE_NEVER        (0x1 << LDOFF_CHG_SHARE_SHIFT)
+#define LDOFF_CHG_SHARE_OK_NO_PROP   (0x2 << LDOFF_CHG_SHARE_SHIFT)
+#define LDOFF_CHG_SHARE_OK_PROP      (0x3 << LDOFF_CHG_SHARE_SHIFT)
+
+#define LDOFF_ENABLE_AUTO_NFIFO         (1 << 2)
+#define LDOFF_DISABLE_AUTO_NFIFO        (1 << 3)
+
+#define LDOFF_CHG_NONSEQLIODN_SHIFT     4
+#define LDOFF_CHG_NONSEQLIODN_MASK      (0x3 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+#define LDOFF_CHG_NONSEQLIODN_SEQ       (0x1 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+#define LDOFF_CHG_NONSEQLIODN_NON_SEQ   (0x2 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+#define LDOFF_CHG_NONSEQLIODN_TRUSTED   (0x3 << LDOFF_CHG_NONSEQLIODN_SHIFT)
+
+#define LDOFF_CHG_SEQLIODN_SHIFT     6
+#define LDOFF_CHG_SEQLIODN_MASK      (0x3 << LDOFF_CHG_SEQLIODN_SHIFT)
+#define LDOFF_CHG_SEQLIODN_SEQ       (0x1 << LDOFF_CHG_SEQLIODN_SHIFT)
+#define LDOFF_CHG_SEQLIODN_NON_SEQ   (0x2 << LDOFF_CHG_SEQLIODN_SHIFT)
+#define LDOFF_CHG_SEQLIODN_TRUSTED   (0x3 << LDOFF_CHG_SEQLIODN_SHIFT)
+
+/* Data length in bytes                                 */
+#define LDST_LEN_SHIFT          0
+#define LDST_LEN_MASK           (0xff << LDST_LEN_SHIFT)
+
+/* Special Length definitions when dst=deco-ctrl */
+#define LDLEN_ENABLE_OSL_COUNT      (1 << 7)
+#define LDLEN_RST_CHA_OFIFO_PTR     (1 << 6)
+#define LDLEN_RST_OFIFO             (1 << 5)
+#define LDLEN_SET_OFIFO_OFF_VALID   (1 << 4)
+#define LDLEN_SET_OFIFO_OFF_RSVD    (1 << 3)
+#define LDLEN_SET_OFIFO_OFFSET_SHIFT 0
+#define LDLEN_SET_OFIFO_OFFSET_MASK (3 << LDLEN_SET_OFIFO_OFFSET_SHIFT)
+
+/*
+ * FIFO_LOAD/FIFO_STORE/SEQ_FIFO_LOAD/SEQ_FIFO_STORE
+ * Command Constructs
+ */
+
+/*
+ * Load Destination: 0 = skip (SEQ_FIFO_LOAD only),
+ * 1 = Load for Class1, 2 = Load for Class2, 3 = Load both
+ * Store Source: 0 = normal, 1 = Class1key, 2 = Class2key
+ */
+#define FIFOLD_CLASS_SHIFT      25
+#define FIFOLD_CLASS_MASK       (0x03 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_SKIP       (0x00 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_CLASS1     (0x01 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_CLASS2     (0x02 << FIFOLD_CLASS_SHIFT)
+#define FIFOLD_CLASS_BOTH       (0x03 << FIFOLD_CLASS_SHIFT)
+
+#define FIFOST_CLASS_SHIFT      25
+#define FIFOST_CLASS_MASK       (0x03 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_NORMAL     (0x00 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS1KEY  (0x01 << FIFOST_CLASS_SHIFT)
+#define FIFOST_CLASS_CLASS2KEY  (0x02 << FIFOST_CLASS_SHIFT)
+
+/*
+ * Scatter-Gather Table/Variable Length Field
+ * If set for FIFO_LOAD, refers to a SG table. Within
+ * SEQ_FIFO_LOAD, is variable input sequence
+ */
+#define FIFOLDST_SGF_SHIFT      24
+#define FIFOLDST_SGF_MASK       (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_VLF_MASK       (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_SGF            (1 << FIFOLDST_SGF_SHIFT)
+#define FIFOLDST_VLF            (1 << FIFOLDST_SGF_SHIFT)
+
+/* Immediate - Data follows command in descriptor */
+#define FIFOLD_IMM_SHIFT      23
+#define FIFOLD_IMM_MASK       (1 << FIFOLD_IMM_SHIFT)
+#define FIFOLD_IMM            (1 << FIFOLD_IMM_SHIFT)
+
+/* Continue - Not the last FIFO store to come */
+#define FIFOST_CONT_SHIFT     23
+#define FIFOST_CONT_MASK      (1 << FIFOST_CONT_SHIFT)
+#define FIFOST_CONT_MASK      (1 << FIFOST_CONT_SHIFT)
+
+/*
+ * Extended Length - use 32-bit extended length that
+ * follows the pointer field. Illegal with IMM set
+ */
+#define FIFOLDST_EXT_SHIFT      22
+#define FIFOLDST_EXT_MASK       (1 << FIFOLDST_EXT_SHIFT)
+#define FIFOLDST_EXT            (1 << FIFOLDST_EXT_SHIFT)
+
+/* Input data type.*/
+#define FIFOLD_TYPE_SHIFT       16
+#define FIFOLD_CONT_TYPE_SHIFT  19 /* shift past last-flush bits */
+#define FIFOLD_TYPE_MASK        (0x3f << FIFOLD_TYPE_SHIFT)
+
+/* PK types */
+#define FIFOLD_TYPE_PK          (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_MASK     (0x30 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_TYPEMASK (0x0f << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A0       (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A1       (0x01 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A2       (0x02 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A3       (0x03 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B0       (0x04 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B1       (0x05 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B2       (0x06 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B3       (0x07 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_N        (0x08 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_A        (0x0c << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_PK_B        (0x0d << FIFOLD_TYPE_SHIFT)
+
+/* Other types. Need to OR in last/flush bits as desired */
+#define FIFOLD_TYPE_MSG_MASK    (0x38 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_MSG         (0x10 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_MSG1OUT2    (0x18 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_IV          (0x20 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_BITDATA     (0x28 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_AAD         (0x30 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_ICV         (0x38 << FIFOLD_TYPE_SHIFT)
+
+/* Last/Flush bits for use with "other" types above */
+#define FIFOLD_TYPE_ACT_MASK    (0x07 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_NOACTION    (0x00 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_FLUSH1      (0x01 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST1       (0x02 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2FLUSH  (0x03 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2       (0x04 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LAST2FLUSH1 (0x05 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LASTBOTH    (0x06 << FIFOLD_TYPE_SHIFT)
+#define FIFOLD_TYPE_LASTBOTHFL  (0x07 << FIFOLD_TYPE_SHIFT)
+
+#define FIFOLDST_LEN_MASK       0xffff
+#define FIFOLDST_EXT_LEN_MASK   0xffffffff
+
+/* Output data types */
+#define FIFOST_TYPE_SHIFT       16
+#define FIFOST_TYPE_MASK        (0x3f << FIFOST_TYPE_SHIFT)
+
+#define FIFOST_TYPE_PKHA_A0      (0x00 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A1      (0x01 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A2      (0x02 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A3      (0x03 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B0      (0x04 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B1      (0x05 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B2      (0x06 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B3      (0x07 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_N       (0x08 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_A       (0x0c << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_B       (0x0d << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_AF_SBOX_JKEK (0x10 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_AF_SBOX_TKEK (0x21 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_E_JKEK  (0x22 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_PKHA_E_TKEK  (0x23 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_KEY_KEK      (0x24 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_KEY_TKEK     (0x25 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SPLIT_KEK    (0x26 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SPLIT_TKEK   (0x27 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_OUTFIFO_KEK  (0x28 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_OUTFIFO_TKEK (0x29 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_MESSAGE_DATA (0x30 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_RNGSTORE     (0x34 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_RNGFIFO      (0x35 << FIFOST_TYPE_SHIFT)
+#define FIFOST_TYPE_SKIP         (0x3f << FIFOST_TYPE_SHIFT)
+
+/*
+ * OPERATION Command Constructs
+ */
+
+/* Operation type selectors - OP TYPE */
+#define OP_TYPE_SHIFT           24
+#define OP_TYPE_MASK            (0x07 << OP_TYPE_SHIFT)
+
+#define OP_TYPE_UNI_PROTOCOL    (0x00 << OP_TYPE_SHIFT)
+#define OP_TYPE_PK              (0x01 << OP_TYPE_SHIFT)
+#define OP_TYPE_CLASS1_ALG      (0x02 << OP_TYPE_SHIFT)
+#define OP_TYPE_CLASS2_ALG      (0x04 << OP_TYPE_SHIFT)
+#define OP_TYPE_DECAP_PROTOCOL  (0x06 << OP_TYPE_SHIFT)
+#define OP_TYPE_ENCAP_PROTOCOL  (0x07 << OP_TYPE_SHIFT)
+
+/* ProtocolID selectors - PROTID */
+#define OP_PCLID_SHIFT          16
+#define OP_PCLID_MASK           (0xff << 16)
+
+/* Assuming OP_TYPE = OP_TYPE_UNI_PROTOCOL */
+#define OP_PCLID_IKEV1_PRF      (0x01 << OP_PCLID_SHIFT)
+#define OP_PCLID_IKEV2_PRF      (0x02 << OP_PCLID_SHIFT)
+#define OP_PCLID_SSL30_PRF      (0x08 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS10_PRF      (0x09 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS11_PRF      (0x0a << OP_PCLID_SHIFT)
+#define OP_PCLID_DTLS10_PRF     (0x0c << OP_PCLID_SHIFT)
+#define OP_PCLID_PRF            (0x06 << OP_PCLID_SHIFT)
+#define OP_PCLID_BLOB           (0x0d << OP_PCLID_SHIFT)
+#define OP_PCLID_SECRETKEY      (0x11 << OP_PCLID_SHIFT)
+#define OP_PCLID_PUBLICKEYPAIR  (0x14 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSASIGN        (0x15 << OP_PCLID_SHIFT)
+#define OP_PCLID_DSAVERIFY      (0x16 << OP_PCLID_SHIFT)
+
+/* Assuming OP_TYPE = OP_TYPE_DECAP_PROTOCOL/ENCAP_PROTOCOL */
+#define OP_PCLID_IPSEC          (0x01 << OP_PCLID_SHIFT)
+#define OP_PCLID_SRTP           (0x02 << OP_PCLID_SHIFT)
+#define OP_PCLID_MACSEC         (0x03 << OP_PCLID_SHIFT)
+#define OP_PCLID_WIFI           (0x04 << OP_PCLID_SHIFT)
+#define OP_PCLID_WIMAX          (0x05 << OP_PCLID_SHIFT)
+#define OP_PCLID_SSL30          (0x08 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS10          (0x09 << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS11          (0x0a << OP_PCLID_SHIFT)
+#define OP_PCLID_TLS12          (0x0b << OP_PCLID_SHIFT)
+#define OP_PCLID_DTLS           (0x0c << OP_PCLID_SHIFT)
+
+/*
+ * ProtocolInfo selectors
+ */
+#define OP_PCLINFO_MASK                          0xffff
+
+/* for OP_PCLID_IPSEC */
+#define OP_PCL_IPSEC_CIPHER_MASK                 0xff00
+#define OP_PCL_IPSEC_AUTH_MASK                   0x00ff
+
+#define OP_PCL_IPSEC_DES_IV64                    0x0100
+#define OP_PCL_IPSEC_DES                         0x0200
+#define OP_PCL_IPSEC_3DES                        0x0300
+#define OP_PCL_IPSEC_AES_CBC                     0x0c00
+#define OP_PCL_IPSEC_AES_CTR                     0x0d00
+#define OP_PCL_IPSEC_AES_XTS                     0x1600
+#define OP_PCL_IPSEC_AES_CCM8                    0x0e00
+#define OP_PCL_IPSEC_AES_CCM12                   0x0f00
+#define OP_PCL_IPSEC_AES_CCM16                   0x1000
+#define OP_PCL_IPSEC_AES_GCM8                    0x1200
+#define OP_PCL_IPSEC_AES_GCM12                   0x1300
+#define OP_PCL_IPSEC_AES_GCM16                   0x1400
+
+#define OP_PCL_IPSEC_HMAC_NULL                   0x0000
+#define OP_PCL_IPSEC_HMAC_MD5_96                 0x0001
+#define OP_PCL_IPSEC_HMAC_SHA1_96                0x0002
+#define OP_PCL_IPSEC_AES_XCBC_MAC_96             0x0005
+#define OP_PCL_IPSEC_HMAC_MD5_128                0x0006
+#define OP_PCL_IPSEC_HMAC_SHA1_160               0x0007
+#define OP_PCL_IPSEC_HMAC_SHA2_256_128           0x000c
+#define OP_PCL_IPSEC_HMAC_SHA2_384_192           0x000d
+#define OP_PCL_IPSEC_HMAC_SHA2_512_256           0x000e
+
+/* For SRTP - OP_PCLID_SRTP */
+#define OP_PCL_SRTP_CIPHER_MASK                  0xff00
+#define OP_PCL_SRTP_AUTH_MASK                    0x00ff
+
+#define OP_PCL_SRTP_AES_CTR                      0x0d00
+
+#define OP_PCL_SRTP_HMAC_SHA1_160                0x0007
+
+/* For SSL 3.0 - OP_PCLID_SSL30 */
+#define OP_PCL_SSL30_AES_128_CBC_SHA             0x002f
+#define OP_PCL_SSL30_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_SSL30_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_SSL30_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_SSL30_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_SSL30_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_SSL30_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_SSL30_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_SSL30_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_SSL30_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_SSL30_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_SSL30_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_SSL30_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_SSL30_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_SSL30_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_SSL30_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_SSL30_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_SSL30_AES_256_CBC_SHA             0x0035
+#define OP_PCL_SSL30_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_SSL30_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_SSL30_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_SSL30_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_SSL30_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_SSL30_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_SSL30_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_SSL30_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_SSL30_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_SSL30_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_SSL30_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_SSL30_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_SSL30_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_SSL30_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_SSL30_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_SSL30_AES_256_CBC_SHA_17          0xc022
+
+#define OP_PCL_SSL30_3DES_EDE_CBC_MD5            0x0023
+
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_SSL30_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_SSL30_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_SSL30_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_SSL30_DES40_CBC_SHA               0x0008
+#define OP_PCL_SSL30_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_SSL30_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_SSL30_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_SSL30_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_SSL30_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_SSL30_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_SSL30_DES_CBC_SHA                 0x001e
+#define OP_PCL_SSL30_DES_CBC_SHA_2               0x0009
+#define OP_PCL_SSL30_DES_CBC_SHA_3               0x000c
+#define OP_PCL_SSL30_DES_CBC_SHA_4               0x000f
+#define OP_PCL_SSL30_DES_CBC_SHA_5               0x0012
+#define OP_PCL_SSL30_DES_CBC_SHA_6               0x0015
+#define OP_PCL_SSL30_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_SSL30_RC4_128_MD5                 0x0024
+#define OP_PCL_SSL30_RC4_128_MD5_2               0x0004
+#define OP_PCL_SSL30_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_SSL30_RC4_40_MD5                  0x002b
+#define OP_PCL_SSL30_RC4_40_MD5_2                0x0003
+#define OP_PCL_SSL30_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_SSL30_RC4_128_SHA                 0x0020
+#define OP_PCL_SSL30_RC4_128_SHA_2               0x008a
+#define OP_PCL_SSL30_RC4_128_SHA_3               0x008e
+#define OP_PCL_SSL30_RC4_128_SHA_4               0x0092
+#define OP_PCL_SSL30_RC4_128_SHA_5               0x0005
+#define OP_PCL_SSL30_RC4_128_SHA_6               0xc002
+#define OP_PCL_SSL30_RC4_128_SHA_7               0xc007
+#define OP_PCL_SSL30_RC4_128_SHA_8               0xc00c
+#define OP_PCL_SSL30_RC4_128_SHA_9               0xc011
+#define OP_PCL_SSL30_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_SSL30_RC4_40_SHA                  0x0028
+
+
+/* For TLS 1.0 - OP_PCLID_TLS10 */
+#define OP_PCL_TLS10_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS10_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS10_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS10_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS10_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS10_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS10_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS10_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS10_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS10_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS10_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS10_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS10_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS10_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS10_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS10_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS10_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS10_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS10_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS10_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS10_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS10_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS10_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS10_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS10_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS10_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS10_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS10_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS10_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS10_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS10_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS10_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS10_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS10_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS10_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS10_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS10_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS10_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS10_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS10_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS10_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS10_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS10_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS10_DES40_CBC_SHA_7             0x0026
+
+
+#define OP_PCL_TLS10_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS10_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS10_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS10_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS10_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS10_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS10_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS10_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS10_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS10_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS10_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS10_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS10_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS10_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS10_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS10_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS10_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS10_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS10_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS10_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS10_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS10_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS10_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS10_RC4_40_SHA                  0x0028
+
+#define OP_PCL_TLS10_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS10_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS10_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS10_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS10_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS10_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS10_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS10_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS10_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS10_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS10_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS10_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS10_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS10_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS10_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS10_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS10_AES_256_CBC_SHA512          0xff65
+
+
+
+/* For TLS 1.1 - OP_PCLID_TLS11 */
+#define OP_PCL_TLS11_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS11_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS11_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS11_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS11_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS11_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS11_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS11_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS11_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS11_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS11_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS11_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS11_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS11_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS11_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS11_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS11_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS11_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS11_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS11_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS11_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS11_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS11_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS11_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS11_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS11_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS11_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS11_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS11_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS11_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS11_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS11_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS11_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS11_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS11_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS11_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS11_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS11_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS11_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS11_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS11_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS11_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS11_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS11_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_TLS11_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS11_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS11_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS11_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS11_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS11_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS11_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS11_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS11_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS11_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS11_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS11_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS11_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS11_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS11_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS11_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS11_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS11_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS11_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS11_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS11_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS11_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS11_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS11_RC4_40_SHA                  0x0028
+
+#define OP_PCL_TLS11_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS11_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS11_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS11_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS11_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS11_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS11_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS11_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS11_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS11_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS11_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS11_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS11_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS11_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS11_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS11_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS11_AES_256_CBC_SHA512          0xff65
+
+
+/* For TLS 1.2 - OP_PCLID_TLS12 */
+#define OP_PCL_TLS12_AES_128_CBC_SHA             0x002f
+#define OP_PCL_TLS12_AES_128_CBC_SHA_2           0x0030
+#define OP_PCL_TLS12_AES_128_CBC_SHA_3           0x0031
+#define OP_PCL_TLS12_AES_128_CBC_SHA_4           0x0032
+#define OP_PCL_TLS12_AES_128_CBC_SHA_5           0x0033
+#define OP_PCL_TLS12_AES_128_CBC_SHA_6           0x0034
+#define OP_PCL_TLS12_AES_128_CBC_SHA_7           0x008c
+#define OP_PCL_TLS12_AES_128_CBC_SHA_8           0x0090
+#define OP_PCL_TLS12_AES_128_CBC_SHA_9           0x0094
+#define OP_PCL_TLS12_AES_128_CBC_SHA_10          0xc004
+#define OP_PCL_TLS12_AES_128_CBC_SHA_11          0xc009
+#define OP_PCL_TLS12_AES_128_CBC_SHA_12          0xc00e
+#define OP_PCL_TLS12_AES_128_CBC_SHA_13          0xc013
+#define OP_PCL_TLS12_AES_128_CBC_SHA_14          0xc018
+#define OP_PCL_TLS12_AES_128_CBC_SHA_15          0xc01d
+#define OP_PCL_TLS12_AES_128_CBC_SHA_16          0xc01e
+#define OP_PCL_TLS12_AES_128_CBC_SHA_17          0xc01f
+
+#define OP_PCL_TLS12_AES_256_CBC_SHA             0x0035
+#define OP_PCL_TLS12_AES_256_CBC_SHA_2           0x0036
+#define OP_PCL_TLS12_AES_256_CBC_SHA_3           0x0037
+#define OP_PCL_TLS12_AES_256_CBC_SHA_4           0x0038
+#define OP_PCL_TLS12_AES_256_CBC_SHA_5           0x0039
+#define OP_PCL_TLS12_AES_256_CBC_SHA_6           0x003a
+#define OP_PCL_TLS12_AES_256_CBC_SHA_7           0x008d
+#define OP_PCL_TLS12_AES_256_CBC_SHA_8           0x0091
+#define OP_PCL_TLS12_AES_256_CBC_SHA_9           0x0095
+#define OP_PCL_TLS12_AES_256_CBC_SHA_10          0xc005
+#define OP_PCL_TLS12_AES_256_CBC_SHA_11          0xc00a
+#define OP_PCL_TLS12_AES_256_CBC_SHA_12          0xc00f
+#define OP_PCL_TLS12_AES_256_CBC_SHA_13          0xc014
+#define OP_PCL_TLS12_AES_256_CBC_SHA_14          0xc019
+#define OP_PCL_TLS12_AES_256_CBC_SHA_15          0xc020
+#define OP_PCL_TLS12_AES_256_CBC_SHA_16          0xc021
+#define OP_PCL_TLS12_AES_256_CBC_SHA_17          0xc022
+
+/* #define OP_PCL_TLS12_3DES_EDE_CBC_MD5            0x0023 */
+
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA            0x001f
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_2          0x008b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_3          0x008f
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_4          0x0093
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_5          0x000a
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_6          0x000d
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_7          0x0010
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_8          0x0013
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_9          0x0016
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_10         0x001b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_11         0xc003
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_12         0xc008
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_13         0xc00d
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_14         0xc012
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_15         0xc017
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_16         0xc01a
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_17         0xc01b
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA_18         0xc01c
+
+#define OP_PCL_TLS12_DES40_CBC_MD5               0x0029
+
+#define OP_PCL_TLS12_DES_CBC_MD5                 0x0022
+
+#define OP_PCL_TLS12_DES40_CBC_SHA               0x0008
+#define OP_PCL_TLS12_DES40_CBC_SHA_2             0x000b
+#define OP_PCL_TLS12_DES40_CBC_SHA_3             0x000e
+#define OP_PCL_TLS12_DES40_CBC_SHA_4             0x0011
+#define OP_PCL_TLS12_DES40_CBC_SHA_5             0x0014
+#define OP_PCL_TLS12_DES40_CBC_SHA_6             0x0019
+#define OP_PCL_TLS12_DES40_CBC_SHA_7             0x0026
+
+#define OP_PCL_TLS12_DES_CBC_SHA                 0x001e
+#define OP_PCL_TLS12_DES_CBC_SHA_2               0x0009
+#define OP_PCL_TLS12_DES_CBC_SHA_3               0x000c
+#define OP_PCL_TLS12_DES_CBC_SHA_4               0x000f
+#define OP_PCL_TLS12_DES_CBC_SHA_5               0x0012
+#define OP_PCL_TLS12_DES_CBC_SHA_6               0x0015
+#define OP_PCL_TLS12_DES_CBC_SHA_7               0x001a
+
+#define OP_PCL_TLS12_RC4_128_MD5                 0x0024
+#define OP_PCL_TLS12_RC4_128_MD5_2               0x0004
+#define OP_PCL_TLS12_RC4_128_MD5_3               0x0018
+
+#define OP_PCL_TLS12_RC4_40_MD5                  0x002b
+#define OP_PCL_TLS12_RC4_40_MD5_2                0x0003
+#define OP_PCL_TLS12_RC4_40_MD5_3                0x0017
+
+#define OP_PCL_TLS12_RC4_128_SHA                 0x0020
+#define OP_PCL_TLS12_RC4_128_SHA_2               0x008a
+#define OP_PCL_TLS12_RC4_128_SHA_3               0x008e
+#define OP_PCL_TLS12_RC4_128_SHA_4               0x0092
+#define OP_PCL_TLS12_RC4_128_SHA_5               0x0005
+#define OP_PCL_TLS12_RC4_128_SHA_6               0xc002
+#define OP_PCL_TLS12_RC4_128_SHA_7               0xc007
+#define OP_PCL_TLS12_RC4_128_SHA_8               0xc00c
+#define OP_PCL_TLS12_RC4_128_SHA_9               0xc011
+#define OP_PCL_TLS12_RC4_128_SHA_10              0xc016
+
+#define OP_PCL_TLS12_RC4_40_SHA                  0x0028
+
+/* #define OP_PCL_TLS12_AES_128_CBC_SHA256          0x003c */
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_2        0x003e
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_3        0x003f
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_4        0x0040
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_5        0x0067
+#define OP_PCL_TLS12_AES_128_CBC_SHA256_6        0x006c
+
+/* #define OP_PCL_TLS12_AES_256_CBC_SHA256          0x003d */
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_2        0x0068
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_3        0x0069
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_4        0x006a
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_5        0x006b
+#define OP_PCL_TLS12_AES_256_CBC_SHA256_6        0x006d
+
+/* AEAD_AES_xxx_CCM/GCM remain to be defined... */
+
+#define OP_PCL_TLS12_3DES_EDE_CBC_MD5            0xff23
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA160         0xff30
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA224         0xff34
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA256         0xff36
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA384         0xff33
+#define OP_PCL_TLS12_3DES_EDE_CBC_SHA512         0xff35
+#define OP_PCL_TLS12_AES_128_CBC_SHA160          0xff80
+#define OP_PCL_TLS12_AES_128_CBC_SHA224          0xff84
+#define OP_PCL_TLS12_AES_128_CBC_SHA256          0xff86
+#define OP_PCL_TLS12_AES_128_CBC_SHA384          0xff83
+#define OP_PCL_TLS12_AES_128_CBC_SHA512          0xff85
+#define OP_PCL_TLS12_AES_192_CBC_SHA160          0xff20
+#define OP_PCL_TLS12_AES_192_CBC_SHA224          0xff24
+#define OP_PCL_TLS12_AES_192_CBC_SHA256          0xff26
+#define OP_PCL_TLS12_AES_192_CBC_SHA384          0xff23
+#define OP_PCL_TLS12_AES_192_CBC_SHA512          0xff25
+#define OP_PCL_TLS12_AES_256_CBC_SHA160          0xff60
+#define OP_PCL_TLS12_AES_256_CBC_SHA224          0xff64
+#define OP_PCL_TLS12_AES_256_CBC_SHA256          0xff66
+#define OP_PCL_TLS12_AES_256_CBC_SHA384          0xff63
+#define OP_PCL_TLS12_AES_256_CBC_SHA512          0xff65
+
+/* For DTLS - OP_PCLID_DTLS */
+
+#define OP_PCL_DTLS_AES_128_CBC_SHA              0x002f
+#define OP_PCL_DTLS_AES_128_CBC_SHA_2            0x0030
+#define OP_PCL_DTLS_AES_128_CBC_SHA_3            0x0031
+#define OP_PCL_DTLS_AES_128_CBC_SHA_4            0x0032
+#define OP_PCL_DTLS_AES_128_CBC_SHA_5            0x0033
+#define OP_PCL_DTLS_AES_128_CBC_SHA_6            0x0034
+#define OP_PCL_DTLS_AES_128_CBC_SHA_7            0x008c
+#define OP_PCL_DTLS_AES_128_CBC_SHA_8            0x0090
+#define OP_PCL_DTLS_AES_128_CBC_SHA_9            0x0094
+#define OP_PCL_DTLS_AES_128_CBC_SHA_10           0xc004
+#define OP_PCL_DTLS_AES_128_CBC_SHA_11           0xc009
+#define OP_PCL_DTLS_AES_128_CBC_SHA_12           0xc00e
+#define OP_PCL_DTLS_AES_128_CBC_SHA_13           0xc013
+#define OP_PCL_DTLS_AES_128_CBC_SHA_14           0xc018
+#define OP_PCL_DTLS_AES_128_CBC_SHA_15           0xc01d
+#define OP_PCL_DTLS_AES_128_CBC_SHA_16           0xc01e
+#define OP_PCL_DTLS_AES_128_CBC_SHA_17           0xc01f
+
+#define OP_PCL_DTLS_AES_256_CBC_SHA              0x0035
+#define OP_PCL_DTLS_AES_256_CBC_SHA_2            0x0036
+#define OP_PCL_DTLS_AES_256_CBC_SHA_3            0x0037
+#define OP_PCL_DTLS_AES_256_CBC_SHA_4            0x0038
+#define OP_PCL_DTLS_AES_256_CBC_SHA_5            0x0039
+#define OP_PCL_DTLS_AES_256_CBC_SHA_6            0x003a
+#define OP_PCL_DTLS_AES_256_CBC_SHA_7            0x008d
+#define OP_PCL_DTLS_AES_256_CBC_SHA_8            0x0091
+#define OP_PCL_DTLS_AES_256_CBC_SHA_9            0x0095
+#define OP_PCL_DTLS_AES_256_CBC_SHA_10           0xc005
+#define OP_PCL_DTLS_AES_256_CBC_SHA_11           0xc00a
+#define OP_PCL_DTLS_AES_256_CBC_SHA_12           0xc00f
+#define OP_PCL_DTLS_AES_256_CBC_SHA_13           0xc014
+#define OP_PCL_DTLS_AES_256_CBC_SHA_14           0xc019
+#define OP_PCL_DTLS_AES_256_CBC_SHA_15           0xc020
+#define OP_PCL_DTLS_AES_256_CBC_SHA_16           0xc021
+#define OP_PCL_DTLS_AES_256_CBC_SHA_17           0xc022
+
+/* #define OP_PCL_DTLS_3DES_EDE_CBC_MD5             0x0023 */
+
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA             0x001f
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_2           0x008b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_3           0x008f
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_4           0x0093
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_5           0x000a
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_6           0x000d
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_7           0x0010
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_8           0x0013
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_9           0x0016
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_10          0x001b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_11          0xc003
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_12          0xc008
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_13          0xc00d
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_14          0xc012
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_15          0xc017
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_16          0xc01a
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_17          0xc01b
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA_18          0xc01c
+
+#define OP_PCL_DTLS_DES40_CBC_MD5                0x0029
+
+#define OP_PCL_DTLS_DES_CBC_MD5                  0x0022
+
+#define OP_PCL_DTLS_DES40_CBC_SHA                0x0008
+#define OP_PCL_DTLS_DES40_CBC_SHA_2              0x000b
+#define OP_PCL_DTLS_DES40_CBC_SHA_3              0x000e
+#define OP_PCL_DTLS_DES40_CBC_SHA_4              0x0011
+#define OP_PCL_DTLS_DES40_CBC_SHA_5              0x0014
+#define OP_PCL_DTLS_DES40_CBC_SHA_6              0x0019
+#define OP_PCL_DTLS_DES40_CBC_SHA_7              0x0026
+
+
+#define OP_PCL_DTLS_DES_CBC_SHA                  0x001e
+#define OP_PCL_DTLS_DES_CBC_SHA_2                0x0009
+#define OP_PCL_DTLS_DES_CBC_SHA_3                0x000c
+#define OP_PCL_DTLS_DES_CBC_SHA_4                0x000f
+#define OP_PCL_DTLS_DES_CBC_SHA_5                0x0012
+#define OP_PCL_DTLS_DES_CBC_SHA_6                0x0015
+#define OP_PCL_DTLS_DES_CBC_SHA_7                0x001a
+
+
+#define OP_PCL_DTLS_3DES_EDE_CBC_MD5             0xff23
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA160          0xff30
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA224          0xff34
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA256          0xff36
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA384          0xff33
+#define OP_PCL_DTLS_3DES_EDE_CBC_SHA512          0xff35
+#define OP_PCL_DTLS_AES_128_CBC_SHA160           0xff80
+#define OP_PCL_DTLS_AES_128_CBC_SHA224           0xff84
+#define OP_PCL_DTLS_AES_128_CBC_SHA256           0xff86
+#define OP_PCL_DTLS_AES_128_CBC_SHA384           0xff83
+#define OP_PCL_DTLS_AES_128_CBC_SHA512           0xff85
+#define OP_PCL_DTLS_AES_192_CBC_SHA160           0xff20
+#define OP_PCL_DTLS_AES_192_CBC_SHA224           0xff24
+#define OP_PCL_DTLS_AES_192_CBC_SHA256           0xff26
+#define OP_PCL_DTLS_AES_192_CBC_SHA384           0xff23
+#define OP_PCL_DTLS_AES_192_CBC_SHA512           0xff25
+#define OP_PCL_DTLS_AES_256_CBC_SHA160           0xff60
+#define OP_PCL_DTLS_AES_256_CBC_SHA224           0xff64
+#define OP_PCL_DTLS_AES_256_CBC_SHA256           0xff66
+#define OP_PCL_DTLS_AES_256_CBC_SHA384           0xff63
+#define OP_PCL_DTLS_AES_256_CBC_SHA512           0xff65
+
+/* 802.16 WiMAX protinfos */
+#define OP_PCL_WIMAX_OFDM                        0x0201
+#define OP_PCL_WIMAX_OFDMA                       0x0231
+
+/* 802.11 WiFi protinfos */
+#define OP_PCL_WIFI                              0xac04
+
+/* MacSec protinfos */
+#define OP_PCL_MACSEC                            0x0001
+
+/* PKI unidirectional protocol protinfo bits */
+#define OP_PCL_PKPROT_TEST                       0x0008
+#define OP_PCL_PKPROT_DECRYPT                    0x0004
+#define OP_PCL_PKPROT_ECC                        0x0002
+#define OP_PCL_PKPROT_F2M                        0x0001
+
+/* For non-protocol/alg-only op commands */
+#define OP_ALG_TYPE_SHIFT	24
+#define OP_ALG_TYPE_MASK	(0x7 << OP_ALG_TYPE_SHIFT)
+#define OP_ALG_TYPE_CLASS1	2
+#define OP_ALG_TYPE_CLASS2	4
+
+#define OP_ALG_ALGSEL_SHIFT	16
+#define OP_ALG_ALGSEL_MASK	(0xff << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SUBMASK	(0x0f << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_AES	(0x10 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_DES	(0x20 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_3DES	(0x21 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_ARC4	(0x30 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_MD5	(0x40 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA1	(0x41 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA224	(0x42 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA256	(0x43 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA384	(0x44 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA512	(0x45 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_RNG	(0x50 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW	(0x60 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW_F8	(0x60 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_KASUMI	(0x70 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_CRC	(0x90 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW_F9	(0xA0 << OP_ALG_ALGSEL_SHIFT)
+
+#define OP_ALG_AAI_SHIFT	4
+#define OP_ALG_AAI_MASK		(0x1ff << OP_ALG_AAI_SHIFT)
+
+/* blockcipher AAI set */
+#define OP_ALG_AAI_CTR_MOD128	(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD8	(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD16	(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD24	(0x03 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD32	(0x04 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD40	(0x05 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD48	(0x06 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD56	(0x07 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD64	(0x08 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD72	(0x09 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD80	(0x0a << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD88	(0x0b << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD96	(0x0c << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD104	(0x0d << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD112	(0x0e << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_MOD120	(0x0f << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CBC		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_ECB		(0x20 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CFB		(0x30 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_OFB		(0x40 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_XTS		(0x50 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CMAC		(0x60 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_XCBC_MAC	(0x70 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CCM		(0x80 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_GCM		(0x90 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CBC_XCBCMAC	(0xa0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CTR_XCBCMAC	(0xb0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CHECKODD	(0x80 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DK		(0x100 << OP_ALG_AAI_SHIFT)
+
+/* randomizer AAI set */
+#define OP_ALG_AAI_RNG		(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_RNG_NOZERO	(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_RNG_ODD	(0x20 << OP_ALG_AAI_SHIFT)
+
+/* hmac/smac AAI set */
+#define OP_ALG_AAI_HASH		(0x00 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_HMAC		(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_SMAC		(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_HMAC_PRECOMP	(0x04 << OP_ALG_AAI_SHIFT)
+
+/* CRC AAI set*/
+#define OP_ALG_AAI_802		(0x01 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_3385		(0x02 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_CUST_POLY	(0x04 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DIS		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DOS		(0x20 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_DOC		(0x40 << OP_ALG_AAI_SHIFT)
+
+/* Kasumi/SNOW AAI set */
+#define OP_ALG_AAI_F8		(0xc0 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_F9		(0xc8 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_GSM		(0x10 << OP_ALG_AAI_SHIFT)
+#define OP_ALG_AAI_EDGE		(0x20 << OP_ALG_AAI_SHIFT)
+
+/* RNG4 set */
+#define OP_ALG_RNG4_SHIFT	4
+#define OP_ALG_RNG4_MAS		(0x1f3 << OP_ALG_RNG4_SHIFT)
+#define OP_ALG_RNG4_SK		(0x100 << OP_ALG_RNG4_SHIFT)
+
+#define OP_ALG_AS_SHIFT		2
+#define OP_ALG_AS_MASK		(0x3 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_UPDATE	(0 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_INIT		(1 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_FINALIZE	(2 << OP_ALG_AS_SHIFT)
+#define OP_ALG_AS_INITFINAL	(3 << OP_ALG_AS_SHIFT)
+
+#define OP_ALG_ICV_SHIFT	1
+#define OP_ALG_ICV_MASK		(1 << OP_ALG_ICV_SHIFT)
+#define OP_ALG_ICV_OFF		(0 << OP_ALG_ICV_SHIFT)
+#define OP_ALG_ICV_ON		(1 << OP_ALG_ICV_SHIFT)
+
+#define OP_ALG_DIR_SHIFT	0
+#define OP_ALG_DIR_MASK		1
+#define OP_ALG_DECRYPT		0
+#define OP_ALG_ENCRYPT		1
+
+/* PKHA algorithm type set */
+#define OP_ALG_PK                    0x00800000
+#define OP_ALG_PK_FUN_MASK           0x3f /* clrmem, modmath, or cpymem */
+
+/* PKHA mode clear memory functions */
+#define OP_ALG_PKMODE_A_RAM          0x80000
+#define OP_ALG_PKMODE_B_RAM          0x40000
+#define OP_ALG_PKMODE_E_RAM          0x20000
+#define OP_ALG_PKMODE_N_RAM          0x10000
+#define OP_ALG_PKMODE_CLEARMEM       0x00001
+
+/* PKHA mode modular-arithmetic functions */
+#define OP_ALG_PKMODE_MOD_IN_MONTY   0x80000
+#define OP_ALG_PKMODE_MOD_OUT_MONTY  0x40000
+#define OP_ALG_PKMODE_MOD_F2M        0x20000
+#define OP_ALG_PKMODE_MOD_R2_IN      0x10000
+#define OP_ALG_PKMODE_PRJECTV        0x00800
+#define OP_ALG_PKMODE_TIME_EQ        0x400
+#define OP_ALG_PKMODE_OUT_B          0x000
+#define OP_ALG_PKMODE_OUT_A          0x100
+#define OP_ALG_PKMODE_MOD_ADD        0x002
+#define OP_ALG_PKMODE_MOD_SUB_AB     0x003
+#define OP_ALG_PKMODE_MOD_SUB_BA     0x004
+#define OP_ALG_PKMODE_MOD_MULT       0x005
+#define OP_ALG_PKMODE_MOD_EXPO       0x006
+#define OP_ALG_PKMODE_MOD_REDUCT     0x007
+#define OP_ALG_PKMODE_MOD_INV        0x008
+#define OP_ALG_PKMODE_MOD_ECC_ADD    0x009
+#define OP_ALG_PKMODE_MOD_ECC_DBL    0x00a
+#define OP_ALG_PKMODE_MOD_ECC_MULT   0x00b
+#define OP_ALG_PKMODE_MOD_MONT_CNST  0x00c
+#define OP_ALG_PKMODE_MOD_CRT_CNST   0x00d
+#define OP_ALG_PKMODE_MOD_GCD        0x00e
+#define OP_ALG_PKMODE_MOD_PRIMALITY  0x00f
+
+/* PKHA mode copy-memory functions */
+#define OP_ALG_PKMODE_SRC_REG_SHIFT  13
+#define OP_ALG_PKMODE_SRC_REG_MASK   (7 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_SHIFT  10
+#define OP_ALG_PKMODE_DST_REG_MASK   (7 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_SHIFT  8
+#define OP_ALG_PKMODE_SRC_SEG_MASK   (3 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_SHIFT  6
+#define OP_ALG_PKMODE_DST_SEG_MASK   (3 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+
+#define OP_ALG_PKMODE_SRC_REG_A      (0 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_REG_B      (1 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_REG_N      (3 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_A      (0 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_B      (1 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_E      (2 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_N      (3 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_0      (0 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_1      (1 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_2      (2 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_3      (3 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_0      (0 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_1      (1 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_2      (2 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_3      (3 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_CPYMEM_N_SZ    0x80
+#define OP_ALG_PKMODE_CPYMEM_SRC_SZ  0x81
+
+/*
+ * SEQ_IN_PTR Command Constructs
+ */
+
+/* Release Buffers */
+#define SQIN_RBS               0x04000000
+
+/* Sequence pointer is really a descriptor */
+#define SQIN_INL               0x02000000
+
+/* Sequence pointer is a scatter-gather table */
+#define SQIN_SGF               0x01000000
+
+/* Appends to a previous pointer */
+#define SQIN_PRE               0x00800000
+
+/* Use extended length following pointer */
+#define SQIN_EXT               0x00400000
+
+/* Restore sequence with pointer/length */
+#define SQIN_RTO               0x00200000
+
+/* Replace job descriptor */
+#define SQIN_RJD               0x00100000
+
+#define SQIN_LEN_SHIFT           0
+#define SQIN_LEN_MASK           (0xffff << SQIN_LEN_SHIFT)
+
+/*
+ * SEQ_OUT_PTR Command Constructs
+ */
+
+/* Sequence pointer is a scatter-gather table */
+#define SQOUT_SGF              0x01000000
+
+/* Appends to a previous pointer */
+#define SQOUT_PRE              0x00800000
+
+/* Restore sequence with pointer/length */
+#define SQOUT_RTO              0x00200000
+
+/* Use extended length following pointer */
+#define SQOUT_EXT              0x00400000
+
+#define SQOUT_LEN_SHIFT           0
+#define SQOUT_LEN_MASK           (0xffff << SQOUT_LEN_SHIFT)
+
+
+/*
+ * SIGNATURE Command Constructs
+ */
+
+/* TYPE field is all that's relevant */
+#define SIGN_TYPE_SHIFT         16
+#define SIGN_TYPE_MASK          (0x0f << SIGN_TYPE_SHIFT)
+
+#define SIGN_TYPE_FINAL         (0x00 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_FINAL_RESTORE (0x01 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_FINAL_NONZERO (0x02 << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_2         (0x0a << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_3         (0x0b << SIGN_TYPE_SHIFT)
+#define SIGN_TYPE_IMM_4         (0x0c << SIGN_TYPE_SHIFT)
+
+/*
+ * MOVE Command Constructs
+ */
+
+#define MOVE_AUX_SHIFT          25
+#define MOVE_AUX_MASK           (3 << MOVE_AUX_SHIFT)
+#define MOVE_AUX_MS             (2 << MOVE_AUX_SHIFT)
+#define MOVE_AUX_LS             (1 << MOVE_AUX_SHIFT)
+
+#define MOVE_WAITCOMP_SHIFT     24
+#define MOVE_WAITCOMP_MASK      (1 << MOVE_WAITCOMP_SHIFT)
+#define MOVE_WAITCOMP           (1 << MOVE_WAITCOMP_SHIFT)
+
+#define MOVE_SRC_SHIFT          20
+#define MOVE_SRC_MASK           (0x0f << MOVE_SRC_SHIFT)
+#define MOVE_SRC_CLASS1CTX      (0x00 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_CLASS2CTX      (0x01 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_OUTFIFO        (0x02 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_DESCBUF        (0x03 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH0          (0x04 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH1          (0x05 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH2          (0x06 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_MATH3          (0x07 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_INFIFO         (0x08 << MOVE_SRC_SHIFT)
+#define MOVE_SRC_INFIFO_CL      (0x09 << MOVE_SRC_SHIFT)
+
+#define MOVE_DEST_SHIFT         16
+#define MOVE_DEST_MASK          (0x0f << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1CTX     (0x00 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2CTX     (0x01 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_OUTFIFO       (0x02 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_DESCBUF       (0x03 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH0         (0x04 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH1         (0x05 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH2         (0x06 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_MATH3         (0x07 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1INFIFO  (0x08 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2INFIFO  (0x09 << MOVE_DEST_SHIFT)
+#define MOVE_DEST_PK_A          (0x0c << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS1KEY     (0x0d << MOVE_DEST_SHIFT)
+#define MOVE_DEST_CLASS2KEY     (0x0e << MOVE_DEST_SHIFT)
+
+#define MOVE_OFFSET_SHIFT       8
+#define MOVE_OFFSET_MASK        (0xff << MOVE_OFFSET_SHIFT)
+
+#define MOVE_LEN_SHIFT          0
+#define MOVE_LEN_MASK           (0xff << MOVE_LEN_SHIFT)
+
+#define MOVELEN_MRSEL_SHIFT     0
+#define MOVELEN_MRSEL_MASK      (0x3 << MOVE_LEN_SHIFT)
+
+/*
+ * MATH Command Constructs
+ */
+
+#define MATH_IFB_SHIFT          26
+#define MATH_IFB_MASK           (1 << MATH_IFB_SHIFT)
+#define MATH_IFB                (1 << MATH_IFB_SHIFT)
+
+#define MATH_NFU_SHIFT          25
+#define MATH_NFU_MASK           (1 << MATH_NFU_SHIFT)
+#define MATH_NFU                (1 << MATH_NFU_SHIFT)
+
+#define MATH_STL_SHIFT          24
+#define MATH_STL_MASK           (1 << MATH_STL_SHIFT)
+#define MATH_STL                (1 << MATH_STL_SHIFT)
+
+/* Function selectors */
+#define MATH_FUN_SHIFT          20
+#define MATH_FUN_MASK           (0x0f << MATH_FUN_SHIFT)
+#define MATH_FUN_ADD            (0x00 << MATH_FUN_SHIFT)
+#define MATH_FUN_ADDC           (0x01 << MATH_FUN_SHIFT)
+#define MATH_FUN_SUB            (0x02 << MATH_FUN_SHIFT)
+#define MATH_FUN_SUBB           (0x03 << MATH_FUN_SHIFT)
+#define MATH_FUN_OR             (0x04 << MATH_FUN_SHIFT)
+#define MATH_FUN_AND            (0x05 << MATH_FUN_SHIFT)
+#define MATH_FUN_XOR            (0x06 << MATH_FUN_SHIFT)
+#define MATH_FUN_LSHIFT         (0x07 << MATH_FUN_SHIFT)
+#define MATH_FUN_RSHIFT         (0x08 << MATH_FUN_SHIFT)
+#define MATH_FUN_SHLD           (0x09 << MATH_FUN_SHIFT)
+#define MATH_FUN_ZBYT           (0x0a << MATH_FUN_SHIFT)
+
+/* Source 0 selectors */
+#define MATH_SRC0_SHIFT         16
+#define MATH_SRC0_MASK          (0x0f << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG0          (0x00 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG1          (0x01 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG2          (0x02 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_REG3          (0x03 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_IMM           (0x04 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_SEQINLEN      (0x08 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_SEQOUTLEN     (0x09 << MATH_SRC0_SHIFT)
+#define MATH_SRC0_VARSEQINLEN   (0x0a << MATH_SRC0_SHIFT)
+#define MATH_SRC0_VARSEQOUTLEN  (0x0b << MATH_SRC0_SHIFT)
+#define MATH_SRC0_ZERO          (0x0c << MATH_SRC0_SHIFT)
+
+/* Source 1 selectors */
+#define MATH_SRC1_SHIFT         12
+#define MATH_SRC1_MASK          (0x0f << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG0          (0x00 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG1          (0x01 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG2          (0x02 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_REG3          (0x03 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_IMM           (0x04 << MATH_SRC1_SHIFT)
+#define MATH_SRC1_INFIFO        (0x0a << MATH_SRC1_SHIFT)
+#define MATH_SRC1_OUTFIFO       (0x0b << MATH_SRC1_SHIFT)
+#define MATH_SRC1_ONE           (0x0c << MATH_SRC1_SHIFT)
+
+/* Destination selectors */
+#define MATH_DEST_SHIFT         8
+#define MATH_DEST_MASK          (0x0f << MATH_DEST_SHIFT)
+#define MATH_DEST_REG0          (0x00 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG1          (0x01 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG2          (0x02 << MATH_DEST_SHIFT)
+#define MATH_DEST_REG3          (0x03 << MATH_DEST_SHIFT)
+#define MATH_DEST_SEQINLEN      (0x08 << MATH_DEST_SHIFT)
+#define MATH_DEST_SEQOUTLEN     (0x09 << MATH_DEST_SHIFT)
+#define MATH_DEST_VARSEQINLEN   (0x0a << MATH_DEST_SHIFT)
+#define MATH_DEST_VARSEQOUTLEN  (0x0b << MATH_DEST_SHIFT)
+#define MATH_DEST_NONE          (0x0f << MATH_DEST_SHIFT)
+
+/* Length selectors */
+#define MATH_LEN_SHIFT          0
+#define MATH_LEN_MASK           (0x0f << MATH_LEN_SHIFT)
+#define MATH_LEN_1BYTE          0x01
+#define MATH_LEN_2BYTE          0x02
+#define MATH_LEN_4BYTE          0x04
+#define MATH_LEN_8BYTE          0x08
+
+/*
+ * JUMP Command Constructs
+ */
+
+#define JUMP_CLASS_SHIFT        25
+#define JUMP_CLASS_MASK		(3 << JUMP_CLASS_SHIFT)
+#define JUMP_CLASS_NONE		0
+#define JUMP_CLASS_CLASS1	(1 << JUMP_CLASS_SHIFT)
+#define JUMP_CLASS_CLASS2	(2 << JUMP_CLASS_SHIFT)
+#define JUMP_CLASS_BOTH		(3 << JUMP_CLASS_SHIFT)
+
+#define JUMP_JSL_SHIFT          24
+#define JUMP_JSL_MASK           (1 << JUMP_JSL_SHIFT)
+#define JUMP_JSL                (1 << JUMP_JSL_SHIFT)
+
+#define JUMP_TYPE_SHIFT         22
+#define JUMP_TYPE_MASK          (0x03 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_LOCAL         (0x00 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_NONLOCAL      (0x01 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_HALT          (0x02 << JUMP_TYPE_SHIFT)
+#define JUMP_TYPE_HALT_USER     (0x03 << JUMP_TYPE_SHIFT)
+
+#define JUMP_TEST_SHIFT         16
+#define JUMP_TEST_MASK          (0x03 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_ALL           (0x00 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_INVALL        (0x01 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_ANY           (0x02 << JUMP_TEST_SHIFT)
+#define JUMP_TEST_INVANY        (0x03 << JUMP_TEST_SHIFT)
+
+/* Condition codes. JSL bit is factored in */
+#define JUMP_COND_SHIFT         8
+#define JUMP_COND_MASK          (0x100ff << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_0          (0x80 << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_GCD_1      (0x40 << JUMP_COND_SHIFT)
+#define JUMP_COND_PK_PRIME      (0x20 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_N        (0x08 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_Z        (0x04 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_C        (0x02 << JUMP_COND_SHIFT)
+#define JUMP_COND_MATH_NV       (0x01 << JUMP_COND_SHIFT)
+
+#define JUMP_COND_JRP           ((0x80 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_SHRD          ((0x40 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_SELF          ((0x20 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_CALM          ((0x10 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NIP           ((0x08 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NIFP          ((0x04 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NOP           ((0x02 << JUMP_COND_SHIFT) | JUMP_JSL)
+#define JUMP_COND_NCP           ((0x01 << JUMP_COND_SHIFT) | JUMP_JSL)
+
+#define JUMP_OFFSET_SHIFT       0
+#define JUMP_OFFSET_MASK        (0xff << JUMP_OFFSET_SHIFT)
+
+/*
+ * NFIFO ENTRY
+ * Data Constructs
+ *
+ */
+#define NFIFOENTRY_DEST_SHIFT	30
+#define NFIFOENTRY_DEST_MASK	(3 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_DECO	(0 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_CLASS1	(1 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_CLASS2	(2 << NFIFOENTRY_DEST_SHIFT)
+#define NFIFOENTRY_DEST_BOTH	(3 << NFIFOENTRY_DEST_SHIFT)
+
+#define NFIFOENTRY_LC2_SHIFT	29
+#define NFIFOENTRY_LC2_MASK		(1 << NFIFOENTRY_LC2_SHIFT)
+#define NFIFOENTRY_LC2			(1 << NFIFOENTRY_LC2_SHIFT)
+
+#define NFIFOENTRY_LC1_SHIFT	28
+#define NFIFOENTRY_LC1_MASK		(1 << NFIFOENTRY_LC1_SHIFT)
+#define NFIFOENTRY_LC1			(1 << NFIFOENTRY_LC1_SHIFT)
+
+#define NFIFOENTRY_FC2_SHIFT	27
+#define NFIFOENTRY_FC2_MASK		(1 << NFIFOENTRY_FC2_SHIFT)
+#define NFIFOENTRY_FC2			(1 << NFIFOENTRY_FC2_SHIFT)
+
+#define NFIFOENTRY_FC1_SHIFT	26
+#define NFIFOENTRY_FC1_MASK		(1 << NFIFOENTRY_FC1_SHIFT)
+#define NFIFOENTRY_FC1			(1 << NFIFOENTRY_FC1_SHIFT)
+
+#define NFIFOENTRY_STYPE_SHIFT	24
+#define NFIFOENTRY_STYPE_MASK	(3 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_DFIFO	(0 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_OFIFO	(1 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_PAD	(2 << NFIFOENTRY_STYPE_SHIFT)
+#define NFIFOENTRY_STYPE_SNOOP	(3 << NFIFOENTRY_STYPE_SHIFT)
+
+#define NFIFOENTRY_DTYPE_SHIFT	20
+#define NFIFOENTRY_DTYPE_MASK	(0xF << NFIFOENTRY_DTYPE_SHIFT)
+
+#define NFIFOENTRY_DTYPE_SBOX      (0x0  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_AAD       (0x1  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_IV        (0x2  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_SAD       (0x3  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_ICV       (0xA  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_SKIP      (0xE  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_MSG       (0xF  << NFIFOENTRY_DTYPE_SHIFT)
+
+#define NFIFOENTRY_DTYPE_PK_A0     (0x0  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A1     (0x1  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A2     (0x2  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A3     (0x3  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B0     (0x4  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B1     (0x5  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B2     (0x6  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B3     (0x7  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_N      (0x8  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_E      (0x9  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_A      (0xC  << NFIFOENTRY_DTYPE_SHIFT)
+#define NFIFOENTRY_DTYPE_PK_B      (0xD  << NFIFOENTRY_DTYPE_SHIFT)
+
+
+#define NFIFOENTRY_BND_SHIFT	19
+#define NFIFOENTRY_BND_MASK		(1 << NFIFOENTRY_BND_SHIFT)
+#define NFIFOENTRY_BND			(1 << NFIFOENTRY_BND_SHIFT)
+
+#define NFIFOENTRY_PTYPE_SHIFT	16
+#define NFIFOENTRY_PTYPE_MASK	(0x7 << NFIFOENTRY_PTYPE_SHIFT)
+
+#define NFIFOENTRY_PTYPE_ZEROS         (0x0  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND_NOZEROS   (0x1  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_INCREMENT     (0x2  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND           (0x3  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_ZEROS_NZ      (0x4  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND_NZ_LZ     (0x5  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_N             (0x6  << NFIFOENTRY_PTYPE_SHIFT)
+#define NFIFOENTRY_PTYPE_RND_NZ_N      (0x7  << NFIFOENTRY_PTYPE_SHIFT)
+
+#define NFIFOENTRY_OC_SHIFT		15
+#define NFIFOENTRY_OC_MASK		(1 << NFIFOENTRY_OC_SHIFT)
+#define NFIFOENTRY_OC			(1 << NFIFOENTRY_OC_SHIFT)
+
+#define NFIFOENTRY_AST_SHIFT	14
+#define NFIFOENTRY_AST_MASK		(1 << NFIFOENTRY_OC_SHIFT)
+#define NFIFOENTRY_AST			(1 << NFIFOENTRY_OC_SHIFT)
+
+#define NFIFOENTRY_BM_SHIFT		11
+#define NFIFOENTRY_BM_MASK		(1 << NFIFOENTRY_BM_SHIFT)
+#define NFIFOENTRY_BM			(1 << NFIFOENTRY_BM_SHIFT)
+
+#define NFIFOENTRY_PS_SHIFT		10
+#define NFIFOENTRY_PS_MASK		(1 << NFIFOENTRY_PS_SHIFT)
+#define NFIFOENTRY_PS			(1 << NFIFOENTRY_PS_SHIFT)
+
+
+#define NFIFOENTRY_DLEN_SHIFT	0
+#define NFIFOENTRY_DLEN_MASK	(0xFFF << NFIFOENTRY_DLEN_SHIFT)
+
+#define NFIFOENTRY_PLEN_SHIFT	0
+#define NFIFOENTRY_PLEN_MASK	(0xFF << NFIFOENTRY_PLEN_SHIFT)
+
+/*
+ * PDB internal definitions
+ */
+
+/* IPSec ESP CBC Encap/Decap Options */
+#define PDBOPTS_ESPCBC_ARSNONE  0x00   /* no antireplay window              */
+#define PDBOPTS_ESPCBC_ARS32    0x40   /* 32-entry antireplay window        */
+#define PDBOPTS_ESPCBC_ARS64    0xc0   /* 64-entry antireplay window        */
+#define PDBOPTS_ESPCBC_IVSRC    0x20   /* IV comes from internal random gen */
+#define PDBOPTS_ESPCBC_ESN      0x10   /* extended sequence included        */
+#define PDBOPTS_ESPCBC_OUTFMT   0x08   /* output only decapsulation (decap) */
+#define PDBOPTS_ESPCBC_IPHDRSRC 0x08   /* IP header comes from PDB (encap)  */
+#define PDBOPTS_ESPCBC_INCIPHDR 0x04   /* Prepend IP header to output frame */
+#define PDBOPTS_ESPCBC_IPVSN    0x02   /* process IPv6 header               */
+#define PDBOPTS_ESPCBC_TUNNEL   0x01   /* tunnel mode next-header byte      */
+
+#endif /* DESC_H */
--- u-boot-2014.07/include/fsl_dspi.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/include/fsl_dspi.h	2022-05-09 14:06:24.045116527 -0700
@@ -0,0 +1,142 @@
+/*
+ * Freescale DSPI Module Defines
+ *
+ * Copyright (C) 2004-2007, 2013 Freescale Semiconductor, Inc.
+ * TsiChung Liew (Tsi-Chung.Liew@freescale.com)
+ * Chao Fu (B44548@freesacle.com)
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DSPI_H__
+#define __DSPI_H__
+
+/* DMA Serial Peripheral Interface (DSPI) */
+typedef struct dspi {
+	u32 mcr;	/* 0x00 */
+	u32 resv0;	/* 0x04 */
+	u32 tcr;	/* 0x08 */
+	u32 ctar[8];	/* 0x0C - 0x28 */
+	u32 sr;		/* 0x2C */
+	u32 irsr;	/* 0x30 */
+	u32 tfr;	/* 0x34 - PUSHR */
+	u32 rfr;	/* 0x38 - POPR */
+#ifdef CONFIG_MCF547x_8x
+	u32 tfdr[4];	/* 0x3C */
+	u8 resv2[0x30];	/* 0x40 */
+	u32 rfdr[4];	/* 0x7C */
+#else
+	u32 tfdr[16];	/* 0x3C */
+	u32 rfdr[16];	/* 0x7C */
+#endif
+} dspi_t;
+
+/* Module configuration */
+#define DSPI_MCR_MSTR			(0x80000000)
+#define DSPI_MCR_CSCK			(0x40000000)
+#define DSPI_MCR_DCONF(x)		(((x)&0x03)<<28)
+#define DSPI_MCR_FRZ			(0x08000000)
+#define DSPI_MCR_MTFE			(0x04000000)
+#define DSPI_MCR_PCSSE			(0x02000000)
+#define DSPI_MCR_ROOE			(0x01000000)
+#define DSPI_MCR_CSIS7			(0x00800000)
+#define DSPI_MCR_CSIS6			(0x00400000)
+#define DSPI_MCR_CSIS5			(0x00200000)
+#define DSPI_MCR_CSIS4			(0x00100000)
+#define DSPI_MCR_CSIS3			(0x00080000)
+#define DSPI_MCR_CSIS2			(0x00040000)
+#define DSPI_MCR_CSIS1			(0x00020000)
+#define DSPI_MCR_CSIS0			(0x00010000)
+#define DSPI_MCR_MDIS			(0x00004000)
+#define DSPI_MCR_DTXF			(0x00002000)
+#define DSPI_MCR_DRXF			(0x00001000)
+#define DSPI_MCR_CTXF			(0x00000800)
+#define DSPI_MCR_CRXF			(0x00000400)
+#define DSPI_MCR_SMPL_PT(x)		(((x)&0x03)<<8)
+#define DSPI_MCR_HALT			(0x00000001)
+
+/* Transfer count */
+#define DSPI_TCR_SPI_TCNT(x)		(((x)&0x0000FFFF)<<16)
+
+/* Clock and transfer attributes */
+#define DSPI_CTAR_DBR			(0x80000000)
+#define DSPI_CTAR_TRSZ(x)		(((x)&0x0F)<<27)
+#define DSPI_CTAR_CPOL			(0x04000000)
+#define DSPI_CTAR_CPHA			(0x02000000)
+#define DSPI_CTAR_LSBFE			(0x01000000)
+#define DSPI_CTAR_PCSSCK(x)		(((x)&0x03)<<22)
+#define DSPI_CTAR_PCSSCK_7CLK		(0x00A00000)
+#define DSPI_CTAR_PCSSCK_5CLK		(0x00800000)
+#define DSPI_CTAR_PCSSCK_3CLK		(0x00400000)
+#define DSPI_CTAR_PCSSCK_1CLK		(0x00000000)
+#define DSPI_CTAR_PASC(x)		(((x)&0x03)<<20)
+#define DSPI_CTAR_PASC_7CLK		(0x00300000)
+#define DSPI_CTAR_PASC_5CLK		(0x00200000)
+#define DSPI_CTAR_PASC_3CLK		(0x00100000)
+#define DSPI_CTAR_PASC_1CLK		(0x00000000)
+#define DSPI_CTAR_PDT(x)		(((x)&0x03)<<18)
+#define DSPI_CTAR_PDT_7CLK		(0x000A0000)
+#define DSPI_CTAR_PDT_5CLK		(0x00080000)
+#define DSPI_CTAR_PDT_3CLK		(0x00040000)
+#define DSPI_CTAR_PDT_1CLK		(0x00000000)
+#define DSPI_CTAR_PBR(x)		(((x)&0x03)<<16)
+#define DSPI_CTAR_PBR_7CLK		(0x00030000)
+#define DSPI_CTAR_PBR_5CLK		(0x00020000)
+#define DSPI_CTAR_PBR_3CLK		(0x00010000)
+#define DSPI_CTAR_PBR_1CLK		(0x00000000)
+#define DSPI_CTAR_CSSCK(x)		(((x)&0x0F)<<12)
+#define DSPI_CTAR_ASC(x)		(((x)&0x0F)<<8)
+#define DSPI_CTAR_DT(x)			(((x)&0x0F)<<4)
+#define DSPI_CTAR_BR(x)			(((x)&0x0F))
+
+/* Status */
+#define DSPI_SR_TCF			(0x80000000)
+#define DSPI_SR_TXRXS			(0x40000000)
+#define DSPI_SR_EOQF			(0x10000000)
+#define DSPI_SR_TFUF			(0x08000000)
+#define DSPI_SR_TFFF			(0x02000000)
+#define DSPI_SR_RFOF			(0x00080000)
+#define DSPI_SR_RFDF			(0x00020000)
+#define DSPI_SR_TXCTR(x)		(((x)&0x0F)<<12)
+#define DSPI_SR_TXPTR(x)		(((x)&0x0F)<<8)
+#define DSPI_SR_RXCTR(x)		(((x)&0x0F)<<4)
+#define DSPI_SR_RXPTR(x)		(((x)&0x0F))
+
+/* DMA/interrupt request selct and enable */
+#define DSPI_IRSR_TCFE			(0x80000000)
+#define DSPI_IRSR_EOQFE			(0x10000000)
+#define DSPI_IRSR_TFUFE			(0x08000000)
+#define DSPI_IRSR_TFFFE			(0x02000000)
+#define DSPI_IRSR_TFFFS			(0x01000000)
+#define DSPI_IRSR_RFOFE			(0x00080000)
+#define DSPI_IRSR_RFDFE			(0x00020000)
+#define DSPI_IRSR_RFDFS			(0x00010000)
+
+/* Transfer control - 32-bit access */
+#define DSPI_TFR_CONT			(0x80000000)
+#define DSPI_TFR_CTAS(x)		(((x)&0x07)<<12)
+#define DSPI_TFR_EOQ			(0x08000000)
+#define DSPI_TFR_CTCNT			(0x04000000)
+#define DSPI_TFR_CS7			(0x00800000)
+#define DSPI_TFR_CS6			(0x00400000)
+#define DSPI_TFR_CS5			(0x00200000)
+#define DSPI_TFR_CS4			(0x00100000)
+#define DSPI_TFR_CS3			(0x00080000)
+#define DSPI_TFR_CS2			(0x00040000)
+#define DSPI_TFR_CS1			(0x00020000)
+#define DSPI_TFR_CS0			(0x00010000)
+
+/* Transfer Fifo */
+#define DSPI_TFR_TXDATA(x)		(((x)&0xFFFF))
+
+/* Bit definitions and macros for DRFR */
+#define DSPI_RFR_RXDATA(x)		(((x)&0xFFFF))
+
+/* Bit definitions and macros for DTFDR group */
+#define DSPI_TFDR_TXDATA(x)		(((x)&0x0000FFFF))
+#define DSPI_TFDR_TXCMD(x)		(((x)&0x0000FFFF)<<16)
+
+/* Bit definitions and macros for DRFDR group */
+#define DSPI_RFDR_RXDATA(x)		(((x)&0x0000FFFF))
+
+#endif				/* __DSPI_H__ */
--- u-boot-2014.07/doc/README.fsl-dpaa.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/doc/README.fsl-dpaa	2022-05-09 14:06:23.629133352 -0700
@@ -0,0 +1,10 @@
+This file documents Freescale DPAA-specific options.
+
+FMan (Frame Manager)
+  - CONFIG_FSL_FM_10GEC_REGULAR_NOTATION
+	on SoCs earlier(e.g. T4240, T2080), the notation between 10GEC and MAC as below:
+		10GEC1->MAC9, 10GEC2->MAC10, 10GEC3->MAC1, 10GEC4->MAC2
+	on SoCs later(e.g. T1024, etc), the notation between 10GEC and MAC as below:
+		10GEC1->MAC1, 10GEC2->MAC2
+	so we introduce CONFIG_FSL_FM_10GEC_REGULAR_NOTATION to identify the new SoCs on
+	which 10GEC enumeration is consistent with MAC enumeration.
--- u-boot-2014.07/doc/README.fsl-esdhc.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2014.07/doc/README.fsl-esdhc	2022-05-09 14:06:23.629133352 -0700
@@ -0,0 +1,5 @@
+CONFIG_SYS_FSL_ESDHC_LE means ESDHC IP is in little-endian mode.
+CONFIG_SYS_FSL_ESDHC_BE means ESDHC IP is in big-endian mode.
+
+Accessing ESDHC registers can be determined by ESDHC IP's endian
+mode or processor's endian mode.
