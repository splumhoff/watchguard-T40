WatchGuard patches to sources for cavecreek-1.0.3-42 as of
Mon May  9 13:48:28 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/qat_direct/src/adf_process_proxy.c.orig	2022-05-09 13:48:21.933011099 -0700
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/qat_direct/src/adf_process_proxy.c	2022-05-09 13:48:22.500988043 -0700
@@ -52,7 +52,9 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <pthread.h>
+#ifndef	CONFIG_WG_PLATFORM
 #include <libudev.h>
+#endif
 
 #include "cpa.h"
 #include "icp_accel_devices.h"
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/qat_direct/src/uio_user_utils.c.orig	2022-05-09 13:48:21.953010287 -0700
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/qat_direct/src/uio_user_utils.c	2022-05-09 13:48:22.508987719 -0700
@@ -40,7 +40,9 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <unistd.h>
+#ifndef	CONFIG_WG_PLATFORM
 #include <libudev.h>
+#endif
 
 #include "cpa.h"
 #include "uio_user_utils.h"
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/Makefile.orig	2022-05-09 13:48:21.857014184 -0700
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/Makefile	2022-05-09 13:48:22.448990154 -0700
@@ -177,7 +177,8 @@
 	(cp $$dir/build/$(ICP_OS)/$(ICP_OS_LEVEL)/*.o $(ICP_BUILD_OUTPUT_DIR) ; ) \
 	done ;\
 	cd $(ICP_FINAL_OUTPUT_DIR);\
-	cmd="$(LINKER) $(LIB_SHARED_FLAGS) -o $(LIB_SHARED) -lc $(ADDITIONAL_OBJECTS) $(ADDITIONAL_LIBS) *.o -lpthread -ludev \
+#	cmd="$(LINKER) $(LIB_SHARED_FLAGS) -o $(LIB_SHARED) -lc $(ADDITIONAL_OBJECTS) $(ADDITIONAL_LIBS) *.o -lpthread -ludev \
+	cmd="$(LINKER) $(LIB_SHARED_FLAGS) -o $(LIB_SHARED) -lc $(ADDITIONAL_OBJECTS) $(ADDITIONAL_LIBS) *.o -lpthread \
 		-Bstatic -L$(ADF_DIR)/src/build/$(ICP_OS)/$(ICP_OS_LEVEL) -ladf -L$(OSAL_DIR)/src/build/$(ICP_OS)/$(ICP_OS_LEVEL)/ -losal -Bdynamic"; \
 	echo "$$cmd"; \
 	$$cmd
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/common/utils/lac_mem_pools.c.orig	2022-05-09 13:48:21.917011748 -0700
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/common/utils/lac_mem_pools.c	2022-05-09 13:48:22.496988206 -0700
@@ -306,7 +306,15 @@
     pMemBlkCurrent = pop(&pPoolID->stack);
     if (NULL == pMemBlkCurrent)
     {
+#ifdef CONFIG_WG_PLATFORM // WG:JB FBX-7483
+#ifdef __KERNEL__
+        return in_atomic() ? NULL : (void*)CPA_STATUS_RETRY;
+#else
         return (void*)CPA_STATUS_RETRY;
+#endif
+#else
+        return (void*)CPA_STATUS_RETRY;
+#endif
     }
     __sync_sub_and_fetch(&pPoolID->availBlks, 1);
     pMemBlkCurrent->isInUse = CPA_TRUE;
--- cavecreek-1.0.3-42/quickassist/utilities/libusdm_drv/linux/kernel_space/qae_mem_drv.c.orig	2022-05-09 13:48:22.340994538 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/libusdm_drv/linux/kernel_space/qae_mem_drv.c	2022-05-09 13:48:22.752977814 -0700
@@ -82,7 +82,11 @@
 #include <linux/seq_file.h>
 #include <linux/nodemask.h>
 
+#ifdef	CONFIG_WG_KERNEL_4_14
+#include <linux/uaccess.h>
+#else
 #include <asm/uaccess.h>
+#endif
 #include <linux/string.h>
 #include <asm/io.h>
 
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/swap.hpp.orig	2022-05-09 13:48:22.340994538 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/swap.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,17 +0,0 @@
-/*
- * Copyright (c) 2014 Glen Fernandes
- *
- * Distributed under the Boost Software License, Version 1.0. (See
- * accompanying file LICENSE_1_0.txt or copy at
- * http://www.boost.org/LICENSE_1_0.txt)
- */
-
-#ifndef BOOST_SWAP_HPP
-#define BOOST_SWAP_HPP
-
-// The header file at this path is deprecated;
-// use boost/core/swap.hpp instead.
-
-#include "core/swap.hpp"
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/stream_translator.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/stream_translator.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,229 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-
-#ifndef BOOST_PROPERTY_TREE_STREAM_TRANSLATOR_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_STREAM_TRANSLATOR_HPP_INCLUDED
-
-#include "ptree_fwd.hpp"
-
-#include <boost/optional.hpp>
-#include <boost/optional/optional_io.hpp>
-#include <boost/utility/enable_if.hpp>
-#include <boost/type_traits/decay.hpp>
-#include <boost/type_traits/integral_constant.hpp>
-#include <sstream>
-#include <string>
-#include <locale>
-#include <limits>
-
-namespace boost { namespace property_tree
-{
-
-    template <typename Ch, typename Traits, typename E, typename Enabler = void>
-    struct customize_stream
-    {
-        static void insert(std::basic_ostream<Ch, Traits>& s, const E& e) {
-            s << e;
-        }
-        static void extract(std::basic_istream<Ch, Traits>& s, E& e) {
-            s >> e;
-            if(!s.eof()) {
-                s >> std::ws;
-            }
-        }
-    };
-
-    // No whitespace skipping for single characters.
-    template <typename Ch, typename Traits>
-    struct customize_stream<Ch, Traits, Ch, void>
-    {
-        static void insert(std::basic_ostream<Ch, Traits>& s, Ch e) {
-            s << e;
-        }
-        static void extract(std::basic_istream<Ch, Traits>& s, Ch& e) {
-            s.unsetf(std::ios_base::skipws);
-            s >> e;
-        }
-    };
-
-    // Ugly workaround for numeric_traits that don't have members when not
-    // specialized, e.g. MSVC.
-    namespace detail
-    {
-        template <bool is_specialized>
-        struct is_inexact_impl
-        {
-            template <typename T>
-            struct test
-            {
-                typedef boost::false_type type;
-            };
-        };
-        template <>
-        struct is_inexact_impl<true>
-        {
-            template <typename T>
-            struct test
-            {
-              typedef boost::integral_constant<bool,
-                  !std::numeric_limits<T>::is_exact> type;
-            };
-        };
-
-        template <typename F>
-        struct is_inexact
-        {
-            typedef typename boost::decay<F>::type decayed;
-            typedef typename is_inexact_impl<
-                std::numeric_limits<decayed>::is_specialized
-            >::BOOST_NESTED_TEMPLATE test<decayed>::type type;
-            static const bool value = type::value;
-        };
-    }
-
-    template <typename Ch, typename Traits, typename F>
-    struct customize_stream<Ch, Traits, F,
-        typename boost::enable_if< detail::is_inexact<F> >::type
-    >
-    {
-        static void insert(std::basic_ostream<Ch, Traits>& s, const F& e) {
-#ifndef BOOST_NO_CXX11_NUMERIC_LIMITS 
-            s.precision(std::numeric_limits<F>::max_digits10); 
-#else 
-            s.precision(std::numeric_limits<F>::digits10 + 2); 
-#endif 
-            s << e;
-        }
-        static void extract(std::basic_istream<Ch, Traits>& s, F& e) {
-            s >> e;
-            if(!s.eof()) {
-                s >> std::ws;
-            }
-        }
-    };
-
-    template <typename Ch, typename Traits>
-    struct customize_stream<Ch, Traits, bool, void>
-    {
-        static void insert(std::basic_ostream<Ch, Traits>& s, bool e) {
-            s.setf(std::ios_base::boolalpha);
-            s << e;
-        }
-        static void extract(std::basic_istream<Ch, Traits>& s, bool& e) {
-            s >> e;
-            if(s.fail()) {
-                // Try again in word form.
-                s.clear();
-                s.setf(std::ios_base::boolalpha);
-                s >> e;
-            }
-            if(!s.eof()) {
-                s >> std::ws;
-            }
-        }
-    };
-
-    template <typename Ch, typename Traits>
-    struct customize_stream<Ch, Traits, signed char, void>
-    {
-        static void insert(std::basic_ostream<Ch, Traits>& s, signed char e) {
-            s << (int)e;
-        }
-        static void extract(std::basic_istream<Ch, Traits>& s, signed char& e) {
-            int i;
-            s >> i;
-            // out of range?
-            if(i > (std::numeric_limits<signed char>::max)() ||
-                i < (std::numeric_limits<signed char>::min)())
-            {
-                s.clear(); // guarantees eof to be unset
-                e = 0;
-                s.setstate(std::ios_base::badbit);
-                return;
-            }
-            e = (signed char)i;
-            if(!s.eof()) {
-                s >> std::ws;
-            }
-        }
-    };
-
-    template <typename Ch, typename Traits>
-    struct customize_stream<Ch, Traits, unsigned char, void>
-    {
-        static void insert(std::basic_ostream<Ch, Traits>& s, unsigned char e) {
-            s << (unsigned)e;
-        }
-        static void extract(std::basic_istream<Ch,Traits>& s, unsigned char& e){
-            unsigned i;
-            s >> i;
-            // out of range?
-            if(i > (std::numeric_limits<unsigned char>::max)()) {
-                s.clear(); // guarantees eof to be unset
-                e = 0;
-                s.setstate(std::ios_base::badbit);
-                return;
-            }
-            e = (unsigned char)i;
-            if(!s.eof()) {
-                s >> std::ws;
-            }
-        }
-    };
-
-    /// Implementation of Translator that uses the stream overloads.
-    template <typename Ch, typename Traits, typename Alloc, typename E>
-    class stream_translator
-    {
-        typedef customize_stream<Ch, Traits, E> customized;
-    public:
-        typedef std::basic_string<Ch, Traits, Alloc> internal_type;
-        typedef E external_type;
-
-        explicit stream_translator(std::locale loc = std::locale())
-            : m_loc(loc)
-        {}
-
-        boost::optional<E> get_value(const internal_type &v) {
-            std::basic_istringstream<Ch, Traits, Alloc> iss(v);
-            iss.imbue(m_loc);
-            E e;
-            customized::extract(iss, e);
-            if(iss.fail() || iss.bad() || iss.get() != Traits::eof()) {
-                return boost::optional<E>();
-            }
-            return e;
-        }
-        boost::optional<internal_type> put_value(const E &v) {
-            std::basic_ostringstream<Ch, Traits, Alloc> oss;
-            oss.imbue(m_loc);
-            customized::insert(oss, v);
-            if(oss) {
-                return oss.str();
-            }
-            return boost::optional<internal_type>();
-        }
-
-    private:
-        std::locale m_loc;
-    };
-
-    // This is the default translator when basic_string is the internal type.
-    // Unless the external type is also basic_string, in which case
-    // id_translator takes over.
-    template <typename Ch, typename Traits, typename Alloc, typename E>
-    struct translator_between<std::basic_string<Ch, Traits, Alloc>, E>
-    {
-        typedef stream_translator<Ch, Traits, Alloc, E> type;
-    };
-
-}}
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/property_tree/ptree.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/property_tree/ptree.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,518 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-
-#ifndef BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
-
-#include <boost/property_tree/ptree_fwd.hpp>
-#include <boost/property_tree/string_path.hpp>
-#include <boost/property_tree/stream_translator.hpp>
-#include <boost/property_tree/exceptions.hpp>
-#include <boost/property_tree/detail/ptree_utils.hpp>
-
-#include <boost/multi_index_container.hpp>
-#include <boost/multi_index/indexed_by.hpp>
-#include <boost/multi_index/sequenced_index.hpp>
-#include <boost/multi_index/ordered_index.hpp>
-#include <boost/multi_index/member.hpp>
-#include <boost/utility/enable_if.hpp>
-#include <boost/throw_exception.hpp>
-#include <boost/optional.hpp>
-#include <utility>                  // for std::pair
-
-namespace boost { namespace property_tree
-{
-
-    /**
-     * Property tree main structure. A property tree is a hierarchical data
-     * structure which has one element of type @p Data in each node, as well
-     * as an ordered sequence of sub-nodes, which are additionally identified
-     * by a non-unique key of type @p Key.
-     *
-     * Key equivalency is defined by @p KeyCompare, a predicate defining a
-     * strict weak ordering.
-     *
-     * Property tree defines a Container-like interface to the (key-node) pairs
-     * of its direct sub-nodes. The iterators are bidirectional. The sequence
-     * of nodes is held in insertion order, not key order.
-     */
-    template<class Key, class Data, class KeyCompare>
-    class basic_ptree
-    {
-#if defined(BOOST_PROPERTY_TREE_DOXYGEN_INVOKED)
-    public:
-#endif
-        // Internal types
-        /**
-         * Simpler way to refer to this basic_ptree\<C,K,P,A\> type.
-         * Note that this is private, and made public only for doxygen.
-         */
-        typedef basic_ptree<Key, Data, KeyCompare> self_type;
-
-    public:
-        // Basic types
-        typedef Key                                  key_type;
-        typedef Data                                 data_type;
-        typedef KeyCompare                           key_compare;
-
-        // Container view types
-        typedef std::pair<const Key, self_type>      value_type;
-        typedef std::size_t                          size_type;
-
-        // The problem with the iterators is that I can't make them complete
-        // until the container is complete. Sucks. Especially for the reverses.
-        class iterator;
-        class const_iterator;
-        class reverse_iterator;
-        class const_reverse_iterator;
-
-        // Associative view types
-        class assoc_iterator;
-        class const_assoc_iterator;
-
-        // Property tree view types
-        typedef typename path_of<Key>::type          path_type;
-
-
-        // The big five
-
-        /** Creates a node with no children and default-constructed data. */
-        basic_ptree();
-        /** Creates a node with no children and a copy of the given data. */
-        explicit basic_ptree(const data_type &data);
-        basic_ptree(const self_type &rhs);
-        ~basic_ptree();
-        /** Basic guarantee only. */
-        self_type &operator =(const self_type &rhs);
-
-        /** Swap with other tree. Only constant-time and nothrow if the
-         * data type's swap is.
-         */
-        void swap(self_type &rhs);
-
-        // Container view functions
-
-        /** The number of direct children of this node. */
-        size_type size() const;
-        size_type max_size() const;
-        /** Whether there are any direct children. */
-        bool empty() const;
-
-        iterator begin();
-        const_iterator begin() const;
-        iterator end();
-        const_iterator end() const;
-        reverse_iterator rbegin();
-        const_reverse_iterator rbegin() const;
-        reverse_iterator rend();
-        const_reverse_iterator rend() const;
-
-        value_type &front();
-        const value_type &front() const;
-        value_type &back();
-        const value_type &back() const;
-
-        /** Insert a copy of the given tree with its key just before the given
-         * position in this node. This operation invalidates no iterators.
-         * @return An iterator to the newly created child.
-         */
-        iterator insert(iterator where, const value_type &value);
-
-        /** Range insert. Equivalent to:
-         * @code
-         * for(; first != last; ++first) insert(where, *first);
-         * @endcode
-         */
-        template<class It> void insert(iterator where, It first, It last);
-
-        /** Erase the child pointed at by the iterator. This operation
-         * invalidates the given iterator, as well as its equivalent
-         * assoc_iterator.
-         * @return A valid iterator pointing to the element after the erased.
-         */
-        iterator erase(iterator where);
-
-        /** Range erase. Equivalent to:
-         * @code
-         * while(first != last;) first = erase(first);
-         * @endcode
-         */
-        iterator erase(iterator first, iterator last);
-
-        /** Equivalent to insert(begin(), value). */
-        iterator push_front(const value_type &value);
-
-        /** Equivalent to insert(end(), value). */
-        iterator push_back(const value_type &value);
-
-        /** Equivalent to erase(begin()). */
-        void pop_front();
-
-        /** Equivalent to erase(boost::prior(end())). */
-        void pop_back();
-
-        /** Reverses the order of direct children in the property tree. */
-        void reverse();
-
-        /** Sorts the direct children of this node according to the predicate.
-         * The predicate is passed the whole pair of key and child.
-         */
-        template<class Compare> void sort(Compare comp);
-
-        /** Sorts the direct children of this node according to key order. */
-        void sort();
-
-        // Equality
-
-        /** Two property trees are the same if they have the same data, the keys
-         * and order of their children are the same, and the children compare
-         * equal, recursively.
-         */
-        bool operator ==(const self_type &rhs) const;
-        bool operator !=(const self_type &rhs) const;
-
-        // Associative view
-
-        /** Returns an iterator to the first child, in key order. */
-        assoc_iterator ordered_begin();
-        /** Returns an iterator to the first child, in key order. */
-        const_assoc_iterator ordered_begin() const;
-
-        /** Returns the not-found iterator. Equivalent to end() in a real
-         * associative container.
-         */
-        assoc_iterator not_found();
-        /** Returns the not-found iterator. Equivalent to end() in a real
-         * associative container.
-         */
-        const_assoc_iterator not_found() const;
-
-        /** Find a child with the given key, or not_found() if there is none.
-         * There is no guarantee about which child is returned if multiple have
-         * the same key.
-         */
-        assoc_iterator find(const key_type &key);
-
-        /** Find a child with the given key, or not_found() if there is none.
-         * There is no guarantee about which child is returned if multiple have
-         * the same key.
-         */
-        const_assoc_iterator find(const key_type &key) const;
-
-        /** Find the range of children that have the given key. */
-        std::pair<assoc_iterator, assoc_iterator>
-            equal_range(const key_type &key);
-
-        /** Find the range of children that have the given key. */
-        std::pair<const_assoc_iterator, const_assoc_iterator>
-            equal_range(const key_type &key) const;
-
-        /** Count the number of direct children with the given key. */
-        size_type count(const key_type &key) const;
-
-        /** Erase all direct children with the given key and return the count.
-         */
-        size_type erase(const key_type &key);
-
-        /** Get the iterator that points to the same element as the argument.
-         * @note A valid assoc_iterator range (a, b) does not imply that
-         *       (to_iterator(a), to_iterator(b)) is a valid range.
-         */
-        iterator to_iterator(assoc_iterator it);
-
-        /** Get the iterator that points to the same element as the argument.
-         * @note A valid const_assoc_iterator range (a, b) does not imply that
-         *       (to_iterator(a), to_iterator(b)) is a valid range.
-         */
-        const_iterator to_iterator(const_assoc_iterator it) const;
-
-        // Property tree view
-
-        /** Reference to the actual data in this node. */
-        data_type &data();
-
-        /** Reference to the actual data in this node. */
-        const data_type &data() const;
-
-        /** Clear this tree completely, of both data and children. */
-        void clear();
-
-        /** Get the child at the given path, or throw @c ptree_bad_path.
-         * @note Depending on the path, the result at each level may not be
-         *       completely deterministic, i.e. if the same key appears multiple
-         *       times, which child is chosen is not specified. This can lead
-         *       to the path not being resolved even though there is a
-         *       descendant with this path. Example:
-         * @code
-         *   a -> b -> c
-         *     -> b
-         * @endcode
-         *       The path "a.b.c" will succeed if the resolution of "b" chooses
-         *       the first such node, but fail if it chooses the second.
-         */
-        self_type &get_child(const path_type &path);
-
-        /** Get the child at the given path, or throw @c ptree_bad_path. */
-        const self_type &get_child(const path_type &path) const;
-
-        /** Get the child at the given path, or return @p default_value. */
-        self_type &get_child(const path_type &path, self_type &default_value);
-
-        /** Get the child at the given path, or return @p default_value. */
-        const self_type &get_child(const path_type &path,
-                                   const self_type &default_value) const;
-
-        /** Get the child at the given path, or return boost::null. */
-        optional<self_type &> get_child_optional(const path_type &path);
-
-        /** Get the child at the given path, or return boost::null. */
-        optional<const self_type &>
-          get_child_optional(const path_type &path) const;
-
-        /** Set the node at the given path to the given value. Create any
-         * missing parents. If the node at the path already exists, replace it.
-         * @return A reference to the inserted subtree.
-         * @note Because of the way paths work, it is not generally guaranteed
-         *       that a node newly created can be accessed using the same path.
-         * @note If the path could refer to multiple nodes, it is unspecified
-         *       which one gets replaced.
-         */
-        self_type &put_child(const path_type &path, const self_type &value);
-
-        /** Add the node at the given path. Create any missing parents. If there
-         * already is a node at the path, add another one with the same key.
-         * @param path Path to the child. The last fragment must not have an
-         *             index.
-         * @return A reference to the inserted subtree.
-         * @note Because of the way paths work, it is not generally guaranteed
-         *       that a node newly created can be accessed using the same path.
-         */
-        self_type &add_child(const path_type &path, const self_type &value);
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the supplied translator.
-         * @throw ptree_bad_data if the conversion fails.
-         */
-        template<class Type, class Translator>
-        typename boost::enable_if<detail::is_translator<Translator>, Type>::type
-        get_value(Translator tr) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the default translator.
-         * @throw ptree_bad_data if the conversion fails.
-         */
-        template<class Type>
-        Type get_value() const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the supplied translator. Return @p default_value
-         * if this fails.
-         */
-        template<class Type, class Translator>
-        Type get_value(const Type &default_value, Translator tr) const;
-
-        /** Make get_value do the right thing for string literals. */
-        template <class Ch, class Translator>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get_value(const Ch *default_value, Translator tr) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the default translator. Return @p default_value
-         * if this fails.
-         */
-        template<class Type>
-        typename boost::disable_if<detail::is_translator<Type>, Type>::type
-        get_value(const Type &default_value) const;
-
-        /** Make get_value do the right thing for string literals. */
-        template <class Ch>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get_value(const Ch *default_value) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the supplied translator. Return boost::null if
-         * this fails.
-         */
-        template<class Type, class Translator>
-        optional<Type> get_value_optional(Translator tr) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the default translator. Return boost::null if
-         * this fails.
-         */
-        template<class Type>
-        optional<Type> get_value_optional() const;
-
-        /** Replace the value at this node with the given value, translated
-         * to the tree's data type using the supplied translator.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type, class Translator>
-        void put_value(const Type &value, Translator tr);
-
-        /** Replace the value at this node with the given value, translated
-         * to the tree's data type using the default translator.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type>
-        void put_value(const Type &value);
-
-        /** Shorthand for get_child(path).get_value(tr). */
-        template<class Type, class Translator>
-        typename boost::enable_if<detail::is_translator<Translator>, Type>::type
-        get(const path_type &path, Translator tr) const;
-
-        /** Shorthand for get_child(path).get_value\<Type\>(). */
-        template<class Type>
-        Type get(const path_type &path) const;
-
-        /** Shorthand for get_child(path, empty_ptree())
-         *                    .get_value(default_value, tr).
-         * That is, return the translated value if possible, and the default
-         * value if the node doesn't exist or conversion fails.
-         */
-        template<class Type, class Translator>
-        Type get(const path_type &path,
-                 const Type &default_value,
-                 Translator tr) const;
-
-        /** Make get do the right thing for string literals. */
-        template <class Ch, class Translator>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get(const path_type &path, const Ch *default_value, Translator tr)const;
-
-        /** Shorthand for get_child(path, empty_ptree())
-         *                    .get_value(default_value).
-         * That is, return the translated value if possible, and the default
-         * value if the node doesn't exist or conversion fails.
-         */
-        template<class Type>
-        typename boost::disable_if<detail::is_translator<Type>, Type>::type
-        get(const path_type &path, const Type &default_value) const;
-
-        /** Make get do the right thing for string literals. */
-        template <class Ch>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get(const path_type &path, const Ch *default_value) const;
-
-        /** Shorthand for:
-         * @code
-         * if(optional\<self_type&\> node = get_child_optional(path))
-         *   return node->get_value_optional(tr);
-         * return boost::null;
-         * @endcode
-         * That is, return the value if it exists and can be converted, or nil.
-        */
-        template<class Type, class Translator>
-        optional<Type> get_optional(const path_type &path, Translator tr) const;
-
-        /** Shorthand for:
-         * @code
-         * if(optional\<const self_type&\> node = get_child_optional(path))
-         *   return node->get_value_optional();
-         * return boost::null;
-         * @endcode
-         * That is, return the value if it exists and can be converted, or nil.
-        */
-        template<class Type>
-        optional<Type> get_optional(const path_type &path) const;
-
-        /** Set the value of the node at the given path to the supplied value,
-         * translated to the tree's data type. If the node doesn't exist, it is
-         * created, including all its missing parents.
-         * @return The node that had its value changed.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type, class Translator>
-        self_type &put(const path_type &path, const Type &value, Translator tr);
-
-        /** Set the value of the node at the given path to the supplied value,
-         * translated to the tree's data type. If the node doesn't exist, it is
-         * created, including all its missing parents.
-         * @return The node that had its value changed.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type>
-        self_type &put(const path_type &path, const Type &value);
-
-        /** If the node identified by the path does not exist, create it,
-         * including all its missing parents.
-         * If the node already exists, add a sibling with the same key.
-         * Set the newly created node's value to the given paremeter,
-         * translated with the supplied translator.
-         * @param path Path to the child. The last fragment must not have an
-         *             index.
-         * @param value The value to add.
-         * @param tr The translator to use.
-         * @return The node that was added.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type, class Translator>
-        self_type &add(const path_type &path,
-                       const Type &value,
-                       Translator tr);
-
-        /** If the node identified by the path does not exist, create it,
-         * including all its missing parents.
-         * If the node already exists, add a sibling with the same key.
-         * Set the newly created node's value to the given paremeter,
-         * translated with the supplied translator.
-         * @param path Path to the child. The last fragment must not have an
-         *             index.
-         * @param value The value to add.
-         * @return The node that was added.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type>
-        self_type &add(const path_type &path, const Type &value);
-
-    private:
-        // Hold the data of this node
-        data_type m_data;
-        // Hold the children - this is a void* because we can't complete the
-        // container type within the class.
-        void* m_children;
-
-        // Getter tree-walk. Not const-safe! Gets the node the path refers to,
-        // or null. Destroys p's value.
-        self_type* walk_path(path_type& p) const;
-
-        // Modifer tree-walk. Gets the parent of the node referred to by the
-        // path, creating nodes as necessary. p is the path to the remaining
-        // child.
-        self_type& force_path(path_type& p);
-
-        // This struct contains typedefs for the concrete types.
-        struct subs;
-        friend struct subs;
-        friend class iterator;
-        friend class const_iterator;
-        friend class reverse_iterator;
-        friend class const_reverse_iterator;
-    };
-
-}}
-
-#include <boost/property_tree/detail/ptree_implementation.hpp>
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/property_tree/ini_parser.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/property_tree/ini_parser.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,334 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-#include <boost/property_tree/detail/ptree_utils.hpp>
-#include <boost/property_tree/detail/file_parser_error.hpp>
-#include <fstream>
-#include <string>
-#include <sstream>
-#include <stdexcept>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace ini_parser
-{
-
-    /**
-     * Determines whether the @c flags are valid for use with the ini_parser.
-     * @param flags value to check for validity as flags to ini_parser.
-     * @return true if the flags are valid, false otherwise.
-     */
-    inline bool validate_flags(int flags)
-    {
-        return flags == 0;
-    }
-
-    /** Indicates an error parsing INI formatted data. */
-    class ini_parser_error: public file_parser_error
-    {
-    public:
-        /**
-         * Construct an @c ini_parser_error
-         * @param message Message describing the parser error.
-         * @param filename The name of the file being parsed containing the
-         *                 error.
-         * @param line The line in the given file where an error was
-         *             encountered.
-         */
-        ini_parser_error(const std::string &message,
-                         const std::string &filename,
-                         unsigned long line)
-            : file_parser_error(message, filename, line)
-        {
-        }
-    };
-
-    /**
-     * Read INI from a the given stream and translate it to a property tree.
-     * @note Clears existing contents of property tree. In case of error
-     *       the property tree is not modified.
-     * @throw ini_parser_error If a format violation is found.
-     * @param stream Stream from which to read in the property tree.
-     * @param[out] pt The property tree to populate.
-     */
-    template<class Ptree>
-    void read_ini(std::basic_istream<
-                    typename Ptree::key_type::value_type> &stream,
-                  Ptree &pt)
-    {
-        typedef typename Ptree::key_type::value_type Ch;
-        typedef std::basic_string<Ch> Str;
-        const Ch semicolon = stream.widen(';');
-        const Ch hash = stream.widen('#');
-        const Ch lbracket = stream.widen('[');
-        const Ch rbracket = stream.widen(']');
-
-        Ptree local;
-        unsigned long line_no = 0;
-        Ptree *section = 0;
-        Str line;
-
-        // For all lines
-        while (stream.good())
-        {
-
-            // Get line from stream
-            ++line_no;
-            std::getline(stream, line);
-            if (!stream.good() && !stream.eof())
-                BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                    "read error", "", line_no));
-
-            // If line is non-empty
-            line = property_tree::detail::trim(line, stream.getloc());
-            if (!line.empty())
-            {
-                // Comment, section or key?
-                if (line[0] == semicolon || line[0] == hash)
-                {
-                    // Ignore comments
-                }
-                else if (line[0] == lbracket)
-                {
-                    // If the previous section was empty, drop it again.
-                    if (section && section->empty())
-                        local.pop_back();
-                    typename Str::size_type end = line.find(rbracket);
-                    if (end == Str::npos)
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "unmatched '['", "", line_no));
-                    Str key = property_tree::detail::trim(
-                        line.substr(1, end - 1), stream.getloc());
-                    if (local.find(key) != local.not_found())
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "duplicate section name", "", line_no));
-                    section = &local.push_back(
-                        std::make_pair(key, Ptree()))->second;
-                }
-                else
-                {
-                    Ptree &container = section ? *section : local;
-                    typename Str::size_type eqpos = line.find(Ch('='));
-                    if (eqpos == Str::npos)
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "'=' character not found in line", "", line_no));
-                    if (eqpos == 0)
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "key expected", "", line_no));
-                    Str key = property_tree::detail::trim(
-                        line.substr(0, eqpos), stream.getloc());
-                    Str data = property_tree::detail::trim(
-                        line.substr(eqpos + 1, Str::npos), stream.getloc());
-                    if (container.find(key) != container.not_found())
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "duplicate key name", "", line_no));
-                    container.push_back(std::make_pair(key, Ptree(data)));
-                }
-            }
-        }
-        // If the last section was empty, drop it again.
-        if (section && section->empty())
-            local.pop_back();
-
-        // Swap local ptree with result ptree
-        pt.swap(local);
-
-    }
-
-    /**
-     * Read INI from a the given file and translate it to a property tree.
-     * @note Clears existing contents of property tree.  In case of error the
-     *       property tree unmodified.
-     * @throw ini_parser_error In case of error deserializing the property tree.
-     * @param filename Name of file from which to read in the property tree.
-     * @param[out] pt The property tree to populate.
-     * @param loc The locale to use when reading in the file contents.
-     */
-    template<class Ptree>
-    void read_ini(const std::string &filename, 
-                  Ptree &pt,
-                  const std::locale &loc = std::locale())
-    {
-        std::basic_ifstream<typename Ptree::key_type::value_type>
-            stream(filename.c_str());
-        if (!stream)
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                "cannot open file", filename, 0));
-        stream.imbue(loc);
-        try {
-            read_ini(stream, pt);
-        }
-        catch (ini_parser_error &e) {
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                e.message(), filename, e.line()));
-        }
-    }
-
-    namespace detail
-    {
-        template<class Ptree>
-        void check_dupes(const Ptree &pt)
-        {
-            if(pt.size() <= 1)
-                return;
-            const typename Ptree::key_type *lastkey = 0;
-            typename Ptree::const_assoc_iterator it = pt.ordered_begin(),
-                                                 end = pt.not_found();
-            lastkey = &it->first;
-            for(++it; it != end; ++it) {
-                if(*lastkey == it->first)
-                    BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                        "duplicate key", "", 0));
-                lastkey = &it->first;
-            }
-        }
-
-        template <typename Ptree>
-        void write_keys(std::basic_ostream<
-                                      typename Ptree::key_type::value_type
-                                  > &stream,
-                                  const Ptree& pt,
-                                  bool throw_on_children)
-        {
-            typedef typename Ptree::key_type::value_type Ch;
-            for (typename Ptree::const_iterator it = pt.begin(), end = pt.end();
-                 it != end; ++it)
-            {
-                if (!it->second.empty()) {
-                    if (throw_on_children) {
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "ptree is too deep", "", 0));
-                    }
-                    continue;
-                }
-                stream << it->first << Ch('=')
-                    << it->second.template get_value<
-                        std::basic_string<Ch> >()
-                    << Ch('\n');
-            }
-        }
-
-        template <typename Ptree>
-        void write_top_level_keys(std::basic_ostream<
-                                      typename Ptree::key_type::value_type
-                                  > &stream,
-                                  const Ptree& pt)
-        {
-            write_keys(stream, pt, false);
-        }
-
-        template <typename Ptree>
-        void write_sections(std::basic_ostream<
-                                typename Ptree::key_type::value_type
-                            > &stream,
-                            const Ptree& pt)
-        {
-            typedef typename Ptree::key_type::value_type Ch;
-            for (typename Ptree::const_iterator it = pt.begin(), end = pt.end();
-                 it != end; ++it)
-            {
-                if (!it->second.empty()) {
-                    check_dupes(it->second);
-                    if (!it->second.data().empty())
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "mixed data and children", "", 0));
-                    stream << Ch('[') << it->first << Ch(']') << Ch('\n');
-                    write_keys(stream, it->second, true);
-                }
-            }
-        }
-    }
-
-    /**
-     * Translates the property tree to INI and writes it the given output
-     * stream.
-     * @pre @e pt cannot have data in its root.
-     * @pre @e pt cannot have keys both data and children.
-     * @pre @e pt cannot be deeper than two levels.
-     * @pre There cannot be duplicate keys on any given level of @e pt.
-     * @throw ini_parser_error In case of error translating the property tree to
-     *                         INI or writing to the output stream.
-     * @param stream The stream to which to write the INI representation of the 
-     *               property tree.
-     * @param pt The property tree to tranlsate to INI and output.
-     * @param flags The flags to use when writing the INI file.
-     *              No flags are currently supported.
-     */
-    template<class Ptree>
-    void write_ini(std::basic_ostream<
-                       typename Ptree::key_type::value_type
-                   > &stream,
-                   const Ptree &pt,
-                   int flags = 0)
-    {
-        BOOST_ASSERT(validate_flags(flags));
-        (void)flags;
-
-        if (!pt.data().empty())
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                "ptree has data on root", "", 0));
-        detail::check_dupes(pt);
-
-        detail::write_top_level_keys(stream, pt);
-        detail::write_sections(stream, pt);
-    }
-
-    /**
-     * Translates the property tree to INI and writes it the given file.
-     * @pre @e pt cannot have data in its root.
-     * @pre @e pt cannot have keys both data and children.
-     * @pre @e pt cannot be deeper than two levels.
-     * @pre There cannot be duplicate keys on any given level of @e pt.
-     * @throw info_parser_error In case of error translating the property tree
-     *                          to INI or writing to the file.
-     * @param filename The name of the file to which to write the INI
-     *                 representation of the property tree.
-     * @param pt The property tree to tranlsate to INI and output.
-     * @param flags The flags to use when writing the INI file.
-     *              The following flags are supported:
-     * @li @c skip_ini_validity_check -- Skip check if ptree is a valid ini. The
-     *     validity check covers the preconditions but takes <tt>O(n log n)</tt>
-     *     time.
-     * @param loc The locale to use when writing the file.
-     */
-    template<class Ptree>
-    void write_ini(const std::string &filename,
-                   const Ptree &pt,
-                   int flags = 0,
-                   const std::locale &loc = std::locale())
-    {
-        std::basic_ofstream<typename Ptree::key_type::value_type>
-            stream(filename.c_str());
-        if (!stream)
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                "cannot open file", filename, 0));
-        stream.imbue(loc);
-        try {
-            write_ini(stream, pt, flags);
-        }
-        catch (ini_parser_error &e) {
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                e.message(), filename, e.line()));
-        }
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using ini_parser::ini_parser_error;
-    using ini_parser::read_ini;
-    using ini_parser::write_ini;
-} }
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/property_tree/ptree_serialization.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/property_tree/ptree_serialization.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,129 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_PTREE_SERIALIZATION_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_PTREE_SERIALIZATION_HPP_INCLUDED
-
-#include <boost/property_tree/ptree.hpp>
-
-#include <boost/serialization/nvp.hpp>
-#include <boost/serialization/collections_save_imp.hpp>
-#include <boost/serialization/detail/stack_constructor.hpp>
-#include <boost/serialization/split_free.hpp>
-#include <boost/serialization/utility.hpp>
-
-namespace boost { namespace property_tree
-{
-
-    ///////////////////////////////////////////////////////////////////////////
-    // boost::serialization support
-
-    /**
-     * Serialize the property tree to the given archive.
-     * @note In addition to serializing to regular archives, this supports
-     *       serializing to archives requiring name-value pairs, e.g. XML
-     *       archives.  However, the output format in the XML archive is not
-     *       guaranteed to be the same as that when using the Boost.PropertyTree
-     *       library's @c boost::property_tree::xml_parser::write_xml.
-     * @param ar The archive to which to save the serialized property tree.
-     *           This archive should conform to the concept laid out by the
-     *           Boost.Serialization library.
-     * @param t The property tree to serialize.
-     * @param file_version file_version for the archive.
-     * @post @c ar will contain the serialized form of @c t.
-     */
-    template<class Archive, class K, class D, class C>
-    inline void save(Archive &ar,
-                     const basic_ptree<K, D, C> &t,
-                     const unsigned int file_version)
-    {
-        using namespace boost::serialization;
-        stl::save_collection<Archive, basic_ptree<K, D, C> >(ar, t);
-        ar << make_nvp("data", t.data());
-    }
-
-    namespace detail
-    {
-        template <class Archive, class K, class D, class C>
-        inline void load_children(Archive &ar,
-                                  basic_ptree<K, D, C> &t)
-        {
-            namespace bsl = boost::serialization;
-            namespace bsa = boost::archive;
-
-            typedef basic_ptree<K, D, C> tree;
-            typedef typename tree::value_type value_type;
-    
-            bsl::collection_size_type count;
-            ar >> BOOST_SERIALIZATION_NVP(count);
-            bsl::item_version_type item_version(0);
-            const bsa::library_version_type library_version(
-                ar.get_library_version()
-            );
-            if(bsa::library_version_type(3) < library_version){
-                ar >> BOOST_SERIALIZATION_NVP(item_version);
-            }
-            // Can't use the serialization helper, it expects resize() to exist
-            // for default-constructible elements.
-            // This is a copy/paste of the fallback version.
-            t.clear();
-            while(count-- > 0){
-                bsl::detail::stack_construct<Archive, value_type>
-                    u(ar, item_version);
-                ar >> bsl::make_nvp("item", u.reference());
-                t.push_back(u.reference());
-                ar.reset_object_address(& t.back() , & u.reference());
-            }
-        }
-    }
-
-    /**
-     * De-serialize the property tree to the given archive.
-     * @note In addition to de-serializing from regular archives, this supports
-     *       loading from archives requiring name-value pairs, e.g. XML
-     *       archives. The format should be that used by
-     *       boost::property_tree::save.
-     * @param ar The archive from which to load the serialized property tree.
-     *           This archive should conform to the concept laid out by the
-     *           Boost.Serialization library.
-     * @param t The property tree to de-serialize.
-     * @param file_version file_version for the archive.
-     * @post @c t will contain the de-serialized data from @c ar.
-     */
-    template<class Archive, class K, class D, class C>
-    inline void load(Archive &ar,
-                     basic_ptree<K, D, C> &t,
-                     const unsigned int file_version)
-    {
-        namespace bsl = boost::serialization;
-
-        detail::load_children(ar, t);
-        ar >> bsl::make_nvp("data", t.data());
-    }
-
-    /**
-     * Load or store the property tree using the given archive.
-     * @param ar The archive from which to load or save the serialized property
-     *           tree. The type of this archive will determine whether saving or
-     *           loading is performed.
-     * @param t The property tree to load or save.
-     * @param file_version file_version for the archive.
-     */
-    template<class Archive, class K, class D, class C>
-    inline void serialize(Archive &ar,
-                          basic_ptree<K, D, C> &t,
-                          const unsigned int file_version)
-    {
-        using namespace boost::serialization;
-        split_free(ar, t, file_version);
-    }
-
-} }
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree_fwd.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree_fwd.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,144 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_PTREE_FWD_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_PTREE_FWD_HPP_INCLUDED
-
-#include <boost/config.hpp>
-#include <boost/optional/optional_fwd.hpp>
-#include <boost/throw_exception.hpp>
-#include <functional>           // for std::less
-#include <memory>               // for std::allocator
-#include <string>
-
-namespace boost { namespace property_tree
-{
-    namespace detail {
-        template <typename T> struct less_nocase;
-    }
-
-    // Classes
-
-    template < class Key, class Data, class KeyCompare = std::less<Key> >
-    class basic_ptree;
-
-    template <typename T>
-    struct id_translator;
-
-    template <typename String, typename Translator>
-    class string_path;
-
-    // Texas-style concepts for documentation only.
-#if 0
-    concept PropertyTreePath<class Path> {
-        // The key type for which this path works.
-        typename key_type;
-        // Return the key that the first segment of the path names.
-        // Split the head off the state.
-        key_type Path::reduce();
-
-        // Return true if the path is empty.
-        bool Path::empty() const;
-
-        // Return true if the path contains a single element.
-        bool Path::single() const;
-
-        // Dump as a std::string, for exception messages.
-        std::string Path::dump() const;
-    }
-    concept PropertyTreeKey<class Key> {
-        PropertyTreePath path;
-        requires SameType<Key, PropertyTreePath<path>::key_type>;
-    }
-    concept PropertyTreeTranslator<class Tr> {
-        typename internal_type;
-        typename external_type;
-
-        boost::optional<external_type> Tr::get_value(internal_type);
-        boost::optional<internal_type> Tr::put_value(external_type);
-    }
-#endif
-    /// If you want to use a custom key type, specialize this struct for it
-    /// and give it a 'type' typedef that specifies your path type. The path
-    /// type must conform to the Path concept described in the documentation.
-    /// This is already specialized for std::basic_string.
-    template <typename Key>
-    struct path_of;
-
-    /// Specialize this struct to specify a default translator between the data
-    /// in a tree whose data_type is Internal, and the external data_type
-    /// specified in a get_value, get, put_value or put operation.
-    /// This is already specialized for Internal being std::basic_string.
-    template <typename Internal, typename External>
-    struct translator_between;
-
-    class ptree_error;
-    class ptree_bad_data;
-    class ptree_bad_path;
-
-    // Typedefs
-
-    /** Implements a path using a std::string as the key. */
-    typedef string_path<std::string, id_translator<std::string> > path;
-
-    /**
-     * A property tree with std::string for key and data, and default
-     * comparison.
-     */
-    typedef basic_ptree<std::string, std::string> ptree;
-
-    /**
-     * A property tree with std::string for key and data, and case-insensitive
-     * comparison.
-     */
-    typedef basic_ptree<std::string, std::string,
-                        detail::less_nocase<std::string> >
-        iptree;
-
-#ifndef BOOST_NO_STD_WSTRING
-    /** Implements a path using a std::wstring as the key. */
-    typedef string_path<std::wstring, id_translator<std::wstring> > wpath;
-
-    /**
-     * A property tree with std::wstring for key and data, and default
-     * comparison.
-     * @note The type only exists if the platform supports @c wchar_t.
-     */
-    typedef basic_ptree<std::wstring, std::wstring> wptree;
-
-    /**
-     * A property tree with std::wstring for key and data, and case-insensitive
-     * comparison.
-     * @note The type only exists if the platform supports @c wchar_t.
-     */
-    typedef basic_ptree<std::wstring, std::wstring,
-                        detail::less_nocase<std::wstring> >
-        wiptree;
-#endif
-
-    // Free functions
-
-    /**
-     * Swap two property tree instances.
-     */
-    template<class K, class D, class C>
-    void swap(basic_ptree<K, D, C> &pt1,
-              basic_ptree<K, D, C> &pt2);
-
-} }
-
-
-#if !defined(BOOST_PROPERTY_TREE_DOXYGEN_INVOKED)
-    // Throwing macro to avoid no return warnings portably
-#   define BOOST_PROPERTY_TREE_THROW(e) { throw_exception(e); std::exit(1); }
-
-#endif
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,518 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-
-#ifndef BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_PTREE_HPP_INCLUDED
-
-#include "ptree_fwd.hpp"
-#include "string_path.hpp"
-#include "stream_translator.hpp"
-#include "exceptions.hpp"
-#include "ptree_utils.hpp"
-
-#include <boost/multi_index_container.hpp>
-#include <boost/multi_index/indexed_by.hpp>
-#include <boost/multi_index/sequenced_index.hpp>
-#include <boost/multi_index/ordered_index.hpp>
-#include <boost/multi_index/member.hpp>
-#include <boost/utility/enable_if.hpp>
-#include <boost/throw_exception.hpp>
-#include <boost/optional.hpp>
-#include <utility>                  // for std::pair
-
-namespace boost { namespace property_tree
-{
-
-    /**
-     * Property tree main structure. A property tree is a hierarchical data
-     * structure which has one element of type @p Data in each node, as well
-     * as an ordered sequence of sub-nodes, which are additionally identified
-     * by a non-unique key of type @p Key.
-     *
-     * Key equivalency is defined by @p KeyCompare, a predicate defining a
-     * strict weak ordering.
-     *
-     * Property tree defines a Container-like interface to the (key-node) pairs
-     * of its direct sub-nodes. The iterators are bidirectional. The sequence
-     * of nodes is held in insertion order, not key order.
-     */
-    template<class Key, class Data, class KeyCompare>
-    class basic_ptree
-    {
-#if defined(BOOST_PROPERTY_TREE_DOXYGEN_INVOKED)
-    public:
-#endif
-        // Internal types
-        /**
-         * Simpler way to refer to this basic_ptree\<C,K,P,A\> type.
-         * Note that this is private, and made public only for doxygen.
-         */
-        typedef basic_ptree<Key, Data, KeyCompare> self_type;
-
-    public:
-        // Basic types
-        typedef Key                                  key_type;
-        typedef Data                                 data_type;
-        typedef KeyCompare                           key_compare;
-
-        // Container view types
-        typedef std::pair<const Key, self_type>      value_type;
-        typedef std::size_t                          size_type;
-
-        // The problem with the iterators is that I can't make them complete
-        // until the container is complete. Sucks. Especially for the reverses.
-        class iterator;
-        class const_iterator;
-        class reverse_iterator;
-        class const_reverse_iterator;
-
-        // Associative view types
-        class assoc_iterator;
-        class const_assoc_iterator;
-
-        // Property tree view types
-        typedef typename path_of<Key>::type          path_type;
-
-
-        // The big five
-
-        /** Creates a node with no children and default-constructed data. */
-        basic_ptree();
-        /** Creates a node with no children and a copy of the given data. */
-        explicit basic_ptree(const data_type &data);
-        basic_ptree(const self_type &rhs);
-        ~basic_ptree();
-        /** Basic guarantee only. */
-        self_type &operator =(const self_type &rhs);
-
-        /** Swap with other tree. Only constant-time and nothrow if the
-         * data type's swap is.
-         */
-        void swap(self_type &rhs);
-
-        // Container view functions
-
-        /** The number of direct children of this node. */
-        size_type size() const;
-        size_type max_size() const;
-        /** Whether there are any direct children. */
-        bool empty() const;
-
-        iterator begin();
-        const_iterator begin() const;
-        iterator end();
-        const_iterator end() const;
-        reverse_iterator rbegin();
-        const_reverse_iterator rbegin() const;
-        reverse_iterator rend();
-        const_reverse_iterator rend() const;
-
-        value_type &front();
-        const value_type &front() const;
-        value_type &back();
-        const value_type &back() const;
-
-        /** Insert a copy of the given tree with its key just before the given
-         * position in this node. This operation invalidates no iterators.
-         * @return An iterator to the newly created child.
-         */
-        iterator insert(iterator where, const value_type &value);
-
-        /** Range insert. Equivalent to:
-         * @code
-         * for(; first != last; ++first) insert(where, *first);
-         * @endcode
-         */
-        template<class It> void insert(iterator where, It first, It last);
-
-        /** Erase the child pointed at by the iterator. This operation
-         * invalidates the given iterator, as well as its equivalent
-         * assoc_iterator.
-         * @return A valid iterator pointing to the element after the erased.
-         */
-        iterator erase(iterator where);
-
-        /** Range erase. Equivalent to:
-         * @code
-         * while(first != last;) first = erase(first);
-         * @endcode
-         */
-        iterator erase(iterator first, iterator last);
-
-        /** Equivalent to insert(begin(), value). */
-        iterator push_front(const value_type &value);
-
-        /** Equivalent to insert(end(), value). */
-        iterator push_back(const value_type &value);
-
-        /** Equivalent to erase(begin()). */
-        void pop_front();
-
-        /** Equivalent to erase(boost::prior(end())). */
-        void pop_back();
-
-        /** Reverses the order of direct children in the property tree. */
-        void reverse();
-
-        /** Sorts the direct children of this node according to the predicate.
-         * The predicate is passed the whole pair of key and child.
-         */
-        template<class Compare> void sort(Compare comp);
-
-        /** Sorts the direct children of this node according to key order. */
-        void sort();
-
-        // Equality
-
-        /** Two property trees are the same if they have the same data, the keys
-         * and order of their children are the same, and the children compare
-         * equal, recursively.
-         */
-        bool operator ==(const self_type &rhs) const;
-        bool operator !=(const self_type &rhs) const;
-
-        // Associative view
-
-        /** Returns an iterator to the first child, in key order. */
-        assoc_iterator ordered_begin();
-        /** Returns an iterator to the first child, in key order. */
-        const_assoc_iterator ordered_begin() const;
-
-        /** Returns the not-found iterator. Equivalent to end() in a real
-         * associative container.
-         */
-        assoc_iterator not_found();
-        /** Returns the not-found iterator. Equivalent to end() in a real
-         * associative container.
-         */
-        const_assoc_iterator not_found() const;
-
-        /** Find a child with the given key, or not_found() if there is none.
-         * There is no guarantee about which child is returned if multiple have
-         * the same key.
-         */
-        assoc_iterator find(const key_type &key);
-
-        /** Find a child with the given key, or not_found() if there is none.
-         * There is no guarantee about which child is returned if multiple have
-         * the same key.
-         */
-        const_assoc_iterator find(const key_type &key) const;
-
-        /** Find the range of children that have the given key. */
-        std::pair<assoc_iterator, assoc_iterator>
-            equal_range(const key_type &key);
-
-        /** Find the range of children that have the given key. */
-        std::pair<const_assoc_iterator, const_assoc_iterator>
-            equal_range(const key_type &key) const;
-
-        /** Count the number of direct children with the given key. */
-        size_type count(const key_type &key) const;
-
-        /** Erase all direct children with the given key and return the count.
-         */
-        size_type erase(const key_type &key);
-
-        /** Get the iterator that points to the same element as the argument.
-         * @note A valid assoc_iterator range (a, b) does not imply that
-         *       (to_iterator(a), to_iterator(b)) is a valid range.
-         */
-        iterator to_iterator(assoc_iterator it);
-
-        /** Get the iterator that points to the same element as the argument.
-         * @note A valid const_assoc_iterator range (a, b) does not imply that
-         *       (to_iterator(a), to_iterator(b)) is a valid range.
-         */
-        const_iterator to_iterator(const_assoc_iterator it) const;
-
-        // Property tree view
-
-        /** Reference to the actual data in this node. */
-        data_type &data();
-
-        /** Reference to the actual data in this node. */
-        const data_type &data() const;
-
-        /** Clear this tree completely, of both data and children. */
-        void clear();
-
-        /** Get the child at the given path, or throw @c ptree_bad_path.
-         * @note Depending on the path, the result at each level may not be
-         *       completely deterministic, i.e. if the same key appears multiple
-         *       times, which child is chosen is not specified. This can lead
-         *       to the path not being resolved even though there is a
-         *       descendant with this path. Example:
-         * @code
-         *   a -> b -> c
-         *     -> b
-         * @endcode
-         *       The path "a.b.c" will succeed if the resolution of "b" chooses
-         *       the first such node, but fail if it chooses the second.
-         */
-        self_type &get_child(const path_type &path);
-
-        /** Get the child at the given path, or throw @c ptree_bad_path. */
-        const self_type &get_child(const path_type &path) const;
-
-        /** Get the child at the given path, or return @p default_value. */
-        self_type &get_child(const path_type &path, self_type &default_value);
-
-        /** Get the child at the given path, or return @p default_value. */
-        const self_type &get_child(const path_type &path,
-                                   const self_type &default_value) const;
-
-        /** Get the child at the given path, or return boost::null. */
-        optional<self_type &> get_child_optional(const path_type &path);
-
-        /** Get the child at the given path, or return boost::null. */
-        optional<const self_type &>
-          get_child_optional(const path_type &path) const;
-
-        /** Set the node at the given path to the given value. Create any
-         * missing parents. If the node at the path already exists, replace it.
-         * @return A reference to the inserted subtree.
-         * @note Because of the way paths work, it is not generally guaranteed
-         *       that a node newly created can be accessed using the same path.
-         * @note If the path could refer to multiple nodes, it is unspecified
-         *       which one gets replaced.
-         */
-        self_type &put_child(const path_type &path, const self_type &value);
-
-        /** Add the node at the given path. Create any missing parents. If there
-         * already is a node at the path, add another one with the same key.
-         * @param path Path to the child. The last fragment must not have an
-         *             index.
-         * @return A reference to the inserted subtree.
-         * @note Because of the way paths work, it is not generally guaranteed
-         *       that a node newly created can be accessed using the same path.
-         */
-        self_type &add_child(const path_type &path, const self_type &value);
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the supplied translator.
-         * @throw ptree_bad_data if the conversion fails.
-         */
-        template<class Type, class Translator>
-        typename boost::enable_if<detail::is_translator<Translator>, Type>::type
-        get_value(Translator tr) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the default translator.
-         * @throw ptree_bad_data if the conversion fails.
-         */
-        template<class Type>
-        Type get_value() const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the supplied translator. Return @p default_value
-         * if this fails.
-         */
-        template<class Type, class Translator>
-        Type get_value(const Type &default_value, Translator tr) const;
-
-        /** Make get_value do the right thing for string literals. */
-        template <class Ch, class Translator>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get_value(const Ch *default_value, Translator tr) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the default translator. Return @p default_value
-         * if this fails.
-         */
-        template<class Type>
-        typename boost::disable_if<detail::is_translator<Type>, Type>::type
-        get_value(const Type &default_value) const;
-
-        /** Make get_value do the right thing for string literals. */
-        template <class Ch>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get_value(const Ch *default_value) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the supplied translator. Return boost::null if
-         * this fails.
-         */
-        template<class Type, class Translator>
-        optional<Type> get_value_optional(Translator tr) const;
-
-        /** Take the value of this node and attempt to translate it to a
-         * @c Type object using the default translator. Return boost::null if
-         * this fails.
-         */
-        template<class Type>
-        optional<Type> get_value_optional() const;
-
-        /** Replace the value at this node with the given value, translated
-         * to the tree's data type using the supplied translator.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type, class Translator>
-        void put_value(const Type &value, Translator tr);
-
-        /** Replace the value at this node with the given value, translated
-         * to the tree's data type using the default translator.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type>
-        void put_value(const Type &value);
-
-        /** Shorthand for get_child(path).get_value(tr). */
-        template<class Type, class Translator>
-        typename boost::enable_if<detail::is_translator<Translator>, Type>::type
-        get(const path_type &path, Translator tr) const;
-
-        /** Shorthand for get_child(path).get_value\<Type\>(). */
-        template<class Type>
-        Type get(const path_type &path) const;
-
-        /** Shorthand for get_child(path, empty_ptree())
-         *                    .get_value(default_value, tr).
-         * That is, return the translated value if possible, and the default
-         * value if the node doesn't exist or conversion fails.
-         */
-        template<class Type, class Translator>
-        Type get(const path_type &path,
-                 const Type &default_value,
-                 Translator tr) const;
-
-        /** Make get do the right thing for string literals. */
-        template <class Ch, class Translator>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get(const path_type &path, const Ch *default_value, Translator tr)const;
-
-        /** Shorthand for get_child(path, empty_ptree())
-         *                    .get_value(default_value).
-         * That is, return the translated value if possible, and the default
-         * value if the node doesn't exist or conversion fails.
-         */
-        template<class Type>
-        typename boost::disable_if<detail::is_translator<Type>, Type>::type
-        get(const path_type &path, const Type &default_value) const;
-
-        /** Make get do the right thing for string literals. */
-        template <class Ch>
-        typename boost::enable_if<
-            detail::is_character<Ch>,
-            std::basic_string<Ch>
-        >::type
-        get(const path_type &path, const Ch *default_value) const;
-
-        /** Shorthand for:
-         * @code
-         * if(optional\<self_type&\> node = get_child_optional(path))
-         *   return node->get_value_optional(tr);
-         * return boost::null;
-         * @endcode
-         * That is, return the value if it exists and can be converted, or nil.
-        */
-        template<class Type, class Translator>
-        optional<Type> get_optional(const path_type &path, Translator tr) const;
-
-        /** Shorthand for:
-         * @code
-         * if(optional\<const self_type&\> node = get_child_optional(path))
-         *   return node->get_value_optional();
-         * return boost::null;
-         * @endcode
-         * That is, return the value if it exists and can be converted, or nil.
-        */
-        template<class Type>
-        optional<Type> get_optional(const path_type &path) const;
-
-        /** Set the value of the node at the given path to the supplied value,
-         * translated to the tree's data type. If the node doesn't exist, it is
-         * created, including all its missing parents.
-         * @return The node that had its value changed.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type, class Translator>
-        self_type &put(const path_type &path, const Type &value, Translator tr);
-
-        /** Set the value of the node at the given path to the supplied value,
-         * translated to the tree's data type. If the node doesn't exist, it is
-         * created, including all its missing parents.
-         * @return The node that had its value changed.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type>
-        self_type &put(const path_type &path, const Type &value);
-
-        /** If the node identified by the path does not exist, create it,
-         * including all its missing parents.
-         * If the node already exists, add a sibling with the same key.
-         * Set the newly created node's value to the given paremeter,
-         * translated with the supplied translator.
-         * @param path Path to the child. The last fragment must not have an
-         *             index.
-         * @param value The value to add.
-         * @param tr The translator to use.
-         * @return The node that was added.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type, class Translator>
-        self_type &add(const path_type &path,
-                       const Type &value,
-                       Translator tr);
-
-        /** If the node identified by the path does not exist, create it,
-         * including all its missing parents.
-         * If the node already exists, add a sibling with the same key.
-         * Set the newly created node's value to the given paremeter,
-         * translated with the supplied translator.
-         * @param path Path to the child. The last fragment must not have an
-         *             index.
-         * @param value The value to add.
-         * @return The node that was added.
-         * @throw ptree_bad_data if the conversion fails.
-        */
-        template<class Type>
-        self_type &add(const path_type &path, const Type &value);
-
-    private:
-        // Hold the data of this node
-        data_type m_data;
-        // Hold the children - this is a void* because we can't complete the
-        // container type within the class.
-        void* m_children;
-
-        // Getter tree-walk. Not const-safe! Gets the node the path refers to,
-        // or null. Destroys p's value.
-        self_type* walk_path(path_type& p) const;
-
-        // Modifer tree-walk. Gets the parent of the node referred to by the
-        // path, creating nodes as necessary. p is the path to the remaining
-        // child.
-        self_type& force_path(path_type& p);
-
-        // This struct contains typedefs for the concrete types.
-        struct subs;
-        friend struct subs;
-        friend class iterator;
-        friend class const_iterator;
-        friend class reverse_iterator;
-        friend class const_reverse_iterator;
-    };
-
-}}
-
-#include "ptree_implementation.hpp"
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/file_parser_error.hpp.orig	2022-05-09 13:48:22.300996161 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/file_parser_error.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,88 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_FILE_PARSER_ERROR_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_FILE_PARSER_ERROR_HPP_INCLUDED
-
-#include "ptree.hpp"
-#include <string>
-
-namespace boost { namespace property_tree
-{
-
-    //! File parse error
-    class file_parser_error: public ptree_error
-    {
-
-    public:
-
-        ///////////////////////////////////////////////////////////////////////
-        // Construction & destruction
-
-        // Construct error
-        file_parser_error(const std::string &msg,
-                          const std::string &file,
-                          unsigned long l) :
-            ptree_error(format_what(msg, file, l)),
-            m_message(msg), m_filename(file), m_line(l)
-        {
-        }
-
-        ~file_parser_error() throw()
-            // gcc 3.4.2 complains about lack of throw specifier on compiler
-            // generated dtor
-        {
-        }
-
-        ///////////////////////////////////////////////////////////////////////
-        // Data access
-
-        // Get error message (without line and file - use what() to get
-        // full message)
-        std::string message() const
-        {
-            return m_message;
-        }
-
-        // Get error filename
-        std::string filename() const
-        {
-            return m_filename;
-        }
-
-        // Get error line number
-        unsigned long line() const
-        {
-            return m_line;
-        }
-
-    private:
-
-        std::string m_message;
-        std::string m_filename;
-        unsigned long m_line;
-
-        // Format error message to be returned by std::runtime_error::what()
-        static std::string format_what(const std::string &msg,
-                                       const std::string &file,
-                                       unsigned long l)
-        {
-            std::stringstream stream;
-            stream << (file.empty() ? "<unspecified file>" : file.c_str());
-            if (l > 0)
-                stream << '(' << l << ')';
-            stream << ": " << msg;
-            return stream.str();
-        }
-
-    };
-
-} }
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree_implementation.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree_implementation.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,934 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_IMPLEMENTATION_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_PTREE_IMPLEMENTATION_HPP_INCLUDED
-
-#include <boost/iterator/iterator_adaptor.hpp>
-#include <boost/iterator/reverse_iterator.hpp>
-#include <boost/assert.hpp>
-#include "swap.hpp"
-
-#include <memory>
-
-#if (defined(BOOST_MSVC) && \
-     (_MSC_FULL_VER >= 160000000 && _MSC_FULL_VER < 170000000)) || \
-    (defined(BOOST_INTEL_WIN) && \
-     defined(BOOST_DINKUMWARE_STDLIB))
-#define BOOST_PROPERTY_TREE_PAIR_BUG
-#endif
-
-namespace boost { namespace property_tree
-{
-    template <class K, class D, class C>
-    struct basic_ptree<K, D, C>::subs
-    {
-        struct by_name {};
-        // The actual child container.
-#if defined(BOOST_PROPERTY_TREE_PAIR_BUG)
-        // MSVC 10 has moved std::pair's members to a base
-        // class. Unfortunately this does break the interface.
-        BOOST_STATIC_CONSTANT(unsigned,
-            first_offset = offsetof(value_type, first));
-#endif
-        typedef multi_index_container<value_type,
-            multi_index::indexed_by<
-                multi_index::sequenced<>,
-                multi_index::ordered_non_unique<multi_index::tag<by_name>,
-#if defined(BOOST_PROPERTY_TREE_PAIR_BUG)
-                    multi_index::member_offset<value_type, const key_type,
-                                        first_offset>,
-#else
-                    multi_index::member<value_type, const key_type,
-                                        &value_type::first>,
-#endif
-                    key_compare
-                >
-            >
-        > base_container;
-
-        // The by-name lookup index.
-        typedef typename base_container::template index<by_name>::type
-            by_name_index;
-
-        // Access functions for getting to the children of a tree.
-        static base_container& ch(self_type *s) {
-            return *static_cast<base_container*>(s->m_children);
-        }
-        static const base_container& ch(const self_type *s) {
-            return *static_cast<const base_container*>(s->m_children);
-        }
-        static by_name_index& assoc(self_type *s) {
-            return ch(s).BOOST_NESTED_TEMPLATE get<by_name>();
-        }
-        static const by_name_index& assoc(const self_type *s) {
-            return ch(s).BOOST_NESTED_TEMPLATE get<by_name>();
-        }
-    };
-    template <class K, class D, class C>
-    class basic_ptree<K, D, C>::iterator : public boost::iterator_adaptor<
-        iterator, typename subs::base_container::iterator, value_type>
-    {
-        friend class boost::iterator_core_access;
-        typedef boost::iterator_adaptor<
-            iterator, typename subs::base_container::iterator, value_type>
-            baset;
-    public:
-        typedef typename baset::reference reference;
-        iterator() {}
-        explicit iterator(typename iterator::base_type b)
-            : iterator::iterator_adaptor_(b)
-        {}
-        reference dereference() const
-        {
-            // multi_index doesn't allow modification of its values, because
-            // indexes could sort by anything, and modification screws that up.
-            // However, we only sort by the key, and it's protected against
-            // modification in the value_type, so this const_cast is safe.
-            return const_cast<reference>(*this->base_reference());
-        }
-    };
-    template <class K, class D, class C>
-    class basic_ptree<K, D, C>::const_iterator : public boost::iterator_adaptor<
-        const_iterator, typename subs::base_container::const_iterator>
-    {
-    public:
-        const_iterator() {}
-        explicit const_iterator(typename const_iterator::base_type b)
-            : const_iterator::iterator_adaptor_(b)
-        {}
-        const_iterator(iterator b)
-            : const_iterator::iterator_adaptor_(b.base())
-        {}
-    };
-    template <class K, class D, class C>
-    class basic_ptree<K, D, C>::reverse_iterator
-        : public boost::reverse_iterator<iterator>
-    {
-    public:
-        reverse_iterator() {}
-        explicit reverse_iterator(iterator b)
-            : boost::reverse_iterator<iterator>(b)
-        {}
-    };
-    template <class K, class D, class C>
-    class basic_ptree<K, D, C>::const_reverse_iterator
-        : public boost::reverse_iterator<const_iterator>
-    {
-    public:
-        const_reverse_iterator() {}
-        explicit const_reverse_iterator(const_iterator b)
-            : boost::reverse_iterator<const_iterator>(b)
-        {}
-        const_reverse_iterator(
-            typename basic_ptree<K, D, C>::reverse_iterator b)
-            : boost::reverse_iterator<const_iterator>(b)
-        {}
-    };
-    template <class K, class D, class C>
-    class basic_ptree<K, D, C>::assoc_iterator
-        : public boost::iterator_adaptor<assoc_iterator,
-                                         typename subs::by_name_index::iterator,
-                                         value_type>
-    {
-        friend class boost::iterator_core_access;
-        typedef boost::iterator_adaptor<assoc_iterator,
-                                         typename subs::by_name_index::iterator,
-                                         value_type>
-            baset;
-    public:
-        typedef typename baset::reference reference;
-        assoc_iterator() {}
-        explicit assoc_iterator(typename assoc_iterator::base_type b)
-            : assoc_iterator::iterator_adaptor_(b)
-        {}
-        reference dereference() const
-        {
-            return const_cast<reference>(*this->base_reference());
-        }
-    };
-    template <class K, class D, class C>
-    class basic_ptree<K, D, C>::const_assoc_iterator
-        : public boost::iterator_adaptor<const_assoc_iterator,
-                                   typename subs::by_name_index::const_iterator>
-    {
-    public:
-        const_assoc_iterator() {}
-        explicit const_assoc_iterator(
-            typename const_assoc_iterator::base_type b)
-            : const_assoc_iterator::iterator_adaptor_(b)
-        {}
-        const_assoc_iterator(assoc_iterator b)
-            : const_assoc_iterator::iterator_adaptor_(b.base())
-        {}
-    };
-
-
-    // Big five
-
-    // Perhaps the children collection could be created on-demand only, to
-    // reduce heap traffic. But that's a lot more work to implement.
-
-    template<class K, class D, class C> inline
-    basic_ptree<K, D, C>::basic_ptree()
-        : m_children(new typename subs::base_container)
-    {
-    }
-
-    template<class K, class D, class C> inline
-    basic_ptree<K, D, C>::basic_ptree(const data_type &d)
-        : m_data(d), m_children(new typename subs::base_container)
-    {
-    }
-
-    template<class K, class D, class C> inline
-    basic_ptree<K, D, C>::basic_ptree(const basic_ptree<K, D, C> &rhs)
-        : m_data(rhs.m_data),
-          m_children(new typename subs::base_container(subs::ch(&rhs)))
-    {
-    }
-
-    template<class K, class D, class C>
-    basic_ptree<K, D, C> &
-        basic_ptree<K, D, C>::operator =(const basic_ptree<K, D, C> &rhs)
-    {
-        self_type(rhs).swap(*this);
-        return *this;
-    }
-
-    template<class K, class D, class C>
-    basic_ptree<K, D, C>::~basic_ptree()
-    {
-        delete &subs::ch(this);
-    }
-
-    template<class K, class D, class C> inline
-    void basic_ptree<K, D, C>::swap(basic_ptree<K, D, C> &rhs)
-    {
-        boost::swap(m_data, rhs.m_data);
-        // Void pointers, no ADL necessary
-        std::swap(m_children, rhs.m_children);
-    }
-
-    // Container view
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::size_type
-        basic_ptree<K, D, C>::size() const
-    {
-        return subs::ch(this).size();
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::size_type
-        basic_ptree<K, D, C>::max_size() const
-    {
-        return subs::ch(this).max_size();
-    }
-
-    template<class K, class D, class C> inline
-    bool basic_ptree<K, D, C>::empty() const
-    {
-        return subs::ch(this).empty();
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-        basic_ptree<K, D, C>::begin()
-    {
-        return iterator(subs::ch(this).begin());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_iterator
-        basic_ptree<K, D, C>::begin() const
-    {
-        return const_iterator(subs::ch(this).begin());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-        basic_ptree<K, D, C>::end()
-    {
-        return iterator(subs::ch(this).end());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_iterator
-        basic_ptree<K, D, C>::end() const
-    {
-        return const_iterator(subs::ch(this).end());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::reverse_iterator
-        basic_ptree<K, D, C>::rbegin()
-    {
-        return reverse_iterator(this->end());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_reverse_iterator
-        basic_ptree<K, D, C>::rbegin() const
-    {
-        return const_reverse_iterator(this->end());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::reverse_iterator
-        basic_ptree<K, D, C>::rend()
-    {
-        return reverse_iterator(this->begin());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_reverse_iterator
-        basic_ptree<K, D, C>::rend() const
-    {
-        return const_reverse_iterator(this->begin());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::value_type &
-        basic_ptree<K, D, C>::front()
-    {
-        return const_cast<value_type&>(subs::ch(this).front());
-    }
-
-    template<class K, class D, class C> inline
-    const typename basic_ptree<K, D, C>::value_type &
-        basic_ptree<K, D, C>::front() const
-    {
-        return subs::ch(this).front();
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::value_type &
-        basic_ptree<K, D, C>::back()
-    {
-        return const_cast<value_type&>(subs::ch(this).back());
-    }
-
-    template<class K, class D, class C> inline
-    const typename basic_ptree<K, D, C>::value_type &
-        basic_ptree<K, D, C>::back() const
-    {
-        return subs::ch(this).back();
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-    basic_ptree<K, D, C>::insert(iterator where, const value_type &value)
-    {
-        return iterator(subs::ch(this).insert(where.base(), value).first);
-    }
-
-    template<class K, class D, class C>
-    template<class It> inline
-    void basic_ptree<K, D, C>::insert(iterator where, It first, It last)
-    {
-        subs::ch(this).insert(where.base(), first, last);
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-        basic_ptree<K, D, C>::erase(iterator where)
-    {
-        return iterator(subs::ch(this).erase(where.base()));
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-        basic_ptree<K, D, C>::erase(iterator first, iterator last)
-    {
-        return iterator(subs::ch(this).erase(first.base(), last.base()));
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-        basic_ptree<K, D, C>::push_front(const value_type &value)
-    {
-        return iterator(subs::ch(this).push_front(value).first);
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-        basic_ptree<K, D, C>::push_back(const value_type &value)
-    {
-        return iterator(subs::ch(this).push_back(value).first);
-    }
-
-    template<class K, class D, class C> inline
-    void basic_ptree<K, D, C>::pop_front()
-    {
-        subs::ch(this).pop_front();
-    }
-
-    template<class K, class D, class C> inline
-    void basic_ptree<K, D, C>::pop_back()
-    {
-        subs::ch(this).pop_back();
-    }
-
-    template<class K, class D, class C> inline
-    void basic_ptree<K, D, C>::reverse()
-    {
-        subs::ch(this).reverse();
-    }
-
-    namespace impl
-    {
-        struct by_first
-        {
-            template <typename P>
-            bool operator ()(const P& lhs, const P& rhs) const {
-              return lhs.first < rhs.first;
-            }
-        };
-
-        template <typename C>
-        struct equal_pred
-        {
-            template <typename P>
-            bool operator ()(const P& lhs, const P& rhs) const {
-                C c;
-                return !c(lhs.first, rhs.first) &&
-                       !c(rhs.first, lhs.first) &&
-                       lhs.second == rhs.second;
-            }
-        };
-
-        template <typename C, typename MI>
-        bool equal_children(const MI& ch1, const MI& ch2) {
-            // Assumes ch1.size() == ch2.size()
-            return std::equal(ch1.begin(), ch1.end(),
-                ch2.begin(), equal_pred<C>());
-        }
-    }
-
-    template<class K, class D, class C> inline
-    void basic_ptree<K, D, C>::sort()
-    {
-        sort(impl::by_first());
-    }
-
-    template<class K, class D, class C>
-    template<class Compare> inline
-    void basic_ptree<K, D, C>::sort(Compare comp)
-    {
-        subs::ch(this).sort(comp);
-    }
-
-    // Equality
-
-    template<class K, class D, class C> inline
-    bool basic_ptree<K, D, C>::operator ==(
-                                  const basic_ptree<K, D, C> &rhs) const
-    {
-        // The size test is cheap, so add it as an optimization
-        return size() == rhs.size() && data() == rhs.data() &&
-            impl::equal_children<C>(subs::ch(this), subs::ch(&rhs));
-    }
-
-    template<class K, class D, class C> inline
-    bool basic_ptree<K, D, C>::operator !=(
-                                  const basic_ptree<K, D, C> &rhs) const
-    {
-        return !(*this == rhs);
-    }
-
-    // Associative view
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::assoc_iterator
-        basic_ptree<K, D, C>::ordered_begin()
-    {
-        return assoc_iterator(subs::assoc(this).begin());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_assoc_iterator
-        basic_ptree<K, D, C>::ordered_begin() const
-    {
-        return const_assoc_iterator(subs::assoc(this).begin());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::assoc_iterator
-        basic_ptree<K, D, C>::not_found()
-    {
-        return assoc_iterator(subs::assoc(this).end());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_assoc_iterator
-        basic_ptree<K, D, C>::not_found() const
-    {
-        return const_assoc_iterator(subs::assoc(this).end());
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::assoc_iterator
-        basic_ptree<K, D, C>::find(const key_type &key)
-    {
-        return assoc_iterator(subs::assoc(this).find(key));
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_assoc_iterator
-        basic_ptree<K, D, C>::find(const key_type &key) const
-    {
-        return const_assoc_iterator(subs::assoc(this).find(key));
-    }
-
-    template<class K, class D, class C> inline
-    std::pair<
-        typename basic_ptree<K, D, C>::assoc_iterator,
-        typename basic_ptree<K, D, C>::assoc_iterator
-    > basic_ptree<K, D, C>::equal_range(const key_type &key)
-    {
-        std::pair<typename subs::by_name_index::iterator,
-                  typename subs::by_name_index::iterator> r(
-            subs::assoc(this).equal_range(key));
-        return std::pair<assoc_iterator, assoc_iterator>(
-          assoc_iterator(r.first), assoc_iterator(r.second));
-    }
-
-    template<class K, class D, class C> inline
-    std::pair<
-        typename basic_ptree<K, D, C>::const_assoc_iterator,
-        typename basic_ptree<K, D, C>::const_assoc_iterator
-    > basic_ptree<K, D, C>::equal_range(const key_type &key) const
-    {
-        std::pair<typename subs::by_name_index::const_iterator,
-                  typename subs::by_name_index::const_iterator> r(
-            subs::assoc(this).equal_range(key));
-        return std::pair<const_assoc_iterator, const_assoc_iterator>(
-            const_assoc_iterator(r.first), const_assoc_iterator(r.second));
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::size_type
-        basic_ptree<K, D, C>::count(const key_type &key) const
-    {
-        return subs::assoc(this).count(key);
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::size_type
-        basic_ptree<K, D, C>::erase(const key_type &key)
-    {
-        return subs::assoc(this).erase(key);
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::iterator
-        basic_ptree<K, D, C>::to_iterator(assoc_iterator ai)
-    {
-        return iterator(subs::ch(this).
-            BOOST_NESTED_TEMPLATE project<0>(ai.base()));
-    }
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::const_iterator
-        basic_ptree<K, D, C>::to_iterator(const_assoc_iterator ai) const
-    {
-        return const_iterator(subs::ch(this).
-            BOOST_NESTED_TEMPLATE project<0>(ai.base()));
-    }
-
-    // Property tree view
-
-    template<class K, class D, class C> inline
-    typename basic_ptree<K, D, C>::data_type &
-        basic_ptree<K, D, C>::data()
-    {
-        return m_data;
-    }
-
-    template<class K, class D, class C> inline
-    const typename basic_ptree<K, D, C>::data_type &
-        basic_ptree<K, D, C>::data() const
-    {
-        return m_data;
-    }
-
-    template<class K, class D, class C> inline
-    void basic_ptree<K, D, C>::clear()
-    {
-        m_data = data_type();
-        subs::ch(this).clear();
-    }
-
-    template<class K, class D, class C>
-    basic_ptree<K, D, C> &
-        basic_ptree<K, D, C>::get_child(const path_type &path)
-    {
-        path_type p(path);
-        self_type *n = walk_path(p);
-        if (!n) {
-            BOOST_PROPERTY_TREE_THROW(ptree_bad_path("No such node", path));
-        }
-        return *n;
-    }
-
-    template<class K, class D, class C> inline
-    const basic_ptree<K, D, C> &
-        basic_ptree<K, D, C>::get_child(const path_type &path) const
-    {
-        return const_cast<self_type*>(this)->get_child(path);
-    }
-
-    template<class K, class D, class C> inline
-    basic_ptree<K, D, C> &
-        basic_ptree<K, D, C>::get_child(const path_type &path,
-                                        self_type &default_value)
-    {
-        path_type p(path);
-        self_type *n = walk_path(p);
-        return n ? *n : default_value;
-    }
-
-    template<class K, class D, class C> inline
-    const basic_ptree<K, D, C> &
-        basic_ptree<K, D, C>::get_child(const path_type &path,
-                                        const self_type &default_value) const
-    {
-        return const_cast<self_type*>(this)->get_child(path,
-            const_cast<self_type&>(default_value));
-    }
-
-
-    template<class K, class D, class C>
-    optional<basic_ptree<K, D, C> &>
-        basic_ptree<K, D, C>::get_child_optional(const path_type &path)
-    {
-        path_type p(path);
-        self_type *n = walk_path(p);
-        if (!n) {
-            return optional<self_type&>();
-        }
-        return *n;
-    }
-
-    template<class K, class D, class C>
-    optional<const basic_ptree<K, D, C> &>
-        basic_ptree<K, D, C>::get_child_optional(const path_type &path) const
-    {
-        path_type p(path);
-        self_type *n = walk_path(p);
-        if (!n) {
-            return optional<const self_type&>();
-        }
-        return *n;
-    }
-
-    template<class K, class D, class C>
-    basic_ptree<K, D, C> &
-        basic_ptree<K, D, C>::put_child(const path_type &path,
-                                        const self_type &value)
-    {
-        path_type p(path);
-        self_type &parent = force_path(p);
-        // Got the parent. Now get the correct child.
-        key_type fragment = p.reduce();
-        assoc_iterator el = parent.find(fragment);
-        // If the new child exists, replace it.
-        if(el != parent.not_found()) {
-            return el->second = value;
-        } else {
-            return parent.push_back(value_type(fragment, value))->second;
-        }
-    }
-
-    template<class K, class D, class C>
-    basic_ptree<K, D, C> &
-        basic_ptree<K, D, C>::add_child(const path_type &path,
-                                        const self_type &value)
-    {
-        path_type p(path);
-        self_type &parent = force_path(p);
-        // Got the parent.
-        key_type fragment = p.reduce();
-        return parent.push_back(value_type(fragment, value))->second;
-    }
-
-    template<class K, class D, class C>
-    template<class Type, class Translator>
-    typename boost::enable_if<detail::is_translator<Translator>, Type>::type
-    basic_ptree<K, D, C>::get_value(Translator tr) const
-    {
-        if(boost::optional<Type> o = get_value_optional<Type>(tr)) {
-            return *o;
-        }
-        BOOST_PROPERTY_TREE_THROW(ptree_bad_data(
-            std::string("conversion of data to type \"") +
-            typeid(Type).name() + "\" failed", data()));
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    Type basic_ptree<K, D, C>::get_value() const
-    {
-        return get_value<Type>(
-            typename translator_between<data_type, Type>::type());
-    }
-
-    template<class K, class D, class C>
-    template<class Type, class Translator> inline
-    Type basic_ptree<K, D, C>::get_value(const Type &default_value,
-                                         Translator tr) const
-    {
-        return get_value_optional<Type>(tr).get_value_or(default_value);
-    }
-
-    template<class K, class D, class C>
-    template <class Ch, class Translator>
-    typename boost::enable_if<
-        detail::is_character<Ch>,
-        std::basic_string<Ch>
-    >::type
-    basic_ptree<K, D, C>::get_value(const Ch *default_value, Translator tr)const
-    {
-        return get_value<std::basic_string<Ch>, Translator>(default_value, tr);
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    typename boost::disable_if<detail::is_translator<Type>, Type>::type
-    basic_ptree<K, D, C>::get_value(const Type &default_value) const
-    {
-        return get_value(default_value,
-                         typename translator_between<data_type, Type>::type());
-    }
-
-    template<class K, class D, class C>
-    template <class Ch>
-    typename boost::enable_if<
-        detail::is_character<Ch>,
-        std::basic_string<Ch>
-    >::type
-    basic_ptree<K, D, C>::get_value(const Ch *default_value) const
-    {
-        return get_value< std::basic_string<Ch> >(default_value);
-    }
-
-    template<class K, class D, class C>
-    template<class Type, class Translator> inline
-    optional<Type> basic_ptree<K, D, C>::get_value_optional(
-                                                Translator tr) const
-    {
-        return tr.get_value(data());
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    optional<Type> basic_ptree<K, D, C>::get_value_optional() const
-    {
-        return get_value_optional<Type>(
-            typename translator_between<data_type, Type>::type());
-    }
-
-    template<class K, class D, class C>
-    template<class Type, class Translator> inline
-    typename boost::enable_if<detail::is_translator<Translator>, Type>::type
-    basic_ptree<K, D, C>::get(const path_type &path,
-                              Translator tr) const
-    {
-        return get_child(path).BOOST_NESTED_TEMPLATE get_value<Type>(tr);
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    Type basic_ptree<K, D, C>::get(const path_type &path) const
-    {
-        return get_child(path).BOOST_NESTED_TEMPLATE get_value<Type>();
-    }
-
-    template<class K, class D, class C>
-    template<class Type, class Translator> inline
-    Type basic_ptree<K, D, C>::get(const path_type &path,
-                                   const Type &default_value,
-                                   Translator tr) const
-    {
-        return get_optional<Type>(path, tr).get_value_or(default_value);
-    }
-
-    template<class K, class D, class C>
-    template <class Ch, class Translator>
-    typename boost::enable_if<
-        detail::is_character<Ch>,
-        std::basic_string<Ch>
-    >::type
-    basic_ptree<K, D, C>::get(
-        const path_type &path, const Ch *default_value, Translator tr) const
-    {
-        return get<std::basic_string<Ch>, Translator>(path, default_value, tr);
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    typename boost::disable_if<detail::is_translator<Type>, Type>::type
-    basic_ptree<K, D, C>::get(const path_type &path,
-                              const Type &default_value) const
-    {
-        return get_optional<Type>(path).get_value_or(default_value);
-    }
-
-    template<class K, class D, class C>
-    template <class Ch>
-    typename boost::enable_if<
-        detail::is_character<Ch>,
-        std::basic_string<Ch>
-    >::type
-    basic_ptree<K, D, C>::get(
-        const path_type &path, const Ch *default_value) const
-    {
-        return get< std::basic_string<Ch> >(path, default_value);
-    }
-
-    template<class K, class D, class C>
-    template<class Type, class Translator>
-    optional<Type> basic_ptree<K, D, C>::get_optional(const path_type &path,
-                                                         Translator tr) const
-    {
-        if (optional<const self_type&> child = get_child_optional(path))
-            return child.get().
-                BOOST_NESTED_TEMPLATE get_value_optional<Type>(tr);
-        else
-            return optional<Type>();
-    }
-
-    template<class K, class D, class C>
-    template<class Type>
-    optional<Type> basic_ptree<K, D, C>::get_optional(
-                                                const path_type &path) const
-    {
-        if (optional<const self_type&> child = get_child_optional(path))
-            return child.get().BOOST_NESTED_TEMPLATE get_value_optional<Type>();
-        else
-            return optional<Type>();
-    }
-
-    template<class K, class D, class C>
-    template<class Type, class Translator>
-    void basic_ptree<K, D, C>::put_value(const Type &value, Translator tr)
-    {
-        if(optional<data_type> o = tr.put_value(value)) {
-            data() = *o;
-        } else {
-            BOOST_PROPERTY_TREE_THROW(ptree_bad_data(
-                std::string("conversion of type \"") + typeid(Type).name() +
-                "\" to data failed", boost::any()));
-        }
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    void basic_ptree<K, D, C>::put_value(const Type &value)
-    {
-        put_value(value, typename translator_between<data_type, Type>::type());
-    }
-
-    template<class K, class D, class C>
-    template<class Type, typename Translator>
-    basic_ptree<K, D, C> & basic_ptree<K, D, C>::put(
-        const path_type &path, const Type &value, Translator tr)
-    {
-        if(optional<self_type &> child = get_child_optional(path)) {
-            child.get().put_value(value, tr);
-            return *child;
-        } else {
-            self_type &child2 = put_child(path, self_type());
-            child2.put_value(value, tr);
-            return child2;
-        }
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    basic_ptree<K, D, C> & basic_ptree<K, D, C>::put(
-        const path_type &path, const Type &value)
-    {
-        return put(path, value,
-                   typename translator_between<data_type, Type>::type());
-    }
-
-    template<class K, class D, class C>
-    template<class Type, typename Translator> inline
-    basic_ptree<K, D, C> & basic_ptree<K, D, C>::add(
-        const path_type &path, const Type &value, Translator tr)
-    {
-        self_type &child = add_child(path, self_type());
-        child.put_value(value, tr);
-        return child;
-    }
-
-    template<class K, class D, class C>
-    template<class Type> inline
-    basic_ptree<K, D, C> & basic_ptree<K, D, C>::add(
-        const path_type &path, const Type &value)
-    {
-        return add(path, value,
-                   typename translator_between<data_type, Type>::type());
-    }
-
-
-    template<class K, class D, class C>
-    basic_ptree<K, D, C> *
-    basic_ptree<K, D, C>::walk_path(path_type &p) const
-    {
-        if(p.empty()) {
-            // I'm the child we're looking for.
-            return const_cast<basic_ptree*>(this);
-        }
-        // Recurse down the tree to find the path.
-        key_type fragment = p.reduce();
-        const_assoc_iterator el = find(fragment);
-        if(el == not_found()) {
-            // No such child.
-            return 0;
-        }
-        // Not done yet, recurse.
-        return el->second.walk_path(p);
-    }
-
-    template<class K, class D, class C>
-    basic_ptree<K, D, C> & basic_ptree<K, D, C>::force_path(path_type &p)
-    {
-        BOOST_ASSERT(!p.empty() && "Empty path not allowed for put_child.");
-        if(p.single()) {
-            // I'm the parent we're looking for.
-            return *this;
-        }
-        key_type fragment = p.reduce();
-        assoc_iterator el = find(fragment);
-        // If we've found an existing child, go down that path. Else
-        // create a new one.
-        self_type& child = el == not_found() ?
-            push_back(value_type(fragment, self_type()))->second : el->second;
-        return child.force_path(p);
-    }
-
-    // Free functions
-
-    template<class K, class D, class C>
-    inline void swap(basic_ptree<K, D, C> &pt1, basic_ptree<K, D, C> &pt2)
-    {
-        pt1.swap(pt2);
-    }
-
-} }
-
-#if defined(BOOST_PROPERTY_TREE_PAIR_BUG)
-#undef BOOST_PROPERTY_TREE_PAIR_BUG
-#endif
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree_utils.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ptree_utils.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,105 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_PTREE_UTILS_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_PTREE_UTILS_HPP_INCLUDED
-
-#include <boost/limits.hpp>
-#include <boost/type_traits/integral_constant.hpp>
-#include <boost/mpl/has_xxx.hpp>
-#include <boost/mpl/and.hpp>
-#include <string>
-#include <algorithm>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace detail
-{
-
-    template<class T>
-    struct less_nocase
-    {
-        typedef typename T::value_type Ch;
-        std::locale m_locale;
-        inline bool operator()(Ch c1, Ch c2) const
-        {
-            return std::toupper(c1, m_locale) < std::toupper(c2, m_locale);
-        }
-        inline bool operator()(const T &t1, const T &t2) const
-        {
-            return std::lexicographical_compare(t1.begin(), t1.end(),
-                                                t2.begin(), t2.end(), *this);
-        }
-    };
-
-    template <typename Ch>
-    struct is_character : public boost::false_type {};
-    template <>
-    struct is_character<char> : public boost::true_type {};
-    template <>
-    struct is_character<wchar_t> : public boost::true_type {};
-
-
-    BOOST_MPL_HAS_XXX_TRAIT_DEF(internal_type)
-    BOOST_MPL_HAS_XXX_TRAIT_DEF(external_type)
-    template <typename T>
-    struct is_translator : public boost::mpl::and_<
-        has_internal_type<T>, has_external_type<T> > {};
-
-
-
-    // Naively convert narrow string to another character type
-    template<typename Str>
-    Str widen(const char *text)
-    {
-	Str result;
-        while (*text)
-        {
-            result += typename Str::value_type(*text);
-            ++text;
-        }
-        return result;
-    }
-
-    // Naively convert string to narrow character type
-    template<typename Str, typename char_type>
-    Str narrow(const char_type *text)
-    {
-	Str result;
-        while (*text)
-        {
-            if (*text < 0 || *text > (std::numeric_limits<char>::max)())
-                result += '*';
-            else
-                result += typename Str::value_type(*text);
-            ++text;
-        }
-        return result;
-    }
-
-    // Remove trailing and leading spaces
-    template<class Str>
-    Str trim(const Str &s, const std::locale &loc = std::locale())
-    {
-        typename Str::const_iterator first = s.begin();
-        typename Str::const_iterator end = s.end();
-        while (first != end && std::isspace(*first, loc))
-            ++first;
-        if (first == end)
-            return Str();
-        typename Str::const_iterator last = end;
-        do --last; while (std::isspace(*last, loc));
-        if (first != s.begin() || last + 1 != end)
-            return Str(first, last + 1);
-        else
-            return s;
-    }
-
-} } }
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/exceptions.hpp.orig	2022-05-09 13:48:22.300996161 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/exceptions.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,86 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-
-#ifndef BOOST_PROPERTY_TREE_EXCEPTIONS_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_EXCEPTIONS_HPP_INCLUDED
-
-#include "ptree_fwd.hpp"
-
-#include <boost/any.hpp>
-#include <string>
-#include <stdexcept>
-
-namespace boost { namespace property_tree
-{
-
-    /// Base class for all property tree errors. Derives from
-    /// @c std::runtime_error. Call member function @c what to get human
-    /// readable message associated with the error.
-    class ptree_error : public std::runtime_error
-    {
-    public:
-        /// Instantiate a ptree_error instance with the given message.
-        /// @param what The message to associate with this error.
-        ptree_error(const std::string &what);
-
-        ~ptree_error() throw();
-    };
-
-
-    /// Error indicating that translation from given value to the property tree
-    /// data_type (or vice versa) failed. Derives from ptree_error.
-    class ptree_bad_data : public ptree_error
-    {
-    public:
-        /// Instantiate a ptree_bad_data instance with the given message and
-        /// data.
-        /// @param what The message to associate with this error.
-        /// @param data The value associated with this error that was the source
-        ///             of the translation failure.
-        template<class T> ptree_bad_data(const std::string &what,
-                                         const T &data);
-
-        ~ptree_bad_data() throw();
-
-        /// Retrieve the data associated with this error. This is the source
-        /// value that failed to be translated. You need to explicitly
-        /// specify its type.
-        template<class T> T data() const;
-    private:
-        boost::any m_data;
-    };
-
-
-    /// Error indicating that specified path does not exist. Derives from
-    /// ptree_error.
-    class ptree_bad_path : public ptree_error
-    {
-    public:
-        /// Instantiate a ptree_bad_path with the given message and path data.
-        /// @param what The message to associate with this error.
-        /// @param path The path that could not be found in the property_tree.
-        template<class T> ptree_bad_path(const std::string &what,
-                                         const T &path);
-
-        ~ptree_bad_path() throw();
-
-        /// Retrieve the invalid path. You need to explicitly specify the
-        /// type of path.
-        template<class T> T path() const;
-    private:
-        boost::any m_path;
-    };
-
-}}
-
-#include "exception_implementation.hpp"
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/core/swap.hpp.orig	2022-05-09 13:48:22.300996161 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/core/swap.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,60 +0,0 @@
-// Copyright (C) 2007, 2008 Steven Watanabe, Joseph Gauterin, Niels Dekker
-//
-// Distributed under the Boost Software License, Version 1.0. (See
-// accompanying file LICENSE_1_0.txt or copy at
-// http://www.boost.org/LICENSE_1_0.txt)
-// For more information, see http://www.boost.org
-
-
-#ifndef BOOST_CORE_SWAP_HPP
-#define BOOST_CORE_SWAP_HPP
-
-// Note: the implementation of this utility contains various workarounds:
-// - swap_impl is put outside the boost namespace, to avoid infinite
-// recursion (causing stack overflow) when swapping objects of a primitive
-// type.
-// - swap_impl has a using-directive, rather than a using-declaration,
-// because some compilers (including MSVC 7.1, Borland 5.9.3, and
-// Intel 8.1) don't do argument-dependent lookup when it has a
-// using-declaration instead.
-// - boost::swap has two template arguments, instead of one, to
-// avoid ambiguity when swapping objects of a Boost type that does
-// not have its own boost::swap overload.
-
-#include <utility> //for std::swap (C++11)
-#include <algorithm> //for std::swap (C++98)
-#include <cstddef> //for std::size_t
-#include <boost/config.hpp>
-
-namespace boost_swap_impl
-{
-  template<class T>
-  //BOOST_GPU_ENABLED
-  void swap_impl(T& left, T& right)
-  {
-    using namespace std;//use std::swap if argument dependent lookup fails
-    swap(left,right);
-  }
-
-  template<class T, std::size_t N>
-  //BOOST_GPU_ENABLED
-  void swap_impl(T (& left)[N], T (& right)[N])
-  {
-    for (std::size_t i = 0; i < N; ++i)
-    {
-      ::boost_swap_impl::swap_impl(left[i], right[i]);
-    }
-  }
-}
-
-namespace boost
-{
-  template<class T1, class T2>
-  //BOOST_GPU_ENABLED
-  void swap(T1& left, T2& right)
-  {
-    ::boost_swap_impl::swap_impl(left, right);
-  }
-}
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/throw_exception.hpp.orig	2022-05-09 13:48:22.340994538 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/throw_exception.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,102 +0,0 @@
-#ifndef UUID_AA15E74A856F11E08B8D93F24824019B
-#define UUID_AA15E74A856F11E08B8D93F24824019B
-#if (__GNUC__*100+__GNUC_MINOR__>301) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)
-#pragma GCC system_header
-#endif
-#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)
-#pragma warning(push,1)
-#endif
-
-// MS compatible compilers support #pragma once
-
-#if defined(_MSC_VER) && (_MSC_VER >= 1020)
-# pragma once
-#endif
-
-//
-//  boost/throw_exception.hpp
-//
-//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
-//  Copyright (c) 2008-2009 Emil Dotchevski and Reverge Studios, Inc.
-//
-//  Distributed under the Boost Software License, Version 1.0. (See
-//  accompanying file LICENSE_1_0.txt or copy at
-//  http://www.boost.org/LICENSE_1_0.txt)
-//
-//  http://www.boost.org/libs/utility/throw_exception.html
-//
-
-#include <boost/detail/workaround.hpp>
-#include <boost/config.hpp>
-#include <exception>
-
-#if !defined( BOOST_EXCEPTION_DISABLE ) && defined( __BORLANDC__ ) && BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x593) )
-# define BOOST_EXCEPTION_DISABLE
-#endif
-
-#if !defined( BOOST_EXCEPTION_DISABLE ) && defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, < 1310 )
-# define BOOST_EXCEPTION_DISABLE
-#endif
-
-#if !defined( BOOST_EXCEPTION_DISABLE )
-# include <boost/exception/exception.hpp>
-#if !defined(BOOST_THROW_EXCEPTION_CURRENT_FUNCTION)
-# include <boost/current_function.hpp>
-# define BOOST_THROW_EXCEPTION_CURRENT_FUNCTION BOOST_CURRENT_FUNCTION
-#endif
-# define BOOST_THROW_EXCEPTION(x) ::boost::exception_detail::throw_exception_(x,BOOST_THROW_EXCEPTION_CURRENT_FUNCTION,__FILE__,__LINE__)
-#else
-# define BOOST_THROW_EXCEPTION(x) ::boost::throw_exception(x)
-#endif
-
-namespace boost
-{
-#ifdef BOOST_NO_EXCEPTIONS
-
-void throw_exception( std::exception const & e ); // user defined
-
-#else
-
-inline void throw_exception_assert_compatibility( std::exception const & ) { }
-
-template<class E> BOOST_NORETURN inline void throw_exception( E const & e )
-{
-    //All boost exceptions are required to derive from std::exception,
-    //to ensure compatibility with BOOST_NO_EXCEPTIONS.
-    throw_exception_assert_compatibility(e);
-
-#ifndef BOOST_EXCEPTION_DISABLE
-    throw enable_current_exception(enable_error_info(e));
-#else
-    throw e;
-#endif
-}
-
-#endif
-
-#if !defined( BOOST_EXCEPTION_DISABLE )
-    namespace
-    exception_detail
-    {
-        template <class E>
-        BOOST_NORETURN
-        void
-        throw_exception_( E const & x, char const * current_function, char const * file, int line )
-        {
-            boost::throw_exception(
-                set_info(
-                    set_info(
-                        set_info(
-                            enable_error_info(x),
-                            throw_function(current_function)),
-                        throw_file(file)),
-                    throw_line(line)));
-        }
-    }
-#endif
-} // namespace boost
-
-#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)
-#pragma warning(pop)
-#endif
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/id_translator.hpp.orig	2022-05-09 13:48:22.300996161 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/id_translator.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,51 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-
-#ifndef BOOST_PROPERTY_TREE_ID_TRANSLATOR_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_ID_TRANSLATOR_HPP_INCLUDED
-
-#include "ptree_fwd.hpp"
-
-#include <boost/optional.hpp>
-#include <string>
-
-namespace boost { namespace property_tree
-{
-
-    /// Simple implementation of the Translator concept. It does no translation.
-    template <typename T>
-    struct id_translator
-    {
-        typedef T internal_type;
-        typedef T external_type;
-
-        boost::optional<T> get_value(const T &v) { return v; }
-        boost::optional<T> put_value(const T &v) { return v; }
-    };
-
-    // This is the default translator whenever you get two equal types.
-    template <typename T>
-    struct translator_between<T, T>
-    {
-        typedef id_translator<T> type;
-    };
-
-    // A more specific specialization for std::basic_string. Otherwise,
-    // stream_translator's specialization wins.
-    template <typename Ch, typename Traits, typename Alloc>
-    struct translator_between< std::basic_string<Ch, Traits, Alloc>,
-                               std::basic_string<Ch, Traits, Alloc> >
-    {
-        typedef id_translator< std::basic_string<Ch, Traits, Alloc> > type;
-    };
-
-}}
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/exception_implementation.hpp.orig	2022-05-09 13:48:22.300996161 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/exception_implementation.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,83 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_DETAIL_EXCEPTIONS_IMPLEMENTATION_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_DETAIL_EXCEPTIONS_IMPLEMENTATION_HPP_INCLUDED
-
-namespace boost { namespace property_tree
-{
-
-    namespace detail
-    {
-
-        // Helper for preparing what string in ptree_bad_path exception
-        template<class P> inline
-        std::string prepare_bad_path_what(const std::string &what,
-                                          const P &path)
-        {
-            return what + " (" + path.dump() + ")";
-        }
-
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // ptree_error
-
-    inline ptree_error::ptree_error(const std::string &w): 
-        std::runtime_error(w) 
-    {
-    }
-
-    inline ptree_error::~ptree_error() throw()
-    {
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // ptree_bad_data
-
-    template<class D> inline
-    ptree_bad_data::ptree_bad_data(const std::string &w, const D &d):
-        ptree_error(w), m_data(d)
-    {
-    }
-
-    inline ptree_bad_data::~ptree_bad_data() throw()
-    {
-    }
-
-    template<class D> inline
-    D ptree_bad_data::data() const
-    {
-        return boost::any_cast<D>(m_data);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-    // ptree_bad_path
-
-    template<class P> inline
-    ptree_bad_path::ptree_bad_path(const std::string &w, const P &p):
-        ptree_error(detail::prepare_bad_path_what(w, p)), m_path(p)
-    {
-
-    }
-
-    inline ptree_bad_path::~ptree_bad_path() throw()
-    {
-    }
-
-    template<class P> inline
-    P ptree_bad_path::path() const
-    {
-        return boost::any_cast<P>(m_path);
-    }
-
-}}
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ini_parser.hpp.orig	2022-05-09 13:48:22.336994700 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/ini_parser.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,334 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2002-2006 Marcin Kalicinski
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-#ifndef BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_INI_PARSER_HPP_INCLUDED
-
-#include "ptree.hpp"
-#include "ptree_utils.hpp"
-#include "file_parser_error.hpp"
-#include <fstream>
-#include <string>
-#include <sstream>
-#include <stdexcept>
-#include <locale>
-
-namespace boost { namespace property_tree { namespace ini_parser
-{
-
-    /**
-     * Determines whether the @c flags are valid for use with the ini_parser.
-     * @param flags value to check for validity as flags to ini_parser.
-     * @return true if the flags are valid, false otherwise.
-     */
-    inline bool validate_flags(int flags)
-    {
-        return flags == 0;
-    }
-
-    /** Indicates an error parsing INI formatted data. */
-    class ini_parser_error: public file_parser_error
-    {
-    public:
-        /**
-         * Construct an @c ini_parser_error
-         * @param message Message describing the parser error.
-         * @param filename The name of the file being parsed containing the
-         *                 error.
-         * @param line The line in the given file where an error was
-         *             encountered.
-         */
-        ini_parser_error(const std::string &message,
-                         const std::string &filename,
-                         unsigned long line)
-            : file_parser_error(message, filename, line)
-        {
-        }
-    };
-
-    /**
-     * Read INI from a the given stream and translate it to a property tree.
-     * @note Clears existing contents of property tree. In case of error
-     *       the property tree is not modified.
-     * @throw ini_parser_error If a format violation is found.
-     * @param stream Stream from which to read in the property tree.
-     * @param[out] pt The property tree to populate.
-     */
-    template<class Ptree>
-    void read_ini(std::basic_istream<
-                    typename Ptree::key_type::value_type> &stream,
-                  Ptree &pt)
-    {
-        typedef typename Ptree::key_type::value_type Ch;
-        typedef std::basic_string<Ch> Str;
-        const Ch semicolon = stream.widen(';');
-        const Ch hash = stream.widen('#');
-        const Ch lbracket = stream.widen('[');
-        const Ch rbracket = stream.widen(']');
-
-        Ptree local;
-        unsigned long line_no = 0;
-        Ptree *section = 0;
-        Str line;
-
-        // For all lines
-        while (stream.good())
-        {
-
-            // Get line from stream
-            ++line_no;
-            std::getline(stream, line);
-            if (!stream.good() && !stream.eof())
-                BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                    "read error", "", line_no));
-
-            // If line is non-empty
-            line = property_tree::detail::trim(line, stream.getloc());
-            if (!line.empty())
-            {
-                // Comment, section or key?
-                if (line[0] == semicolon || line[0] == hash)
-                {
-                    // Ignore comments
-                }
-                else if (line[0] == lbracket)
-                {
-                    // If the previous section was empty, drop it again.
-                    if (section && section->empty())
-                        local.pop_back();
-                    typename Str::size_type end = line.find(rbracket);
-                    if (end == Str::npos)
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "unmatched '['", "", line_no));
-                    Str key = property_tree::detail::trim(
-                        line.substr(1, end - 1), stream.getloc());
-                    if (local.find(key) != local.not_found())
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "duplicate section name", "", line_no));
-                    section = &local.push_back(
-                        std::make_pair(key, Ptree()))->second;
-                }
-                else
-                {
-                    Ptree &container = section ? *section : local;
-                    typename Str::size_type eqpos = line.find(Ch('='));
-                    if (eqpos == Str::npos)
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "'=' character not found in line", "", line_no));
-                    if (eqpos == 0)
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "key expected", "", line_no));
-                    Str key = property_tree::detail::trim(
-                        line.substr(0, eqpos), stream.getloc());
-                    Str data = property_tree::detail::trim(
-                        line.substr(eqpos + 1, Str::npos), stream.getloc());
-                    if (container.find(key) != container.not_found())
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "duplicate key name", "", line_no));
-                    container.push_back(std::make_pair(key, Ptree(data)));
-                }
-            }
-        }
-        // If the last section was empty, drop it again.
-        if (section && section->empty())
-            local.pop_back();
-
-        // Swap local ptree with result ptree
-        pt.swap(local);
-
-    }
-
-    /**
-     * Read INI from a the given file and translate it to a property tree.
-     * @note Clears existing contents of property tree.  In case of error the
-     *       property tree unmodified.
-     * @throw ini_parser_error In case of error deserializing the property tree.
-     * @param filename Name of file from which to read in the property tree.
-     * @param[out] pt The property tree to populate.
-     * @param loc The locale to use when reading in the file contents.
-     */
-    template<class Ptree>
-    void read_ini(const std::string &filename, 
-                  Ptree &pt,
-                  const std::locale &loc = std::locale())
-    {
-        std::basic_ifstream<typename Ptree::key_type::value_type>
-            stream(filename.c_str());
-        if (!stream)
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                "cannot open file", filename, 0));
-        stream.imbue(loc);
-        try {
-            read_ini(stream, pt);
-        }
-        catch (ini_parser_error &e) {
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                e.message(), filename, e.line()));
-        }
-    }
-
-    namespace detail
-    {
-        template<class Ptree>
-        void check_dupes(const Ptree &pt)
-        {
-            if(pt.size() <= 1)
-                return;
-            const typename Ptree::key_type *lastkey = 0;
-            typename Ptree::const_assoc_iterator it = pt.ordered_begin(),
-                                                 end = pt.not_found();
-            lastkey = &it->first;
-            for(++it; it != end; ++it) {
-                if(*lastkey == it->first)
-                    BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                        "duplicate key", "", 0));
-                lastkey = &it->first;
-            }
-        }
-
-        template <typename Ptree>
-        void write_keys(std::basic_ostream<
-                                      typename Ptree::key_type::value_type
-                                  > &stream,
-                                  const Ptree& pt,
-                                  bool throw_on_children)
-        {
-            typedef typename Ptree::key_type::value_type Ch;
-            for (typename Ptree::const_iterator it = pt.begin(), end = pt.end();
-                 it != end; ++it)
-            {
-                if (!it->second.empty()) {
-                    if (throw_on_children) {
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "ptree is too deep", "", 0));
-                    }
-                    continue;
-                }
-                stream << it->first << Ch('=')
-                    << it->second.template get_value<
-                        std::basic_string<Ch> >()
-                    << Ch('\n');
-            }
-        }
-
-        template <typename Ptree>
-        void write_top_level_keys(std::basic_ostream<
-                                      typename Ptree::key_type::value_type
-                                  > &stream,
-                                  const Ptree& pt)
-        {
-            write_keys(stream, pt, false);
-        }
-
-        template <typename Ptree>
-        void write_sections(std::basic_ostream<
-                                typename Ptree::key_type::value_type
-                            > &stream,
-                            const Ptree& pt)
-        {
-            typedef typename Ptree::key_type::value_type Ch;
-            for (typename Ptree::const_iterator it = pt.begin(), end = pt.end();
-                 it != end; ++it)
-            {
-                if (!it->second.empty()) {
-                    check_dupes(it->second);
-                    if (!it->second.data().empty())
-                        BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                            "mixed data and children", "", 0));
-                    stream << Ch('[') << it->first << Ch(']') << Ch('\n');
-                    write_keys(stream, it->second, true);
-                }
-            }
-        }
-    }
-
-    /**
-     * Translates the property tree to INI and writes it the given output
-     * stream.
-     * @pre @e pt cannot have data in its root.
-     * @pre @e pt cannot have keys both data and children.
-     * @pre @e pt cannot be deeper than two levels.
-     * @pre There cannot be duplicate keys on any given level of @e pt.
-     * @throw ini_parser_error In case of error translating the property tree to
-     *                         INI or writing to the output stream.
-     * @param stream The stream to which to write the INI representation of the 
-     *               property tree.
-     * @param pt The property tree to tranlsate to INI and output.
-     * @param flags The flags to use when writing the INI file.
-     *              No flags are currently supported.
-     */
-    template<class Ptree>
-    void write_ini(std::basic_ostream<
-                       typename Ptree::key_type::value_type
-                   > &stream,
-                   const Ptree &pt,
-                   int flags = 0)
-    {
-        BOOST_ASSERT(validate_flags(flags));
-        (void)flags;
-
-        if (!pt.data().empty())
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                "ptree has data on root", "", 0));
-        detail::check_dupes(pt);
-
-        detail::write_top_level_keys(stream, pt);
-        detail::write_sections(stream, pt);
-    }
-
-    /**
-     * Translates the property tree to INI and writes it the given file.
-     * @pre @e pt cannot have data in its root.
-     * @pre @e pt cannot have keys both data and children.
-     * @pre @e pt cannot be deeper than two levels.
-     * @pre There cannot be duplicate keys on any given level of @e pt.
-     * @throw info_parser_error In case of error translating the property tree
-     *                          to INI or writing to the file.
-     * @param filename The name of the file to which to write the INI
-     *                 representation of the property tree.
-     * @param pt The property tree to tranlsate to INI and output.
-     * @param flags The flags to use when writing the INI file.
-     *              The following flags are supported:
-     * @li @c skip_ini_validity_check -- Skip check if ptree is a valid ini. The
-     *     validity check covers the preconditions but takes <tt>O(n log n)</tt>
-     *     time.
-     * @param loc The locale to use when writing the file.
-     */
-    template<class Ptree>
-    void write_ini(const std::string &filename,
-                   const Ptree &pt,
-                   int flags = 0,
-                   const std::locale &loc = std::locale())
-    {
-        std::basic_ofstream<typename Ptree::key_type::value_type>
-            stream(filename.c_str());
-        if (!stream)
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                "cannot open file", filename, 0));
-        stream.imbue(loc);
-        try {
-            write_ini(stream, pt, flags);
-        }
-        catch (ini_parser_error &e) {
-            BOOST_PROPERTY_TREE_THROW(ini_parser_error(
-                e.message(), filename, e.line()));
-        }
-    }
-
-} } }
-
-namespace boost { namespace property_tree
-{
-    using ini_parser::ini_parser_error;
-    using ini_parser::read_ini;
-    using ini_parser::write_ini;
-} }
-
-#endif
--- cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/string_path.hpp.orig	2022-05-09 13:48:22.340994538 -0700
+++ cavecreek-1.0.3-42/quickassist/utilities/adf_ctl/third_party/boost/string_path.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,283 +0,0 @@
-// ----------------------------------------------------------------------------
-// Copyright (C) 2009 Sebastian Redl
-//
-// Distributed under the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at 
-// http://www.boost.org/LICENSE_1_0.txt)
-//
-// For more information, see www.boost.org
-// ----------------------------------------------------------------------------
-
-#ifndef BOOST_PROPERTY_TREE_STRING_PATH_HPP_INCLUDED
-#define BOOST_PROPERTY_TREE_STRING_PATH_HPP_INCLUDED
-
-#include "ptree_fwd.hpp"
-#include "id_translator.hpp"
-#include "exceptions.hpp"
-#include "ptree_utils.hpp"
-//#include "throw_exception.hpp"
-#include <exception>
-
-#include <boost/static_assert.hpp>
-#include <boost/assert.hpp>
-#include <boost/type_traits/is_same.hpp>
-#include <boost/optional.hpp>
-#include <boost/throw_exception.hpp>
-#include <algorithm>
-#include <string>
-#include <iterator>
-
-//#define BOOST_THROW_EXCEPTION(x) ::boost::throw_exception(x)
-
-namespace boost { namespace property_tree
-{
-    namespace detail
-    {
-        template <typename Sequence, typename Iterator>
-        void append_and_preserve_iter(Sequence &s, const Sequence &r,
-                                      Iterator &, std::forward_iterator_tag)
-        {
-            // Here we boldly assume that anything that is not random-access
-            // preserves validity. This is valid for the STL sequences.
-            s.insert(s.end(), r.begin(), r.end());
-        }
-        template <typename Sequence, typename Iterator>
-        void append_and_preserve_iter(Sequence &s, const Sequence &r,
-                                      Iterator &it,
-                                      std::random_access_iterator_tag)
-        {
-            // Convert the iterator to an index, and later back.
-            typename std::iterator_traits<Iterator>::difference_type idx =
-                it - s.begin();
-            s.insert(s.end(), r.begin(), r.end());
-            it = s.begin() + idx;
-        }
-
-        template <typename Sequence>
-        inline std::string dump_sequence(const Sequence &)
-        {
-            return "<undumpable sequence>";
-        }
-        inline std::string dump_sequence(const std::string &s)
-        {
-            return s;
-        }
-#ifndef BOOST_NO_STD_WSTRING
-        inline std::string dump_sequence(const std::wstring &s)
-        {
-            return narrow<std::string>(s.c_str());
-        }
-#endif
-    }
-
-    /// Default path class. A path is a sequence of values. Groups of values
-    /// are separated by the separator value, which defaults to '.' cast to
-    /// the sequence's value type. The group of values is then passed to the
-    /// translator to get a key.
-    ///
-    /// If instantiated with std::string and id_translator\<std::string\>,
-    /// it accepts paths of the form "one.two.three.four".
-    ///
-    /// @tparam String Any Sequence. If the sequence does not support random-
-    ///                access iteration, concatenation of paths assumes that
-    ///                insertions at the end preserve iterator validity.
-    /// @tparam Translator A translator with internal_type == String.
-    template <typename String, typename Translator>
-    class string_path
-    {
-        BOOST_STATIC_ASSERT((is_same<String,
-                                   typename Translator::internal_type>::value));
-    public:
-        typedef typename Translator::external_type key_type;
-        typedef typename String::value_type char_type;
-
-        /// Create an empty path.
-        explicit string_path(char_type separator = char_type('.'));
-        /// Create a path by parsing the given string.
-        /// @param value A sequence, possibly with separators, that describes
-        ///              the path, e.g. "one.two.three".
-        /// @param separator The separator used in parsing. Defaults to '.'.
-        /// @param tr The translator used by this path to convert the individual
-        ///           parts to keys.
-        string_path(const String &value, char_type separator = char_type('.'),
-                    Translator tr = Translator());
-        /// Create a path by parsing the given string.
-        /// @param value A zero-terminated array of values. Only use if zero-
-        ///              termination makes sense for your type, and your
-        ///              sequence supports construction from it. Intended for
-        ///              string literals.
-        /// @param separator The separator used in parsing. Defaults to '.'.
-        /// @param tr The translator used by this path to convert the individual
-        ///           parts to keys.
-        string_path(const char_type *value,
-                    char_type separator = char_type('.'),
-                    Translator tr = Translator());
-
-        // Default copying doesn't do the right thing with the iterator
-        string_path(const string_path &o);
-        string_path& operator =(const string_path &o);
-
-        /// Take a single element off the path at the front and return it.
-        key_type reduce();
-
-        /// Test if the path is empty.
-        bool empty() const;
-
-        /// Test if the path contains a single element, i.e. no separators.
-        bool single() const;
-
-        /// Get the separator used by this path.
-        char_type separator() const { return m_separator; }
-
-        std::string dump() const {
-            return detail::dump_sequence(m_value);
-        }
-
-        /// Append a second path to this one.
-        /// @pre o's separator is the same as this one's, or o has no separators
-        string_path& operator /=(const string_path &o) {
-            // If it's single, there's no separator. This allows to do
-            // p /= "piece";
-            // even for non-default separators.
-            BOOST_ASSERT((m_separator == o.m_separator
-                          || o.empty()
-                          || o.single())
-                         && "Incompatible paths.");
-            if(!o.empty()) {
-                String sub;
-                if(!this->empty()) {
-                    sub.push_back(m_separator);
-                }
-                sub.insert(sub.end(), o.cstart(), o.m_value.end());
-                detail::append_and_preserve_iter(m_value, sub, m_start,
-                    typename std::iterator_traits<s_iter>::iterator_category());
-            }
-            return *this;
-        }
-
-    private:
-        typedef typename String::iterator s_iter;
-        typedef typename String::const_iterator s_c_iter;
-        String m_value;
-        char_type m_separator;
-        Translator m_tr;
-        s_iter m_start;
-        s_c_iter cstart() const { return m_start; }
-    };
-
-    template <typename String, typename Translator> inline
-    string_path<String, Translator>::string_path(char_type separator)
-        : m_separator(separator), m_start(m_value.begin())
-    {}
-
-    template <typename String, typename Translator> inline
-    string_path<String, Translator>::string_path(const String &value,
-                                                 char_type separator,
-                                                 Translator tr)
-        : m_value(value), m_separator(separator),
-          m_tr(tr), m_start(m_value.begin())
-    {}
-
-    template <typename String, typename Translator> inline
-    string_path<String, Translator>::string_path(const char_type *value,
-                                                 char_type separator,
-                                                 Translator tr)
-        : m_value(value), m_separator(separator),
-          m_tr(tr), m_start(m_value.begin())
-    {}
-
-    template <typename String, typename Translator> inline
-    string_path<String, Translator>::string_path(const string_path &o)
-        : m_value(o.m_value), m_separator(o.m_separator),
-          m_tr(o.m_tr), m_start(m_value.begin())
-    {
-        std::advance(m_start, std::distance(o.m_value.begin(), o.cstart()));
-    }
-
-    template <typename String, typename Translator> inline
-    string_path<String, Translator>&
-    string_path<String, Translator>::operator =(const string_path &o)
-    {
-        m_value = o.m_value;
-        m_separator = o.m_separator;
-        m_tr = o.m_tr;
-        m_start = m_value.begin();
-        std::advance(m_start, std::distance(o.m_value.begin(), o.cstart()));
-        return *this;
-    }
-
-    template <typename String, typename Translator>
-    typename Translator::external_type string_path<String, Translator>::reduce()
-    {
-        BOOST_ASSERT(!empty() && "Reducing empty path");
-
-        s_iter next_sep = std::find(m_start, m_value.end(), m_separator);
-        String part(m_start, next_sep);
-        m_start = next_sep;
-        if(!empty()) {
-          // Unless we're at the end, skip the separator we found.
-          ++m_start;
-        }
-
-        if(optional<key_type> key = m_tr.get_value(part)) {
-            return *key;
-        }
-	//return NULL;
-        BOOST_PROPERTY_TREE_THROW(ptree_bad_path("Path syntax error", *this));
-    }
-
-    template <typename String, typename Translator> inline
-    bool string_path<String, Translator>::empty() const
-    {
-        return m_start == m_value.end();
-    }
-
-    template <typename String, typename Translator> inline
-    bool string_path<String, Translator>::single() const
-    {
-        return std::find(static_cast<s_c_iter>(m_start),
-                         m_value.end(), m_separator)
-            == m_value.end();
-    }
-
-    // By default, this is the path for strings. You can override this by
-    // specializing path_of for a more specific form of std::basic_string.
-    template <typename Ch, typename Traits, typename Alloc>
-    struct path_of< std::basic_string<Ch, Traits, Alloc> >
-    {
-        typedef std::basic_string<Ch, Traits, Alloc> _string;
-        typedef string_path< _string, id_translator<_string> > type;
-    };
-
-    template <typename String, typename Translator> inline
-    string_path<String, Translator> operator /(
-                                  string_path<String, Translator> p1,
-                                  const string_path<String, Translator> &p2)
-    {
-        p1 /= p2;
-        return p1;
-    }
-
-    // These shouldn't be necessary, but GCC won't find the one above.
-    template <typename String, typename Translator> inline
-    string_path<String, Translator> operator /(
-                                  string_path<String, Translator> p1,
-                                  const typename String::value_type *p2)
-    {
-        p1 /= p2;
-        return p1;
-    }
-
-    template <typename String, typename Translator> inline
-    string_path<String, Translator> operator /(
-                                  const typename String::value_type *p1,
-                                  const string_path<String, Translator> &p2)
-    {
-        string_path<String, Translator> t(p1);
-        t /= p2;
-        return t;
-    }
-
-}}
-
-#endif
--- cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_crypto.c.orig	2022-05-09 13:48:22.201000221 -0700
+++ cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_crypto.c	2022-05-09 13:48:22.640982361 -0700
@@ -148,6 +148,63 @@
 	return inst;
 }
 
+#ifdef CONFIG_WG_PLATFORM   // WG:XD FBX-19660
+struct qat_crypto_instance *qat_crypto_get_local_cpu_instance_node(int node, int cpu)
+{
+	struct adf_accel_dev *accel_dev = NULL, *tmp_dev;
+	struct qat_crypto_instance *inst = NULL, *tmp_inst;
+	unsigned long best = ~0;
+
+	list_for_each_entry(tmp_dev, adf_devmgr_get_head(), list) {
+		unsigned long ctr;
+
+		if ((node == dev_to_node(&GET_DEV(tmp_dev)) ||
+			 dev_to_node(&GET_DEV(tmp_dev)) < 0) &&
+			adf_dev_started(tmp_dev) &&
+			!list_empty(&tmp_dev->crypto_list)) {
+			ctr = atomic_read(&tmp_dev->ref_count);
+			if (best > ctr) {
+				accel_dev = tmp_dev;
+				best = ctr;
+			}
+		}
+	}
+
+	if (!accel_dev) {
+		pr_info("QAT: Could not find a device on node %d\n", node);
+		/* Get any started device */
+		list_for_each_entry(tmp_dev, adf_devmgr_get_head(), list) {
+			if (adf_dev_started(tmp_dev) &&
+				!list_empty(&tmp_dev->crypto_list)) {
+				accel_dev = tmp_dev;
+				break;
+			}
+		}
+	}
+
+	if (!accel_dev)
+        return NULL;
+
+	best = ~0;
+	list_for_each_entry(tmp_inst, &accel_dev->crypto_list, list) {
+		unsigned long ctr;
+
+		if (tmp_inst->id == cpu) {
+			inst = tmp_inst;
+			break;
+		}
+	}
+	if (inst) {
+		if (adf_dev_get(accel_dev)) {
+			dev_err(&GET_DEV(accel_dev), "Could not increment dev refctr\n");
+			return NULL;
+		}
+		atomic_inc(&inst->refctr);
+	}
+	return inst;
+}
+#endif
+
 /**
  * qat_crypto_dev_config() - create dev config required to create crypto inst.
  *
--- cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_algs.c.orig	2022-05-09 13:48:22.177001195 -0700
+++ cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_algs.c	2022-05-09 13:48:22.636982523 -0700
@@ -54,6 +54,9 @@
 #include <crypto/hash.h>
 #include <crypto/algapi.h>
 #include <crypto/authenc.h>
+#ifdef	CONFIG_WG_PLATFORM
+#include <crypto/rng.h>
+#endif
 #include <linux/dma-mapping.h>
 #include "adf_accel_devices.h"
 #include "adf_transport.h"
@@ -63,6 +66,118 @@
 #include "icp_qat_fw.h"
 #include "icp_qat_fw_la.h"
 
+#ifdef	CONFIG_WG_PLATFORM
+
+#define	CONFIG_WG_PLATFORM_GCM		1
+#define	CONFIG_WG_PLATFORM_SHA2		1
+#define	CONFIG_WG_PLATFORM_MODE0	1
+
+#define	PrintK(...)
+#define	PrintHex(a,b)
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+
+#if	CONFIG_WG_PLATFORM_GCM > 1
+
+#define	static
+
+#undef	PrintK
+#undef	PrintHex
+
+#define	PrintK		if (unlikely(console_loglevel & 16)) printk
+#define	PrintHex(a,b)	if (unlikely(console_loglevel & 32)) wg_dump_hex((u8*)(a),(b),"")
+
+#endif
+
+#define	GCM_NONCE_SIZE		( 4)
+#define	GCM_IV_SIZE		( 8)
+#define	GCM_DIGEST_SIZE		(16)
+#define	GCM_AAD_PAD_SIZE	(16)
+
+#define	GCM_STATE1_SZ		(16)
+#define	GCM_STATE2_SZ		(40)
+#define	GCM_PARAMS_SZ		((int)(sizeof(struct icp_qat_hw_auth_setup) + \
+				 GCM_STATE1_SZ + GCM_STATE2_SZ + \
+				 sizeof(struct icp_qat_hw_cipher_config)))
+
+#define	QAT_AES_HW_CONFIG_GCM_ENC(alg) \
+	ICP_QAT_HW_CIPHER_CONFIG_BUILD(ICP_QAT_HW_CIPHER_CTR_MODE, alg, \
+				       ICP_QAT_HW_CIPHER_NO_CONVERT, \
+				       ICP_QAT_HW_CIPHER_ENCRYPT)
+
+#define	QAT_AES_HW_CONFIG_GCM_DEC(alg) \
+	ICP_QAT_HW_CIPHER_CONFIG_BUILD(ICP_QAT_HW_CIPHER_CTR_MODE, alg, \
+				       ICP_QAT_HW_CIPHER_NO_CONVERT, \
+				       ICP_QAT_HW_CIPHER_ENCRYPT)
+
+static	struct crypto_cipher* gcm_aes_cipher;
+
+#if	CONFIG_WG_PLATFORM_GCM > 8
+
+char	GCMKey[] = {
+	0x47, 0x43, 0x4D, 0x31, 0x36, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0X00, 0x00, 0x00, 0x00
+};
+
+char	GCMAad[] = {
+	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x01
+};
+
+char	GCMIv[]  = {
+	0x4E, 0x4F, 0x4E, 0x45, 0x93, 0x2F, 0xA9, 0x4F,
+	0x4A, 0xF6, 0xDB, 0xB6
+};
+
+char	GCMSrc[] = {
+	0x45, 0x00, 0x00, 0x54, 0x92, 0x43, 0x40, 0x00,
+	0x40, 0x01, 0x30, 0x10, 0xc0, 0xa8, 0xfb, 0x01,
+
+	0xc0, 0xa8, 0xfc, 0x02, 0x08, 0x00, 0x57, 0xD4,
+	0xDE, 0x0D, 0x00, 0x01, 0x7A, 0x04, 0x8F, 0x5A,
+
+	0x00, 0x00, 0x00, 0x00, 0xF7, 0xEA, 0x02, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13,
+
+	0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
+	0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
+
+	0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
+	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
+
+	0x34, 0x35, 0x36, 0x37, 0x01, 0x02, 0x02, 0x04
+};
+
+char	GCMDst[] = {
+	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x01,
+	0x93, 0x2F, 0xA9, 0x4F,	0x4A, 0xF6, 0xDB, 0xB6,
+
+	0xb3, 0x13, 0xfe, 0x1e, 0xcf, 0x0b, 0xba, 0x74,
+	0xb3, 0xeb, 0x28, 0xc5, 0x20, 0xd2, 0x3e, 0xca,
+
+	0x6b, 0xdc, 0x48, 0x61, 0x05, 0x8c, 0xc5, 0x2f,
+	0x9f, 0xaa, 0xd0, 0x10, 0xa4, 0xeb, 0xc8, 0xfd,
+
+	0xe3, 0x85, 0x7b, 0x68, 0x5b, 0x18, 0xe0, 0x43,
+	0x00, 0x21, 0x06, 0xcc, 0xa3, 0x7e, 0xbc, 0xc6,
+
+	0x7d, 0x2f, 0xbe, 0xda, 0x0c, 0x50, 0x73, 0xd0,
+	0xf6, 0x86, 0x8b, 0xcf, 0xe1, 0x26, 0xa6, 0xb2,
+
+	0x46, 0x61, 0x54, 0xcc, 0xc9, 0x84, 0xd3, 0xec,
+	0xbf, 0x3d, 0xae, 0x35, 0x97, 0xeb, 0x32, 0xe5,
+
+	0x30, 0x04, 0xd9, 0xcc, 0x2e, 0x78, 0x02, 0xc9,
+	// Tag
+	0x58, 0xbd, 0x2a, 0x75, 0x04, 0x01, 0xbc, 0xfd,
+	0x08, 0x30, 0x98, 0x93, 0x14, 0x94, 0x9f, 0x30
+};
+
+#endif	// CONFIG_WG_PLATFORM_GCM > 8
+
+#endif	// CONFIG_WG_PLATFORM_GCM
+
+#endif	// CONFIG_WG_PLATFORM
+
 #define QAT_AES_HW_CONFIG_ENC(alg, mode) \
 	ICP_QAT_HW_CIPHER_CONFIG_BUILD(mode, alg, \
 				       ICP_QAT_HW_CIPHER_NO_CONVERT, \
@@ -113,6 +228,11 @@
 	struct crypto_shash *hash_tfm;
 	enum icp_qat_hw_auth_algo qat_hash_alg;
 	struct qat_crypto_instance *inst;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	u32	   gcm_keylen;	/* keylen for GCM mode operations */
+	u32	   gcm_nonce;	/* nonce  for GCM mode operations */
+	atomic64_t gcm_seqno;	/* seqno  for GCM mode operations */
+#endif
 };
 
 struct qat_alg_ablkcipher_ctx {
@@ -127,6 +247,10 @@
 	spinlock_t lock;	/* protects qat_alg_ablkcipher_ctx struct */
 };
 
+#ifdef CONFIG_WG_PLATFORM   // WG:XD FBX-19123
+extern struct qat_crypto_instance *qat_crypto_get_local_cpu_instance_node(int node, int cpu);
+#endif
+
 static int qat_get_inter_state_size(enum icp_qat_hw_auth_algo qat_hash_alg)
 {
 	switch (qat_hash_alg) {
@@ -134,6 +258,10 @@
 		return ICP_QAT_HW_SHA1_STATE1_SZ;
 	case ICP_QAT_HW_AUTH_ALGO_SHA256:
 		return ICP_QAT_HW_SHA256_STATE1_SZ;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+		return ICP_QAT_HW_SHA384_STATE1_SZ;
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		return ICP_QAT_HW_SHA512_STATE1_SZ;
 	default:
@@ -159,6 +287,29 @@
 	__be64 *hash512_state_out;
 	int i, offset;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		char gcm_zeros[AES_BLOCK_SIZE] = {0};
+
+		hash->sha.inner_setup.auth_counter.counter = 0;
+
+		crypto_cipher_setkey(gcm_aes_cipher, auth_key, auth_keylen);
+		crypto_cipher_encrypt_one(gcm_aes_cipher,
+					  &hash->sha.state1[GCM_STATE1_SZ],
+					  gcm_zeros);
+
+		return 0;
+	}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (unlikely(auth_keylen == 0))
+	if (unlikely(wg_fips_sha >  0)) {
+		auth_keylen = wg_fips_sha_len;
+		auth_key    = wg_fips_sha_key;
+	}
+#endif
+
 	memset(ipad, 0, block_size);
 	memset(opad, 0, block_size);
 	shash->tfm = ctx->hash_tfm;
@@ -205,6 +356,9 @@
 		for (i = 0; i < digest_size >> 2; i++, hash_state_out++)
 			*hash_state_out = cpu_to_be32(*(sha256.state + i));
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		if (crypto_shash_export(shash, &sha512))
 			return -EFAULT;
@@ -238,6 +392,9 @@
 		for (i = 0; i < digest_size >> 2; i++, hash_state_out++)
 			*hash_state_out = cpu_to_be32(*(sha256.state + i));
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		if (crypto_shash_export(shash, &sha512))
 			return -EFAULT;
@@ -262,6 +419,12 @@
 					    QAT_COMN_PTR_TYPE_SGL);
 	ICP_QAT_FW_LA_PARTIAL_SET(header->serv_specif_flags,
 				  ICP_QAT_FW_LA_PARTIAL_NONE);
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0)) {
+	ICP_QAT_FW_LA_CIPH_AUTH_CFG_OFFSET_FLAG_SET(header->serv_specif_flags,
+						    ICP_QAT_FW_CIPH_AUTH_CFG_OFFSET_IN_SHRAM_CP);
+	} else
+#endif
 	ICP_QAT_FW_LA_CIPH_IV_FLD_FLAG_SET(header->serv_specif_flags,
 					   ICP_QAT_FW_CIPH_IV_16BYTE_DATA);
 	ICP_QAT_FW_LA_PROTO_SET(header->serv_specif_flags,
@@ -270,6 +433,71 @@
 				       ICP_QAT_FW_LA_NO_UPDATE_STATE);
 }
 
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+
+static void qat_alg_aeadcipher_init_com(struct icp_qat_fw_la_bulk_req *req,
+					struct icp_qat_hw_cipher_algo_blk *cd,
+					const uint8_t *key, unsigned int keylen)
+{
+	struct icp_qat_fw_comn_req_hdr_cd_pars *cd_pars = &req->cd_pars;
+	struct icp_qat_fw_comn_req_hdr *header = &req->comn_hdr;
+	struct icp_qat_fw_cipher_cd_ctrl_hdr *cd_ctrl = (void *)&req->cd_ctrl;
+
+	memcpy(cd->aes.key, key, keylen);
+	qat_alg_init_common_hdr(header);
+	header->service_cmd_id = ICP_QAT_FW_LA_CMD_CIPHER;
+	cd_pars->u.s.content_desc_params_sz =
+		sizeof(struct icp_qat_hw_cipher_algo_blk) >> 3;
+
+	/* Cipher CD config setup */
+	cd_ctrl->cipher_key_sz = keylen >> 3;
+	cd_ctrl->cipher_state_sz = AES_BLOCK_SIZE >> 3;
+	cd_ctrl->cipher_cfg_offset = 0;
+	ICP_QAT_FW_COMN_CURR_ID_SET(cd_ctrl, ICP_QAT_FW_SLICE_CIPHER);
+	ICP_QAT_FW_COMN_NEXT_ID_SET(cd_ctrl, ICP_QAT_FW_SLICE_DRAM_WR);
+}
+
+static void qat_alg_aeadcipher_init_enc(struct qat_alg_aead_ctx *ctx,
+					int alg, const uint8_t *key,
+					unsigned int keylen, int mode)
+{
+	struct qat_enc *enc_ctx = &ctx->enc_cd->qat_enc_cd;
+	struct icp_qat_hw_cipher_algo_blk *enc_cd = &enc_ctx->cipher;
+	struct icp_qat_fw_la_bulk_req *req = &ctx->enc_fw_req;
+	struct icp_qat_fw_comn_req_hdr_cd_pars *cd_pars = &req->cd_pars;
+
+
+	PrintK(KERN_DEBUG "%s: alg %d keylen %d\n", __FUNCTION__, alg, keylen);
+
+	qat_alg_aeadcipher_init_com(req, enc_cd, key, keylen);
+	cd_pars->u.s.content_desc_addr = ctx->enc_cd_paddr;
+	enc_cd->aes.cipher_config.val = QAT_AES_HW_CONFIG_ENC(alg, mode);
+}
+
+static void qat_alg_aeadcipher_init_dec(struct qat_alg_aead_ctx *ctx,
+					int alg, const uint8_t *key,
+					unsigned int keylen, int mode)
+{
+	// Use 'enc' here since we need struct icp_qat_hw_cipher_algo_blk
+	// to come first for aeadcipher operations given there is no hash.
+	struct qat_enc *dec_ctx = &ctx->dec_cd->qat_enc_cd;
+	struct icp_qat_hw_cipher_algo_blk *dec_cd = &dec_ctx->cipher;
+	struct icp_qat_fw_la_bulk_req *req = &ctx->dec_fw_req;
+	struct icp_qat_fw_comn_req_hdr_cd_pars *cd_pars = &req->cd_pars;
+
+	PrintK(KERN_DEBUG "%s: alg %d keylen %d\n", __FUNCTION__, alg, keylen);
+
+	qat_alg_aeadcipher_init_com(req, dec_cd, key, keylen);
+	cd_pars->u.s.content_desc_addr = ctx->dec_cd_paddr;
+
+	if (mode != ICP_QAT_HW_CIPHER_CTR_MODE)
+	dec_cd->aes.cipher_config.val =	QAT_AES_HW_CONFIG_DEC(alg, mode);
+	else
+	dec_cd->aes.cipher_config.val =	QAT_AES_HW_CONFIG_ENC(alg, mode);
+}
+
+#endif
+
 static int qat_alg_aead_init_enc_session(struct crypto_aead *aead_tfm,
 					 int alg,
 					 struct crypto_authenc_keys *keys,
@@ -290,8 +518,25 @@
 	struct icp_qat_fw_auth_cd_ctrl_hdr *hash_cd_ctrl = ptr;
 
 	/* CD setup */
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+	hash = (struct icp_qat_hw_auth_algo_blk *)((char *)enc_ctx +
+		sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_GCM_ENC(alg);
+	} else
+#endif
 	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_ENC(alg, mode);
 	memcpy(cipher->aes.key, keys->enckey, keys->enckeylen);
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0)) {
+
+	hash = (struct icp_qat_hw_auth_algo_blk *)cipher;
+	hash->sha.inner_setup.auth_config.config =
+		ICP_QAT_HW_AUTH_CONFIG_BUILD(ICP_QAT_HW_AUTH_MODE0,
+					     ctx->qat_hash_alg,
+					     digestsize = wg_fips_sha / 8);
+	} else
+#endif
 	hash->sha.inner_setup.auth_config.config =
 		ICP_QAT_HW_AUTH_CONFIG_BUILD(ICP_QAT_HW_AUTH_MODE1,
 					     ctx->qat_hash_alg, digestsize);
@@ -303,7 +548,13 @@
 
 	/* Request setup */
 	qat_alg_init_common_hdr(header);
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0))
+	header->service_cmd_id = ICP_QAT_FW_LA_CMD_AUTH;
+	else
+#endif
 	header->service_cmd_id = ICP_QAT_FW_LA_CMD_CIPHER_HASH;
+
 	ICP_QAT_FW_LA_DIGEST_IN_BUFFER_SET(header->serv_specif_flags,
 					   ICP_QAT_FW_LA_DIGEST_IN_BUFFER);
 	ICP_QAT_FW_LA_RET_AUTH_SET(header->serv_specif_flags,
@@ -314,10 +565,16 @@
 	cd_pars->u.s.content_desc_params_sz = sizeof(struct qat_alg_cd) >> 3;
 
 	/* Cipher CD config setup */
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (likely(alg != 0)) {
+#endif
 	cipher_cd_ctrl->cipher_key_sz = keys->enckeylen >> 3;
 	cipher_cd_ctrl->cipher_state_sz = AES_BLOCK_SIZE >> 3;
 	cipher_cd_ctrl->cipher_cfg_offset = 0;
 	ICP_QAT_FW_COMN_CURR_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_CIPHER);
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	}
+#endif
 	ICP_QAT_FW_COMN_NEXT_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_AUTH);
 	/* Auth CD config setup */
 	hash_cd_ctrl->hash_cfg_offset = ((char *)hash - (char *)cipher) >> 3;
@@ -336,13 +593,64 @@
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA256_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA256_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA384_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA384_STATE2_SZ;
+		break;
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA512_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA512_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	case ICP_QAT_HW_AUTH_ALGO_GALOIS_128:
+		hash_cd_ctrl->inner_state1_sz = GCM_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = GCM_STATE2_SZ;
+		hash_cd_ctrl->inner_res_sz    = GCM_DIGEST_SIZE;
+		hash_cd_ctrl->final_sz	      = GCM_DIGEST_SIZE;
+
+		cd_pars->u.s.content_desc_params_sz = (sizeof(struct icp_qat_hw_auth_setup) +
+						       GCM_STATE1_SZ + GCM_STATE2_SZ +
+						       sizeof(struct icp_qat_hw_cipher_config) +
+						       keys->enckeylen) >> 3;
+
+		ICP_QAT_FW_LA_PROTO_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_PROTO);
+		ICP_QAT_FW_LA_GCM_IV_LEN_FLAG_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_IV_LEN_12_OCTETS);
+
+		PrintK(KERN_DEBUG "%s: cipher_algo_blk   %p %3d\n", __FUNCTION__, cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+		PrintHex(cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+
+		PrintK(KERN_DEBUG "%s: auth_algo_blk     %p %3d\n", __FUNCTION__, hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+		PrintHex(hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+
+		break;
+#endif
 	default:
 		break;
 	}
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0)) {
+
+		hash_cd_ctrl->resrvd1		  = 0;
+		hash_cd_ctrl->inner_state2_sz	  = 0;
+
+		hash_cd_ctrl->inner_state2_offset = (hash_cd_ctrl->inner_state1_sz >> 3);
+
+		switch (wg_fips_sha_mode0) {
+		case 256: hash_cd_ctrl->hash_cfg_offset = 54; break;
+		case 384: hash_cd_ctrl->hash_cfg_offset = 60; break;
+		case 512: hash_cd_ctrl->hash_cfg_offset = 70; break;
+		default:  hash_cd_ctrl->hash_cfg_offset = 41;
+		}
+	}
+#endif
 	hash_cd_ctrl->inner_state2_offset = hash_cd_ctrl->hash_cfg_offset +
 			((sizeof(struct icp_qat_hw_auth_setup) +
 			 round_up(hash_cd_ctrl->inner_state1_sz, 8)) >> 3);
@@ -376,6 +684,14 @@
 		sizeof(struct icp_qat_fw_la_cipher_req_params));
 
 	/* CD setup */
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+	cipher = (struct icp_qat_hw_cipher_algo_blk *)((char *)dec_ctx +
+		sizeof(struct icp_qat_hw_auth_setup) +
+		GCM_STATE1_SZ + GCM_STATE2_SZ);
+	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_GCM_DEC(alg);
+	} else
+#endif
 	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_DEC(alg, mode);
 	memcpy(cipher->aes.key, keys->enckey, keys->enckeylen);
 	hash->sha.inner_setup.auth_config.config =
@@ -389,6 +705,9 @@
 		return -EFAULT;
 
 	/* Request setup */
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (likely(alg != 0))
+#endif
 	qat_alg_init_common_hdr(header);
 	header->service_cmd_id = ICP_QAT_FW_LA_CMD_HASH_CIPHER;
 	ICP_QAT_FW_LA_DIGEST_IN_BUFFER_SET(header->serv_specif_flags,
@@ -401,6 +720,9 @@
 	cd_pars->u.s.content_desc_params_sz = sizeof(struct qat_alg_cd) >> 3;
 
 	/* Cipher CD config setup */
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (likely(alg != 0)) {
+#endif
 	cipher_cd_ctrl->cipher_key_sz = keys->enckeylen >> 3;
 	cipher_cd_ctrl->cipher_state_sz = AES_BLOCK_SIZE >> 3;
 	cipher_cd_ctrl->cipher_cfg_offset =
@@ -408,6 +730,9 @@
 		 roundup(crypto_shash_digestsize(ctx->hash_tfm), 8) * 2) >> 3;
 	ICP_QAT_FW_COMN_CURR_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_CIPHER);
 	ICP_QAT_FW_COMN_NEXT_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_DRAM_WR);
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	}
+#endif
 
 	/* Auth CD config setup */
 	hash_cd_ctrl->hash_cfg_offset = 0;
@@ -426,10 +751,48 @@
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA256_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA256_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA384_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA384_STATE2_SZ;
+		break;
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA512_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA512_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	case ICP_QAT_HW_AUTH_ALGO_GALOIS_128:
+		hash_cd_ctrl->inner_state1_sz = GCM_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = GCM_STATE2_SZ;
+		hash_cd_ctrl->inner_res_sz    = GCM_DIGEST_SIZE;
+		hash_cd_ctrl->final_sz	      = GCM_DIGEST_SIZE;
+
+		cipher_cd_ctrl->cipher_cfg_offset   = (sizeof(struct icp_qat_hw_auth_setup) +
+						       GCM_STATE1_SZ + GCM_STATE2_SZ) >> 3;
+
+		cd_pars->u.s.content_desc_params_sz = (sizeof(struct icp_qat_hw_auth_setup) +
+						       GCM_STATE1_SZ + GCM_STATE2_SZ +
+						       sizeof(struct icp_qat_hw_cipher_config) +
+						       keys->enckeylen) >> 3;
+
+		ICP_QAT_FW_LA_PROTO_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_PROTO);
+		ICP_QAT_FW_LA_GCM_IV_LEN_FLAG_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_IV_LEN_12_OCTETS);
+
+		PrintK(KERN_DEBUG "%s: cipher_algo_blk %p %5d\n", __FUNCTION__, cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+		PrintHex(cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+
+		PrintK(KERN_DEBUG "%s: auth_algo_blk   %p %5d\n", __FUNCTION__, hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+		PrintHex(hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+
+		break;
+#endif
 	default:
 		break;
 	}
@@ -510,6 +873,11 @@
 		case AES_KEYSIZE_256:
 			*alg = ICP_QAT_HW_CIPHER_ALGO_AES256;
 			break;
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+		case 0:
+			*alg = ICP_QAT_HW_CIPHER_ALGO_NULL;
+			break;
+#endif
 		default:
 			return -EINVAL;
 		}
@@ -533,13 +901,46 @@
 {
 	struct crypto_authenc_keys keys;
 	int alg;
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	struct qat_alg_aead_ctx *ctx = crypto_aead_ctx(tfm);
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen == GCM_NONCE_SIZE) {
+
+		if (likely(crypto_default_rng))
+		if (crypto_rng_get_bytes(crypto_default_rng,
+					 (u8*)&ctx->gcm_seqno, GCM_IV_SIZE))
+			return -EFAULT;
+
+		ctx->gcm_keylen = keylen;
+
+		keylen -= GCM_NONCE_SIZE;
+
+		memcpy((void*)&ctx->gcm_nonce, &key[keylen],  GCM_NONCE_SIZE);
+		// WG:XD FBX-20244
+		// memset((void*)&key[keylen],		  0,  GCM_NONCE_SIZE);
+
+		if (keylen == 0) key = NULL;
 
+		keys.enckey    = keys.authkey    = key;
+		keys.enckeylen = keys.authkeylen = keylen;
+
+		PrintK(KERN_DEBUG "%s: gcmkey %p %5d\n", __FUNCTION__, key, keylen);
+		PrintHex(key, keylen);
+	}
+	else
+#endif
 	if (crypto_authenc_extractkeys(&keys, key, keylen))
 		goto bad_key;
 
 	if (qat_alg_validate_key(keys.enckeylen, &alg, mode))
 		goto bad_key;
 
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (unlikely(!ctx->qat_hash_alg)) if (alg) goto nohash;
+#endif
+
 	if (qat_alg_aead_init_enc_session(tfm, alg, &keys, mode))
 		goto error;
 
@@ -547,6 +948,14 @@
 		goto error;
 
 	return 0;
+
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+nohash:
+	qat_alg_aeadcipher_init_enc(ctx, alg, keys.enckey, keys.enckeylen, mode);
+	qat_alg_aeadcipher_init_dec(ctx, alg, keys.enckey, keys.enckeylen, mode);
+	return 0;
+#endif
+
 bad_key:
 	crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
 	return -EINVAL;
@@ -578,6 +987,11 @@
 	struct qat_alg_aead_ctx *ctx = crypto_aead_ctx(tfm);
 	struct device *dev;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	PrintK(KERN_DEBUG "%s: keylen %d gcm %d\n", __FUNCTION__,
+	       keylen, ctx->gcm_keylen);
+#endif
+
 	if (ctx->enc_cd) {
 		/* rekeying */
 		dev = &GET_DEV(ctx->inst->accel_dev);
@@ -773,6 +1187,158 @@
 	return -ENOMEM;
 }
 
+#ifdef	CONFIG_WG_PLATFORM_GCM // WG:XD FBX-17246 copied from qat_algs_old.c
+static int old_qat_alg_sgl_to_bufl(struct qat_crypto_instance *inst,
+			       struct scatterlist *assoc, int assoclen,
+			       struct scatterlist *sgl,
+			       struct scatterlist *sglout, uint8_t *iv,
+			       uint8_t ivlen,
+			       struct qat_crypto_request *qat_req)
+{
+	struct device *dev = &GET_DEV(inst->accel_dev);
+	int i, bufs = 0, sg_nctr = 0;
+	int n = sg_nents(sgl), assoc_n = sg_nents(assoc);
+	struct qat_alg_buf_list *bufl;
+	struct qat_alg_buf_list *buflout = NULL;
+	dma_addr_t blp;
+	dma_addr_t bloutp = 0;
+	struct scatterlist *sg;
+	size_t sz_out = 0, sz = sizeof(struct qat_alg_buf_list) +
+			((1 + n + assoc_n) * sizeof(struct qat_alg_buf));
+
+	if (unlikely(!n))
+		return -EINVAL;
+
+	bufl = kzalloc_node(sz, GFP_ATOMIC,
+			    dev_to_node(&GET_DEV(inst->accel_dev)));
+	if (unlikely(!bufl))
+		return -ENOMEM;
+
+	blp = dma_map_single(dev, bufl, sz, DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(dev, blp)))
+		goto err;
+
+	for_each_sg(assoc, sg, assoc_n, i) {
+		if (!sg->length)
+			continue;
+
+		if (!(assoclen > 0))
+			break;
+
+		bufl->bufers[bufs].addr =
+			dma_map_single(dev, sg_virt(sg),
+				       min_t(int, assoclen, sg->length),
+				       DMA_BIDIRECTIONAL);
+		bufl->bufers[bufs].len = min_t(int, assoclen, sg->length);
+		if (unlikely(dma_mapping_error(dev, bufl->bufers[bufs].addr)))
+			goto err;
+		bufs++;
+		assoclen -= sg->length;
+	}
+
+    if (console_loglevel == 6)
+		printk(KERN_WARNING "@@ %s: iv: %p, ivlen: %d\n", __FUNCTION__, iv, ivlen);
+	if (ivlen) {
+		bufl->bufers[bufs].addr = dma_map_single(dev, iv, ivlen,
+							 DMA_BIDIRECTIONAL);
+		bufl->bufers[bufs].len = ivlen;
+		if (unlikely(dma_mapping_error(dev, bufl->bufers[bufs].addr)))
+			goto err;
+		bufs++;
+	}
+
+	for_each_sg(sgl, sg, n, i) {
+		int y = sg_nctr + bufs;
+
+		if (!sg->length)
+			continue;
+
+		bufl->bufers[y].addr = dma_map_single(dev, sg_virt(sg),
+						      sg->length,
+						      DMA_BIDIRECTIONAL);
+		bufl->bufers[y].len = sg->length;
+		if (unlikely(dma_mapping_error(dev, bufl->bufers[y].addr)))
+			goto err;
+		sg_nctr++;
+	}
+	bufl->num_bufs = sg_nctr + bufs;
+	qat_req->buf.bl = bufl;
+	qat_req->buf.blp = blp;
+	qat_req->buf.sz = sz;
+	/* Handle out of place operation */
+	if (sgl != sglout) {
+		struct qat_alg_buf *bufers;
+
+		n = sg_nents(sglout);
+		sz_out = sizeof(struct qat_alg_buf_list) +
+			((1 + n + assoc_n) * sizeof(struct qat_alg_buf));
+		sg_nctr = 0;
+		buflout = kzalloc_node(sz_out, GFP_ATOMIC,
+				       dev_to_node(&GET_DEV(inst->accel_dev)));
+		if (unlikely(!buflout))
+			goto err;
+		bloutp = dma_map_single(dev, buflout, sz_out, DMA_TO_DEVICE);
+		if (unlikely(dma_mapping_error(dev, bloutp)))
+			goto err;
+		bufers = buflout->bufers;
+		/* For out of place operation dma map only data and
+		 * reuse assoc mapping and iv */
+		for (i = 0; i < bufs; i++) {
+			bufers[i].len = bufl->bufers[i].len;
+			bufers[i].addr = bufl->bufers[i].addr;
+		}
+		for_each_sg(sglout, sg, n, i) {
+			int y = sg_nctr + bufs;
+
+			if (!sg->length)
+				continue;
+
+			bufers[y].addr = dma_map_single(dev, sg_virt(sg),
+							sg->length,
+							DMA_BIDIRECTIONAL);
+			if (unlikely(dma_mapping_error(dev, bufers[y].addr)))
+				goto err;
+			bufers[y].len = sg->length;
+			sg_nctr++;
+		}
+		buflout->num_bufs = sg_nctr + bufs;
+		buflout->num_mapped_bufs = sg_nctr;
+		qat_req->buf.blout = buflout;
+		qat_req->buf.bloutp = bloutp;
+		qat_req->buf.sz_out = sz_out;
+	} else {
+		/* Otherwise set the src and dst to the same address */
+		qat_req->buf.bloutp = qat_req->buf.blp;
+		qat_req->buf.sz_out = 0;
+	}
+	return 0;
+err:
+	dev_err(dev, "Failed to map buf for dma\n");
+	sg_nctr = 0;
+	for (i = 0; i < n + bufs; i++)
+		if (!dma_mapping_error(dev, bufl->bufers[i].addr))
+			dma_unmap_single(dev, bufl->bufers[i].addr,
+					 bufl->bufers[i].len,
+					 DMA_BIDIRECTIONAL);
+
+	if (!dma_mapping_error(dev, blp))
+		dma_unmap_single(dev, blp, sz, DMA_TO_DEVICE);
+	kfree(bufl);
+	if (sgl != sglout && buflout) {
+		n = sg_nents(sglout);
+		for (i = bufs; i < n + bufs; i++)
+			if (!dma_mapping_error(dev, buflout->bufers[i].addr))
+				dma_unmap_single(dev, buflout->bufers[i].addr,
+						 buflout->bufers[i].len,
+						 DMA_BIDIRECTIONAL);
+		if (!dma_mapping_error(dev, bloutp))
+			dma_unmap_single(dev, bloutp, sz_out, DMA_TO_DEVICE);
+		kfree(buflout);
+	}
+	return -ENOMEM;
+}
+#endif
+
 static void qat_aead_alg_callback(struct icp_qat_fw_la_resp *qat_resp,
 				  struct qat_crypto_request *qat_req)
 {
@@ -785,6 +1351,43 @@
 	qat_alg_free_bufl(inst, qat_req);
 	if (unlikely(qat_res != ICP_QAT_FW_COMN_STATUS_FLAG_OK))
 		res = -EBADMSG;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+
+#define	OP_ENC	(qat_req->req.comn_hdr.service_cmd_id == ICP_QAT_FW_LA_CMD_CIPHER_HASH)
+#define	OP_DEC	(qat_req->req.comn_hdr.service_cmd_id == ICP_QAT_FW_LA_CMD_HASH_CIPHER)
+
+	if (unlikely(wg_fips_aad_len & 7)) {
+		u8* aad = sg_virt(areq->src);
+		int j = ((-areq->assoclen) & 7);
+		memmove(aad, aad - j, areq->assoclen);
+	}
+
+	if (OP_ENC)	// WG:XD FBX-17246
+		memcpy(sg_virt(areq->src) + areq->assoclen - GCM_IV_SIZE, &ctx->gcm_seqno, GCM_IV_SIZE);
+
+	PrintK(KERN_DEBUG "%s: result %p   %5d+%2d\n", __FUNCTION__,
+		 sg_virt(areq->dst),
+		 areq->cryptlen -
+		 (OP_DEC*(GCM_DIGEST_SIZE)),  GCM_DIGEST_SIZE);
+	PrintHex(sg_virt(areq->dst),
+		 areq->cryptlen + areq->assoclen +
+		 (OP_ENC*(GCM_DIGEST_SIZE)) + GCM_IV_SIZE);
+#if	CONFIG_WG_PLATFORM_GCM > 8
+		PrintK(KERN_DEBUG "%s: expect\n",      __FUNCTION__);
+		PrintHex(GCMDst, sizeof(GCMDst));
+#endif
+	}
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	else // JJJ
+	if (unlikely(wg_fips_sha > 0))
+	if (unlikely(res == -EBADMSG)) {
+		wg_fips_sha_err++;
+		printk(KERN_ERR "%s: sha%d Auth Errors %d\n",
+		       __FUNCTION__, wg_fips_sha, wg_fips_sha_err);
+	}
+#endif
 	areq->base.complete(&areq->base, res);
 }
 
@@ -823,8 +1426,19 @@
 	struct icp_qat_fw_la_bulk_req *msg;
 	int digst_size = crypto_aead_authsize(aead_tfm);
 	int ret, ctr = 0;
-
+#ifdef	CONFIG_WG_PLATFORM_GCM	// WG:XD FBX-17246
+	if (ctx->gcm_keylen) {
+		struct scatterlist req_sg;
+		sg_set_buf(&req_sg, (const void*) sg_virt(areq->src) + areq->assoclen,
+				   areq->src->length - areq->assoclen);
+		sg_mark_end(&req_sg);
+		ret = old_qat_alg_sgl_to_bufl(ctx->inst, NULL, 0, &req_sg, &req_sg,
+								 sg_virt(areq->src), areq->assoclen, qat_req);
+	} else
+	ret = qat_alg_sgl_to_bufl(ctx->inst, areq->src, areq->dst, qat_req);
+#else
 	ret = qat_alg_sgl_to_bufl(ctx->inst, areq->src, areq->dst, qat_req);
+#endif
 	if (unlikely(ret))
 		return ret;
 
@@ -843,7 +1457,130 @@
 	auth_param = (void *)((uint8_t *)cipher_param + sizeof(*cipher_param));
 	auth_param->auth_off = 0;
 	auth_param->auth_len = areq->assoclen + cipher_param->cipher_length;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->src);
+
+		struct icp_qat_hw_auth_algo_blk *hash =
+		(struct icp_qat_hw_auth_algo_blk *)((char *)ctx->dec_cd);
+
+		memcpy(areq->iv, sg_virt(areq->src) + areq->assoclen - GCM_IV_SIZE, GCM_IV_SIZE);
+
+		hash->sha.state1[GCM_STATE1_SZ + AES_BLOCK_SIZE + 3] = areq->assoclen - GCM_IV_SIZE;
+
+		cipher_param->cipher_length = areq->cryptlen - GCM_DIGEST_SIZE;
+		cipher_param->cipher_offset = areq->assoclen;
+
+		auth_param->auth_len	    = areq->cryptlen - GCM_DIGEST_SIZE;
+		auth_param->auth_off	    = areq->assoclen;
+
+		auth_param->u1.aad_adr	    = qat_req->buf.bl->bufers[0].addr;
+		auth_param->u2.aad_sz	    = round_up(areq->assoclen - GCM_IV_SIZE, GCM_AAD_PAD_SIZE);
+		auth_param->hash_state_sz   = round_up(areq->assoclen - GCM_IV_SIZE, GCM_STATE1_SZ) >> 3;
+		auth_param->auth_res_sz	    = GCM_DIGEST_SIZE;
+
+		memcpy(&cipher_param->u.cipher_IV_array[0],
+		       &ctx->gcm_nonce,	GCM_NONCE_SIZE);
+		memcpy(&cipher_param->u.cipher_IV_array[GCM_NONCE_SIZE/sizeof(u32)],
+		       areq->iv,	GCM_IV_SIZE);
+
+		if (unlikely(wg_fips_aad_len & 7)) {
+			int j = ((-areq->assoclen) & 7);
+			memmove(aad - j, aad, areq->assoclen);
+			aad -= j;
+			auth_param->u1.aad_adr -= j;
+		}
+
+		memset(aad + areq->assoclen - GCM_IV_SIZE, 0,
+			   auth_param->u2.aad_sz - areq->assoclen + GCM_IV_SIZE);
+	}
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	else // JJJ
+	if (unlikely(wg_fips_sha_key))
+	if (unlikely(wg_fips_sha == 0)) {
+		auth_param->auth_len	    = 0;
+	}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+#if	CONFIG_WG_PLATFORM_GCM > 1
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+
+	PrintK(KERN_DEBUG "%s: coff %d clen %d aoff %d alen %d\n", __FUNCTION__,
+	       cipher_param->cipher_offset, cipher_param->cipher_length,
+	       auth_param->auth_off,	    auth_param->auth_len);
+
+	PrintK(KERN_DEBUG "%s: cipher_params %p\n", __FUNCTION__, cipher_param);
+	PrintK(KERN_DEBUG "%s: auth_params   %p\n", __FUNCTION__, auth_param);
+
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->src) - ((-areq->assoclen) & 7);
+
+		PrintK(KERN_DEBUG "%s: aad+pad %p %3d+%1d\n", __FUNCTION__,
+			 aad, areq->assoclen,	auth_param->u2.aad_sz - areq->assoclen);
+		PrintHex(aad,			auth_param->u2.aad_sz);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %3d+%d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE,  4);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+		PrintHex(sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+
+		PrintK(KERN_DEBUG "%s: dec_cd  %p %5d\n", __FUNCTION__,
+			 ctx->dec_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+		PrintHex(ctx->dec_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+	} else {
+		PrintK(KERN_DEBUG "%s: assoc   %p %5d\n", __FUNCTION__,
+		       sg_virt(areq->src), areq->assoclen);
+		// PrintHex(assoc, areq->assoclen);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %5d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), auth_param->auth_len + digst_size);
+		PrintHex(sg_virt(areq->src), auth_param->auth_len + digst_size);
+
+		PrintK(KERN_DEBUG "%s: dec_cd  %p %5d\n", __FUNCTION__,
+			 ctx->dec_cd, (int)sizeof(struct qat_alg_cd));
+		PrintHex(ctx->dec_cd, (int)sizeof(struct qat_alg_cd));
+	}
+
+#if	CONFIG_WG_PLATFORM_GCM > 2
+	PrintK(KERN_DEBUG "%s: req     %p %5d\n", __FUNCTION__,
+		&qat_req->req, (int)sizeof(struct icp_qat_fw_la_bulk_req));
+
+	PrintK(KERN_DEBUG "%s: comn_hdr\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_hdr, sizeof(struct icp_qat_fw_comn_req_hdr));
+	PrintK(KERN_DEBUG "%s: cd_pars\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_pars,  sizeof(struct icp_qat_fw_comn_req_hdr_cd_pars));
+	PrintK(KERN_DEBUG "%s: comn_mid\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_mid, sizeof(struct icp_qat_fw_comn_req_mid));
+	PrintK(KERN_DEBUG "%s: serv_specif_rqpars\n",   __FUNCTION__);
+	PrintHex(&qat_req->req.serv_specif_rqpars, sizeof(struct icp_qat_fw_comn_req_rqpars));
+	PrintK(KERN_DEBUG "%s: cd_ctrl\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_ctrl,  sizeof(struct icp_qat_fw_comn_req_cd_ctrl));
+#endif
+#endif
+#endif
+
 	do {
+#ifdef CONFIG_WG_PLATFORM	// WG:XD FBX-19123
+		struct qat_crypto_instance *inst;
+		int cpu = smp_processor_id();
+		if (ctx->inst->id != cpu) {
+			inst = qat_crypto_get_local_cpu_instance_node(get_current_node(), cpu);
+			if (inst)
+				ret = adf_send_message(inst->sym_tx, (uint32_t *)msg);
+			else
+				ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
+		} else
+#endif
 		ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
 	} while (ret == -EAGAIN && ctr++ < 10);
 
@@ -865,8 +1602,45 @@
 	struct icp_qat_fw_la_bulk_req *msg;
 	uint8_t *iv = areq->iv;
 	int ret, ctr = 0;
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	int ivlen = crypto_aead_ivsize(aead_tfm);
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		__be64 seq = atomic64_read(&ctx->gcm_seqno);
+		memcpy(iv, &seq, sizeof(uint64_t));
+	}
+#endif
+
+	if (unlikely(ivlen == 0)) {
+		if (unlikely(wg_fips_iv)) {
+		memcpy(iv - areq->assoclen, wg_fips_iv, AES_BLOCK_SIZE + areq->assoclen);
+		}
+	}
+	else
+	if (unlikely(wg_fips_iv)) {
+		memcpy(iv, wg_fips_iv, ivlen);
+#ifdef	CONFIG_WG_PLATFORM_GCM
+		if (ctx->gcm_keylen) {
+		memcpy( (u8*)&ctx->gcm_seqno, iv, sizeof(uint64_t));
+		atomic64_dec(&ctx->gcm_seqno);
+		}
+#endif
+	}
+#endif
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		struct scatterlist req_sg;
+		sg_set_buf(&req_sg, (const void*) sg_virt(areq->src) + areq->assoclen,
+				   areq->src->length - areq->assoclen);
+		sg_mark_end(&req_sg);
+		ret = old_qat_alg_sgl_to_bufl(ctx->inst, NULL, 0, &req_sg, &req_sg,
+									  sg_virt(areq->src), areq->assoclen, qat_req);
+	}else
+	ret = qat_alg_sgl_to_bufl(ctx->inst, areq->src, areq->dst, qat_req);
+#else
 	ret = qat_alg_sgl_to_bufl(ctx->inst, areq->src, areq->dst, qat_req);
+#endif
 	if (unlikely(ret))
 		return ret;
 
@@ -888,7 +1662,158 @@
 	auth_param->auth_off = 0;
 	auth_param->auth_len = areq->assoclen + areq->cryptlen;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->src);
+
+		struct icp_qat_hw_auth_algo_blk *hash =
+		(struct icp_qat_hw_auth_algo_blk *)((char *)ctx->enc_cd +
+		sizeof(struct icp_qat_hw_cipher_config) + (ctx->gcm_keylen & -8));
+
+		hash->sha.state1[GCM_STATE1_SZ + AES_BLOCK_SIZE + 3] = areq->assoclen - GCM_IV_SIZE;
+
+		cipher_param->cipher_length = areq->cryptlen;
+		cipher_param->cipher_offset = areq->assoclen;
+
+		auth_param->auth_len	    = areq->cryptlen;
+		auth_param->auth_off	    = areq->assoclen;
+
+		auth_param->u1.aad_adr	    = qat_req->buf.bl->bufers[0].addr;
+		auth_param->u2.aad_sz	    = round_up(areq->assoclen - 8, GCM_AAD_PAD_SIZE);
+		auth_param->hash_state_sz   = round_up(areq->assoclen - 8, GCM_STATE1_SZ) >> 3;
+
+		memcpy(&cipher_param->u.cipher_IV_array[0],
+		       &ctx->gcm_nonce,	GCM_NONCE_SIZE);
+		memcpy(&cipher_param->u.cipher_IV_array[GCM_NONCE_SIZE/sizeof(u32)],
+		       iv,		GCM_IV_SIZE);
+
+		if (unlikely(wg_fips_aad_len & 7)) {
+			int j = ((-areq->assoclen) & 7);
+			memmove(aad - j, aad, areq->assoclen);
+			aad -= j;
+			auth_param->u1.aad_adr -= j;
+		}
+
+		memset(aad + areq->assoclen - GCM_IV_SIZE, 0,
+			   auth_param->u2.aad_sz - areq->assoclen + GCM_IV_SIZE);
+
+#if	CONFIG_WG_PLATFORM_GCM > 8
+		{
+		__be64  seq;
+		u8*     src = sg_virt(areq->src) + GCM_IV_SIZE + sizeof(GCMAad);
+
+		memcpy(&seq,		 &GCMIv[GCM_NONCE_SIZE], sizeof(u64));
+		atomic64_set(&ctx->gcm_seqno, seq);
+
+		memcpy(cipher_param->u.cipher_IV_array,	GCMIv,	 sizeof(GCMIv));
+		memcpy(sg_virt(areq->src),		GCMAad,	 sizeof(GCMAad));
+		memcpy(src,				GCMSrc,	 sizeof(GCMSrc));
+		memset(src + areq->cryptlen, 0xEE,	GCM_DIGEST_SIZE + 8);
+		}
+#endif
+	}
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	else // JJJ
+	if (unlikely(ivlen == 0)) {
+		cipher_param->cipher_offset = 0;
+		cipher_param->cipher_length = 0;
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+		if (unlikely(wg_fips_sha_mode0)) {
+			auth_param->auth_len -= (wg_fips_sha / 8);
+			memset(&msg->cd_pars, 0, sizeof(msg->cd_pars));
+			wg_fips_sha_mode0 = 0;
+		}
+#endif
+	} else
+	if (unlikely(wg_fips_iv))
+	if (unlikely(wg_fips_sha_key))
+	if (unlikely(wg_fips_sha != 0)) {
+		cipher_param->cipher_offset += ivlen;
+		cipher_param->cipher_length -= ivlen;
+	}
+
+	wg_fips_iv = NULL;
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+#if	CONFIG_WG_PLATFORM_GCM > 1
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+
+	PrintK(KERN_DEBUG "%s: coff %d clen %d aoff %d alen %d\n", __FUNCTION__,
+	       cipher_param->cipher_offset, cipher_param->cipher_length,
+	       auth_param->auth_off,	    auth_param->auth_len);
+
+	PrintK(KERN_DEBUG "%s: cipher_params %p\n", __FUNCTION__, cipher_param);
+	PrintK(KERN_DEBUG "%s: auth_params   %p\n", __FUNCTION__, auth_param);
+
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->src) - ((-areq->assoclen) & 7);
+
+		PrintK(KERN_DEBUG "%s: aad+pad %p %3d+%1d\n", __FUNCTION__,
+			 aad, areq->assoclen,	auth_param->u2.aad_sz - areq->assoclen);
+		PrintHex(aad,			auth_param->u2.aad_sz);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %3d+%d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE,  4);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+		PrintHex(sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+
+		PrintK(KERN_DEBUG "%s: enc_cd  %p %5d\n", __FUNCTION__,
+			 ctx->enc_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+		PrintHex(ctx->enc_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+	} else {
+		PrintK(KERN_DEBUG "%s: assoc   %p %5d\n", __FUNCTION__,
+		       sg_virt(areq->src), areq->assoclen);
+		// PrintHex(assoc, areq->assoclen);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %5d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), auth_param->auth_len);
+		PrintHex(sg_virt(areq->src), auth_param->auth_len);
+
+		PrintK(KERN_DEBUG "%s: enc_cd  %p %5d\n", __FUNCTION__,
+			 ctx->enc_cd, (int)sizeof(struct qat_alg_cd));
+		PrintHex(ctx->enc_cd, (int)sizeof(struct qat_alg_cd));
+	}
+
+#if	CONFIG_WG_PLATFORM_GCM > 2
+	PrintK(KERN_DEBUG "%s: req     %p %5d\n", __FUNCTION__,
+		&qat_req->req, (int)sizeof(struct icp_qat_fw_la_bulk_req));
+
+	PrintK(KERN_DEBUG "%s: comn_hdr\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_hdr, sizeof(struct icp_qat_fw_comn_req_hdr));
+	PrintK(KERN_DEBUG "%s: cd_pars\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_pars,  sizeof(struct icp_qat_fw_comn_req_hdr_cd_pars));
+	PrintK(KERN_DEBUG "%s: comn_mid\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_mid, sizeof(struct icp_qat_fw_comn_req_mid));
+	PrintK(KERN_DEBUG "%s: serv_specif_rqpars\n",   __FUNCTION__);
+	PrintHex(&qat_req->req.serv_specif_rqpars, sizeof(struct icp_qat_fw_comn_req_rqpars));
+	PrintK(KERN_DEBUG "%s: cd_ctrl\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_ctrl,  sizeof(struct icp_qat_fw_comn_req_cd_ctrl));
+#endif
+#endif
+#endif
+
 	do {
+#ifdef CONFIG_WG_PLATFORM   // WG:XD FBX-19123
+		struct qat_crypto_instance *inst;
+		int cpu = smp_processor_id();
+		if (ctx->inst->id != cpu) {
+			inst = qat_crypto_get_local_cpu_instance_node(get_current_node(), cpu);
+			if (inst)
+				ret = adf_send_message(inst->sym_tx, (uint32_t *)msg);
+			else
+				ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
+		} else
+#endif
 		ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
 	} while (ret == -EAGAIN && ctr++ < 10);
 
@@ -991,6 +1916,13 @@
 	struct icp_qat_fw_la_bulk_req *msg;
 	int ret, ctr = 0;
 
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (unlikely(wg_fips_iv)) {
+		memcpy(req->info, wg_fips_iv, crypto_ablkcipher_ivsize(atfm));
+		wg_fips_iv = NULL;
+	}
+#endif
+
 	ret = qat_alg_sgl_to_bufl(ctx->inst, req->src, req->dst, qat_req);
 	if (unlikely(ret))
 		return ret;
@@ -1061,9 +1993,24 @@
 {
 	struct qat_alg_aead_ctx *ctx = crypto_aead_ctx(tfm);
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	ctx->gcm_keylen = (hash == ICP_QAT_HW_AUTH_ALGO_GALOIS_128) ? GCM_NONCE_SIZE : 0;
+	PrintK(KERN_DEBUG "%s: fips %d mode0 %d gcm %d hash %d %s\n", __FUNCTION__,
+	       wg_fips_sha, wg_fips_sha_mode0, ctx->gcm_keylen, hash, hash_name);
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS
+	if (hash == ICP_QAT_HW_AUTH_ALGO_NULL)
+	ctx->hash_tfm = NULL;
+	else {
+	ctx->hash_tfm = crypto_alloc_shash(hash_name, 0, 0);
+	if (IS_ERR(ctx->hash_tfm))
+		return PTR_ERR(ctx->hash_tfm);
+	}
+#else
 	ctx->hash_tfm = crypto_alloc_shash(hash_name, 0, 0);
 	if (IS_ERR(ctx->hash_tfm))
 		return PTR_ERR(ctx->hash_tfm);
+#endif
 	ctx->qat_hash_alg = hash;
 	crypto_aead_set_reqsize(tfm, sizeof(struct qat_crypto_request));
 	return 0;
@@ -1079,11 +2026,41 @@
 	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA256, "sha256");
 }
 
+#ifdef	CONFIG_WG_PLATFORM_C3XXX_SHA384
+static int qat_alg_aead_sha384_init(struct crypto_aead *tfm)
+{
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA384, "sha384");
+}
+#endif
+
 static int qat_alg_aead_sha512_init(struct crypto_aead *tfm)
 {
 	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA512, "sha512");
 }
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+static int qat_alg_aead_ghash_init(struct crypto_aead *tfm)
+{
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_GALOIS_128, "ghash");
+}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+static int qat_alg_aead_null_init(struct crypto_aead *tfm)
+{
+	if (wg_fips_sha >= 512)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA512, "sha512");
+	if (wg_fips_sha >= 384)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA384, "sha384");
+	if (wg_fips_sha >= 256)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA256, "sha256");
+	if (wg_fips_sha >= 160)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA1,   "sha1");
+
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_NULL,   "");
+}
+#endif
+
 static void qat_alg_aead_exit(struct crypto_aead *tfm)
 {
 	struct qat_alg_aead_ctx *ctx = crypto_aead_ctx(tfm);
@@ -1198,6 +2175,150 @@
 	.encrypt = qat_alg_aead_enc,
 	.ivsize = AES_BLOCK_SIZE,
 	.maxauthsize = SHA512_DIGEST_SIZE,
+#ifdef	CONFIG_WG_PLATFORM_GCM
+}, {
+	.base = {
+		.cra_name = "rfc4106(gcm(aes))",
+		.cra_driver_name = "qat_rfc4106_gcm_aes",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_ASYNC,
+		.cra_blocksize = 4,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_ghash_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = GCM_IV_SIZE,
+	.maxauthsize = GCM_DIGEST_SIZE,
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB Extra WG algos
+#ifdef	CONFIG_WG_PLATFORM_C3XXX_SHA384
+}, {
+	.base = {
+		.cra_name = "authenc(hmac(sha384),cbc(aes))",
+		.cra_driver_name = "qat_aes_cbc_hmac_sha384",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = AES_BLOCK_SIZE,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_sha384_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = AES_BLOCK_SIZE,
+	.maxauthsize = SHA384_DIGEST_SIZE,
+#endif
+}, {
+	.base = {
+		.cra_name = "authenc(digest_null,cbc(cipher_null))",
+		.cra_driver_name = "qat_cipher_null_cbc_digest_null",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = 1,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_null_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = 000*000,
+	.maxauthsize = 000*000,
+}, {
+	.base = {
+		.cra_name = "authenc(hmac(sha1),cbc(cipher_null))",
+		.cra_driver_name = "qat_cipher_null_cbc_hmac_sha1",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = 4,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_sha1_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = 000*000,
+	.maxauthsize = SHA1_DIGEST_SIZE,
+}, {
+	.base = {
+		.cra_name = "authenc(hmac(sha256),cbc(cipher_null))",
+		.cra_driver_name = "qat_cipher_null_cbc_hmac_sha256",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = 4,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_sha256_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = 000*000,
+	.maxauthsize = SHA256_DIGEST_SIZE,
+#ifdef	CONFIG_WG_PLATFORM_C3XXX_SHA384
+}, {
+	.base = {
+		.cra_name = "authenc(hmac(sha384),cbc(cipher_null))",
+		.cra_driver_name = "qat_cipher_null_cbc_hmac_sha384",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = 4,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_sha384_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = 000*000,
+	.maxauthsize = SHA384_DIGEST_SIZE,
+#endif
+}, {
+	.base = {
+		.cra_name = "authenc(hmac(sha512),cbc(cipher_null))",
+		.cra_driver_name = "qat_cipher_null_cbc_hmac_sha512",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = 4,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_sha512_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = 000*000,
+	.maxauthsize = SHA512_DIGEST_SIZE,
+}, {
+	.base = {
+		.cra_name = "authenc(digest_null,cbc(aes))",
+		.cra_driver_name = "qat_aes_cbc_digest_null",
+		.cra_priority = 4001,
+		.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+		.cra_blocksize = AES_BLOCK_SIZE,
+		.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+		.cra_module = THIS_MODULE,
+	},
+	.init = qat_alg_aead_null_init,
+	.exit = qat_alg_aead_exit,
+	.setkey = qat_alg_aead_setkey,
+	.decrypt = qat_alg_aead_dec,
+	.encrypt = qat_alg_aead_enc,
+	.ivsize = AES_BLOCK_SIZE,
+	.maxauthsize = 000*000,
+#endif
 } };
 
 static struct crypto_alg qat_algs[] = { {
@@ -1266,16 +2387,49 @@
 			.ivsize = AES_BLOCK_SIZE,
 		},
 	},
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB Extra WG algos
+}, {
+	.cra_name = "ablk(cbc(aes))",
+	.cra_driver_name = "qat_ablk_aes_cbc",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = AES_BLOCK_SIZE,
+	.cra_ctxsize = sizeof(struct qat_alg_ablkcipher_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_ablkcipher_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_ablkcipher_init,
+	.cra_exit = qat_alg_ablkcipher_exit,
+	.cra_u = {
+		.ablkcipher = {
+			.setkey = qat_alg_ablkcipher_cbc_setkey,
+			.decrypt = qat_alg_ablkcipher_decrypt,
+			.encrypt = qat_alg_ablkcipher_encrypt,
+			.min_keysize = AES_MIN_KEY_SIZE,
+			.max_keysize = AES_MAX_KEY_SIZE,
+			.ivsize = AES_BLOCK_SIZE,
+		},
+	},
+#endif
 } };
 
 int qat_algs_register(void)
 {
 	int ret = 0, i;
 
+#ifdef	CONFIG_WG_PLATFORM
+	printk(KERN_INFO "\n%s: Built " __DATE__ " " __TIME__ "\n\n", __FUNCTION__);
+#endif
+
 	mutex_lock(&algs_lock);
 	if (++active_devs != 1)
 		goto unlock;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	gcm_aes_cipher = crypto_alloc_cipher("aes", 0, 0);
+	if (IS_ERR(gcm_aes_cipher)) goto unlock;
+#endif
+
 	for (i = 0; i < ARRAY_SIZE(qat_algs); i++)
 		qat_algs[i].cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC;
 
@@ -1290,6 +2444,10 @@
 	if (ret)
 		goto unreg_algs;
 
+#ifdef	CONFIG_WG_PLATFORM
+	crypto_get_default_rng();
+#endif
+
 unlock:
 	mutex_unlock(&algs_lock);
 	return ret;
@@ -1308,6 +2466,10 @@
 	crypto_unregister_aeads(qat_aeads, ARRAY_SIZE(qat_aeads));
 	crypto_unregister_algs(qat_algs, ARRAY_SIZE(qat_algs));
 
+#ifdef	CONFIG_WG_PLATFORM
+	crypto_put_default_rng();
+#endif
+
 unlock:
 	mutex_unlock(&algs_lock);
 }
--- cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_asym_algs.c.orig	2022-05-09 13:48:22.201000221 -0700
+++ cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_asym_algs.c	2022-05-09 13:48:22.636982523 -0700
@@ -492,8 +492,13 @@
 	ctx->g2 = false;
 }
 
+#ifdef	CONFIG_WG_GIT
+static int qat_dh_set_secret(struct crypto_kpp *tfm, const void *buf,
+			     unsigned int len)
+#else
 static int qat_dh_set_secret(struct crypto_kpp *tfm, void *buf,
 			     unsigned int len)
+#endif
 {
 	struct qat_dh_ctx *ctx = kpp_tfm_ctx(tfm);
 	struct device *dev = &GET_DEV(ctx->inst->accel_dev);
@@ -522,7 +527,11 @@
 	return 0;
 }
 
+#ifdef	CONFIG_WG_GIT
+static unsigned int qat_dh_max_size(struct crypto_kpp *tfm)
+#else
 static int qat_dh_max_size(struct crypto_kpp *tfm)
+#endif
 {
 	struct qat_dh_ctx *ctx = kpp_tfm_ctx(tfm);
 
@@ -1257,7 +1266,11 @@
 	return qat_rsa_setkey(tfm, key, keylen, true);
 }
 
+#ifdef	CONFIG_WG_GIT
+static unsigned int qat_rsa_max_size(struct crypto_akcipher *tfm)
+#else
 static int qat_rsa_max_size(struct crypto_akcipher *tfm)
+#endif
 {
 	struct qat_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);
 
--- cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_algs_old.c.orig	2022-05-09 13:48:22.197000383 -0700
+++ cavecreek-1.0.3-42/quickassist/qat/drivers/crypto/qat/qat_common/qat_algs_old.c	2022-05-09 13:48:22.636982523 -0700
@@ -64,12 +64,121 @@
 #include "icp_qat_fw.h"
 #include "icp_qat_fw_la.h"
 
-#define QAT_AES_HW_CONFIG_CBC_ENC(alg) \
+#ifdef	CONFIG_WG_PLATFORM
+
+#define	CONFIG_WG_PLATFORM_GCM		1
+#define	CONFIG_WG_PLATFORM_SHA2		1
+#define	CONFIG_WG_PLATFORM_MODE0	1
+
+#define	PrintK(...)
+#define	PrintHex(...)
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+
+#if	CONFIG_WG_PLATFORM_GCM > 1
+
+#define	static
+
+#undef	PrintK
+#undef	PrintHex
+
+#define	PrintK		if (unlikely(console_loglevel & 16)) printk
+#define	PrintHex(a,b)	if (unlikely(console_loglevel & 32)) wg_dump_hex((u8*)(a),(b),"")
+
+#endif
+
+#define	GCM_NONCE_SIZE		( 4)
+#define	GCM_IV_SIZE		( 8)
+#define	GCM_DIGEST_SIZE		(16)
+#define	GCM_AAD_PAD_SIZE	(16)
+
+#define	GCM_STATE1_SZ		(16)
+#define	GCM_STATE2_SZ		(40)
+#define	GCM_PARAMS_SZ		((int)(sizeof(struct icp_qat_hw_auth_setup) + \
+				 GCM_STATE1_SZ + GCM_STATE2_SZ + \
+				 sizeof(struct icp_qat_hw_cipher_config)))
+
+#define	QAT_AES_HW_CONFIG_GCM_ENC(alg) \
+	ICP_QAT_HW_CIPHER_CONFIG_BUILD(ICP_QAT_HW_CIPHER_CTR_MODE, alg, \
+				       ICP_QAT_HW_CIPHER_NO_CONVERT, \
+				       ICP_QAT_HW_CIPHER_ENCRYPT)
+
+#define	QAT_AES_HW_CONFIG_GCM_DEC(alg) \
+	ICP_QAT_HW_CIPHER_CONFIG_BUILD(ICP_QAT_HW_CIPHER_CTR_MODE, alg, \
+				       ICP_QAT_HW_CIPHER_NO_CONVERT, \
+				       ICP_QAT_HW_CIPHER_ENCRYPT)
+
+static	struct crypto_cipher* gcm_aes_cipher;
+
+#if	CONFIG_WG_PLATFORM_GCM > 8
+
+char	GCMKey[] = {
+	0x47, 0x43, 0x4D, 0x31, 0x36, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0X00, 0x00, 0x00, 0x00
+};
+
+char	GCMAad[] = {
+	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x01
+};
+
+char	GCMIv[]  = {
+	0x4E, 0x4F, 0x4E, 0x45, 0x93, 0x2F, 0xA9, 0x4F,
+	0x4A, 0xF6, 0xDB, 0xB6
+};
+
+char	GCMSrc[] = {
+	0x45, 0x00, 0x00, 0x54, 0x92, 0x43, 0x40, 0x00,
+	0x40, 0x01, 0x30, 0x10, 0xc0, 0xa8, 0xfb, 0x01,
+
+	0xc0, 0xa8, 0xfc, 0x02, 0x08, 0x00, 0x57, 0xD4,
+	0xDE, 0x0D, 0x00, 0x01, 0x7A, 0x04, 0x8F, 0x5A,
+
+	0x00, 0x00, 0x00, 0x00, 0xF7, 0xEA, 0x02, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13,
+
+	0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
+	0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
+
+	0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
+	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
+
+	0x34, 0x35, 0x36, 0x37, 0x01, 0x02, 0x02, 0x04
+};
+
+char	GCMDst[] = {
+	0xb3, 0x13, 0xfe, 0x1e, 0xcf, 0x0b, 0xba, 0x74,
+	0xb3, 0xeb, 0x28, 0xc5, 0x20, 0xd2, 0x3e, 0xca,
+
+	0x6b, 0xdc, 0x48, 0x61, 0x05, 0x8c, 0xc5, 0x2f,
+	0x9f, 0xaa, 0xd0, 0x10, 0xa4, 0xeb, 0xc8, 0xfd,
+
+	0xe3, 0x85, 0x7b, 0x68, 0x5b, 0x18, 0xe0, 0x43,
+	0x00, 0x21, 0x06, 0xcc, 0xa3, 0x7e, 0xbc, 0xc6,
+
+	0x7d, 0x2f, 0xbe, 0xda, 0x0c, 0x50, 0x73, 0xd0,
+	0xf6, 0x86, 0x8b, 0xcf, 0xe1, 0x26, 0xa6, 0xb2,
+
+	0x46, 0x61, 0x54, 0xcc, 0xc9, 0x84, 0xd3, 0xec,
+	0xbf, 0x3d, 0xae, 0x35, 0x97, 0xeb, 0x32, 0xe5,
+
+	0x30, 0x04, 0xd9, 0xcc, 0x2e, 0x78, 0x02, 0xc9,
+	// Tag
+	0x58, 0xbd, 0x2a, 0x75, 0x04, 0x01, 0xbc, 0xfd,
+	0x08, 0x30, 0x98, 0x93, 0x14, 0x94, 0x9f, 0x30
+};
+
+#endif	// CONFIG_WG_PLATFORM_GCM > 8
+
+#endif	// CONFIG_WG_PLATFORM_GCM
+
+#endif	// CONFIG_WG_PLATFORM
+
+#define	QAT_AES_HW_CONFIG_CBC_ENC(alg) \
 	ICP_QAT_HW_CIPHER_CONFIG_BUILD(ICP_QAT_HW_CIPHER_CBC_MODE, alg, \
 				       ICP_QAT_HW_CIPHER_NO_CONVERT, \
 				       ICP_QAT_HW_CIPHER_ENCRYPT)
 
-#define QAT_AES_HW_CONFIG_CBC_DEC(alg) \
+#define	QAT_AES_HW_CONFIG_CBC_DEC(alg) \
 	ICP_QAT_HW_CIPHER_CONFIG_BUILD(ICP_QAT_HW_CIPHER_CBC_MODE, alg, \
 				       ICP_QAT_HW_CIPHER_KEY_CONVERT, \
 				       ICP_QAT_HW_CIPHER_DECRYPT)
@@ -117,6 +226,11 @@
 	struct crypto_tfm *tfm;
 	uint8_t salt[AES_BLOCK_SIZE];
 	spinlock_t lock;	/* protects qat_alg_aead_ctx struct */
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	u32	   gcm_keylen;	/* keylen for GCM mode operations */
+	u32	   gcm_nonce;	/* nonce  for GCM mode operations */
+	atomic64_t gcm_seqno;	/* seqno  for GCM mode operations */
+#endif
 };
 
 struct qat_alg_ablkcipher_ctx {
@@ -138,6 +252,10 @@
 		return ICP_QAT_HW_SHA1_STATE1_SZ;
 	case ICP_QAT_HW_AUTH_ALGO_SHA256:
 		return ICP_QAT_HW_SHA256_STATE1_SZ;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+		return ICP_QAT_HW_SHA384_STATE1_SZ;
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		return ICP_QAT_HW_SHA512_STATE1_SZ;
 	default:
@@ -155,6 +273,7 @@
 	struct sha1_state sha1;
 	struct sha256_state sha256;
 	struct sha512_state sha512;
+
 	int block_size = crypto_shash_blocksize(ctx->hash_tfm);
 	int digest_size = crypto_shash_digestsize(ctx->hash_tfm);
 	char ipad[block_size];
@@ -163,6 +282,29 @@
 	__be64 *hash512_state_out;
 	int i, offset;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		char gcm_zeros[AES_BLOCK_SIZE] = {0};
+
+		hash->sha.inner_setup.auth_counter.counter = 0;
+
+		crypto_cipher_setkey(gcm_aes_cipher, auth_key, auth_keylen);
+		crypto_cipher_encrypt_one(gcm_aes_cipher,
+					  &hash->sha.state1[GCM_STATE1_SZ],
+					  gcm_zeros);
+
+		return 0;
+	}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (unlikely(auth_keylen == 0))
+	if (unlikely(wg_fips_sha >  0)) {
+		auth_keylen = wg_fips_sha_len;
+		auth_key    = wg_fips_sha_key;
+	}
+#endif
+
 	memset(ipad, 0, block_size);
 	memset(opad, 0, block_size);
 	shash->tfm = ctx->hash_tfm;
@@ -209,6 +351,9 @@
 		for (i = 0; i < digest_size >> 2; i++, hash_state_out++)
 			*hash_state_out = cpu_to_be32(*(sha256.state + i));
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		if (crypto_shash_export(shash, &sha512))
 			return -EFAULT;
@@ -242,6 +387,9 @@
 		for (i = 0; i < digest_size >> 2; i++, hash_state_out++)
 			*hash_state_out = cpu_to_be32(*(sha256.state + i));
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		if (crypto_shash_export(shash, &sha512))
 			return -EFAULT;
@@ -266,6 +414,12 @@
 					    QAT_COMN_PTR_TYPE_SGL);
 	ICP_QAT_FW_LA_PARTIAL_SET(header->serv_specif_flags,
 				  ICP_QAT_FW_LA_PARTIAL_NONE);
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0)) {
+	ICP_QAT_FW_LA_CIPH_AUTH_CFG_OFFSET_FLAG_SET(header->serv_specif_flags,
+						    ICP_QAT_FW_CIPH_AUTH_CFG_OFFSET_IN_SHRAM_CP);
+	} else
+#endif
 	ICP_QAT_FW_LA_CIPH_IV_FLD_FLAG_SET(header->serv_specif_flags,
 					   ICP_QAT_FW_CIPH_IV_16BYTE_DATA);
 	ICP_QAT_FW_LA_PROTO_SET(header->serv_specif_flags,
@@ -274,6 +428,67 @@
 				       ICP_QAT_FW_LA_NO_UPDATE_STATE);
 }
 
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+
+static void qat_alg_aeadcipher_init_com(struct icp_qat_fw_la_bulk_req *req,
+					struct icp_qat_hw_cipher_algo_blk *cd,
+					const uint8_t *key, unsigned int keylen)
+{
+	struct icp_qat_fw_comn_req_hdr_cd_pars *cd_pars = &req->cd_pars;
+	struct icp_qat_fw_comn_req_hdr *header = &req->comn_hdr;
+	struct icp_qat_fw_cipher_cd_ctrl_hdr *cd_ctrl = (void *)&req->cd_ctrl;
+
+	memcpy(cd->aes.key, key, keylen);
+	qat_alg_init_common_hdr(header);
+	header->service_cmd_id = ICP_QAT_FW_LA_CMD_CIPHER;
+	cd_pars->u.s.content_desc_params_sz =
+		sizeof(struct icp_qat_hw_cipher_algo_blk) >> 3;
+
+	/* Cipher CD config setup */
+	cd_ctrl->cipher_key_sz = keylen >> 3;
+	cd_ctrl->cipher_state_sz = AES_BLOCK_SIZE >> 3;
+	cd_ctrl->cipher_cfg_offset = 0;
+	ICP_QAT_FW_COMN_CURR_ID_SET(cd_ctrl, ICP_QAT_FW_SLICE_CIPHER);
+	ICP_QAT_FW_COMN_NEXT_ID_SET(cd_ctrl, ICP_QAT_FW_SLICE_DRAM_WR);
+}
+
+static void qat_alg_aeadcipher_init_enc(struct qat_alg_aead_ctx *ctx,
+					int alg, const uint8_t *key,
+					unsigned int keylen)
+{
+	struct qat_enc *enc_ctx = &ctx->enc_cd->qat_enc_cd;
+	struct icp_qat_hw_cipher_algo_blk *enc_cd = &enc_ctx->cipher;
+	struct icp_qat_fw_la_bulk_req *req = &ctx->enc_fw_req;
+	struct icp_qat_fw_comn_req_hdr_cd_pars *cd_pars = &req->cd_pars;
+
+
+	PrintK(KERN_DEBUG "%s: alg %d keylen %d\n", __FUNCTION__, alg, keylen);
+
+	qat_alg_aeadcipher_init_com(req, enc_cd, key, keylen);
+	cd_pars->u.s.content_desc_addr = ctx->enc_cd_paddr;
+	enc_cd->aes.cipher_config.val = QAT_AES_HW_CONFIG_CBC_ENC(alg);
+}
+
+static void qat_alg_aeadcipher_init_dec(struct qat_alg_aead_ctx *ctx,
+					int alg, const uint8_t *key,
+					unsigned int keylen)
+{
+	// Use 'enc' here since we need struct icp_qat_hw_cipher_algo_blk
+	// to come first for aeadcipher operations given there is no hash.
+	struct qat_enc *dec_ctx = &ctx->dec_cd->qat_enc_cd;
+	struct icp_qat_hw_cipher_algo_blk *dec_cd = &dec_ctx->cipher;
+	struct icp_qat_fw_la_bulk_req *req = &ctx->dec_fw_req;
+	struct icp_qat_fw_comn_req_hdr_cd_pars *cd_pars = &req->cd_pars;
+
+	PrintK(KERN_DEBUG "%s: alg %d keylen %d\n", __FUNCTION__, alg, keylen);
+
+	qat_alg_aeadcipher_init_com(req, dec_cd, key, keylen);
+	cd_pars->u.s.content_desc_addr = ctx->dec_cd_paddr;
+	dec_cd->aes.cipher_config.val = QAT_AES_HW_CONFIG_CBC_DEC(alg);
+}
+
+#endif
+
 static int qat_alg_aead_init_enc_session(struct qat_alg_aead_ctx *ctx,
 					 int alg,
 					 struct crypto_authenc_keys *keys)
@@ -293,8 +508,25 @@
 	struct icp_qat_fw_auth_cd_ctrl_hdr *hash_cd_ctrl = ptr;
 
 	/* CD setup */
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+	hash = (struct icp_qat_hw_auth_algo_blk *)((char *)enc_ctx +
+		sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_GCM_ENC(alg);
+	} else
+#endif
 	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_CBC_ENC(alg);
 	memcpy(cipher->aes.key, keys->enckey, keys->enckeylen);
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0)) {
+
+	hash = (struct icp_qat_hw_auth_algo_blk *)cipher;
+	hash->sha.inner_setup.auth_config.config =
+		ICP_QAT_HW_AUTH_CONFIG_BUILD(ICP_QAT_HW_AUTH_MODE0,
+					     ctx->qat_hash_alg,
+					     digestsize = wg_fips_sha / 8);
+	} else
+#endif
 	hash->sha.inner_setup.auth_config.config =
 		ICP_QAT_HW_AUTH_CONFIG_BUILD(ICP_QAT_HW_AUTH_MODE1,
 					     ctx->qat_hash_alg, digestsize);
@@ -306,7 +538,13 @@
 
 	/* Request setup */
 	qat_alg_init_common_hdr(header);
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0))
+	header->service_cmd_id = ICP_QAT_FW_LA_CMD_AUTH;
+	else
+#endif
 	header->service_cmd_id = ICP_QAT_FW_LA_CMD_CIPHER_HASH;
+
 	ICP_QAT_FW_LA_DIGEST_IN_BUFFER_SET(header->serv_specif_flags,
 					   ICP_QAT_FW_LA_DIGEST_IN_BUFFER);
 	ICP_QAT_FW_LA_RET_AUTH_SET(header->serv_specif_flags,
@@ -317,10 +555,16 @@
 	cd_pars->u.s.content_desc_params_sz = sizeof(struct qat_alg_cd) >> 3;
 
 	/* Cipher CD config setup */
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (likely(alg != 0)) {
+#endif
 	cipher_cd_ctrl->cipher_key_sz = keys->enckeylen >> 3;
 	cipher_cd_ctrl->cipher_state_sz = AES_BLOCK_SIZE >> 3;
 	cipher_cd_ctrl->cipher_cfg_offset = 0;
 	ICP_QAT_FW_COMN_CURR_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_CIPHER);
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	}
+#endif
 	ICP_QAT_FW_COMN_NEXT_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_AUTH);
 	/* Auth CD config setup */
 	hash_cd_ctrl->hash_cfg_offset = ((char *)hash - (char *)cipher) >> 3;
@@ -339,13 +583,64 @@
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA256_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA256_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA384_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA384_STATE2_SZ;
+		break;
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA512_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA512_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	case ICP_QAT_HW_AUTH_ALGO_GALOIS_128:
+		hash_cd_ctrl->inner_state1_sz = GCM_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = GCM_STATE2_SZ;
+		hash_cd_ctrl->inner_res_sz    = GCM_DIGEST_SIZE;
+		hash_cd_ctrl->final_sz	      = GCM_DIGEST_SIZE;
+
+		cd_pars->u.s.content_desc_params_sz = (sizeof(struct icp_qat_hw_auth_setup) +
+						       GCM_STATE1_SZ + GCM_STATE2_SZ +
+						       sizeof(struct icp_qat_hw_cipher_config) +
+						       keys->enckeylen) >> 3;
+
+		ICP_QAT_FW_LA_PROTO_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_PROTO);
+		ICP_QAT_FW_LA_GCM_IV_LEN_FLAG_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_IV_LEN_12_OCTETS);
+
+		PrintK(KERN_DEBUG "%s: cipher_algo_blk   %p %3d\n", __FUNCTION__, cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+		PrintHex(cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+
+		PrintK(KERN_DEBUG "%s: auth_algo_blk     %p %3d\n", __FUNCTION__, hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+		PrintHex(hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+
+		break;
+#endif
 	default:
 		break;
 	}
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+	if (unlikely(wg_fips_sha_mode0)) {
+
+		hash_cd_ctrl->resrvd1		  = 0;
+		hash_cd_ctrl->inner_state2_sz	  = 0;
+
+		hash_cd_ctrl->inner_state2_offset = (hash_cd_ctrl->inner_state1_sz >> 3);
+
+		switch (wg_fips_sha_mode0) {
+		case 256: hash_cd_ctrl->hash_cfg_offset = 54; break;
+		case 384: hash_cd_ctrl->hash_cfg_offset = 60; break;
+		case 512: hash_cd_ctrl->hash_cfg_offset = 70; break;
+		default:  hash_cd_ctrl->hash_cfg_offset = 41;
+		}
+	}
+#endif
 	hash_cd_ctrl->inner_state2_offset = hash_cd_ctrl->hash_cfg_offset +
 			((sizeof(struct icp_qat_hw_auth_setup) +
 			 round_up(hash_cd_ctrl->inner_state1_sz, 8)) >> 3);
@@ -378,6 +673,14 @@
 		sizeof(struct icp_qat_fw_la_cipher_req_params));
 
 	/* CD setup */
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+	cipher = (struct icp_qat_hw_cipher_algo_blk *)((char *)dec_ctx +
+		sizeof(struct icp_qat_hw_auth_setup) +
+		GCM_STATE1_SZ + GCM_STATE2_SZ);
+	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_GCM_DEC(alg);
+	} else
+#endif
 	cipher->aes.cipher_config.val = QAT_AES_HW_CONFIG_CBC_DEC(alg);
 	memcpy(cipher->aes.key, keys->enckey, keys->enckeylen);
 	hash->sha.inner_setup.auth_config.config =
@@ -391,6 +694,9 @@
 		return -EFAULT;
 
 	/* Request setup */
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (likely(alg != 0))
+#endif
 	qat_alg_init_common_hdr(header);
 	header->service_cmd_id = ICP_QAT_FW_LA_CMD_HASH_CIPHER;
 	ICP_QAT_FW_LA_DIGEST_IN_BUFFER_SET(header->serv_specif_flags,
@@ -403,6 +709,9 @@
 	cd_pars->u.s.content_desc_params_sz = sizeof(struct qat_alg_cd) >> 3;
 
 	/* Cipher CD config setup */
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (likely(alg != 0)) {
+#endif
 	cipher_cd_ctrl->cipher_key_sz = keys->enckeylen >> 3;
 	cipher_cd_ctrl->cipher_state_sz = AES_BLOCK_SIZE >> 3;
 	cipher_cd_ctrl->cipher_cfg_offset =
@@ -410,6 +719,9 @@
 		 roundup(crypto_shash_digestsize(ctx->hash_tfm), 8) * 2) >> 3;
 	ICP_QAT_FW_COMN_CURR_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_CIPHER);
 	ICP_QAT_FW_COMN_NEXT_ID_SET(cipher_cd_ctrl, ICP_QAT_FW_SLICE_DRAM_WR);
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	}
+#endif
 
 	/* Auth CD config setup */
 	hash_cd_ctrl->hash_cfg_offset = 0;
@@ -428,10 +740,48 @@
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA256_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA256_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_SHA2 // WG:JB SHA384
+	case ICP_QAT_HW_AUTH_ALGO_SHA384:
+		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA384_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA384_STATE2_SZ;
+		break;
+#endif
 	case ICP_QAT_HW_AUTH_ALGO_SHA512:
 		hash_cd_ctrl->inner_state1_sz = ICP_QAT_HW_SHA512_STATE1_SZ;
 		hash_cd_ctrl->inner_state2_sz = ICP_QAT_HW_SHA512_STATE2_SZ;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	case ICP_QAT_HW_AUTH_ALGO_GALOIS_128:
+		hash_cd_ctrl->inner_state1_sz = GCM_STATE1_SZ;
+		hash_cd_ctrl->inner_state2_sz = GCM_STATE2_SZ;
+		hash_cd_ctrl->inner_res_sz    = GCM_DIGEST_SIZE;
+		hash_cd_ctrl->final_sz	      = GCM_DIGEST_SIZE;
+
+		cipher_cd_ctrl->cipher_cfg_offset   = (sizeof(struct icp_qat_hw_auth_setup) +
+						       GCM_STATE1_SZ + GCM_STATE2_SZ) >> 3;
+
+		cd_pars->u.s.content_desc_params_sz = (sizeof(struct icp_qat_hw_auth_setup) +
+						       GCM_STATE1_SZ + GCM_STATE2_SZ +
+						       sizeof(struct icp_qat_hw_cipher_config) +
+						       keys->enckeylen) >> 3;
+
+		ICP_QAT_FW_LA_PROTO_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_PROTO);
+		ICP_QAT_FW_LA_GCM_IV_LEN_FLAG_SET(header->serv_specif_flags,
+		ICP_QAT_FW_LA_GCM_IV_LEN_12_OCTETS);
+
+		PrintK(KERN_DEBUG "%s: cipher_algo_blk %p %5d\n", __FUNCTION__, cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+		PrintHex(cipher,
+			 (int)sizeof(struct icp_qat_hw_cipher_config) + keys->enckeylen);
+
+		PrintK(KERN_DEBUG "%s: auth_algo_blk   %p %5d\n", __FUNCTION__, hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+		PrintHex(hash,
+			 (int)sizeof(struct icp_qat_hw_auth_setup) + GCM_STATE1_SZ + GCM_STATE2_SZ);
+
+		break;
+#endif
 	default:
 		break;
 	}
@@ -458,7 +808,8 @@
 	qat_alg_init_common_hdr(header);
 	header->service_cmd_id = ICP_QAT_FW_LA_CMD_CIPHER;
 	cd_pars->u.s.content_desc_params_sz =
-				sizeof(struct icp_qat_hw_cipher_algo_blk) >> 3;
+		sizeof(struct icp_qat_hw_cipher_algo_blk) >> 3;
+
 	/* Cipher CD config setup */
 	cd_ctrl->cipher_key_sz = keylen >> 3;
 	cd_ctrl->cipher_state_sz = AES_BLOCK_SIZE >> 3;
@@ -505,6 +856,11 @@
 	case AES_KEYSIZE_256:
 		*alg = ICP_QAT_HW_CIPHER_ALGO_AES256;
 		break;
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	case 0:
+		*alg = ICP_QAT_HW_CIPHER_ALGO_NULL;
+		break;
+#endif
 	default:
 		return -EINVAL;
 	}
@@ -520,12 +876,37 @@
 	if (crypto_rng_get_bytes(crypto_default_rng, ctx->salt, AES_BLOCK_SIZE))
 		return -EFAULT;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen == GCM_NONCE_SIZE) {
+
+		ctx->gcm_keylen = keylen;
+
+		keylen -= GCM_NONCE_SIZE;
+
+		memcpy((void*)&ctx->gcm_nonce, &key[keylen],  GCM_NONCE_SIZE);
+		memset((void*)&key[keylen],		  0,  GCM_NONCE_SIZE);
+		memcpy((void*)&ctx->gcm_seqno, &ctx->salt[0], GCM_IV_SIZE);
+
+		if (keylen == 0) key = NULL;
+
+		keys.enckey    = keys.authkey    = key;
+		keys.enckeylen = keys.authkeylen = keylen;
+
+		PrintK(KERN_DEBUG "%s: gcmkey %p %5d\n", __FUNCTION__, key, keylen);
+		PrintHex(key, keylen);
+	}
+	else
+#endif
 	if (crypto_authenc_extractkeys(&keys, key, keylen))
 		goto bad_key;
 
 	if (qat_alg_validate_key(keys.enckeylen, &alg))
 		goto bad_key;
 
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (unlikely(!ctx->qat_hash_alg)) if (alg) goto nohash;
+#endif
+
 	if (qat_alg_aead_init_enc_session(ctx, alg, &keys))
 		goto error;
 
@@ -533,6 +914,14 @@
 		goto error;
 
 	return 0;
+
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+nohash:
+	qat_alg_aeadcipher_init_enc(ctx, alg, keys.enckey, keys.enckeylen);
+	qat_alg_aeadcipher_init_dec(ctx, alg, keys.enckey, keys.enckeylen);
+	return 0;
+#endif
+
 bad_key:
 	crypto_tfm_set_flags(ctx->tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
 	return -EINVAL;
@@ -563,6 +952,11 @@
 	struct qat_alg_aead_ctx *ctx = crypto_aead_ctx(tfm);
 	struct device *dev;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	PrintK(KERN_DEBUG "%s: keylen %d gcm %d\n", __FUNCTION__,
+	       keylen, ctx->gcm_keylen);
+#endif
+
 	spin_lock(&ctx->lock);
 	if (ctx->enc_cd) {
 		/* rekeying */
@@ -809,6 +1203,35 @@
 	qat_alg_free_bufl(inst, qat_req);
 	if (unlikely(qat_res != ICP_QAT_FW_COMN_STATUS_FLAG_OK))
 		res = -EBADMSG;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+
+		if (unlikely(wg_fips_aad_len & 7)) {
+			u8* aad = sg_virt(areq->assoc);
+			int j = ((-areq->assoclen) & 7);
+			memmove(aad, aad - j, areq->assoclen);
+		}
+
+		memcpy(sg_virt(areq->assoc) + areq->assoclen, &ctx->gcm_seqno, GCM_IV_SIZE);
+
+		PrintK(KERN_DEBUG "%s: result %p   %5d+%2d\n", __FUNCTION__,
+			 sg_virt(areq->dst), areq->cryptlen,  GCM_DIGEST_SIZE);
+		PrintHex(sg_virt(areq->dst), areq->cryptlen + GCM_DIGEST_SIZE);
+#if	CONFIG_WG_PLATFORM_GCM > 8
+		PrintK(KERN_DEBUG "%s: expect\n", __FUNCTION__);
+		PrintHex(GCMDst, sizeof(GCMDst));
+#endif
+	}
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	else
+	if (unlikely(wg_fips_sha > 0))
+	if (unlikely(res == -EBADMSG)) {
+		wg_fips_sha_err++;
+		printk(KERN_ERR "%s: %s Auth Errors %d\n", __FUNCTION__,
+		       ctx->tfm->__crt_alg->cra_name, wg_fips_sha_err);
+	}
+#endif
 	areq->base.complete(&areq->base, res);
 }
 
@@ -848,6 +1271,13 @@
 	int digst_size = crypto_aead_crt(aead_tfm)->authsize;
 	int ret, ctr = 0;
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen)
+	ret = qat_alg_sgl_to_bufl(ctx->inst, NULL, 0,
+				  areq->src, areq->dst, sg_virt(areq->assoc),
+				  areq->assoclen + GCM_IV_SIZE, qat_req);
+	else
+#endif
 	ret = qat_alg_sgl_to_bufl(ctx->inst, areq->assoc, areq->assoclen,
 				  areq->src, areq->dst, areq->iv,
 				  AES_BLOCK_SIZE, qat_req);
@@ -870,6 +1300,107 @@
 	auth_param->auth_off = 0;
 	auth_param->auth_len = areq->assoclen +
 				cipher_param->cipher_length + AES_BLOCK_SIZE;
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->assoc);
+		struct icp_qat_hw_auth_algo_blk *hash =
+		(struct icp_qat_hw_auth_algo_blk *)((char *)ctx->dec_cd);
+
+		hash->sha.state1[GCM_STATE1_SZ + AES_BLOCK_SIZE + 3] = areq->assoclen;
+
+		cipher_param->cipher_length = areq->cryptlen - GCM_DIGEST_SIZE;
+		cipher_param->cipher_offset = areq->assoclen + GCM_IV_SIZE;
+
+		auth_param->auth_len	    = areq->cryptlen - GCM_DIGEST_SIZE;
+		auth_param->auth_off	    = areq->assoclen + GCM_IV_SIZE;
+
+		auth_param->u1.aad_adr	    = qat_req->buf.bl->bufers[0].addr;
+		auth_param->u2.aad_sz	    = round_up(areq->assoclen, GCM_AAD_PAD_SIZE);
+		auth_param->hash_state_sz   = round_up(areq->assoclen, GCM_STATE1_SZ) >> 3;
+		auth_param->auth_res_sz	    = GCM_DIGEST_SIZE;
+
+		memcpy(&cipher_param->u.cipher_IV_array[0],
+		       &ctx->gcm_nonce,	      GCM_NONCE_SIZE);
+		memcpy(&cipher_param->u.cipher_IV_array[GCM_NONCE_SIZE/sizeof(u32)],
+		       areq->iv,	      GCM_IV_SIZE);
+
+		if (unlikely(wg_fips_aad_len & 7)) {
+			int j = ((-areq->assoclen) & 7);
+			memmove(aad - j, aad, areq->assoclen);
+			aad -= j;
+			auth_param->u1.aad_adr -= j;
+		}
+
+		memset(aad + areq->assoclen, 0, auth_param->u2.aad_sz - areq->assoclen);
+	}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+#if	CONFIG_WG_PLATFORM_GCM > 1
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+
+	PrintK(KERN_DEBUG "%s: coff %d clen %d aoff %d alen %d\n", __FUNCTION__,
+	       cipher_param->cipher_offset, cipher_param->cipher_length,
+	       auth_param->auth_off,	    auth_param->auth_len);
+
+	PrintK(KERN_DEBUG "%s: cipher_params %p\n", __FUNCTION__, cipher_param);
+	PrintK(KERN_DEBUG "%s: auth_params   %p\n", __FUNCTION__, auth_param);
+
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->src) - ((-areq->assoclen) & 7);
+
+		PrintK(KERN_DEBUG "%s: aad+pad %p %3d+%1d\n", __FUNCTION__,
+			 aad, areq->assoclen,	auth_param->u2.aad_sz - areq->assoclen);
+		PrintHex(aad,			auth_param->u2.aad_sz);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %3d+%d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE,  4);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+		PrintHex(sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+
+		PrintK(KERN_DEBUG "%s: dec_cd  %p %5d\n", __FUNCTION__,
+			 ctx->dec_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+		PrintHex(ctx->dec_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+	} else {
+		PrintK(KERN_DEBUG "%s: assoc   %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->assoc), areq->assoclen);
+		PrintHex(sg_virt(areq->assoc), areq->assoclen);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %5d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), auth_param->auth_len + digst_size);
+		PrintHex(sg_virt(areq->src), auth_param->auth_len + digst_size);
+
+		PrintK(KERN_DEBUG "%s: dec_cd  %p %5d\n", __FUNCTION__,
+			 ctx->dec_cd, (int)sizeof(struct qat_alg_cd));
+		PrintHex(ctx->dec_cd, (int)sizeof(struct qat_alg_cd));
+	}
+
+#if	CONFIG_WG_PLATFORM_GCM > 2
+	PrintK(KERN_DEBUG "%s: req     %p %5d\n", __FUNCTION__,
+		&qat_req->req, (int)sizeof(struct icp_qat_fw_la_bulk_req));
+
+	PrintK(KERN_DEBUG "%s: comn_hdr\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_hdr, sizeof(struct icp_qat_fw_comn_req_hdr));
+	PrintK(KERN_DEBUG "%s: cd_pars\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_pars,  sizeof(struct icp_qat_fw_comn_req_hdr_cd_pars));
+	PrintK(KERN_DEBUG "%s: comn_mid\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_mid, sizeof(struct icp_qat_fw_comn_req_mid));
+	PrintK(KERN_DEBUG "%s: serv_specif_rqpars\n",   __FUNCTION__);
+	PrintHex(&qat_req->req.serv_specif_rqpars, sizeof(struct icp_qat_fw_comn_req_rqpars));
+	PrintK(KERN_DEBUG "%s: cd_ctrl\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_ctrl,  sizeof(struct icp_qat_fw_comn_req_cd_ctrl));
+#endif
+#endif
+#endif
+
 	do {
 		ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
 	} while (ret == -EAGAIN && ctr++ < 10);
@@ -892,10 +1423,44 @@
 	struct icp_qat_fw_la_auth_req_params *auth_param;
 	struct icp_qat_fw_la_bulk_req *msg;
 	int ret, ctr = 0;
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	int ivlen = tfm->crt_u.aead.ivsize;
+
+	if (unlikely(ivlen == 0)) {
+
+	areq->src->offset -= areq->assoclen;
+	areq->src->length += areq->assoclen;
+
+	if (unlikely(wg_fips_iv)) {
+		memcpy(iv - areq->assoclen, wg_fips_iv, AES_BLOCK_SIZE + areq->assoclen);
+		wg_fips_iv = NULL;
+	}
 
+	ret = qat_alg_sgl_to_bufl(ctx->inst, NULL, 0,
+				  areq->src, areq->dst, NULL, 0, qat_req);
+
+	} else {
+
+	if (unlikely(wg_fips_iv)) {
+		memcpy(iv, wg_fips_iv, ivlen);
+		wg_fips_iv = NULL;
+		enc_iv = 0;
+	}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen)
+	ret = qat_alg_sgl_to_bufl(ctx->inst, NULL, 0,
+				  areq->src, areq->dst, sg_virt(areq->assoc),
+				  areq->assoclen + GCM_IV_SIZE, qat_req);
+	else
+#endif
 	ret = qat_alg_sgl_to_bufl(ctx->inst, areq->assoc, areq->assoclen,
 				  areq->src, areq->dst, iv, AES_BLOCK_SIZE,
 				  qat_req);
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	}
+#endif
 	if (unlikely(ret))
 		return ret;
 
@@ -910,6 +1475,72 @@
 	cipher_param = (void *)&qat_req->req.serv_specif_rqpars;
 	auth_param = (void *)((uint8_t *)cipher_param + sizeof(*cipher_param));
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->assoc);
+		struct icp_qat_hw_auth_algo_blk *hash =
+		(struct icp_qat_hw_auth_algo_blk *)((char *)ctx->enc_cd +
+		sizeof(struct icp_qat_hw_cipher_config) + (ctx->gcm_keylen & -8));
+
+		hash->sha.state1[GCM_STATE1_SZ + AES_BLOCK_SIZE + 3] = areq->assoclen;
+
+		cipher_param->cipher_length = areq->cryptlen;
+		cipher_param->cipher_offset = areq->assoclen + GCM_IV_SIZE;
+
+		auth_param->auth_len	    = areq->cryptlen;
+		auth_param->auth_off	    = areq->assoclen + GCM_IV_SIZE;
+
+		auth_param->u1.aad_adr	    = qat_req->buf.bl->bufers[0].addr;
+		auth_param->u2.aad_sz	    = round_up(areq->assoclen, GCM_AAD_PAD_SIZE);
+		auth_param->hash_state_sz   = round_up(areq->assoclen, GCM_STATE1_SZ) >> 3;
+
+		memcpy(&cipher_param->u.cipher_IV_array[0],
+		       &ctx->gcm_nonce,	      GCM_NONCE_SIZE);
+		memcpy(&cipher_param->u.cipher_IV_array[GCM_NONCE_SIZE/sizeof(u32)],
+		       iv,		      GCM_IV_SIZE);
+
+		if (unlikely(wg_fips_aad_len & 7)) {
+			int j = ((-areq->assoclen) & 7);
+			memmove(aad - j, aad, areq->assoclen);
+			aad -= j;
+			auth_param->u1.aad_adr -= j;
+		}
+
+		memset(aad + areq->assoclen, 0, auth_param->u2.aad_sz - areq->assoclen);
+
+#if	CONFIG_WG_PLATFORM_GCM > 8
+		{
+		__be64  seq;
+
+		memcpy(&seq,			       &GCMIv[GCM_NONCE_SIZE],	sizeof(u64));
+		atomic64_set(&ctx->gcm_seqno, seq);
+
+		memcpy(cipher_param->u.cipher_IV_array,	GCMIv,			sizeof(GCMIv));
+		memcpy(sg_virt(areq->assoc),		GCMAad,			sizeof(GCMAad));
+		memcpy(sg_virt(areq->src),		GCMSrc,			sizeof(GCMSrc));
+		memset(sg_virt(areq->src) + areq->cryptlen, 0xEE, GCM_DIGEST_SIZE + 8);
+		}
+#endif
+	}
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	else
+	if (unlikely(ivlen == 0)) {
+
+		cipher_param->cipher_offset = 0;
+		cipher_param->cipher_length = 0;
+
+		auth_param->auth_off = 0;
+		auth_param->auth_len = areq->assoclen + areq->cryptlen;
+#ifdef	CONFIG_WG_PLATFORM_MODE0 // WG:JB FIPS algos
+		if (unlikely(wg_fips_sha_mode0)) {
+			auth_param->auth_len -= (wg_fips_sha / 8);
+			memset(&msg->cd_pars, 0, sizeof(msg->cd_pars));
+			wg_fips_sha_mode0 = 0;
+		}
+#endif
+	} else {
+#endif
 	if (enc_iv) {
 		cipher_param->cipher_length = areq->cryptlen + AES_BLOCK_SIZE;
 		cipher_param->cipher_offset = areq->assoclen;
@@ -920,6 +1551,75 @@
 	}
 	auth_param->auth_off = 0;
 	auth_param->auth_len = areq->assoclen + areq->cryptlen + AES_BLOCK_SIZE;
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+#if	CONFIG_WG_PLATFORM_GCM > 1
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+	PrintK(KERN_DEBUG "%s:\n",		    __FUNCTION__);
+
+	PrintK(KERN_DEBUG "%s: coff %d clen %d aoff %d alen %d\n", __FUNCTION__,
+	       cipher_param->cipher_offset, cipher_param->cipher_length,
+	       auth_param->auth_off,	    auth_param->auth_len);
+
+	PrintK(KERN_DEBUG "%s: cipher_params %p\n", __FUNCTION__, cipher_param);
+	PrintK(KERN_DEBUG "%s: auth_params   %p\n", __FUNCTION__, auth_param);
+
+	if (ctx->gcm_keylen) {
+		u8* aad = sg_virt(areq->src) - ((-areq->assoclen) & 7);
+
+		PrintK(KERN_DEBUG "%s: aad+pad %p %3d+%1d\n", __FUNCTION__,
+			 aad, areq->assoclen,	auth_param->u2.aad_sz - areq->assoclen);
+		PrintHex(aad,			auth_param->u2.aad_sz);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %3d+%d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE,  4);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], GCM_NONCE_SIZE + GCM_IV_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+		PrintHex(sg_virt(areq->src), areq->assoclen + GCM_IV_SIZE + areq->cryptlen);
+
+		PrintK(KERN_DEBUG "%s: enc_cd  %p %5d\n", __FUNCTION__,
+			 ctx->enc_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+		PrintHex(ctx->enc_cd, GCM_PARAMS_SZ + (ctx->gcm_keylen & -8));
+	} else {
+		PrintK(KERN_DEBUG "%s: assoc   %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->assoc), areq->assoclen);
+		PrintHex(sg_virt(areq->assoc), areq->assoclen);
+
+		PrintK(KERN_DEBUG "%s: iv      %p %5d\n", __FUNCTION__,
+			 &cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+		PrintHex(&cipher_param->u.cipher_IV_array[0], AES_BLOCK_SIZE);
+
+		PrintK(KERN_DEBUG "%s: src     %p %5d\n", __FUNCTION__,
+			 sg_virt(areq->src), auth_param->auth_len);
+		PrintHex(sg_virt(areq->src), auth_param->auth_len);
+
+		PrintK(KERN_DEBUG "%s: enc_cd  %p %5d\n", __FUNCTION__,
+			 ctx->enc_cd, (int)sizeof(struct qat_alg_cd));
+		PrintHex(ctx->enc_cd, (int)sizeof(struct qat_alg_cd));
+	}
+
+#if	CONFIG_WG_PLATFORM_GCM > 2
+	PrintK(KERN_DEBUG "%s: req     %p %5d\n", __FUNCTION__,
+		&qat_req->req, (int)sizeof(struct icp_qat_fw_la_bulk_req));
+
+	PrintK(KERN_DEBUG "%s: comn_hdr\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_hdr, sizeof(struct icp_qat_fw_comn_req_hdr));
+	PrintK(KERN_DEBUG "%s: cd_pars\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_pars,  sizeof(struct icp_qat_fw_comn_req_hdr_cd_pars));
+	PrintK(KERN_DEBUG "%s: comn_mid\n", __FUNCTION__);
+	PrintHex(&qat_req->req.comn_mid, sizeof(struct icp_qat_fw_comn_req_mid));
+	PrintK(KERN_DEBUG "%s: serv_specif_rqpars\n",   __FUNCTION__);
+	PrintHex(&qat_req->req.serv_specif_rqpars, sizeof(struct icp_qat_fw_comn_req_rqpars));
+	PrintK(KERN_DEBUG "%s: cd_ctrl\n",  __FUNCTION__);
+	PrintHex(&qat_req->req.cd_ctrl,  sizeof(struct icp_qat_fw_comn_req_cd_ctrl));
+#endif
+#endif
+#endif
 
 	do {
 		ret = adf_send_message(ctx->inst->sym_tx, (uint32_t *)msg);
@@ -951,6 +1651,20 @@
 	return qat_alg_aead_enc_internal(&req->areq, req->giv, 1);
 }
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+static int qat_alg_aead_gcm_genivenc(struct aead_givcrypt_request *req)
+{
+	struct crypto_aead *aead_tfm = crypto_aead_reqtfm(&req->areq);
+	struct crypto_tfm *tfm = crypto_aead_tfm(aead_tfm);
+	struct qat_alg_aead_ctx *ctx = crypto_tfm_ctx(tfm);
+	__be64 seq = atomic64_inc_return(&ctx->gcm_seqno);
+
+	memcpy(req->giv, &seq, sizeof(uint64_t));
+	return qat_alg_aead_enc_internal(&req->areq, req->giv, 1);
+}
+
+#endif
+
 static int qat_alg_ablkcipher_setkey(struct crypto_ablkcipher *tfm,
 				     const uint8_t *key,
 				     unsigned int keylen)
@@ -1022,6 +1736,13 @@
 	struct icp_qat_fw_la_bulk_req *msg;
 	int ret, ctr = 0;
 
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+	if (unlikely(wg_fips_iv)) {
+		memcpy(req->info, wg_fips_iv, AES_BLOCK_SIZE);
+		wg_fips_iv = NULL;
+	}
+#endif
+
 	ret = qat_alg_sgl_to_bufl(ctx->inst, NULL, 0, req->src, req->dst,
 				  NULL, 0, qat_req);
 	if (unlikely(ret))
@@ -1094,9 +1815,24 @@
 {
 	struct qat_alg_aead_ctx *ctx = crypto_tfm_ctx(tfm);
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	ctx->gcm_keylen = (hash == ICP_QAT_HW_AUTH_ALGO_GALOIS_128) ? GCM_NONCE_SIZE : 0;
+	PrintK(KERN_DEBUG "%s: fips %d mode0 %d gcm %d hash %d %s\n", __FUNCTION__,
+	       wg_fips_sha, wg_fips_sha_mode0, ctx->gcm_keylen, hash, hash_name);
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS
+	if (hash == ICP_QAT_HW_AUTH_ALGO_NULL)
+	ctx->hash_tfm = NULL;
+	else {
+	ctx->hash_tfm = crypto_alloc_shash(hash_name, 0, 0);
+	if (IS_ERR(ctx->hash_tfm))
+		return -EFAULT;
+	}
+#else
 	ctx->hash_tfm = crypto_alloc_shash(hash_name, 0, 0);
 	if (IS_ERR(ctx->hash_tfm))
 		return -EFAULT;
+#endif
 	spin_lock_init(&ctx->lock);
 	ctx->qat_hash_alg = hash;
 	crypto_aead_set_reqsize(__crypto_aead_cast(tfm),
@@ -1116,11 +1852,41 @@
 	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA256, "sha256");
 }
 
+#ifdef	CONFIG_WG_PLATFORM_C3XXX_SHA384
+static int qat_alg_aead_sha384_init(struct crypto_tfm *tfm)
+{
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA384, "sha384");
+}
+#endif
+
 static int qat_alg_aead_sha512_init(struct crypto_tfm *tfm)
 {
 	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA512, "sha512");
 }
 
+#ifdef	CONFIG_WG_PLATFORM_GCM
+static int qat_alg_aead_ghash_init(struct crypto_tfm *tfm)
+{
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_GALOIS_128, "ghash");
+}
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB FIPS algos
+static int qat_alg_aead_null_init(struct crypto_tfm *tfm)
+{
+	if (wg_fips_sha >= 512)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA512, "sha512");
+	if (wg_fips_sha >= 384)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA384, "sha384");
+	if (wg_fips_sha >= 256)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA256, "sha256");
+	if (wg_fips_sha >= 160)
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_SHA1,   "sha1");
+
+	return qat_alg_aead_init(tfm, ICP_QAT_HW_AUTH_ALGO_NULL,   "");
+}
+#endif
+
 static void qat_alg_aead_exit(struct crypto_tfm *tfm)
 {
 	struct qat_alg_aead_ctx *ctx = crypto_tfm_ctx(tfm);
@@ -1252,6 +2018,214 @@
 		},
 	},
 }, {
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB Extra WG algos
+#ifdef	CONFIG_WG_PLATFORM_C3XXX_SHA384
+	.cra_name = "authenc(hmac(sha384),cbc(aes))",
+	.cra_driver_name = "qat_aes_cbc_hmac_sha384",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = AES_BLOCK_SIZE,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_sha384_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_genivenc,
+			.ivsize = AES_BLOCK_SIZE,
+			.maxauthsize = SHA384_DIGEST_SIZE,
+		},
+	},
+}, {
+#endif
+	.cra_name = "authenc(digest_null,cbc(cipher_null))",
+	.cra_driver_name = "qat_cipher_null_cbc_digest_null",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = 1,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_null_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_genivenc,
+			.ivsize = 000*000,
+			.maxauthsize = 000*000,
+		},
+	},
+}, {
+	.cra_name = "authenc(hmac(sha1),cbc(cipher_null))",
+	.cra_driver_name = "qat_cipher_null_cbc_hmac_sha1",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = 4,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_sha1_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_genivenc,
+			.ivsize = 000*000,
+			.maxauthsize = SHA1_DIGEST_SIZE,
+		},
+	},
+}, {
+	.cra_name = "authenc(hmac(sha256),cbc(cipher_null))",
+	.cra_driver_name = "qat_cipher_null_cbc_hmac_sha256",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = 4,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_sha256_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_genivenc,
+			.ivsize = 000*000,
+			.maxauthsize = SHA256_DIGEST_SIZE,
+		},
+	},
+}, {
+#ifdef	CONFIG_WG_PLATFORM_C3XXX_SHA384
+	.cra_name = "authenc(hmac(sha384),cbc(cipher_null))",
+	.cra_driver_name = "qat_cipher_null_cbc_hmac_sha384",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = 4,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_sha384_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_genivenc,
+			.ivsize = 000*000,
+			.maxauthsize = SHA384_DIGEST_SIZE,
+		},
+	},
+}, {
+#endif
+	.cra_name = "authenc(hmac(sha512),cbc(cipher_null))",
+	.cra_driver_name = "qat_cipher_null_cbc_hmac_sha512",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = 4,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_sha512_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_genivenc,
+			.ivsize = 000*000,
+			.maxauthsize = SHA512_DIGEST_SIZE,
+		},
+	},
+}, {
+	.cra_name = "authenc(digest_null,cbc(aes))",
+	.cra_driver_name = "qat_aes_cbc_digest_null",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = AES_BLOCK_SIZE,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_null_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_genivenc,
+			.ivsize = AES_BLOCK_SIZE,
+			.maxauthsize = 000*000,
+		},
+	},
+}, {
+#endif
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	.cra_name = "rfc4106(gcm(aes))",
+	.cra_driver_name = "qat_rfc4106_gcm_aes",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_AEAD | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = 4,
+	.cra_ctxsize = sizeof(struct qat_alg_aead_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_aead_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_aead_ghash_init,
+	.cra_exit = qat_alg_aead_exit,
+	.cra_u = {
+		.aead = {
+			.setkey = qat_alg_aead_setkey,
+			.decrypt = qat_alg_aead_dec,
+			.encrypt = qat_alg_aead_enc,
+			.givencrypt = qat_alg_aead_gcm_genivenc,
+			.ivsize = GCM_IV_SIZE,
+			.maxauthsize = GCM_DIGEST_SIZE,
+		},
+	},
+}, {
+#endif
+#ifdef	CONFIG_WG_PLATFORM_FIPS // WG:JB Extra WG algos
+	.cra_name = "ablk(cbc(aes))",
+	.cra_driver_name = "qat_ablk_aes_cbc",
+	.cra_priority = 4001,
+	.cra_flags = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+	.cra_blocksize = AES_BLOCK_SIZE,
+	.cra_ctxsize = sizeof(struct qat_alg_ablkcipher_ctx),
+	.cra_alignmask = 0,
+	.cra_type = &crypto_ablkcipher_type,
+	.cra_module = THIS_MODULE,
+	.cra_init = qat_alg_ablkcipher_init,
+	.cra_exit = qat_alg_ablkcipher_exit,
+	.cra_u = {
+		.ablkcipher = {
+			.setkey = qat_alg_ablkcipher_setkey,
+			.decrypt = qat_alg_ablkcipher_decrypt,
+			.encrypt = qat_alg_ablkcipher_encrypt,
+			.min_keysize = AES_MIN_KEY_SIZE,
+			.max_keysize = AES_MAX_KEY_SIZE,
+			.ivsize = AES_BLOCK_SIZE,
+		},
+	},
+}, {
+#endif
 	.cra_name = "cbc(aes)",
 	.cra_driver_name = "qat_aes_cbc",
 	.cra_priority = 4001,
@@ -1279,6 +2253,15 @@
 {
 	int ret = 0;
 
+#ifdef	CONFIG_WG_PLATFORM
+	printk(KERN_INFO "\n%s: Built " __DATE__ " " __TIME__ "\n\n", __FUNCTION__);
+#endif
+
+#ifdef	CONFIG_WG_PLATFORM_GCM
+	gcm_aes_cipher = crypto_alloc_cipher("aes", 0, 0);
+	if (IS_ERR(gcm_aes_cipher)) return -ENOENT;
+#endif
+
 	mutex_lock(&algs_lock);
 	if (++active_devs == 1) {
 		int i;
--- cavecreek-1.0.3-42/quickassist/qat/compat/qat_compat.c.orig	2022-05-09 13:48:22.129003143 -0700
+++ cavecreek-1.0.3-42/quickassist/qat/compat/qat_compat.c	2022-05-09 13:48:22.624983011 -0700
@@ -278,6 +278,7 @@
 }
 #endif /* 3.12.0 && !RHEL7.x */
 
+#ifndef CONFIG_WG_PLATFORM
 /******************************************************************************/
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0) && \
     !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7, 1)) && \
@@ -312,6 +313,7 @@
 	return 0;
 }
 #endif /* 3.13.0 && !RHEL7.1+ && !SUSE12.1 */
+#endif // CONFIG_WG_PLATFORM
 
 /******************************************************************************/
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 3) && \
--- cavecreek-1.0.3-42/quickassist/qat/compat/qat_compat.h.orig	2022-05-09 13:48:22.129003143 -0700
+++ cavecreek-1.0.3-42/quickassist/qat/compat/qat_compat.h	2022-05-09 13:48:22.624983011 -0700
@@ -283,6 +283,7 @@
 
 /******************************************************************************/
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0))
+#ifndef CONFIG_WG_PLATFORM
 #if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7, 1)) &&\
      !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE == RHEL_RELEASE_VERSION(6, 8)) &&\
      !(SLE_VERSION_CODE && SLE_VERSION_CODE < SLE_VERSION(12, 1, 0)))
@@ -300,6 +301,7 @@
 int crypto_authenc_extractkeys(struct crypto_authenc_keys *keys, const u8 *key,
 			       unsigned int keylen);
 #endif /* !RHEL7.1+ && SUSE12.1 */
+#endif // CONFIG_WG_PLATFORM
 #ifndef GENMASK_ULL
 #define GENMASK_ULL(h, l)	(((U64_C(1) << ((h) - (l) + 1)) - 1) << (l))
 #endif /* GENMASK_ULL */
@@ -398,6 +400,7 @@
 #endif /* 3.19.0 */
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0))
+#ifndef CONFIG_WG_PLATFORM
 #if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7, 3)) &&\
      !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE == RHEL_RELEASE_VERSION(6, 8)))
 static inline void crypto_aead_set_reqsize(struct crypto_aead *aead,
@@ -406,6 +409,7 @@
 	crypto_aead_crt(aead)->reqsize = reqsize;
 }
 #endif /* RHEL_RELEASE_VERSION(7.3) */
+#endif // CONFIG_WG_PLATFORM
 #endif /* 4.2.0 */
 
 #ifndef list_next_entry
--- cavecreek-1.0.3-42/quickassist/build_system/build_files/env_files/linux_2.6_user_space.mk.orig	2022-05-09 13:48:21.829015321 -0700
+++ cavecreek-1.0.3-42/quickassist/build_system/build_files/env_files/linux_2.6_user_space.mk	2022-05-09 13:48:22.432990803 -0700
@@ -46,7 +46,9 @@
 #
 #-------------------------------------------------------------
 
-INCLUDES+=-I/usr/include \
+SYSTEM_INCLUDE ?= /usr/include
+
+INCLUDES+=-I$(SYSTEM_INCLUDE) \
           -I$(API_DIR)   \
           -I$(OSAL_DIR)/include \
           -I$(OSAL_DIR)/src/linux/user_space/include
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/b.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/b	2022-05-09 13:48:22.528986907 -0700
@@ -0,0 +1,28 @@
+#
+ICP_ROOT=$(cd ../../../../../../..; pwd)
+ICP_EXPORTS=$ICP_ROOT/../build
+#
+echo
+echo ICP_ROOT    = $ICP_ROOT
+echo ICP_EXPORTS = $ICP_EXPORTS
+#
+rm -f wg_fips
+#
+gcc -g -Wall -O1 \
+-I$ICP_ROOT/include/ \
+-I$ICP_ROOT/include/lac \
+-I$ICP_ROOT/include/dc \
+-I$ICP_ROOT/lookaside/access_layer/include \
+-I$ICP_ROOT/lookaside/access_layer/src/sample_code/functional/include \
+-I$ICP_ROOT/utilities/libusdm_drv// \
+-DUSER_SPACE -DDO_CRYPTO -DWITH_UPSTREAM -DWITH_CMDRV \
+../../common/cpa_sample_utils.c wg_fips.c wg_fips_main.c \
+$ICP_EXPORTS/libqat.a \
+$ICP_EXPORTS/libosal.a \
+$ICP_EXPORTS/libadf.a \
+$ICP_EXPORTS/libusdm_drv.a \
+-lpthread -lcrypto -ludev -lrt -o wg_fips
+#
+echo
+ls -l wg_fips
+echo
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/wg_fips_main.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/wg_fips_main.c	2022-05-09 13:48:22.528986907 -0700
@@ -0,0 +1,98 @@
+/******************************************************************************
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007-2016 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  version: QAT1.7.Upstream.L.1.0.3-42
+ *
+ *****************************************************************************/
+
+
+/**
+ ******************************************************************************
+ * @file  cpa_hash_sample_user.c
+ *
+ *****************************************************************************/
+#include <unistd.h>
+
+#include "cpa_sample_utils.h"
+#include "icp_sal_user.h"
+
+extern CpaStatus
+hashSample(void);
+
+
+int gDebugParam = 0;
+
+extern int DIGEST_SIZE;
+
+int
+main(int argc, const char **argv)
+{
+    CpaStatus stat = CPA_STATUS_SUCCESS;
+
+    if (strstr(argv[0], "sha1"  ) != 0) DIGEST_SIZE = 20;
+    if (strstr(argv[0], "sha256") != 0) DIGEST_SIZE = 32;
+    if (strstr(argv[0], "sha384") != 0) DIGEST_SIZE = 48;
+    if (strstr(argv[0], "sha512") != 0) DIGEST_SIZE = 64;
+
+    PRINT_DBG("Starting Hash Sample Code App ...\n" ) ;
+
+    stat = qaeMemInit();
+    if(CPA_STATUS_SUCCESS != stat)
+    {
+        PRINT_ERR("Failed to initialise memory driver\n");
+        return (int) stat;
+    }
+
+    stat = icp_sal_userStartMultiProcess("SSL", CPA_FALSE);
+    if(CPA_STATUS_SUCCESS != stat)
+    {
+       PRINT_ERR("Failed to start user process SSL\n");
+       qaeMemDestroy();
+       return (int) stat;
+    }
+
+    stat = hashSample();
+    if(CPA_STATUS_SUCCESS != stat)
+    {
+       PRINT_ERR("\nHash Sample Code App failed\n");
+    }
+    else
+    {
+       PRINT_DBG("\nHash Sample Code App finished\n");
+    }
+
+    icp_sal_userStop();
+    qaeMemDestroy();
+
+    return (int)stat;
+}
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/bwg.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/bwg	2022-05-09 13:48:22.528986907 -0700
@@ -0,0 +1,26 @@
+#
+ICP_ROOT=$(cd ../../../../../../..; pwd)
+echo
+echo ICP_ROOT = $ICP_ROOT
+#
+rm -f wg_fips
+#
+gcc -g -Wall -O1 \
+-I$ICP_ROOT/include/ \
+-I$ICP_ROOT/include/lac \
+-I$ICP_ROOT/include/dc \
+-I$ICP_ROOT/lookaside/access_layer/include \
+-I$ICP_ROOT/lookaside/access_layer/src/sample_code/functional/include \
+-I$ICP_ROOT/utilities/libusdm_drv// \
+-DUSER_SPACE -DDO_CRYPTO -DWITH_UPSTREAM -DWITH_CMDRV \
+../../common/cpa_sample_utils.c wg_fips.c wg_fips_main.c \
+$ICP_ROOT/exports/libqat.a \
+$ICP_ROOT/exports/libosal.a \
+$ICP_ROOT/exports/libadf.a \
+$ICP_ROOT/exports/libusdm_drv.a \
+/usr/lib/x86_64-linux-gnu/libudev.a \
+-lpthread -lcrypto -lrt -o wg_fips
+#
+echo
+ls -l wg_fips
+echo
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/wg_fips.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/wg_fips.c	2022-05-09 13:48:22.528986907 -0700
@@ -0,0 +1,1195 @@
+#include "cpa.h"
+#include "cpa_cy_im.h"
+#include "cpa_cy_sym.h"
+#include "cpa_sample_utils.h"
+
+#include <stdio.h>
+#include <unistd.h>
+
+extern	int gDebugParam;
+
+#define TIMEOUT_MS    5000 /* 5 seconds*/
+
+/* For IPSec outbound direction we encrypt the payload and then
+   generate the ICV. For IPSec inbound direction we compare the
+   ICV and decrypt the payload
+*/
+#define IPSEC_OUTBOUND_DIR 0
+#define IPSEC_INBOUND_DIR  1
+
+int	DIGEST_TYPE = CPA_CY_SYM_HASH_SHA1;
+int	DIGEST_SIZE = 20;
+
+int	ICV_LENGTH  = 12;
+
+int ParseHex(uint8_t* dst, uint8_t* src)
+{
+  int     n,  v;
+  uint8_t hex[4] = {0};
+
+  for (n = 0; (v = -1); n++) {
+
+    hex[0] = hex[1] = 0;
+
+    if (src) {
+      if (*src) hex[0] = *src++;
+      if (*src) hex[1] = *src++;
+    } else {
+      if (read(0, &hex[0], 2) != 2) break;
+    }
+
+    if (hex[0] < '0') break;
+    if (hex[1] < '0') break;
+
+    if (sscanf((char*)hex, "%x", &v) != 1) break;
+
+    if (v < 0) break;
+
+    *dst++ = v;
+  }
+
+  return n;
+}
+
+/*
+ * Callback function
+ *
+ * This function is "called back" (invoked by the implementation of
+ * the API) when the asynchronous operation has completed.  The
+ * context in which it is invoked depends on the implementation, but
+ * as described in the API it should not sleep (since it may be called
+ * in a context which does not permit sleeping, e.g. a Linux bottom
+ * half).
+ *
+ * This function can perform whatever processing is appropriate to the
+ * application.  For example, it may free memory, continue processing
+ * of a decrypted packet, etc.  In this example, the function checks
+ * verifyResult returned and sets the complete variable to indicate it
+ * has been called.
+ */
+static void
+symCallback(void *pCallbackTag,
+        CpaStatus status,
+        const CpaCySymOp operationType,
+        void *pOpData,
+        CpaBufferList *pDstBuffer,
+        CpaBoolean verifyResult)
+{
+    PRINT_DBG("Callback called with status = %d.\n", status);
+
+    /* For this implementation verifyResult is true by default. In
+       the digest generate case verifyDigest will never be false. In
+       the digest verify case verifyDigest can be false if digest
+       verification fails */
+    if(CPA_FALSE == verifyResult)
+    {
+       PRINT_ERR("Callback verify result error\n");
+    }
+
+    if (NULL != pCallbackTag)
+    {
+        /** indicate that the function has been called */
+        COMPLETE((struct COMPLETION_STRUCT *)pCallbackTag);
+    }
+}
+
+static Cpa8U sampleCipherKey[] = {
+        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
+        0x88, 0x99, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55
+};
+
+static Cpa8U sampleCipherIv[] = {
+        0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
+        0xde, 0xca, 0xf8, 0x88, 0x3d, 0x11, 0x59, 0x04
+};
+
+static Cpa8U sampleAuthKey[] = {
+        0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
+        0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF,
+        0xDE, 0xAD, 0xBE, 0xEF
+};
+
+static Cpa8U sampleEspHdrData[] = {
+        0x00, 0x00, 0x01, 0x2c, 0x00, 0x00, 0x00, 0x05
+};
+
+/* Payload padded to a multiple of the cipher block size
+   (16), 2nd last byte gives pad length, last byte gives
+   next header info */
+static Cpa8U samplePayload[] = {
+        0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,
+        0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
+        0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
+        0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
+        0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
+        0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
+        0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,
+        0xba, 0x63, 0x7b, 0x39, 0x01, 0x02, 0x02, 0x61
+};
+
+
+static Cpa8U expectedOutput[] = {
+        /* ESP header unmodified */
+        0x00, 0x00, 0x01, 0x2c, 0x00, 0x00, 0x00, 0x05,
+        /* IV unmodified */
+        0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
+        0xde, 0xca, 0xf8, 0x88, 0x3d, 0x11, 0x59, 0x04,
+        /* Ciphertext */
+        0x39, 0x8E, 0x4C, 0x1B, 0x7B, 0x28, 0x94, 0x52,
+        0x97, 0xAD, 0x95, 0x97, 0xD7, 0xF9, 0xB9, 0x4A,
+        0x49, 0x03, 0x51, 0x47, 0x45, 0xC7, 0x58, 0x6A,
+        0x9A, 0x48, 0xB6, 0x38, 0xB4, 0xD5, 0xEE, 0x42,
+        0x4F, 0x39, 0x09, 0x3D, 0xAB, 0x1E, 0xB3, 0x6A,
+        0x71, 0x0B, 0xFC, 0x80, 0xAD, 0x2E, 0x4C, 0xA5,
+        0xAB, 0x78, 0xB8, 0xAB, 0x87, 0xCC, 0x37, 0xF0,
+        0xB9, 0x61, 0xDC, 0xB1, 0xA7, 0x24, 0x26, 0x23,
+        /* ICV */
+        0xE6, 0x55, 0xBD, 0x90, 0x33, 0x2D, 0x04, 0x8C,
+        0x34, 0x06, 0xE3, 0x2D
+};
+
+/*
+ * Perform an algorithm chaining operation
+ */
+static CpaStatus
+algChainPerformOp(CpaInstanceHandle cyInstHandle, CpaCySymSessionCtx sessionCtx, int dir)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    Cpa8U  *pBufferMeta = NULL;
+    Cpa32U bufferMetaSize = 0;
+    CpaBufferList *pBufferList = NULL;
+    CpaFlatBuffer *pFlatBuffer = NULL;
+    CpaCySymOpData *pOpData = NULL;
+    /* buffer size includes space for hdr, iv, payload and icv */
+    Cpa32U bufferSize = sizeof(sampleEspHdrData) + sizeof(sampleCipherIv)
+                            + sizeof(samplePayload) + ICV_LENGTH;
+    Cpa32U numBuffers = 1;  /* only using 1 buffer in this case */
+    /* allocate memory for bufferlist and array of flat buffers in a contiguous
+     * area and carve it up to reduce number of memory allocations required. */
+    Cpa32U bufferListMemSize = sizeof(CpaBufferList) +
+        (numBuffers * sizeof(CpaFlatBuffer));
+    Cpa8U  *pSrcBuffer = NULL;
+    Cpa8U  *pIvBuffer = NULL;
+
+    /* The following variables are allocated on the stack because we block
+     * until the callback comes back. If a non-blocking approach was to be
+     * used then these variables should be dynamically allocated */
+    struct COMPLETION_STRUCT complete;
+
+    /* get meta information size */
+    status = cpaCyBufferListGetMetaSize( cyInstHandle,
+                numBuffers, &bufferMetaSize);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pBufferMeta, bufferMetaSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = OS_MALLOC(&pBufferList, bufferListMemSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pSrcBuffer, bufferSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* increment by sizeof(CpaBufferList) to get at the
+         * array of flatbuffers */
+        pFlatBuffer = (CpaFlatBuffer *) (pBufferList + 1);
+
+        pBufferList->pBuffers = pFlatBuffer;
+        pBufferList->numBuffers = 1;
+        pBufferList->pPrivateMetaData = pBufferMeta;
+
+        pFlatBuffer->dataLenInBytes = bufferSize;
+        pFlatBuffer->pData = pSrcBuffer;
+
+        /* copy source into buffer */
+        if(IPSEC_OUTBOUND_DIR == dir)
+        {
+           memcpy(pSrcBuffer, sampleEspHdrData, sizeof(sampleEspHdrData));
+           memcpy(pSrcBuffer+sizeof(sampleEspHdrData), sampleCipherIv, sizeof(sampleCipherIv));
+           memcpy(pSrcBuffer+(sizeof(sampleEspHdrData)+sizeof(sampleCipherIv)),
+                                  samplePayload, sizeof(samplePayload));
+        }
+        else
+        {
+           memcpy(pSrcBuffer, expectedOutput, sizeof(expectedOutput));
+        }
+
+        pIvBuffer = pSrcBuffer + sizeof(sampleEspHdrData);
+
+        status = OS_MALLOC(&pOpData, sizeof(CpaCySymOpData));
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        if(IPSEC_OUTBOUND_DIR == dir)
+        {
+//<snippet name="opDataIPSecOut">
+           /** Populate the structure containing the operational data that is
+            * needed to run the algorithm in outbound direction */
+           pOpData->sessionCtx = sessionCtx;
+           pOpData->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+           pOpData->pIv = pIvBuffer;
+           pOpData->ivLenInBytes = sizeof(sampleCipherIv);
+           pOpData->cryptoStartSrcOffsetInBytes = sizeof(sampleEspHdrData)+sizeof(sampleCipherIv);
+           pOpData->messageLenToCipherInBytes = sizeof(samplePayload);
+           pOpData->hashStartSrcOffsetInBytes = 0;
+           pOpData->messageLenToHashInBytes = sizeof(sampleEspHdrData)
+                                   +sizeof(sampleCipherIv)+sizeof(samplePayload);
+           /* Even though ICV follows immediately after the region to hash
+           digestIsAppended is set to false in this case to workaround
+           errata number IXA00378322 */
+           pOpData->pDigestResult = pSrcBuffer+
+                 (sizeof(sampleEspHdrData)+sizeof(sampleCipherIv)+sizeof(samplePayload));
+//</snippet>
+       }
+       else
+       {
+//<snippet name="opDataIPSecIn">
+           /** Populate the structure containing the operational data that is
+            * needed to run the algorithm in inbound direction */
+           pOpData->sessionCtx = sessionCtx;
+           pOpData->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+           pOpData->pIv = pIvBuffer;
+           pOpData->ivLenInBytes = sizeof(sampleCipherIv);
+           pOpData->cryptoStartSrcOffsetInBytes = sizeof(sampleEspHdrData)+sizeof(sampleCipherIv);
+           pOpData->messageLenToCipherInBytes = bufferSize -
+                                    (sizeof(sampleEspHdrData)+sizeof(sampleCipherIv)+ICV_LENGTH);
+           pOpData->hashStartSrcOffsetInBytes = 0;
+           pOpData->messageLenToHashInBytes = bufferSize - ICV_LENGTH;
+//</snippet>
+       }
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /** initialisation for callback; the "complete" variable is used by the
+         * callback function to indicate it has been called*/
+        COMPLETION_INIT(&complete);
+
+        PRINT_DBG("cpaCySymPerformOp\n");
+
+        /** Perform symmetric operation */
+        status = cpaCySymPerformOp(cyInstHandle,
+                (void *)&complete, /* data sent as is to the callback function*/
+                pOpData,           /* operational data struct */
+                pBufferList,       /* source buffer list */
+                pBufferList,       /* same src & dst for an in-place operation*/
+                NULL);             /* pVerifyResult not required in async mode */
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymPerformOp failed. (status = %d)\n", status);
+        }
+
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            /** wait until the completion of the operation*/
+            if (!COMPLETION_WAIT(&complete, TIMEOUT_MS))
+            {
+                PRINT_ERR("timeout or interruption in cpaCySymPerformOp\n");
+                status = CPA_STATUS_FAIL;
+            }
+        }
+
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            if(IPSEC_OUTBOUND_DIR == dir)
+            {
+               if (0 == memcmp(pSrcBuffer, expectedOutput, bufferSize))
+               {
+                   PRINT_DBG("Output matches expected output encrypt generate\n");
+               }
+               else
+               {
+                   PRINT_DBG("Output does not match expected output encrypt generate\n");
+                   status = CPA_STATUS_FAIL;
+               }
+            }
+            else
+            {
+               if (0 == memcmp(pSrcBuffer+(sizeof(sampleEspHdrData)+sizeof(sampleCipherIv)),
+                              samplePayload, sizeof(samplePayload)))
+               {
+                   PRINT_DBG("Output matches expected output decrypt verify\n");
+               }
+               else
+               {
+                   PRINT_DBG("Output does not match expected output decrypt verify\n");
+                   status = CPA_STATUS_FAIL;
+                }
+            }
+        }
+    }
+
+
+    /* at this stage, the callback function has returned, so it is sure that
+     * the structures won't be needed any more*/
+    PHYS_CONTIG_FREE(pSrcBuffer);
+    OS_FREE(pBufferList);
+    PHYS_CONTIG_FREE(pBufferMeta);
+    OS_FREE(pOpData);
+
+    COMPLETION_DESTROY(&complete);
+
+    return status;
+}
+
+CpaStatus
+algChainSample(void)
+{
+    CpaStatus status = CPA_STATUS_FAIL;
+    CpaCySymSessionCtx sessionCtx = NULL;
+    Cpa32U sessionCtxSize = 0;
+    CpaInstanceHandle cyInstHandle = NULL;
+    CpaCySymSessionSetupData sessionSetupData = {0};
+    CpaCySymStats64 symStats = {0};
+    /*
+     * In this simplified version of instance discovery, we discover
+     * exactly one instance of a crypto service.
+     */
+    sampleCyGetInstance(&cyInstHandle);
+    if (cyInstHandle == NULL)
+    {
+        PRINT_DBG("No crypto instances available\n");
+        return CPA_STATUS_FAIL;
+    }
+
+    /* Start Cryptographic component */
+    PRINT_DBG("cpaCyStartInstance\n");
+    status = cpaCyStartInstance(cyInstHandle);
+
+    if(CPA_STATUS_SUCCESS == status)
+    {
+      /*
+       * Set the address translation function for the instance
+       */
+       status = cpaCySetAddressTranslation(cyInstHandle, sampleVirtToPhys);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+       /*
+        * If the instance is polled start the polling thread. Note that
+        * how the polling is done is implementation-dependant.
+        */
+        sampleCyStartPolling(cyInstHandle);
+
+        PRINT_DBG("Encrypt-Generate ICV\n");
+
+        /* populate symmetric session data structure */
+        sessionSetupData.sessionPriority =  CPA_CY_PRIORITY_HIGH;
+//<snippet name="initSessionIPSecEnc">
+        sessionSetupData.symOperation = CPA_CY_SYM_OP_ALGORITHM_CHAINING;
+        sessionSetupData.algChainOrder =
+                                    CPA_CY_SYM_ALG_CHAIN_ORDER_CIPHER_THEN_HASH;
+
+        sessionSetupData.cipherSetupData.cipherAlgorithm =
+                                    CPA_CY_SYM_CIPHER_AES_CBC;
+        sessionSetupData.cipherSetupData.pCipherKey = sampleCipherKey;
+        sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                                    sizeof(sampleCipherKey);
+        sessionSetupData.cipherSetupData.cipherDirection =
+                                    CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+
+        sessionSetupData.hashSetupData.hashAlgorithm =  CPA_CY_SYM_HASH_SHA1;
+        sessionSetupData.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+        sessionSetupData.hashSetupData.digestResultLenInBytes = ICV_LENGTH;
+        sessionSetupData.hashSetupData.authModeSetupData.authKey = sampleAuthKey;
+        sessionSetupData.hashSetupData.authModeSetupData.authKeyLenInBytes =
+                                            sizeof(sampleAuthKey);
+
+        /* Even though ICV follows immediately after the region to hash
+           digestIsAppended is set to false in this case to workaround
+           errata number IXA00378322 */
+        sessionSetupData.digestIsAppended = CPA_FALSE;
+        /* Generate the ICV in outbound direction */
+        sessionSetupData.verifyDigest = CPA_FALSE;
+//</snippet>
+
+        /* Determine size of session context to allocate */
+        status = cpaCySymSessionCtxGetSize(cyInstHandle,
+                    &sessionSetupData, &sessionCtxSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Allocate session context */
+        status = PHYS_CONTIG_ALLOC(&sessionCtx, sessionCtxSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Initialize the session */
+        status = cpaCySymInitSession(cyInstHandle,
+                    symCallback, &sessionSetupData, sessionCtx);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        CpaStatus sessionStatus = CPA_STATUS_SUCCESS;
+
+        /* Perform algchaining operation */
+        status = algChainPerformOp(cyInstHandle, sessionCtx,
+                                               IPSEC_OUTBOUND_DIR);
+
+        /* Remove the session - session init has already succeeded */
+        sessionStatus = cpaCySymRemoveSession(
+                            cyInstHandle, sessionCtx);
+
+        /* maintain status of remove session only when status of all operations
+         * before it are successful. */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            status = sessionStatus;
+        }
+    }
+
+    if(CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("Decrypt-Verify ICV\n");
+
+        /* populate symmetric session data structure */
+        sessionSetupData.sessionPriority =  CPA_CY_PRIORITY_HIGH;
+//<snippet name="initSessionIPSecDec">
+        sessionSetupData.symOperation = CPA_CY_SYM_OP_ALGORITHM_CHAINING;
+        sessionSetupData.algChainOrder =
+                                    CPA_CY_SYM_ALG_CHAIN_ORDER_HASH_THEN_CIPHER;
+
+        sessionSetupData.cipherSetupData.cipherAlgorithm =
+                                    CPA_CY_SYM_CIPHER_AES_CBC;
+        sessionSetupData.cipherSetupData.pCipherKey = sampleCipherKey;
+        sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                                    sizeof(sampleCipherKey);
+        sessionSetupData.cipherSetupData.cipherDirection =
+                                    CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+
+        sessionSetupData.hashSetupData.hashAlgorithm =  CPA_CY_SYM_HASH_SHA1;
+        sessionSetupData.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+        sessionSetupData.hashSetupData.digestResultLenInBytes = ICV_LENGTH;
+        sessionSetupData.hashSetupData.authModeSetupData.authKey = sampleAuthKey;
+        sessionSetupData.hashSetupData.authModeSetupData.authKeyLenInBytes
+                                                         = sizeof(sampleAuthKey);
+
+        /* ICV follows immediately after the region to hash */
+        sessionSetupData.digestIsAppended = CPA_TRUE;
+        /* Verify the ICV in the inbound direction */
+        sessionSetupData.verifyDigest = CPA_TRUE;
+//</snippet>
+
+    }
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Initialize the session */
+        status = cpaCySymInitSession(cyInstHandle,
+                    symCallback, &sessionSetupData, sessionCtx);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        CpaStatus sessionStatus = CPA_STATUS_SUCCESS;
+
+        /* Perform algchaining operation */
+        status = algChainPerformOp(cyInstHandle, sessionCtx,
+                                                      IPSEC_INBOUND_DIR);
+
+        /* Remove the session - session init has already succeeded */
+        sessionStatus = cpaCySymRemoveSession(
+                            cyInstHandle, sessionCtx);
+
+        /* maintain status of remove session only when status of all operations
+         * before it are successful. */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            status = sessionStatus;
+        }
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Query symmetric statistics */
+        status = cpaCySymQueryStats64(cyInstHandle, &symStats);
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymQueryStats failed, status = %d\n", status);
+        }
+        else
+        {
+            PRINT_DBG("Number of symmetric operations completed: %llu\n",
+                    (unsigned long long)symStats.numSymOpCompleted);
+        }
+    }
+
+    /* Clean up */
+
+    /* Free session Context */
+    PHYS_CONTIG_FREE(sessionCtx);
+
+    /* Stop the polling thread */
+    sampleCyStopPolling();
+
+
+    PRINT_DBG("cpaCyStopInstance\n");
+    cpaCyStopInstance(cyInstHandle);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("Sample code ran successfully\n");
+    }
+    else
+    {
+        PRINT_DBG("Sample code failed with status of %d\n", status);
+    }
+
+    return status;
+}
+
+/* source data to hash */
+static Cpa8U vectorData[] = {
+        0x37
+};
+
+/*
+ * Perform a hash operation
+ */
+static CpaStatus
+hashPerformOp(CpaInstanceHandle cyInstHandle, CpaCySymSessionCtx sessionCtx)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    Cpa8U  *pBufferMeta = NULL;
+    Cpa32U bufferMetaSize = 0;
+    CpaBufferList *pBufferList = NULL;
+    CpaFlatBuffer *pFlatBuffer = NULL;
+    CpaCySymOpData *pOpData = NULL;
+    Cpa32U bufferSize = sizeof(vectorData) + DIGEST_SIZE;
+    Cpa32U numBuffers = 1;  /* only using 1 buffer in this case */
+    /* allocate memory for bufferlist and array of flat buffers in a contiguous
+     * area and carve it up to reduce number of memory allocations required. */
+    Cpa32U bufferListMemSize = sizeof(CpaBufferList) +
+        (numBuffers * sizeof(CpaFlatBuffer));
+    Cpa8U  *pSrcBuffer = NULL;
+    Cpa8U  *pDigestBuffer = NULL;
+
+    /* The following variables are allocated on the stack because we block
+     * until the callback comes back. If a non-blocking approach was to be
+     * used then these variables should be dynamically allocated */
+    struct COMPLETION_STRUCT complete;
+
+    /* get meta information size */
+    PRINT_DBG("cpaCyBufferListGetMetaSize\n");
+    status = cpaCyBufferListGetMetaSize( cyInstHandle,
+                numBuffers, &bufferMetaSize);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pBufferMeta, bufferMetaSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = OS_MALLOC(&pBufferList, bufferListMemSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pSrcBuffer, bufferSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* copy vector into buffer */
+        memcpy(pSrcBuffer, vectorData, sizeof(vectorData));
+
+        pDigestBuffer = pSrcBuffer + sizeof(vectorData);
+        /* increment by sizeof(CpaBufferList) to get at the
+         * array of flatbuffers */
+        pFlatBuffer = (CpaFlatBuffer *) (pBufferList + 1);
+
+        pBufferList->pBuffers = pFlatBuffer;
+        pBufferList->numBuffers = 1;
+        pBufferList->pPrivateMetaData = pBufferMeta;
+
+        pFlatBuffer->dataLenInBytes = bufferSize;
+        pFlatBuffer->pData = pSrcBuffer;
+
+        status = OS_MALLOC(&pOpData, sizeof(CpaCySymOpData));
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+//<snippet name="opData">
+        pOpData->sessionCtx = sessionCtx;
+        pOpData->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+        pOpData->hashStartSrcOffsetInBytes = 0;
+        pOpData->messageLenToHashInBytes = sizeof(vectorData);
+        pOpData->pDigestResult = pDigestBuffer;
+//</snippet>
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /** initialisation for callback; the "complete" variable is used by the
+         * callback function to indicate it has been called*/
+        COMPLETION_INIT((&complete));
+
+        PRINT_DBG("cpaCySymPerformOp\n");
+
+        /** Perform symmetric operation */
+        status = cpaCySymPerformOp(cyInstHandle,
+                (void *)&complete, /* data sent as is to the callback function*/
+                pOpData,           /* operational data struct */
+                pBufferList,       /* source buffer list */
+                pBufferList,       /* same src & dst for an in-place operation*/
+                NULL);
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymPerformOp failed. (status = %d)\n", status);
+        }
+
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            /** wait until the completion of the operation*/
+            if (!COMPLETION_WAIT((&complete), TIMEOUT_MS))
+            {
+                PRINT_ERR("timeout or interruption in cpaCySymPerformOp\n");
+                status = CPA_STATUS_FAIL;
+            }
+        }
+
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            int j;
+            for (j = 0; j < DIGEST_SIZE; j++)
+            printf("%02X", pOpData->pDigestResult[j]);
+            printf("\n");
+        }
+    }
+
+    /* At this stage, the callback function should have returned,
+     * so it is safe to free the memory */
+    PHYS_CONTIG_FREE(pSrcBuffer);
+    OS_FREE(pBufferList);
+    PHYS_CONTIG_FREE(pBufferMeta);
+    OS_FREE(pOpData);
+
+    COMPLETION_DESTROY(&complete);
+
+    return status;
+}
+
+/*
+ * This is the main entry point for the sample cipher code.  It
+ * demonstrates the sequence of calls to be made to the API in order
+ * to create a session, perform one or more hash operations, and
+ * then tear down the session.
+ */
+CpaStatus
+hashSample(void)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    Cpa32U sessionCtxSize = 0;
+    CpaInstanceHandle cyInstHandle = NULL;
+    CpaCySymSessionCtx sessionCtx = NULL;
+    CpaCySymSessionSetupData sessionSetupData = {0};
+    CpaCySymStats64 symStats = {0};
+
+    switch (DIGEST_SIZE) {
+    case 20: DIGEST_TYPE = CPA_CY_SYM_HASH_SHA1;   break;
+    case 32: DIGEST_TYPE = CPA_CY_SYM_HASH_SHA256; break;
+    case 48: DIGEST_TYPE = CPA_CY_SYM_HASH_SHA384; break;
+    case 64: DIGEST_TYPE = CPA_CY_SYM_HASH_SHA512; break;
+    default: return        CPA_STATUS_FAIL;
+    }
+
+    /*
+     * In this simplified version of instance discovery, we discover
+     * exactly one instance of a crypto service.
+     */
+    sampleCyGetInstance(&cyInstHandle);
+    if (cyInstHandle == NULL)
+    {
+        return CPA_STATUS_FAIL;
+    }
+
+    /* Start Cryptographic component */
+    PRINT_DBG("cpaCyStartInstance\n");
+    status = cpaCyStartInstance(cyInstHandle);
+
+    if(CPA_STATUS_SUCCESS == status)
+    {
+       /*
+        * Set the address translation function for the instance
+        */
+        status = cpaCySetAddressTranslation(cyInstHandle, sampleVirtToPhys);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+       /*
+        * If the instance is polled start the polling thread. Note that
+        * how the polling is done is implementation-dependant.
+        */
+        sampleCyStartPolling(cyInstHandle);
+
+       /*
+        * We now populate the fields of the session operational data and create
+        * the session.  Note that the size required to store a session is
+        * implementation-dependent, so we query the API first to determine how
+        * much memory to allocate, and then allocate that memory.
+        */
+//<snippet name="initSession">
+        /* populate symmetric session data structure
+         * for a plain hash operation */
+        sessionSetupData.sessionPriority = CPA_CY_PRIORITY_NORMAL;
+        sessionSetupData.symOperation = CPA_CY_SYM_OP_HASH;
+        sessionSetupData.hashSetupData.hashAlgorithm = DIGEST_TYPE;
+        sessionSetupData.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_PLAIN;
+        sessionSetupData.hashSetupData.digestResultLenInBytes = DIGEST_SIZE;
+        /* Place the digest result in a buffer unrelated to srcBuffer */
+        sessionSetupData.digestIsAppended = CPA_FALSE;
+        /* Generate the digest */
+        sessionSetupData.verifyDigest = CPA_FALSE;
+//</snippet>
+
+        /* Determine size of session context to allocate */
+        PRINT_DBG("cpaCySymSessionCtxGetSize\n");
+        status = cpaCySymSessionCtxGetSize(cyInstHandle,
+                    &sessionSetupData, &sessionCtxSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Allocate session context */
+        status = PHYS_CONTIG_ALLOC(&sessionCtx, sessionCtxSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Initialize the Hash session */
+        PRINT_DBG("cpaCySymInitSession\n");
+        status = cpaCySymInitSession(cyInstHandle,
+                    symCallback, &sessionSetupData, sessionCtx);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        CpaStatus sessionStatus = CPA_STATUS_SUCCESS;
+
+        /* Perform Hash operation */
+        status = hashPerformOp(cyInstHandle, sessionCtx);
+
+        /* Remove the session - session init has already succeeded */
+        PRINT_DBG("cpaCySymRemoveSession\n");
+        sessionStatus = cpaCySymRemoveSession(
+                            cyInstHandle, sessionCtx);
+
+        /* maintain status of remove session only when status of all operations
+         * before it are successful. */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            status = sessionStatus;
+        }
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Query symmetric statistics */
+        status = cpaCySymQueryStats64(cyInstHandle, &symStats);
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymQueryStats failed, status = %d\n", status);
+        }
+        else
+        {
+            PRINT_DBG("Number of symmetric operation completed: %llu\n",
+                    (unsigned long long)symStats.numSymOpCompleted);
+        }
+    }
+
+    /* Clean up */
+
+    /* Free session Context */
+    PHYS_CONTIG_FREE(sessionCtx);
+
+    /* Stop the polling thread */
+    sampleCyStopPolling();
+
+    PRINT_DBG("cpaCyStopInstance\n");
+    cpaCyStopInstance(cyInstHandle);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("Sample code ran successfully\n");
+    }
+    else
+    {
+        PRINT_DBG("Sample code failed with status of %d\n", status);
+    }
+
+    return status;
+}
+
+/* Source data to encrypt */
+static Cpa8U sampleCipherSrc[] = {
+        0xD7,0x1B,0xA4,0xCA,0xEC,0xBD,0x15,0xE2,0x52,0x6A,0x21,0x0B,
+        0x81,0x77,0x0C,0x90,0x68,0xF6,0x86,0x50,0xC6,0x2C,0x6E,0xED,
+        0x2F,0x68,0x39,0x71,0x75,0x1D,0x94,0xF9,0x0B,0x21,0x39,0x06,
+        0xBE,0x20,0x94,0xC3,0x43,0x4F,0x92,0xC9,0x07,0xAA,0xFE,0x7F,
+        0xCF,0x05,0x28,0x6B,0x82,0xC4,0xD7,0x5E,0xF3,0xC7,0x74,0x68,
+        0xCF,0x05,0x28,0x6B,0x82,0xC4,0xD7,0x5E,0xF3,0xC7,0x74,0x68,
+        0x80,0x8B,0x28,0x8D,0xCD,0xCA,0x94,0xB8,0xF5,0x66,0x0C,0x00,
+        0x5C,0x69,0xFC,0xE8,0x7F,0x0D,0x81,0x97,0x48,0xC3,0x6D,0x24
+};
+
+/*
+ * This function performs a cipher operation.
+ */
+static CpaStatus
+cipherPerformOp(CpaInstanceHandle cyInstHandle, CpaCySymSessionCtx sessionCtx)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    Cpa8U  *pBufferMeta = NULL;
+    Cpa32U bufferMetaSize = 0;
+    CpaBufferList *pBufferList = NULL;
+    CpaFlatBuffer *pFlatBuffer = NULL;
+    CpaCySymOpData *pOpData = NULL;
+    Cpa32U bufferSize = sizeof(sampleCipherSrc);
+    Cpa32U numBuffers = 1;  /* only using 1 buffer in this case */
+    /* allocate memory for bufferlist and array of flat buffers in a contiguous
+     * area and carve it up to reduce number of memory allocations required. */
+    Cpa32U bufferListMemSize = sizeof(CpaBufferList) +
+        (numBuffers * sizeof(CpaFlatBuffer));
+    Cpa8U *pSrcBuffer = NULL;
+    Cpa8U  *pIvBuffer = NULL;
+
+    /* The following variables are allocated on the stack because we block
+     * until the callback comes back. If a non-blocking approach was to be
+     * used then these variables should be dynamically allocated */
+    struct COMPLETION_STRUCT complete;
+
+    PRINT_DBG("cpaCyBufferListGetMetaSize\n");
+
+    /*
+     * Different implementations of the API require different
+     * amounts of space to store meta-data associated with buffer
+     * lists.  We query the API to find out how much space the current
+     * implementation needs, and then allocate space for the buffer
+     * meta data, the buffer list, and for the buffer itself.  We also
+     * allocate memory for the initialization vector.  We then
+     * populate this memory with the required data.
+     */
+//<snippet name="memAlloc">
+    status = cpaCyBufferListGetMetaSize( cyInstHandle,
+                numBuffers, &bufferMetaSize);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pBufferMeta, bufferMetaSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = OS_MALLOC(&pBufferList, bufferListMemSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pSrcBuffer, bufferSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pIvBuffer, sizeof(sampleCipherIv));
+    }
+//</snippet>
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* copy source into buffer */
+        memcpy(pSrcBuffer, sampleCipherSrc, sizeof(sampleCipherSrc));
+
+        /* copy IV into buffer */
+        memcpy(pIvBuffer, sampleCipherIv, sizeof(sampleCipherIv));
+
+        /* increment by sizeof(CpaBufferList) to get at the
+         * array of flatbuffers */
+        pFlatBuffer = (CpaFlatBuffer *) (pBufferList + 1);
+
+        pBufferList->pBuffers = pFlatBuffer;
+        pBufferList->numBuffers = 1;
+        pBufferList->pPrivateMetaData = pBufferMeta;
+
+        pFlatBuffer->dataLenInBytes = bufferSize;
+        pFlatBuffer->pData = pSrcBuffer;
+
+        status = OS_MALLOC(&pOpData, sizeof(CpaCySymOpData));
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /*
+         * Populate the structure containing the operational data needed
+         * to run the algorithm:
+         * - packet type information (the algorithm can operate on a full
+         *   packet, perform a partial operation and maintain the state or
+         *   complete the last part of a multi-part operation)
+         * - the initialization vector and its length
+         * - the offset in the source buffer
+         * - the length of the source message
+         */
+//<snippet name="opData">
+        pOpData->sessionCtx = sessionCtx;
+        pOpData->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+        pOpData->pIv = pIvBuffer;
+        pOpData->ivLenInBytes = sizeof(sampleCipherIv);
+        pOpData->cryptoStartSrcOffsetInBytes = 0;
+        pOpData->messageLenToCipherInBytes = sizeof(sampleCipherSrc);
+//</snippet>
+    }
+
+    /*
+     * Now, we initialize the completion variable which is used by the callback function
+     * to indicate that the operation is complete.  We then perform the operation.
+     */
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("cpaCySymPerformOp\n");
+
+//<snippet name="perfOp">
+        COMPLETION_INIT(&complete);
+
+        status = cpaCySymPerformOp(cyInstHandle,
+                (void *)&complete, /* data sent as is to the callback function*/
+                pOpData,           /* operational data struct */
+                pBufferList,       /* source buffer list */
+                pBufferList,       /* same src & dst for an in-place operation*/
+                NULL);
+//</snippet>
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymPerformOp failed. (status = %d)\n", status);
+        }
+
+        /*
+         * We now wait until the completion of the operation.  This uses a macro
+         * which can be defined differently for different OSes.
+         */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+//<snippet name="completion">
+            if (!COMPLETION_WAIT(&complete, TIMEOUT_MS))
+            {
+                PRINT_ERR("timeout or interruption in cpaCySymPerformOp\n");
+                status = CPA_STATUS_FAIL;
+            }
+//</snippet>
+        }
+
+        /*
+         * We now check that the output matches the expected output.
+         */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            if (0 == memcmp(pSrcBuffer, expectedOutput, bufferSize))
+            {
+                PRINT_DBG("Output matches expected output\n");
+            }
+            else
+            {
+                PRINT_DBG("Output does not match expected output\n");
+                status = CPA_STATUS_FAIL;
+            }
+        }
+    }
+
+    /*
+     * At this stage, the callback function has returned, so it is
+     * sure that the structures won't be needed any more.  Free the
+     * memory!
+     */
+    PHYS_CONTIG_FREE(pSrcBuffer);
+    PHYS_CONTIG_FREE(pIvBuffer);
+    OS_FREE(pBufferList);
+    PHYS_CONTIG_FREE(pBufferMeta);
+    OS_FREE(pOpData);
+
+    COMPLETION_DESTROY(&complete);
+
+    return status;
+}
+
+/*
+ * This is the main entry point for the sample cipher code.  It
+ * demonstrates the sequence of calls to be made to the API in order
+ * to create a session, perform one or more cipher operations, and
+ * then tear down the session.
+ */
+CpaStatus
+cipherSample(void)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    Cpa32U sessionCtxSize = 0;
+    CpaCySymSessionCtx sessionCtx = NULL;
+    CpaInstanceHandle cyInstHandle = NULL;
+    CpaCySymSessionSetupData sessionSetupData = {0};
+    CpaCySymStats64 symStats = {0};
+
+    /*
+     * In this simplified version of instance discovery, we discover
+     * exactly one instance of a crypto service.
+     */
+    sampleCyGetInstance(&cyInstHandle);
+    if (cyInstHandle == NULL)
+    {
+        return CPA_STATUS_FAIL;
+    }
+
+    /* Start Cryptographic component */
+    PRINT_DBG("cpaCyStartInstance\n");
+//<snippet name="startup">
+    status = cpaCyStartInstance(cyInstHandle);
+//</snippet>
+
+    if(CPA_STATUS_SUCCESS == status)
+    {
+       /*
+        * Set the address translation function for the instance
+        */
+//<snippet name="virt2phys">
+        status = cpaCySetAddressTranslation(cyInstHandle, sampleVirtToPhys);
+//</snippet>
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+       /*
+        * If the instance is polled start the polling thread. Note that
+        * how the polling is done is implementation-dependant.
+        */
+       sampleCyStartPolling(cyInstHandle);
+
+       /*
+        * We now populate the fields of the session operational data and create
+        * the session.  Note that the size required to store a session is
+        * implementation-dependent, so we query the API first to determine how
+        * much memory to allocate, and then allocate that memory.
+        */
+//<snippet name="initSession">
+        /* Populate the session setup structure for the operation required */
+        sessionSetupData.sessionPriority =  CPA_CY_PRIORITY_NORMAL;
+        sessionSetupData.symOperation =     CPA_CY_SYM_OP_CIPHER;
+        sessionSetupData.cipherSetupData.cipherAlgorithm =
+                                            CPA_CY_SYM_CIPHER_3DES_CBC;
+        sessionSetupData.cipherSetupData.pCipherKey =
+                                            sampleCipherKey;
+        sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                                            sizeof(sampleCipherKey);
+        sessionSetupData.cipherSetupData.cipherDirection =
+                                            CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+
+        /* Determine size of session context to allocate */
+        PRINT_DBG("cpaCySymSessionCtxGetSize\n");
+        status = cpaCySymSessionCtxGetSize(cyInstHandle,
+                    &sessionSetupData, &sessionCtxSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Allocate session context */
+        status = PHYS_CONTIG_ALLOC(&sessionCtx, sessionCtxSize);
+    }
+
+
+    /* Initialize the Cipher session */
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("cpaCySymInitSession\n");
+        status = cpaCySymInitSession(cyInstHandle,
+                            symCallback,        /* callback function */
+                            &sessionSetupData,  /* session setup data */
+                            sessionCtx);       /* output of the function*/
+    }
+//</snippet>
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        CpaStatus sessionStatus = CPA_STATUS_SUCCESS;
+
+        /* Perform Cipher operation */
+        status = cipherPerformOp(cyInstHandle, sessionCtx);
+
+        /*
+         * In a typical usage, the session might be used to encipher
+         * or decipher multiple buffers.  In this example however, we
+         * can now tear down the session.
+         */
+        PRINT_DBG("cpaCySymRemoveSession\n");
+//<snippet name="removeSession">
+        sessionStatus = cpaCySymRemoveSession(
+                cyInstHandle, sessionCtx);
+//</snippet>
+
+        /* Maintain status of remove session only when status of all operations
+         * before it are successful. */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            status = sessionStatus;
+        }
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /*
+         * We can now query the statistics on the instance.
+         *
+         * Note that some implementations may also make the stats
+         * available through other mechanisms, e.g. in the /proc
+         * virtual filesystem.
+         */
+        status = cpaCySymQueryStats64(cyInstHandle, &symStats);
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymQueryStats64 failed, status = %d\n", status);
+        }
+        else
+        {
+            PRINT_DBG("Number of symmetric operation completed: %llu\n",
+                    (unsigned long long)symStats.numSymOpCompleted);
+        }
+    }
+
+    /*
+     * Free up memory, stop the instance, etc.
+     */
+
+    /* Free session Context */
+    PHYS_CONTIG_FREE(sessionCtx);
+
+    /* Stop the polling thread */
+    sampleCyStopPolling();
+
+    PRINT_DBG("cpaCyStopInstance\n");
+    cpaCyStopInstance(cyInstHandle);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("Sample code ran successfully\n");
+    }
+    else
+    {
+        PRINT_DBG("Sample code failed with status of %d\n", status);
+    }
+
+    return status;
+}
--- cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.0.3-42/quickassist/lookaside/access_layer/src/sample_code/functional/sym/wg_fips/Makefile	2022-05-09 13:48:22.528986907 -0700
@@ -0,0 +1,59 @@
+#########################################################################
+#  
+# @par
+#   BSD LICENSE
+# 
+#   Copyright(c) 2007-2016 Intel Corporation. All rights reserved.
+#   All rights reserved.
+# 
+#   Redistribution and use in source and binary forms, with or without 
+#   modification, are permitted provided that the following conditions 
+#   are met:
+# 
+#     * Redistributions of source code must retain the above copyright 
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright 
+#       notice, this list of conditions and the following disclaimer in 
+#       the documentation and/or other materials provided with the 
+#       distribution.
+#     * Neither the name of Intel Corporation nor the names of its 
+#       contributors may be used to endorse or promote products derived 
+#       from this software without specific prior written permission.
+# 
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+#  version: QAT1.7.Upstream.L.1.0.3-42
+############################################################################
+
+include $(PWD)/../../common.mk
+#Add the name for the executable, Library or Module output definitions
+OUTPUT_NAME=wg_fips
+ifeq ($(ICP_OS_LEVEL),user_space)
+#############################################################
+#
+# Build user space executible
+#
+############################################################
+USER_SOURCE_FILES += ../../common/cpa_sample_utils.c wg_fips.c
+USER_SOURCE_FILES += wg_fips_main.c
+
+else
+#############################################################
+#
+# Build kernel space module
+#
+############################################################
+obj-m := $(OUTPUT_NAME).o
+$(OUTPUT_NAME)-objs := ../../common/cpa_sample_utils.o \
+	wg_fips.o wg_fips_linux_kernel_module.o
+endif
