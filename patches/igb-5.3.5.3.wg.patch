WatchGuard patches to sources for igb-5.3.5.3 as of
Mon May  9 13:54:14 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- igb-5.3.5.3/src/e1000_phy.c.orig	2022-05-09 13:54:13.478745596 -0700
+++ igb-5.3.5.3/src/e1000_phy.c	2022-05-09 13:54:13.518743974 -0700
@@ -247,6 +247,1343 @@
 	return hw->phy.ops.write_reg(hw, M88E1000_PHY_GEN_CONTROL, 0);
 }
 
+#ifdef	CONFIG_WG_ARCH_X86 // WG:JB Marvell 98DX3035 init code
+
+struct	mvl98dx3035_init_desc {
+	u32 offset;
+	u32 val;
+};
+
+struct	mvl98dx3035_init_desc dx3035[] = {
+	// Disable switch
+	{0x00000058 , 0x04104002},
+	// Prefer Master, SMI1 AutoNeg preformed.
+	{0x04004034 , 0x00000140},
+	{0x05004034 , 0x00000140},
+	// set SMI0 fast_mdc to div/64
+	{0x04004200 , 0x000B0000},
+	// set SMI1 fast_mdc to div/64
+	{0x05004200 , 0x00030000},
+	// set PHY polling address 88E1680 0x0~0xF, 0x10~0x17
+	{0x04004030 , 0x0A418820},
+	{0x04804030 , 0x16A4A0E6},
+	{0x05004030 , 0x2307B9AC},
+	{0x05804030 , 0x2F6AD272},
+	// Pipe0 access DFX Setting- Pipe Select
+	{0x308F8004 , 0x00000001},
+	// PCL TCAM-DFX Setting
+	{0x30804050 , 0x00020003},
+	// RTR TCAM-DFX Setting
+	{0x3080C050 , 0x00020003},
+	// changed in xCat2, GPP PAD control
+	{0x008F8304 , 0x00000048},
+	// changed in xCat2, SSMII PAD control
+	{0x008F8314 , 0x00000048},
+	// changed in xCat2, RGMII PAD control
+	{0x008F8310 , 0x00000048},
+	// changed in xCat2, LED PAD control       
+	{0x008F8300 , 0x00000048},
+	// disable PECL receiver and common_0_PECL_EN=CMOS
+	{0x0000009C , 0x061B0CC3},
+	// Set Extended Control Register - TTPan: SGMII 2.5G bit22 & bit14 = 1 -> Org=0x00807405 New=0x00C07405
+	{0x0000005C , 0x00807405},
+	// Disable SSMII CLK
+	{0x00000028 , 0x2000000},
+	{0x00000028 , 0x2000000},
+	// Start QSGMII Initial
+	// Power up 5G SERDESs
+	// Set SERDES ref clock register
+	{0x09800000 , 0x00003E80},
+	{0x09800400 , 0x00003E80},
+	{0x09801000 , 0x00003E80},
+	{0x09801400 , 0x00003E80},
+	{0x09802000 , 0x00003E80},
+	{0x09802400 , 0x00003E80},
+	// Wait 10mSec,
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Deactivate sd_reset
+	{0x09800004 , 0x00000008},
+	{0x09800404 , 0x00000008},
+	{0x09801004 , 0x00000008},
+	{0x09801404 , 0x00000008},
+	{0x09802004 , 0x00000008},
+	{0x09802404 , 0x00000008},
+	// Wait for Calibration done (0x09800008 bit 3)
+	// Wait 10mSec,
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Reference Ferquency select = 62.5MHz ; Use registers bits to control speed configuration      
+	{0x0980020C , 0x0000800A},
+	{0x0980060C , 0x0000800A},
+	{0x0980120C , 0x0000800A},
+	{0x0980160C , 0x0000800A},
+	{0x0980220C , 0x0000800A},
+	{0x0980260C , 0x0000800A},
+	// Transmitter/Reciver Divider force, interpulator force; 1.25G: intpi = 25uA , VCO divided by 4 ; 2.5G: intpi = 25uA , VCO divided by 2  ; 3.125G: intpi = 30uA , VCO divided by 2 ; 3.75G: intpi = 20uA , VCO not divided; 6.25G: intpi = 30uA , VCO not divided; 5.15G: intpi = 25uA , VCO not divided
+	{0x09800210 , 0x00004414},
+	{0x09800610 , 0x00004414},
+	{0x09801210 , 0x00004414},
+	{0x09801610 , 0x00004414},
+	{0x09802210 , 0x00004414},
+	{0x09802610 , 0x00004414},
+	// Force FbDiv/RfDiv
+	{0x09800214 , 0x0000A150},
+	{0x09800614 , 0x0000A150},
+	{0x09801214 , 0x0000A150},
+	{0x09801614 , 0x0000A150},
+	{0x09802214 , 0x0000A150},
+	{0x09802614 , 0x0000A150},
+	// Force: PLL Speed, sel_v2i, loadcap_pll,sel_fplres
+	{0x09800218 , 0x0000BAAB},
+	{0x09800618 , 0x0000BAAB},
+	{0x09801218 , 0x0000BAAB},
+	{0x09801618 , 0x0000BAAB},
+	{0x09802218 , 0x0000BAAB},
+	{0x09802618 , 0x0000BAAB},
+	// icp force
+	{0x0980021C , 0x0000882C},
+	{0x0980061C , 0x0000882C},
+	{0x0980121C , 0x0000882C},
+	{0x0980161C , 0x0000882C},
+	{0x0980221C , 0x0000882C},
+	{0x0980261C , 0x0000882C},
+	//  0 = kvco-2
+	{0x098003CC , 0x00002000},
+	{0x098007CC , 0x00002000},
+	{0x098013CC , 0x00002000},
+	{0x098017CC , 0x00002000},
+	{0x098023CC , 0x00002000},
+	{0x098027CC , 0x00002000},
+	// External TX/Rx Impedance changed from 6 to 0 while auto calibration results are used  - based on lab measurments it seems that we need to force the auto imedance calibration values
+	{0x0980022C , 0x00000000},
+	{0x0980062C , 0x00000000},
+	{0x0980122C , 0x00000000},
+	{0x0980162C , 0x00000000},
+	{0x0980222C , 0x00000000},
+	{0x0980262C , 0x00000000},
+	// Auto KVCO,  PLL is not forced to max speed during power up sequence - 
+	{0x09800230 , 0x00000000},
+	{0x09800630 , 0x00000000},
+	{0x09801230 , 0x00000000},
+	{0x09801630 , 0x00000000},
+	{0x09802230 , 0x00000000},
+	{0x09802630 , 0x00000000},
+	// Sampler OS Scale was changed from 5mV/Step to 3.3mV/Step; RX_IMP_VTHIMCAL was chnge from 3 to 0
+	{0x09800234 , 0x00004000},
+	{0x09800634 , 0x00004000},
+	{0x09801234 , 0x00004000},
+	{0x09801634 , 0x00004000},
+	{0x09802234 , 0x00004000},
+	{0x09802634 , 0x00004000},
+	// Use value wiritten to register for process calibration instead of th eauto calibration; Select process from register
+	{0x0980023C , 0x00000018},
+	{0x0980063C , 0x00000018},
+	{0x0980123C , 0x00000018},
+	{0x0980163C , 0x00000018},
+	{0x0980223C , 0x00000018},
+	{0x0980263C, 0x00000018},
+	// DCC should be dissabled at baud 3.125 and below = 8060
+	{0x09800250 , 0x0000A0C0},
+	{0x09800650 , 0x0000A0C0},
+	{0x09801250 , 0x0000A0C0},
+	{0x09801650 , 0x0000A0C0},
+	{0x09802250 , 0x0000A0C0},
+	{0x09802650 , 0x0000A0C0},
+	// Wait 10mSec,
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// DCC should be dissabled at baud 3.125 and below = 8060
+	{0x09800250 , 0x0000A060},
+	{0x09800650 , 0x0000A060},
+	{0x09801250 , 0x0000A060},
+	{0x09801650 , 0x0000A060},
+	{0x09802250 , 0x0000A060},
+	{0x09802650 , 0x0000A060},
+	// PE Setting
+	{0x09800254 , 0x00007F2D},
+	{0x09800654 , 0x00007F2D},
+	{0x09801254 , 0x00007F2D},
+	{0x09801654 , 0x00007F2D},
+	{0x09802254 , 0x00007F2D},
+	{0x09802654 , 0x00007F2D},
+	// PE Type
+	{0x09800258 , 0x00000100},
+	{0x09800658 , 0x00000100},
+	{0x09801258 , 0x00000100},
+	{0x09801658 , 0x00000100},
+	{0x09802258 , 0x00000100},
+	{0x09802658 , 0x00000100},
+	// selmupi/mupf - low value for lower baud
+	{0x0980027C , 0x000090AA},
+	{0x0980067C , 0x000090AA},
+	{0x0980127C , 0x000090AA},
+	{0x0980167C , 0x000090AA},
+	{0x0980227C , 0x000090AA},
+	{0x0980267C , 0x000090AA},
+	// DTL_FLOOP_EN = Dis
+	{0x09800280 , 0x00000800},
+	{0x09800680 , 0x00000800},
+	{0x09801280 , 0x00000800},
+	{0x09801680 , 0x00000800},
+	{0x09802280 , 0x00000800},
+	{0x09802680 , 0x00000800},
+	// FFE Setting DB 24G is 0x363
+	{0x0980028C , 0x00000377},
+	{0x0980068C , 0x00000377},
+	{0x0980128C , 0x00000377},
+	{0x0980168C , 0x00000377},
+	{0x0980228C , 0x00000377},
+	{0x0980268C , 0x00000377},
+	// Slicer Enable; Tx  Imp was changed from 50ohm to 43ohm
+	{0x0980035C , 0x0000423F},
+	{0x0980075C , 0x0000423F},
+	{0x0980135C , 0x0000423F},
+	{0x0980175C , 0x0000423F},
+	{0x0980235C , 0x0000423F},
+	{0x0980275C , 0x0000423F},
+	// Not need to be configure - Same as default 
+	{0x09800364 , 0x00005555},
+	{0x09800764 , 0x00005555},
+	{0x09801364 , 0x00005555},
+	{0x09801764 , 0x00005555},
+	{0x09802364 , 0x00005555},
+	{0x09802764 , 0x00005555},
+	// Disable ana_clk_det
+	{0x0980036C , 0x00000000},
+	{0x0980076C , 0x00000000},
+	{0x0980136C , 0x00000000},
+	{0x0980176C , 0x00000000},
+	{0x0980236C , 0x00000000},
+	{0x0980276C , 0x00000000},
+	// Configure rx_imp_vthimpcal to 0x0 (default value = 0x3); Configure Sampler_os_scale to 3.3mV/step (default value = 5mV/step)
+	{0x09800234 , 0x00004000},
+	{0x09800634 , 0x00004000},
+	{0x09801234 , 0x00004000},
+	{0x09801634 , 0x00004000},
+	{0x09802234 , 0x00004000},
+	{0x09802634 , 0x00004000},
+	// Configure IMP_VTHIMPCAL to 56.7ohm (default value = 53.3 ohm); Configure cal_os_ph_rd to 0x60 (default value = 0x0); Configure Cal_rxclkalign90_ext to use an external ovride value
+	{0x09800228 , 0x0000DAC0},
+	{0x09800628 , 0x0000DAC0},
+	{0x09801228 , 0x0000DAC0},
+	{0x09801628 , 0x0000DAC0},
+	{0x09802228 , 0x0000DAC0},
+	{0x09802628 , 0x0000DAC0},
+	// Reset dtl_rx ; Enable ana_clk_det
+	{0x0980036C , 0x00008040},
+	{0x0980076C , 0x00008040},
+	{0x0980136C , 0x00008040},
+	{0x0980176C , 0x00008040},
+	{0x0980236C , 0x00008040},
+	{0x0980276C , 0x00008040},
+	// Un reset dtl_rx
+	{0x0980036C , 0x00008000},
+	{0x0980076C , 0x00008000},
+	{0x0980136C , 0x00008000},
+	{0x0980176C , 0x00008000},
+	{0x0980236C , 0x00008000},
+	{0x0980276C , 0x00008000},
+	// Wait 10mSec,
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// ?
+	{0x09800224 , 0x00000000},
+	{0x09800624 , 0x00000000},
+	{0x09801224 , 0x00000000},
+	{0x09801624 , 0x00000000},
+	{0x09802224 , 0x00000000},
+	{0x09802624 , 0x00000000},
+	// CAL Start
+	{0x09800224 , 0x00008000},
+	{0x09800624 , 0x00008000},
+	{0x09801224 , 0x00008000},
+	{0x09801624 , 0x00008000},
+	{0x09802224 , 0x00008000},
+	{0x09802624 , 0x00008000},
+	{0x09800224 , 0x00000000},
+	{0x09800624 , 0x00000000},
+	{0x09801224 , 0x00000000},
+	{0x09801624 , 0x00000000},
+	{0x09802224 , 0x00000000},
+	{0x09802624 , 0x00000000},
+	// Wait for RxClk_x2
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Set RxInit to 0x1 (remember that bit 3 is already set to 0x1)
+	{0x09800004 , 0x00000018},
+	{0x09800404 , 0x00000018},
+	{0x09801004 , 0x00000018},
+	{0x09801404 , 0x00000018},
+	{0x09802004 , 0x00000018},
+	{0x09802404 , 0x00000018},
+	// Wait for p_clk = 1 and p_clk = 0
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Set RxInit to 0x0
+	{0x09800004 , 0x00000008},
+	{0x09800404 , 0x00000008},
+	{0x09801004 , 0x00000008},
+	{0x09801404 , 0x00000008},
+	{0x09802004 , 0x00000008},
+	{0x09802404 , 0x00000008},
+	// Wait for ALL PHY_RDY = 1 (0x09800008 bit 0)
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// ?
+	{0x09800004 , 0x00000028},
+	{0x09800404 , 0x00000028},
+	{0x09801004 , 0x00000028},
+	{0x09801404 , 0x00000028},
+	{0x09802004 , 0x00000028},
+	{0x09802404 , 0x00000028},
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// MAC control
+	{0x0a800000 , 0x0000c801},
+	{0x0a800400 , 0x0000c801},
+	{0x0a800800 , 0x0000c801},
+	{0x0a800c00 , 0x0000c801},
+	{0x0a801000 , 0x0000c801},
+	{0x0a801400 , 0x0000c801},
+	{0x0a801800 , 0x0000c801},
+	{0x0a801c00 , 0x0000c801},
+	{0x0a802000 , 0x0000c801},
+	{0x0a802400 , 0x0000c801},
+	{0x0a802800 , 0x0000c801},
+	{0x0a802c00 , 0x0000c801},
+	{0x0a803000 , 0x0000c801},
+	{0x0a803400 , 0x0000c801},
+	{0x0a803800 , 0x0000c801},
+	{0x0a803c00 , 0x0000c801},
+	{0x0a804000 , 0x0000c801},
+	{0x0a804400 , 0x0000c801},
+	{0x0a804800 , 0x0000c801},
+	{0x0a804c00 , 0x0000c801},
+	{0x0a805000 , 0x0000c801},
+	{0x0a805400 , 0x0000c801},
+	{0x0a805800 , 0x0000c801},
+	{0x0a805c00 , 0x0000c801},
+	//?
+	{0x0A800008 , 0x0000C008},
+	{0x0A801008 , 0x0000C008},
+	{0x0A802008 , 0x0000C008},
+	{0x0A803008 , 0x0000C008},
+	{0x0A804008 , 0x0000C008},
+	{0x0A805008 , 0x0000C008},
+	{0x0A800408 , 0x0000C008},
+	{0x0A801408 , 0x0000C008},
+	{0x0A802408 , 0x0000C008},
+	{0x0A803408 , 0x0000C008},
+	{0x0A804408 , 0x0000C008},
+	{0x0A805408 , 0x0000C008},
+	{0x0A800808 , 0x0000C008},
+	{0x0A801808 , 0x0000C008},
+	{0x0A802808 , 0x0000C008},
+	{0x0A803808 , 0x0000C008},
+	{0x0A804808 , 0x0000C008},
+	{0x0A805808 , 0x0000C008},
+	{0x0A800C08 , 0x0000C008},
+	{0x0A801C08 , 0x0000C008},
+	{0x0A802C08 , 0x0000C008},
+	{0x0A803C08 , 0x0000C008},
+	{0x0A804C08 , 0x0000C008},
+	{0x0A805C08 , 0x0000C008},
+	// MAC AN speed/duplex/FC
+	{0x0A80000C , 0x0000BAE8},
+	{0x0A80100C , 0x0000BAE8},
+	{0x0A80200C , 0x0000BAE8},
+	{0x0A80300C , 0x0000BAE8},
+	{0x0A80400C , 0x0000BAE8},
+	{0x0A80500C , 0x0000BAE8},
+	{0x0A80040C , 0x0000BAE8},
+	{0x0A80140C , 0x0000BAE8},
+	{0x0A80240C , 0x0000BAE8},
+	{0x0A80340C , 0x0000BAE8},
+	{0x0A80440C , 0x0000BAE8},
+	{0x0A80540C , 0x0000BAE8},
+	{0x0A80080C , 0x0000BAE8},
+	{0x0A80180C , 0x0000BAE8},
+	{0x0A80280C , 0x0000BAE8},
+	{0x0A80380C , 0x0000BAE8},
+	{0x0A80480C , 0x0000BAE8},
+	{0x0A80580C , 0x0000BAE8},
+	{0x0A800C0C , 0x0000BAE8},
+	{0x0A801C0C , 0x0000BAE8},
+	{0x0A802C0C , 0x0000BAE8},
+	{0x0A803C0C , 0x0000BAE8},
+	{0x0A804C0C , 0x0000BAE8},
+	{0x0A805C0C , 0x0000BAE8},
+	// back pressure en
+	{0x0A800014 , 0x000008D4},
+	{0x0A801014 , 0x000008D4},
+	{0x0A802014 , 0x000008D4},
+	{0x0A803014 , 0x000008D4},
+	{0x0A804014 , 0x000008D4},
+	{0x0A805014 , 0x000008D4},
+	{0x0A800414 , 0x000008D4},
+	{0x0A801414 , 0x000008D4},
+	{0x0A802414 , 0x000008D4},
+	{0x0A803414 , 0x000008D4},
+	{0x0A804414 , 0x000008D4},
+	{0x0A805414 , 0x000008D4},
+	{0x0A800814 , 0x000008D4},
+	{0x0A801814 , 0x000008D4},
+	{0x0A802814 , 0x000008D4},
+	{0x0A803814 , 0x000008D4},
+	{0x0A804814 , 0x000008D4},
+	{0x0A805814 , 0x000008D4},
+	{0x0A800C14 , 0x000008D4},
+	{0x0A801C14 , 0x000008D4},
+	{0x0A802C14 , 0x000008D4},
+	{0x0A803C14 , 0x000008D4},
+	{0x0A804C14 , 0x000008D4},
+	{0x0A805C14 , 0x000008D4},
+	// EEE - Bit_0= 0: Disable LPI, 1: Enable LPI 
+	{0x0A8000C4 , 0x00000101},
+	{0x0A8004C4 , 0x00000101},
+	{0x0A8008C4 , 0x00000101},
+	{0x0A800CC4 , 0x00000101},
+	{0x0A8010C4 , 0x00000101},
+	{0x0A8014C4 , 0x00000101},
+	{0x0A8018C4 , 0x00000101},
+	{0x0A801CC4 , 0x00000101},
+	{0x0A8020C4 , 0x00000101},
+	{0x0A8024C4 , 0x00000101},
+	{0x0A8028C4 , 0x00000101},
+	{0x0A802CC4 , 0x00000101},
+	{0x0A8030C4 , 0x00000101},
+	{0x0A8034C4 , 0x00000101},
+	{0x0A8038C4 , 0x00000101},
+	{0x0A803CC4 , 0x00000101},
+	{0x0A8040C4 , 0x00000101},
+	{0x0A8044C4 , 0x00000101},
+	{0x0A8048C4 , 0x00000101},
+	{0x0A804CC4 , 0x00000101},
+	{0x0A8050C4 , 0x00000101},
+	{0x0A8054C4 , 0x00000101},
+	{0x0A8058C4 , 0x00000101},
+	{0x0A805CC4 , 0x00000101},
+	// ?
+	{0x0A8000C8 , 0x0000017D},
+	{0x0A8004C8 , 0x0000017D},
+	{0x0A8008C8 , 0x0000017D},
+	{0x0A800CC8 , 0x0000017D},
+	{0x0A8010C8 , 0x0000017D},
+	{0x0A8014C8 , 0x0000017D},
+	{0x0A8018C8 , 0x0000017D},
+	{0x0A801CC8 , 0x0000017D},
+	{0x0A8020C8 , 0x0000017D},
+	{0x0A8024C8 , 0x0000017D},
+	{0x0A8028C8 , 0x0000017D},
+	{0x0A802CC8 , 0x0000017D},
+	{0x0A8030C8 , 0x0000017D},
+	{0x0A8034C8 , 0x0000017D},
+	{0x0A8038C8 , 0x0000017D},
+	{0x0A803CC8 , 0x0000017D},
+	{0x0A8040C8 , 0x0000017D},
+	{0x0A8044C8 , 0x0000017D},
+	{0x0A8048C8 , 0x0000017D},
+	{0x0A804CC8 , 0x0000017D},
+	{0x0A8050C8 , 0x0000017D},
+	{0x0A8054C8 , 0x0000017D},
+	{0x0A8058C8 , 0x0000017D},
+	{0x0A805CC8 , 0x0000017D},
+	// END QSGMII Initial
+	// Start SGMII Initial
+	// Power up 1.25G SERDESs
+	// Set SERDES ref clock register
+	{0x09803000 , 0x0000BE80},
+	{0x09803400 , 0x0000BE80},
+	{0x09804000 , 0x0000BE80},
+	{0x09804400 , 0x0000BE80},
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Deactivate sd_reset
+	{0x09803004 , 0x00000008},
+	{0x09803404 , 0x00000008},
+	{0x09804004 , 0x00000008},
+	{0x09804404 , 0x00000008},
+	// Wait for Calibration done (0x09800008 bit 3)
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Reference Ferquency select = 62.5MHz   ;Use registers bits to control speed configuration
+	{0x0980320C , 0x0000800A},
+	{0x0980360C , 0x0000800A},
+	{0x0980420C , 0x0000800A},
+	{0x0980460C , 0x0000800A},
+	// Transmitter/Reciver Divider force, interpulator force; 1.25G: intpi = 25uA , VCO divided by 4 ; 2.5G: intpi = 25uA , VCO divided by 2  ; 3.125G: intpi = 30uA , VCO divided by 2 ; 3.75G: intpi = 20uA , VCO not divided; 6.25G: intpi = 30uA , VCO not divided; 5.15G: intpi = 25uA , VCO not divided
+	{0x09803210 , 0x00006614},
+	{0x09803610 , 0x00006614},
+	{0x09804210 , 0x00006614},
+	{0x09804610 , 0x00006614},
+	// Force FbDiv/RfDiv
+	{0x09803214 , 0x0000A150},
+	{0x09803614 , 0x0000A150},
+	{0x09804214 , 0x0000A150},
+	{0x09804614 , 0x0000A150},
+	// Force: PLL Speed, sel_v2i, loadcap_pll,sel_fplres
+	{0x09803218 , 0x0000BAAB},
+	{0x09803618 , 0x0000BAAB},
+	{0x09804218 , 0x0000BAAB},
+	{0x09804618 , 0x0000BAAB},
+	// icp force
+	{0x0980321C , 0x00008B2C},
+	{0x0980361C , 0x00008B2C},
+	{0x0980421C , 0x00008B2C},
+	{0x0980461C , 0x00008B2C},
+	//  0 = kvco-2
+	{0x098033CC , 0x00002000},
+	{0x098037CC , 0x00002000},
+	{0x098043CC , 0x00002000},
+	{0x098047CC , 0x00002000},
+	// External TX/Rx Impedance changed from 6 to 0 while auto calibration results are used  - based on lab measurments it seems that we need to force the auto imedance calibration values
+	{0x0980322C , 0x00000000},
+	{0x0980362C , 0x00000000},
+	{0x0980422C , 0x00000000},
+	{0x0980462C , 0x00000000},
+	// Auto KVCO,  PLL is not forced to max speed during power up sequence - 
+	{0x09803230 , 0x00000000},
+	{0x09803630 , 0x00000000},
+	{0x09804230 , 0x00000000},
+	{0x09804630 , 0x00000000},
+	// Sampler OS Scale was changed from 5mV/Step to 3.3mV/Step; RX_IMP_VTHIMCAL was chnge from 3 to 0
+	{0x09803234 , 0x00004000},
+	{0x09803634 , 0x00004000},
+	{0x09804234 , 0x00004000},
+	{0x09804634 , 0x00004000},
+	// Use value wiritten to register for process calibration instead of th eauto calibration; Select process from register
+	{0x0980323C , 0x00000018},
+	{0x0980363C , 0x00000018},
+	{0x0980423C , 0x00000018},
+	{0x0980463C , 0x00000018},
+	// DCC should be dissabled at baud 3.125 and below = 8060
+	{0x09803250 , 0x000080C0},
+	{0x09803650 , 0x000080C0},
+	{0x09804250 , 0x000080C0},
+	{0x09804650 , 0x000080C0},
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// DCC should be dissabled at baud 3.125 and below = 8060
+	{0x09803250 , 0x00008060},
+	{0x09803650 , 0x00008060},
+	{0x09804250 , 0x00008060},
+	{0x09804650 , 0x00008060},
+	// PE Setting
+	{0x09803254 , 0x0000770A},
+	{0x09803654 , 0x0000770A},
+	{0x09804254 , 0x0000770A},
+	{0x09804654 , 0x0000770A},
+	// PE Type
+	{0x09803258 , 0x00000000},
+	{0x09803658 , 0x00000000},
+	{0x09804258 , 0x00000000},
+	{0x09804658 , 0x00000000},
+	// selmupi/mupf - low value for lower baud
+	{0x0980327C , 0x0000905A},
+	{0x0980367C , 0x0000905A},
+	{0x0980427C , 0x0000905A},
+	{0x0980467C , 0x0000905A},
+	// DTL_FLOOP_EN = Dis
+	{0x09803280 , 0x00000800},
+	{0x09803680 , 0x00000800},
+	{0x09804280 , 0x00000800},
+	{0x09804680 , 0x00000800},
+	// FFE Setting
+	{0x0980328C , 0x00000266},
+	{0x0980368C , 0x00000266},
+	{0x0980428C , 0x00000266},
+	{0x0980468C , 0x00000266},
+	// Slicer Enable; Tx  Imp was changed from 50ohm to 43ohm
+	{0x0980335C , 0x0000423F},
+	{0x0980375C , 0x0000423F},
+	{0x0980435C , 0x0000423F},
+	{0x0980475C , 0x0000423F},
+	// Not need to be configure - Same as default 
+	{0x09803364 , 0x00005555},
+	{0x09803764 , 0x00005555},
+	{0x09804364 , 0x00005555},
+	{0x09804764 , 0x00005555},
+	// Disable ana_clk_det
+	{0x0980336C , 0x00000000},
+	{0x0980376C , 0x00000000},
+	{0x0980436C , 0x00000000},
+	{0x0980476C , 0x00000000},
+	// Configure rx_imp_vthimpcal to 0x0 (default value = 0x3); Configure Sampler_os_scale to 3.3mV/step (default value = 5mV/step)
+	{0x09803234 , 0x00004000},
+	{0x09803634 , 0x00004000},
+	{0x09804234 , 0x00004000},
+	{0x09804634 , 0x00004000},
+	// Configure IMP_VTHIMPCAL to 56.7ohm (default value = 53.3 ohm); Configure cal_os_ph_rd to 0x60 (default value = 0x0); Configure Cal_rxclkalign90_ext to use an external ovride value
+	{0x09803228 , 0x0000DAC0},
+	{0x09803628 , 0x0000DAC0},
+	{0x09804228 , 0x0000DAC0},
+	{0x09804628 , 0x0000DAC0},
+	// Reset dtl_rx ; Enable ana_clk_det
+	{0x0980336C , 0x00008040},
+	{0x0980376C , 0x00008040},
+	{0x0980436C , 0x00008040},
+	{0x0980476C , 0x00008040},
+	// Un reset dtl_rx
+	{0x0980336C , 0x00008000},
+	{0x0980376C , 0x00008000},
+	{0x0980436C , 0x00008000},
+	{0x0980476C , 0x00008000},
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// ?
+	{0x09803224 , 0x00000000},
+	{0x09803624 , 0x00000000},
+	{0x09804224 , 0x00000000},
+	{0x09804624 , 0x00000000},
+	// CAL Start
+	{0x09803224 , 0x00008000},
+	{0x09803624 , 0x00008000},
+	{0x09804224 , 0x00008000},
+	{0x09804624 , 0x00008000},
+	{0x09803224 , 0x00000000},
+	{0x09803624 , 0x00000000},
+	{0x09804224 , 0x00000000},
+	{0x09804624 , 0x00000000},
+	// Wait for RxClk_x2
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Set RxInit to 0x1 (remember that bit 3 is already set to 0x1)
+	{0x09803004 , 0x00000018},
+	{0x09803404 , 0x00000018},
+	{0x09804004 , 0x00000018},
+	{0x09804404 , 0x00000018},
+	// Wait for p_clk = 1 and p_clk = 0
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// Set RxInit to 0x0
+	{0x09803004 , 0x00000008},
+	{0x09803404 , 0x00000008},
+	{0x09804004 , 0x00000008},
+	{0x09804404 , 0x00000008},
+	// Wait for ALL PHY_RDY = 1 (0x09800008 bit 0)
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// ?
+	{0x09803004 , 0x00000028},
+	{0x09803404 , 0x00000028},
+	{0x09804004 , 0x00000028},
+	{0x09804404 , 0x00000028},
+	// Wait 10mSec
+	{0x000000F0 , 0x00000000},
+	{0x000000F0 , 0x00000001},
+	// End SGMII Initial
+	// port 24~27 SGMII force mode config
+	{0x0a806000 , 0x0000c801},
+	{0x0a806400 , 0x0000c801},
+	{0x0a806800 , 0x0000c801},
+	{0x0a806C00 , 0x0000c801},
+	// ?
+	{0x0a806008 , 0x0000C009},
+	{0x0a806408 , 0x0000C009},
+	{0x0a806808 , 0x0000C009},
+	{0x0a806C08 , 0x0000C009},
+	//  force FC enable
+	{0x0a80600C , 0x00009042},
+	{0x0a80640C , 0x00009042},
+	{0x0a80680C , 0x00009042},
+	{0x0a806C0C , 0x00009042},
+	//==============88E1680 init Start===================
+	// SMI_0 ========================
+	// -88E1680 PHY init settings for A2
+	//----- SMI0, PhyAddr=0x0~0xF
+	//QSGMII power up
+	{0x04004054 , 0x02C0C004},
+	{0x04004054 , 0x02C4C004},
+	{0x04004054 , 0x02C8C004},
+	{0x04004054 , 0x02CCC004},
+	{0x04004054 , 0x03488000},
+	// Global write
+	// 0x0~0xF
+	{0x04004054 , 0x02C0C000},
+	{0x04004054 , 0x02C1C000},
+	{0x04004054 , 0x02C2C000},
+	{0x04004054 , 0x02C3C000},
+	{0x04004054 , 0x02C4C000},
+	{0x04004054 , 0x02C5C000},
+	{0x04004054 , 0x02C6C000},
+	{0x04004054 , 0x02C7C000},
+	{0x04004054 , 0x02C8C000},
+	{0x04004054 , 0x02C9C000},
+	{0x04004054 , 0x02CAC000},
+	{0x04004054 , 0x02CBC000},
+	{0x04004054 , 0x02CCC000},
+	{0x04004054 , 0x02CDC000},
+	{0x04004054 , 0x02CEC000},
+	{0x04004054 , 0x02CFC000},
+	// Matrix LED fix
+	{0x04004054 , 0x02C0C004},
+	{0x04004054 , 0x03603FA0},
+	// Set Page FD
+	// Reg8=0b53 for QSGMII
+	{0x04004054 , 0x02C0C0FD},
+	{0x04004054 , 0x01000B53},
+	//Reg7=200d
+	{0x04004054 , 0x00E0200D},
+	// ?
+	{0x04004054 , 0x02C0C0FF},
+	{0x04004054 , 0x0220B030},
+	{0x04004054 , 0x0200215C},
+	{0x04004054 , 0x02C0C0FC},
+	{0x04004054 , 0x0300888C},
+	{0x04004054 , 0x0320888C},
+	//-Advertise EEE ability
+	{0x04004054 , 0x02C0C000},
+	{0x04004054 , 0x01A00007},
+	{0x04004054 , 0x01C0003C},
+	{0x04004054 , 0x01A04007},
+	{0x04004054 , 0x01C00006},
+	{0x04004054 , 0x00009140},
+	//Config Copper control register
+	{0x04004054 , 0x02C0c000},
+	//Enable Pause(FC) advertisment.
+	{0x04004054 , 0x00800de1},
+	{0x04004054 , 0x00009140},
+	//PHY LED
+	// LED_0 = LINK/ACT
+	// LED_[0:1] = Active high.(Reg_17(0x11)_[3:0]= 2'b0101)
+	{0x04004054 , 0x02c0c003},
+	{0x04004054 , 0x02001130},
+	// offset 0x04004054 0x02208800 ???
+	// PHY Soft Reset and power up PHY
+	{0x04004054 , 0x02c0c000},
+	{0x04004054 , 0x02003360},
+	{0x04004054 , 0x00009140},
+	{0x04004054 , 0x02C00000},
+	// SMI_0 ========================
+	// SMI_1 ========================
+	// -88E1680 PHY init settings for A2
+	//----- SMI0, PhyAddr=0x10~17
+	//QSGMII power up
+	{0x05004054 , 0x02D0C004},
+	{0x05004054 , 0x02D4C004},
+	{0x05004054 , 0x03508000},
+	// Global write
+	// 0x10~0x17
+	{0x05004054 , 0x02D0C000},
+	{0x05004054 , 0x02D1C000},
+	{0x05004054 , 0x02D2C000},
+	{0x05004054 , 0x02D3C000},
+	{0x05004054 , 0x02D4C000},
+	{0x05004054 , 0x02D5C000},
+	{0x05004054 , 0x02D6C000},
+	{0x05004054 , 0x02D7C000},
+	// Matrix LED fix
+	{0x05004054 , 0x02C0C004},
+	{0x05004054 , 0x03603FA0},
+	// Set Page FD
+	// Reg8=0b53 for QSGMII
+	{0x05004054 , 0x02D0C0FD},
+	{0x05004054 , 0x01100B53},
+	//Reg7=200d
+	{0x05004054 , 0x00F0200D},
+	// ?
+	{0x05004054 , 0x02D0C0FF},
+	{0x05004054 , 0x0230B030},
+	{0x05004054 , 0x0210215C},
+	{0x05004054 , 0x02D0C0FC},
+	{0x05004054 , 0x0310888C},
+	{0x05004054 , 0x0330888C},
+	//-Advertise EEE ability
+	{0x05004054 , 0x02D0C000},
+	{0x05004054 , 0x01B00007},
+	{0x05004054 , 0x01D0003C},
+	{0x05004054 , 0x01B04007},
+	{0x05004054 , 0x01D00006},
+	{0x05004054 , 0x00109140},
+	//Config Copper control register
+	{0x05004054 , 0x02D0c000},
+	//Enable Pause(FC) advertisment.
+	{0x05004054 , 0x00900de1},
+	{0x05004054 , 0x00109140},
+	//PHY LED
+	// LED_0 = LINK/ACT
+	// LED_[0:1] = Active high.(Reg_17(0x11)_[3:0]= 2'b0101)
+	{0x05004054 , 0x02D0c003},
+	{0x05004054 , 0x02101130},
+	// offset 0x05004054 0x02308800 ???
+	// PHY Soft Reset and power up PHY
+	{0x05004054 , 0x02D0c000},
+	{0x05004054 , 0x02103360},
+	{0x05004054 , 0x00109140},
+	{0x05004054 , 0x02D00000},
+	// SMI_1 ========================
+	//  VLAN MRU profile 0 and 1 = 9216
+	{0x02000300 , 0x24002400},
+	{0x00000058 , 0x04104003},
+	// 98DX3035 Initialized
+	{0x000000F0 , 0x12345678}
+};
+
+s32 e1000_read_98DX3035_reg_mdic(struct e1000_hw *hw, u32 offset, u32 *data)  // TTPan - MVL98DX3035_DEBUG Read
+{
+	u32 i, mdic = 0;
+
+	DEBUGFUNC("e1000_read_98DX3035_reg_mdic");
+
+	// 1. Write SMI Read Address - Hi-Word (Phy Offset 0x04)
+	mdic = (((u32) ((offset & 0xFFFF0000) >> 16)) |
+		(0x04 << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_WRITE));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Write did not complete\n");
+		printk("R4: MDI Write did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("R4: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x04) {
+		DEBUGOUT2("MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("R4: MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+
+	// 2. Write SMI Read Address - Low-Word (Phy Offset 0x05)
+	mdic = (((u32) (offset & 0x0000FFFF)) |
+		(0x05 << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_WRITE));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Write did not complete\n");
+		printk("R5: MDI Write did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("R5: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x05) {
+		DEBUGOUT2("MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("R5: MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+
+	// 3. Read SMI RW Status (Phy Offset 0x1f)
+	mdic = ((0x1F << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_READ));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Read did not complete\n");
+		printk("R1F: MDI Read did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("R1F: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x1F) {
+		DEBUGOUT2("MDI Read offset error - requested %d, returned %d\n",
+			offset,
+			(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("R1F: MDI Read offset error - requested %d, returned %d\n",
+			offset,
+			(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+	if(mdic & 0x0001) { // SMI RW Status Register Read-Redy = 1
+		// 4. Read SMI Read Data - Hi-Word (Phy Offset 0x06)
+		mdic = ((0x06 << E1000_MDIC_REG_SHIFT) |
+			(0x00 << E1000_MDIC_PHY_SHIFT) |
+			(E1000_MDIC_OP_READ));
+		E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+		for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+			usec_delay_irq(50);
+			mdic = E1000_READ_REG(hw, E1000_MDIC);
+			if (mdic & E1000_MDIC_READY)
+				break;
+		}
+		if (!(mdic & E1000_MDIC_READY)) {
+			DEBUGOUT("MDI Read did not complete\n");
+			printk("R6: MDI Read did not complete\n");
+			return -E1000_ERR_PHY;
+		}
+		if (mdic & E1000_MDIC_ERROR) {
+			DEBUGOUT("MDI Error\n");
+			printk("R6: MDI Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x06) {
+			DEBUGOUT2("MDI Read offset error - requested %d, returned %d\n",
+				offset,
+				(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+			printk("R6: MDI Read offset error - requested %d, returned %d\n",
+				offset,
+				(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+			return -E1000_ERR_PHY;
+		}
+		*data = mdic << 16;
+
+		// 5. Read SMI Read Data - Low-Word (Phy Offset 0x07)
+		mdic = ((0x07 << E1000_MDIC_REG_SHIFT) |
+			(0x00 << E1000_MDIC_PHY_SHIFT) |
+			(E1000_MDIC_OP_READ));
+		E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+		for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+			usec_delay_irq(50);
+			mdic = E1000_READ_REG(hw, E1000_MDIC);
+			if (mdic & E1000_MDIC_READY)
+				break;
+		}
+		if (!(mdic & E1000_MDIC_READY)) {
+			DEBUGOUT("MDI Read did not complete\n");
+			printk("R7 MDI Read did not complete\n");
+			return -E1000_ERR_PHY;
+		}
+		if (mdic & E1000_MDIC_ERROR) {
+			DEBUGOUT("MDI Error\n");
+			printk("R7: MDI Error\n");
+			return -E1000_ERR_PHY;
+		}
+		if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x07) {
+			DEBUGOUT2("MDI Read offset error - requested %d, returned %d\n",
+				offset,
+				(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+			printk("R7: MDI Read offset error - requested %d, returned %d\n",
+				offset,
+				(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+			return -E1000_ERR_PHY;
+		}
+		*data |= (mdic & 0x0000FFFF);
+	}
+
+	return E1000_SUCCESS;
+}
+EXPORT_SYMBOL(e1000_read_98DX3035_reg_mdic);
+
+s32 e1000_write_98DX3035_reg_mdic(struct e1000_hw *hw, u32 offset, u32 data)  // TTPan - MVL98DX3035_DEBUG Write
+{
+	u32 i, mdic = 0;
+
+	DEBUGFUNC("e1000_write_98DX3035_reg_mdic");
+
+	// 1. Write SMI Write Address - Hi-Word (Phy Offset 0x00)
+	mdic = (((u32) ((offset & 0xFFFF0000) >> 16)) |
+		(0x00 << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_WRITE));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Write did not complete\n");
+		printk("W0: MDI Write did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("W0: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x00) {
+		DEBUGOUT2("MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("W0: MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+
+	// 2. Write SMI Write Address - Low-Word (Phy Offset 0x01)
+	mdic = (((u32) (offset & 0x0000FFFF)) |
+		(0x01 << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_WRITE));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Write did not complete\n");
+		printk("W1: MDI Write did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("W1: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x01) {
+		DEBUGOUT2("MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("W1: MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+
+	// 3. Write SMI Write Data - Hi-Word (Phy Offset 0x02)
+	mdic = (((u32) ((data & 0xFFFF0000) >> 16)) |
+		(0x02 << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_WRITE));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Write did not complete\n");
+		printk("W2: MDI Write did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("W2: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x02) {
+		DEBUGOUT2("MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("W2: MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+
+	// 4. Write SMI Write data - Low-Word (Phy Offset 0x3)
+	mdic = (((u32) (data & 0x0000FFFF)) |
+		(0x03 << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_WRITE));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 3); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Write did not complete\n");
+		printk("W3: MDI Write did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("W3: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x03) {
+		DEBUGOUT2("MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("W3: MDI Write offset error - requested %d, returned %d\n",
+			  offset,
+			  (mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+
+	// 5. Read SMI RW Status (Phy Offset 0x1f)
+	mdic = ((0x1F << E1000_MDIC_REG_SHIFT) |
+		(0x00 << E1000_MDIC_PHY_SHIFT) |
+		(E1000_MDIC_OP_READ));
+	E1000_WRITE_REG(hw, E1000_MDIC, mdic);
+	for (i = 0; i < (E1000_GEN_POLL_TIMEOUT * 300); i++) {
+		usec_delay_irq(50);
+		mdic = E1000_READ_REG(hw, E1000_MDIC);
+		if (mdic & E1000_MDIC_READY)
+			break;
+	}
+	if (!(mdic & E1000_MDIC_READY)) {
+		DEBUGOUT("MDI Read did not complete\n");
+		printk("W1F: MDI Read did not complete\n");
+		return -E1000_ERR_PHY;
+	}
+	if (mdic & E1000_MDIC_ERROR) {
+		DEBUGOUT("MDI Error\n");
+		printk("W1F: MDI Error\n");
+		return -E1000_ERR_PHY;
+	}
+	if (((mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT) != 0x1F) {
+		DEBUGOUT2("MDI Read offset error - requested %d, returned %d\n",
+			offset,
+			(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		printk("W1F: MDI Read offset error - requested %d, returned %d\n",
+			offset,
+			(mdic & E1000_MDIC_REG_MASK) >> E1000_MDIC_REG_SHIFT);
+		return -E1000_ERR_PHY;
+	}
+
+	if(mdic & 0x0002) return E1000_SUCCESS;
+	else return -E1000_ERR_PHY;
+}
+EXPORT_SYMBOL(e1000_write_98DX3035_reg_mdic);
+
+#include <linux/phy.h>
+
+extern	struct mii_bus* wg_pss_bus;
+
+int e1000_init_98DX3035(struct e1000_hw *hw)
+{
+	if ((wg_pss_bus != NULL)) return E1000_SUCCESS;
+
+	if ((wg_pss_bus = mdiobus_alloc())) {
+		wg_pss_bus->name   = "Marvell 98DX3035";
+		wg_pss_bus->priv   = hw;
+		wg_pss_bus->parent = NULL;
+
+		strncpy(wg_pss_bus->id, "98DX3035", MII_BUS_ID_SIZE);
+	} else {
+		printk(KERN_EMERG "%s: mii bus alloc failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	return E1000_SUCCESS;
+}
+
+int e1000_reset_98DX3035(struct e1000_hw *hw)
+{
+	static int ix = 0;
+
+	if (ix) return 0;
+
+	for (; ix < (sizeof(dx3035) / sizeof(dx3035[0])); ix++)
+		e1000_write_98DX3035_reg_mdic(hw, dx3035[ix].offset, dx3035[ix].val);
+
+	printk(KERN_INFO "%s: %d registers set\n", __FUNCTION__, ix);
+
+	return ix;
+}
+EXPORT_SYMBOL(e1000_reset_98DX3035);
+
+#endif	// CONFIG_WG_ARCH_X86
+
+#ifdef	CONFIG_WG_PLATFORM_DSA_MODULE
+
+#include <linux/phy.h>
+
+extern	struct mii_bus*  wg_dsa_bus;
+
+static	struct e1000_hw* wg_dsa_hw;
+
+static void set_phy(int phy)
+{
+	u32 mdicnfg;
+
+	mdicnfg  =  E1000_READ_REG(wg_dsa_hw, E1000_MDICNFG);
+	mdicnfg &= ~E1000_MDICNFG_PHY_MASK;
+	mdicnfg |= (phy << 21);
+	mdicnfg |=  E1000_MDICNFG_EXT_MDIO;
+	E1000_WRITE_REG(wg_dsa_hw, E1000_MDICNFG, mdicnfg);
+}
+
+int wg_igb_raw_phy_read (struct mii_bus* _bus, int phy_id, int reg_num)
+{
+	int err;
+	int phy = wg_dsa_hw->phy.addr;
+	u16 val = 0xDEAD;
+
+	wg_dsa_hw->phy.addr = 0;
+	set_phy(phy_id);
+	err = e1000_read_phy_reg_mdic(wg_dsa_hw, reg_num, &val);
+	wg_dsa_hw->phy.addr = phy;
+	if (unlikely(err || (wg_dsa_debug & 0x200)))
+	printk(KERN_EMERG "%s:  phy %2d reg %2d val %4x err %d\n",
+	       __FUNCTION__, phy_id, reg_num, val, err);
+	if (err < 0) return INT_MAX;
+	return val;
+}
+
+int wg_igb_raw_phy_write(struct mii_bus* _bus, int phy_id, int reg_num, u16 val)
+{
+	int err;
+	int phy = wg_dsa_hw->phy.addr;
+
+	wg_dsa_hw->phy.addr = 0;
+	set_phy(phy_id);
+	err = e1000_write_phy_reg_mdic(wg_dsa_hw, reg_num, val);
+	wg_dsa_hw->phy.addr = phy;
+	if (unlikely(err || (wg_dsa_debug & 0x200)))
+	printk(KERN_EMERG "%s: phy %2d reg %2d val %4x err %d\n",
+	       __FUNCTION__, phy_id, reg_num, val, err);
+	if (err < 0) return err;
+	return val;
+}
+
+static void wg_igb_wait(void)
+{
+	while (wg_igb_raw_phy_read(wg_dsa_bus, 28, 24) & 0x8000);
+}
+
+int wg_igb_phy_read (struct mii_bus* _bus, int phy, int reg)
+{
+	if (phy >= 16) return wg_igb_raw_phy_read (wg_dsa_bus, phy, reg);
+
+	wg_igb_wait();
+	wg_igb_raw_phy_write(wg_dsa_bus, 28, 24, 0x9800 | (phy << 5) | reg);
+	wg_igb_wait();
+
+	return wg_igb_raw_phy_read(wg_dsa_bus, 28, 25);
+}
+
+int wg_igb_phy_write(struct mii_bus* _bus, int phy, int reg, u16 val)
+{
+	if (phy >= 16) return wg_igb_raw_phy_write(wg_dsa_bus, phy, reg, val);
+
+	wg_igb_wait();
+	wg_igb_raw_phy_write(wg_dsa_bus, 28, 25, val);
+	wg_igb_raw_phy_write(wg_dsa_bus, 28, 24, 0x9400 | (phy << 5) | reg);
+	wg_igb_wait();
+
+	return val;
+}
+
+int wg_igb_get_phy_id(int phy)
+{
+	int id1 = wg_igb_phy_read(wg_dsa_bus, phy, 2);
+	int id2 = wg_igb_phy_read(wg_dsa_bus, phy, 3);
+
+	printk(KERN_EMERG "%s:  phy %2d id %4x %4x\n", __FUNCTION__, phy, id1, id2);
+
+	return (id1<<16) | id2;
+}
+
+void wg_igb_phy_init(void)
+{
+#if 1111|1111
+	// Set up so all ports talk only to CPU
+	wg_igb_phy_write(wg_dsa_bus, 16,  6, 0x0020);
+	wg_igb_phy_write(wg_dsa_bus, 17,  6, 0x0020);
+	wg_igb_phy_write(wg_dsa_bus, 18,  6, 0x0020);
+	wg_igb_phy_write(wg_dsa_bus, 19,  6, 0x0020);
+	wg_igb_phy_write(wg_dsa_bus, 20,  6, 0x0020);
+	wg_igb_phy_write(wg_dsa_bus, 21,  6, 0x001f);
+	wg_igb_phy_write(wg_dsa_bus, 22,  6, 0x0000);
+
+	// Needed to get enable ports
+	wg_igb_phy_write(wg_dsa_bus, 16,  4, 0x007f);
+	wg_igb_phy_write(wg_dsa_bus, 17,  4, 0x007f);
+	wg_igb_phy_write(wg_dsa_bus, 18,  4, 0x007f);
+	wg_igb_phy_write(wg_dsa_bus, 19,  4, 0x007f);
+	wg_igb_phy_write(wg_dsa_bus, 20,  4, 0x007f);
+	wg_igb_phy_write(wg_dsa_bus, 21,  4, 0x007f);
+	wg_igb_phy_write(wg_dsa_bus, 22,  4, 0x007c);
+
+#if 0	// Seano stuuf we don't need
+	wg_igb_phy_write(wg_dsa_bus, 28,  3, 0x0000);
+	wg_igb_phy_write(wg_dsa_bus, 28,  5, 0x04f7);
+	wg_igb_phy_write(wg_dsa_bus, 27, 26, 0xff5f);
+	wg_igb_phy_write(wg_dsa_bus, 28,  9, 0x9000);
+	wg_igb_phy_write(wg_dsa_bus, 28,  9, 0xcf01);
+	wg_igb_phy_write(wg_dsa_bus, 28, 10, 0x0004);
+	wg_igb_phy_write(wg_dsa_bus, 28,  9, 0xbf01);
+#endif
+
+	// Needed to get external phys to link
+	wg_igb_phy_write(wg_dsa_bus,  0,  0, 0x1140);
+	wg_igb_phy_write(wg_dsa_bus,  1,  0, 0x1140);
+	wg_igb_phy_write(wg_dsa_bus,  2,  0, 0x1140);
+	wg_igb_phy_write(wg_dsa_bus,  3,  0, 0x1140);
+	wg_igb_phy_write(wg_dsa_bus,  4,  0, 0x1140);
+
+	// Needed to get sw link up
+	wg_igb_phy_write(wg_dsa_bus, 15, 22, 0x0001);
+	wg_igb_phy_write(wg_dsa_bus, 15,  0, 0x9340);
+
+	// Display PHY Ids
+	wg_igb_get_phy_id( 0);
+	wg_igb_get_phy_id( 1);
+	wg_igb_get_phy_id( 2);
+	wg_igb_get_phy_id( 3);
+	wg_igb_get_phy_id( 4);
+	wg_igb_get_phy_id(15);
+#endif
+}
+
+int e1000_init_88E6176(struct e1000_hw *hw)
+{
+	if ((wg_dsa_bus != NULL ) ||
+	    (hw->device_id != E1000_DEV_ID_I210_SERDES))
+		return E1000_SUCCESS;
+
+	/* Turn on I2C Enabled or we cannot access mdio */
+	e1000_set_i2c_bb(wg_dsa_hw = hw);
+
+	printk(KERN_INFO "%s: Device: %x\n", __FUNCTION__, hw->device_id);
+
+	if ((wg_dsa_bus = mdiobus_alloc())) {
+
+		wg_dsa_bus->name   = "Marvell 886176";
+		wg_dsa_bus->priv   = hw;
+		wg_dsa_bus->parent = NULL;
+		wg_dsa_bus->read   = wg_igb_phy_read;
+		wg_dsa_bus->write  = wg_igb_phy_write;
+
+		strncpy(wg_dsa_bus->id, "88E6176", MII_BUS_ID_SIZE);
+	} else {
+		printk(KERN_EMERG "%s: mii bus alloc failed\n", __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	wg_igb_phy_init();
+
+	return E1000_SUCCESS;
+}
+
+#endif	// CONFIG_WG_PLATFORM_DSA_MODULE
+
 /**
  *  e1000_read_phy_reg_mdic - Read MDI control register
  *  @hw: pointer to the HW structure
@@ -268,6 +1605,29 @@
 		return -E1000_ERR_PARAM;
 	}
 
+#ifdef	CONFIG_WG_ARCH_X86 // WG:JB Marvell 98DX3035 fake phy read
+	if (wg_seattle)
+	if (hw->device_id == E1000_DEV_ID_I354_SGMII)
+	switch(offset) {
+		default: printk(KERN_EMERG "%s: Bad offset %d\n",
+				__FUNCTION__, offset);
+			 *data = 0x0000; return E1000_SUCCESS;
+		case  0: *data = 0x0140; return E1000_SUCCESS;
+		case  1: *data = 0x796D; return E1000_SUCCESS;
+		case  2: *data = 0x0141; return E1000_SUCCESS;
+		case  3: *data = 0x0EA1; return E1000_SUCCESS;
+		case  4: *data = 0x0DE1; return E1000_SUCCESS;
+		case  5: *data = 0x0DE1; return E1000_SUCCESS;
+		case  9: *data = 0x0E00; return E1000_SUCCESS;
+		case 10: *data = 0x4800; return E1000_SUCCESS;
+		case 14: *data = 0x0006; return E1000_SUCCESS;
+		case 16: *data = 0x5860; return E1000_SUCCESS;
+		case 17: *data = 0x0000; return E1000_SUCCESS;
+		case 21: *data = 0x0000; return E1000_SUCCESS;
+		case 22: *data = 0x0000; return E1000_SUCCESS;
+	}
+#endif	// CONFIG_WG_ARCH_X86
+
 	/* Set up Op-code, Phy Address, and register offset in the MDI
 	 * Control register.  The MAC will take care of interfacing with the
 	 * PHY to retrieve the desired data.
@@ -327,6 +1687,12 @@
 		return -E1000_ERR_PARAM;
 	}
 
+#ifdef	CONFIG_WG_ARCH_X86 // WG:JB Marvell 98DX3035 fake phy write
+	if (wg_seattle)
+	if (hw->device_id == E1000_DEV_ID_I354_SGMII)
+		return E1000_SUCCESS;
+#endif	// CONFIG_WG_ARCH_X86
+
 	/* Set up Op-code, Phy Address, and register offset in the MDI
 	 * Control register.  The MAC will take care of interfacing with the
 	 * PHY to retrieve the desired data.
@@ -3226,9 +4592,19 @@
 	DEBUGFUNC("e1000_read_phy_reg_gs40g");
 
 	offset = offset & GS40G_OFFSET_MASK;
+#ifdef	CONFIG_WG_PLATFORM	// BUG83358 XTM440 lockup
+	local_bh_disable();
+#endif	// CONFIG_WG_PLATFORM
 	ret_val = hw->phy.ops.acquire(hw);
+#ifdef	CONFIG_WG_PLATFORM	//WG:XD FBX-9848
+	if (ret_val) {
+		local_bh_enable();
+		return ret_val;
+	}
+#else
 	if (ret_val)
 		return ret_val;
+#endif
 
 	ret_val = e1000_write_phy_reg_mdic(hw, GS40G_PAGE_SELECT, page);
 	if (ret_val)
@@ -3237,6 +4613,9 @@
 
 release:
 	hw->phy.ops.release(hw);
+#ifdef	CONFIG_WG_PLATFORM	// BUG83358 XTM440 lockup
+	local_bh_enable();
+#endif	// CONFIG_WG_PLATFORM
 	return ret_val;
 }
 
--- igb-5.3.5.3/src/igb.h.orig	2022-05-09 13:54:13.478745596 -0700
+++ igb-5.3.5.3/src/igb.h	2022-05-09 13:54:13.518743974 -0700
@@ -667,6 +667,9 @@
 	u32 rss_indir_tbl_init;
 	u8 rss_indir_tbl[IGB_RETA_SIZE];
 #endif
+#ifdef	CONFIG_WG_PLATFORM	// XD: BUG92243
+  int media_type_set;
+#endif
 };
 
 #ifdef CONFIG_IGB_VMDQ_NETDEV
--- igb-5.3.5.3/src/e1000_82575.c.orig	2022-05-09 13:54:13.470745921 -0700
+++ igb-5.3.5.3/src/e1000_82575.c	2022-05-09 13:54:13.510744298 -0700
@@ -35,6 +35,8 @@
 #include "e1000_api.h"
 #include "e1000_i210.h"
 
+#include "igb.h"	// WG:JB Needed in e1000_check_fiberstore_sfp()
+
 static s32  e1000_init_phy_params_82575(struct e1000_hw *hw);
 static s32  e1000_init_mac_params_82575(struct e1000_hw *hw);
 static s32  e1000_acquire_phy_82575(struct e1000_hw *hw);
@@ -1665,6 +1667,12 @@
 	switch (ctrl_ext & E1000_CTRL_EXT_LINK_MODE_MASK) {
 	case E1000_CTRL_EXT_LINK_MODE_SGMII:
 		/* sgmii mode lets the phy handle forcing speed/duplex */
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Turn off autoneg for SGMII ports
+		if ((wg_seattle) &&
+		    (hw->device_id == E1000_DEV_ID_I354_SGMII))
+			pcs_autoneg = false;
+		else
+#endif	// CONFIG_WG_PLATFORM
 		pcs_autoneg = true;
 		/* autoneg time out should be disabled for SGMII mode */
 		reg &= ~(E1000_PCS_LCTL_AN_TIMEOUT);
@@ -1756,6 +1764,8 @@
 	return ret_val;
 }
 
+extern int wg_igb_serdes_only; // WG:JB Lanner SFP fix
+
 /**
  *  e1000_get_media_type_82575 - derives current media type.
  *  @hw: pointer to the HW structure
@@ -1818,6 +1828,14 @@
 			break;
 		}
 
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Lanner SFP fix
+		if (wg_igb_serdes_only) {
+			hw->phy.media_type = e1000_media_type_internal_serdes;
+			ctrl_ext &= ~E1000_CTRL_EXT_LINK_MODE_MASK;
+			ctrl_ext |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;
+			E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
+		}
+#endif	// CONFIG_WG_PLATFORM
 		/* do not change link mode for 100BaseFX */
 		if (dev_spec->eth_flags.e100_base_fx)
 			break;
@@ -1830,6 +1848,12 @@
 		else
 			ctrl_ext |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;
 
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Lanner SFP fix
+		if (wg_igb_serdes_only) {
+			ctrl_ext &= ~E1000_CTRL_EXT_LINK_MODE_MASK;
+			ctrl_ext |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;
+		}
+#endif	// CONFIG_WG_PLATFORM
 		E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
 
 		break;
@@ -1903,10 +1927,182 @@
 	ret_val = E1000_SUCCESS;
 out:
 	/* Restore I2C interface setting */
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Lanner SFP fix
+	if (!wg_igb_serdes_only)
+#endif	// CONFIG_WG_PLATFORM
+	E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
+	return ret_val;
+}
+
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Lanner SFP fix
+
+/* FBX-6424 - dump extra info from the SFP+ transceivers to help debug the problems in the field.
+ * Since the extra info also includes the vendor string, it replaces existing subroutine that
+ * queries vendor string only
+ */
+#define SFP_BASIC_FIELD_SIZE	64
+static void e1000_dump_extra_sfp_info(struct e1000_hw *hw)
+{
+  	int i;
+	int ret;
+	unsigned char tmp;
+	struct igb_adapter *adapter = hw->back;
+	unsigned char sfp_info[SFP_BASIC_FIELD_SIZE] = {0,};
+
+  
+	for (i = 0; i < SFP_BASIC_FIELD_SIZE; i++) {
+	  	ret = e1000_read_sfp_data_byte(hw, E1000_I2CCMD_SFP_DATA_ADDR(i), &sfp_info[i]);
+		if (ret) {
+		  	printk(KERN_WARNING "## %s reading sfp+ byte # %d error\n", adapter->netdev->name, i);
+		  	break;
+		}
+	}
+
+	/* start dumping the SFP+ info just read ... */
+	printk(KERN_INFO "@@ %s SFP+ ID: 0x%02x, Ext. ID: 0x%02x, Connector: 0x%02x, Tx Compat: 0x%02x\n",
+		   adapter->netdev->name, sfp_info[0], sfp_info[1], sfp_info[2], sfp_info[36]);
+	print_hex_dump(KERN_INFO, "byte 03 to 18: ", DUMP_PREFIX_NONE, 16, 1, &sfp_info[3], 16, 0);
+	sfp_info[36] = '\0'; 	// NULL terminator for Vendor Name string, already done with byte 36
+	tmp = sfp_info[56];
+	sfp_info[56] = '\0';	// NULL terminator for P/N string
+	printk(KERN_INFO "Vendor ID: %02x%02x%02x, Vendor Name: %s, P/N: %s\n",
+		   sfp_info[37], sfp_info[38], sfp_info[39], &sfp_info[20], &sfp_info[40]);
+	sfp_info[56] = tmp;		// recover byte 56
+	tmp = sfp_info[60];
+	sfp_info[60] = '\0';	// NULL terminator for P/N Revision string
+	printk(KERN_INFO "P/N rev: %s, Wave Length: %02x%02x\n", &sfp_info[56], tmp, sfp_info[61]);
+
+	return;
+}
+
+static s32 e1000_set_current_sfp_media_type_and_set_link_mode_82575(struct e1000_hw *hw)
+{
+	s32 ret_val = E1000_ERR_CONFIG;
+	u32 ctrl_ext = 0, ctrl_ext_reg=0;
+	struct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;
+	struct sfp_e1000_flags *eth_flags = &dev_spec->eth_flags;
+	u8 tranceiver_type = 0;
+	s32 timeout = 3;
+
+	/* Turn I2C interface ON and power on sfp cage */
+	ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);
+	ctrl_ext_reg = ctrl_ext;
+	ctrl_ext &= ~E1000_CTRL_EXT_SDP3_DATA;
+	E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext | E1000_CTRL_I2C_ENA);
+
+	E1000_WRITE_FLUSH(hw);
+
+	msec_delay(200);
+	e1000_dump_extra_sfp_info(hw);
+
+	/* Read SFP module data */
+	while (timeout) {
+		ret_val = e1000_read_sfp_data_byte(hw,
+			E1000_I2CCMD_SFP_DATA_ADDR(E1000_SFF_IDENTIFIER_OFFSET),
+			&tranceiver_type);
+		if (ret_val == E1000_SUCCESS)
+			break;
+		msec_delay(100);
+		timeout--;
+	}
+	if (ret_val != E1000_SUCCESS)
+		goto err_out;
+
+	ret_val = e1000_read_sfp_data_byte(hw,
+			E1000_I2CCMD_SFP_DATA_ADDR(E1000_SFF_ETH_FLAGS_OFFSET),
+			(u8 *)eth_flags);
+	if (ret_val != E1000_SUCCESS)
+		goto err_out;
+
+	/* Check if there is some SFP module plugged and powered */
+	if ((tranceiver_type == E1000_SFF_IDENTIFIER_SFP) ||
+	    (tranceiver_type == E1000_SFF_IDENTIFIER_SFF)) {
+		dev_spec->module_plugged = true;
+		if (eth_flags->e1000_base_lx || eth_flags->e1000_base_sx) {
+			DEBUGOUT("PHY module = fiber\n");
+			hw->phy.media_type = e1000_media_type_internal_serdes;
+			ctrl_ext_reg &= ~E1000_CTRL_EXT_LINK_MODE_MASK;
+			ctrl_ext_reg |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;
+		} else if (eth_flags->e100_base_fx) {
+			DEBUGOUT("PHY module = e100_base_fx\n");
+			dev_spec->sgmii_active = true;
+			hw->phy.media_type = e1000_media_type_internal_serdes;
+
+		} else if (eth_flags->e1000_base_t) {
+			dev_spec->sgmii_active = true;
+			DEBUGOUT("PHY module = e1000_base_t\n");
+			hw->phy.media_type = e1000_media_type_copper;
+			ctrl_ext_reg &= ~E1000_CTRL_EXT_LINK_MODE_MASK;
+			ctrl_ext_reg |= E1000_CTRL_EXT_LINK_MODE_SGMII;
+
+		} else {
+			hw->phy.media_type = e1000_media_type_unknown;
+			DEBUGOUT("PHY module has not been recognized\n");
+			hw->phy.media_type = e1000_media_type_internal_serdes;
+			ctrl_ext_reg &= ~E1000_CTRL_EXT_LINK_MODE_MASK;
+			ctrl_ext_reg |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;
+
+			goto out;
+		}
+	} else {
+		hw->phy.media_type = e1000_media_type_unknown;
+	}
+	ret_val = E1000_SUCCESS;
+out:
+	/* For Kirkland, no need to do vendor string comparison for special handling any more due to 
+	 * FBX-4968. The only outcome of existing e1000_check_fiberstore_sfp() is to gather vendor string
+	 * info from the SFP+ transceiver for debugging. It's replaced by e1000_dump_extra_sfp_info(),
+	 * which includes dumping vendor string as well as other extra info
+	 */
+	if (wg_kirkland) {
+		ctrl_ext_reg &= ~E1000_CTRL_EXT_LINK_MODE_MASK;
+		ctrl_ext_reg |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;
+	}
+	ctrl_ext = ctrl_ext_reg;
+err_out:
+	/* Restore I2C interface setting */
 	E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);
 	return ret_val;
 }
 
+void e1000_get_current_media_type_82575(struct e1000_hw *hw)
+{
+	s32 ret_val = E1000_ERR_CONFIG;
+	struct e1000_mac_info *mac = &hw->mac;
+	struct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;
+	struct e1000_phy_info *phy = &hw->phy;
+
+	/* Set internal phy as default */
+	dev_spec->module_plugged = true;
+
+	/* read current plugged module and set correspond link mode */
+	ret_val = e1000_set_current_sfp_media_type_and_set_link_mode_82575(hw);
+
+	/* setup correct interface*/
+	mac->ops.setup_physical_interface =
+		(hw->phy.media_type == e1000_media_type_copper)
+		? e1000_setup_copper_link_82575 : e1000_setup_serdes_link_82575;
+
+	hw->phy.type = e1000_phy_i210;
+
+	if (e1000_sgmii_active_82575(hw)) {
+		hw->phy.addr = 6;
+		phy->autoneg_mask	= AUTONEG_ADVERTISE_SPEED_DEFAULT;
+		phy->ops.reset = e1000_phy_hw_reset_sgmii_82575;
+		phy->ops.read_reg = e1000_read_phy_reg_sgmii_82575;
+		phy->ops.write_reg = e1000_write_phy_reg_sgmii_82575;
+	} else {
+		hw->phy.addr = 0;
+		phy->ops.reset = e1000_phy_hw_reset_generic;
+		phy->ops.read_reg = e1000_read_phy_reg_gs40g;
+		phy->ops.write_reg = e1000_write_phy_reg_gs40g;
+	}
+
+	return;
+}
+
+#endif	// CONFIG_WG_PLATFORM
+
 /**
  *  e1000_valid_led_default_82575 - Verify a valid default LED config
  *  @hw: pointer to the HW structure
@@ -2367,6 +2563,9 @@
 
 	DEBUGFUNC("e1000_read_phy_reg_82580");
 
+#ifdef CONFIG_WG_PLATFORM // WG: XD FBX-5661
+	local_bh_disable();
+#endif
 	ret_val = hw->phy.ops.acquire(hw);
 	if (ret_val)
 		goto out;
@@ -2376,6 +2575,9 @@
 	hw->phy.ops.release(hw);
 
 out:
+#ifdef CONFIG_WG_PLATFORM // WG: XD FBX-5661
+	local_bh_enable();
+#endif
 	return ret_val;
 }
 
@@ -2734,7 +2936,39 @@
 
 	DEBUGFUNC("e1000_validate_nvm_checksum_i350");
 
+#ifdef	CONFIG_WG_PLATFORM // WG:MJ BUG72184 WORKAROUND
+	/* MukundJ: Moving to this (igb 4.1.2) driver breaks spokane network interfaces.
+	 *  It breaks because the nvm_checksum is being detected a INVALID.
+	 *  The same checksum check does not fail on igb 2.4.12.
+	 *
+	 *  GIST of the problem: it is driver change problem.
+	 *
+	 *  Ground info:  I350 is a Quad port card. There is only one EEPROM for all the 4 ports.
+	 *                According to the I350 datasheet, there are 4 different configuration spaces on the
+	 *		  EEPROM for each of the ports.
+	 *
+	 *  Functional info:
+	 *   old driver: (2.4.12)
+	 *		validate/update checksum: Updates the checksum on only one of 4 LAN configuration spaces.
+	 *					  Only the first configuration space (LAN0) is updated even
+	 *					   if the configuration on LAN1/2/3 have changed.
+	 *					  Validates only first one configuration space (LAN0) @ load time.
+	 *					  This is a buddy behavior on the driver part
+	 *   new driver: (4.1.2)
+	 *		validate/update checksum: Updates the checksum on all 4 LAN configuration spaces.
+	 *		                          Validates all configuration space (LAN0/1/2/3) @ load time
+	 *
+	 *
+	 *   Solution: Fix the new driver to calculate update/validate the checksum only on First
+	 *   	       LAN(lan0) config space.
+	 *   	      We can also fix it in the field but it is very risky to do that in the field
+	 *	      and it is not absolutely necessary as it does not break any functionality.
+	 *
+	 */
+	for (j = 0; j < 1; j++) {
+#else	// CONFIG_WG_PLATFORM
 	for (j = 0; j < 4; j++) {
+#endif	// CONFIG_WG_PLATFORM
 		nvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);
 		ret_val = e1000_validate_nvm_checksum_with_offset(hw,
 								  nvm_offset);
--- igb-5.3.5.3/src/kcompat.h.orig	2022-05-09 13:54:13.486745272 -0700
+++ igb-5.3.5.3/src/kcompat.h	2022-05-09 13:54:13.526743649 -0700
@@ -65,6 +65,12 @@
 #endif
 #endif
 
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Not needed in newer kernels
+#if	(LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0))
+#undef	CONFIG_NETDEVICES_MULTIQUEUE
+#endif
+#endif	// CONFIG_PLATFORM
+
 /* NAPI enable/disable flags here */
 #define NAPI
 
@@ -2574,11 +2580,13 @@
 
 #else /* < 2.6.25 */
 
+#ifndef	CONFIG_WG_PLATFORM // WG:JB No need to enable hwmon support ... otherwise hwmon sensor paths will change for other hwmon devices
 #if IS_ENABLED(CONFIG_HWMON)
 #ifndef IGB_HWMON
 #define IGB_HWMON
 #endif /* IGB_HWMON */
 #endif /* CONFIG_HWMON */
+#endif
 
 #endif /* < 2.6.25 */
 
--- igb-5.3.5.3/src/e1000_i210.c.orig	2022-05-09 13:54:13.474745758 -0700
+++ igb-5.3.5.3/src/e1000_i210.c	2022-05-09 13:54:13.514744136 -0700
@@ -85,6 +85,14 @@
 
 	DEBUGFUNC("e1000_acquire_swfw_sync_i210");
 
+#ifdef	CONFIG_WG_PLATFORM	//WG:XD FBX-9848
+	/* if we are in irq context, we can't afford long busy waiting to acquire
+	 * the hw samphore to access the PHY. We rather it fail under IRQ context
+	 */
+	if (irq_count())
+		timeout = 2;
+#endif
+
 	while (i < timeout) {
 		if (e1000_get_hw_semaphore_i210(hw)) {
 			ret_val = -E1000_ERR_SWFW_SYNC;
--- igb-5.3.5.3/src/igb_main.c.orig	2022-05-09 13:54:13.482745434 -0700
+++ igb-5.3.5.3/src/igb_main.c	2022-05-09 13:54:13.522743811 -0700
@@ -182,8 +182,13 @@
 static void igb_process_mdd_event(struct igb_adapter *);
 #ifdef IFLA_VF_MAX
 static int igb_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac);
+#ifdef	CONFIG_WG_KERNEL_4_14
+static int igb_ndo_set_vf_vlan(struct net_device *netdev,
+			       int vf, u16 vlan, u8 qos, __be16 proto);
+#else
 static int igb_ndo_set_vf_vlan(struct net_device *netdev,
 			       int vf, u16 vlan, u8 qos);
+#endif
 #ifdef HAVE_VF_SPOOFCHK_CONFIGURE
 static int igb_ndo_set_vf_spoofchk(struct net_device *netdev, int vf,
 				bool setting);
@@ -318,6 +323,9 @@
 module_param(debug, int, 0);
 MODULE_PARM_DESC(debug, "Debug level (0=none, ..., 16=all)");
 
+extern	struct net_device* wg_dsa_dev[2];	// WG:JB Devices that the switch chips are attached to
+int			   wg_igb_serdes_only;	// WG:JB Lanner SFP fix
+
 /**
  * igb_init_module - Driver Registration Routine
  *
@@ -332,6 +340,13 @@
 	       igb_driver_string, igb_driver_version);
 
 	pr_info("%s\n", igb_copyright);
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Lanner SFP fix
+	if (wg_kirkland) {
+		wg_igb_serdes_only = 1;
+		printk(KERN_INFO "Setting SERDES only mode\n");
+	}
+#endif	// CONFIG_WG_PLATFORM
+
 #ifdef IGB_HWMON
 /* only use IGB_PROCFS if IGB_HWMON is not defined */
 #else
@@ -1536,12 +1551,14 @@
 	igb_configure_rx(adapter);
 
 	e1000_rx_fifo_flush_82575(&adapter->hw);
+#ifndef	CONFIG_WG_PLATFORM // WG:JB Don't use this
 #ifdef CONFIG_NETDEVICES_MULTIQUEUE
 	if (adapter->num_tx_queues > 1)
 		netdev->features |= NETIF_F_MULTI_QUEUE;
 	else
 		netdev->features &= ~NETIF_F_MULTI_QUEUE;
 #endif
+#endif
 
 	/* call igb_desc_unused which always leaves
 	 * at least 1 descriptor unused to make sure
@@ -1854,7 +1871,13 @@
 	del_timer_sync(&adapter->phy_info_timer);
 
 	/* record the stats before reset*/
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG84635 XTM-2520 lockup
+	local_bh_disable();
 	igb_update_stats(adapter);
+	local_bh_enable();
+#else	// CONFIG_WG_PLATFORM
+	igb_update_stats(adapter);
+#endif	// CONFIG_WG_PLATFORM
 
 	adapter->link_speed = 0;
 	adapter->link_duplex = 0;
@@ -1878,6 +1901,9 @@
 	WARN_ON(in_interrupt());
 	while (test_and_set_bit(__IGB_RESETTING, &adapter->state))
 		usleep_range(1000, 2000);
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG92243
+	adapter->media_type_set = 0;
+#endif
 	igb_down(adapter);
 	igb_up(adapter);
 	clear_bit(__IGB_RESETTING, &adapter->state);
@@ -2085,6 +2111,10 @@
 	e1000_get_phy_info(hw);
 
 	adapter->devrc++;
+
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG92243
+	adapter->media_type_set = 0;
+#endif
 }
 
 #ifdef HAVE_NDO_SET_FEATURES
@@ -2852,6 +2882,13 @@
 	if (pci_using_dac)
 		netdev->features |= NETIF_F_HIGHDMA;
 
+#ifdef CONFIG_WG_PLATFORM_BACKPORT	// WG:XD FBX-20414
+#define ETH_MIN_MTU 68
+#define MAX_STD_JUMBO_FRAME_SIZE 9238
+	netdev->min_mtu = ETH_MIN_MTU;
+	netdev->max_mtu = MAX_STD_JUMBO_FRAME_SIZE;
+#endif
+
 	adapter->en_mng_pt = e1000_enable_mng_pass_thru(hw);
 #ifdef DEBUG
 	if (adapter->dmac != IGB_DMAC_DISABLE)
@@ -3306,6 +3343,29 @@
 	adapter->max_frame_size = netdev->mtu + ETH_HLEN + ETH_FCS_LEN +
 					      VLAN_HLEN;
 
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Init switch device
+	if (wg_seattle) {
+		extern s32 e1000_init_98DX3035(struct e1000_hw *hw);
+		if (memcmp(netdev->name, "0000:00:14.",   11) == 0) {
+			adapter->max_frame_size += VLAN_HLEN;
+			printk(KERN_INFO "%s: sw%c Max Frame %d\n",
+			       __FUNCTION__, netdev->name[11], adapter->max_frame_size);
+		}
+		e1000_init_98DX3035(hw);
+	}
+#ifdef	CONFIG_WG_PLATFORM_DSA_MODULE
+	if (wg_westport) {
+		extern s32 e1000_init_88E6176(struct e1000_hw *hw);
+		if (memcmp(netdev->name, "0000:04:00.0",  12) == 0) {
+			adapter->max_frame_size += VLAN_HLEN;
+			printk(KERN_INFO "%s: sw%c Max Frame %d\n",
+			       __FUNCTION__, netdev->name[12], adapter->max_frame_size);
+		}
+		e1000_init_88E6176(hw);
+	}
+#endif	// CONFIG_WG_PLATFORM_DSA_MODULE
+#endif	// CONFIG_WG_PLATFORM
+
 	/* Initialize the hardware-specific values */
 	if (e1000_setup_init_funcs(hw, TRUE)) {
 		dev_err(pci_dev_to_dev(pdev), "Hardware Initialization Failure\n");
@@ -3366,6 +3426,10 @@
 		return -EBUSY;
 	}
 
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG92243
+	adapter->media_type_set = 0;
+#endif
+
 #ifdef CONFIG_PM_RUNTIME
 	if (!resuming)
 		pm_runtime_get_sync(&pdev->dev);
@@ -3480,6 +3544,9 @@
 	struct pci_dev *pdev = adapter->pdev;
 #endif /* CONFIG_PM_RUNTIME */
 
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG92243
+	adapter->media_type_set = 0;
+#endif
 	WARN_ON(test_bit(__IGB_RESETTING, &adapter->state));
 
 #ifdef CONFIG_PM_RUNTIME
@@ -4630,6 +4697,9 @@
 #endif /* HAVE_SET_RX_MODE */
 		rctl |= E1000_RCTL_VFE;
 	}
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Force promisc mode on for DSA
+	if (netdev == wg_dsa_dev[0]) rctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE | E1000_RCTL_SBP);
+#endif
 	E1000_WRITE_REG(hw, E1000_RCTL, rctl);
 
 	/*
@@ -4779,6 +4849,18 @@
 	int i;
 	u32 connsw;
 
+#ifdef	CONFIG_WG_PLATFORM // WG:JB SFP patch from Lanner; BUG92247; FBX-6424
+	void e1000_get_current_media_type_82575(struct e1000_hw *hw);
+
+	if ((!wg_igb_serdes_only || wg_kirkland) && !adapter->media_type_set) {
+		if (hw->device_id == E1000_DEV_ID_I210_FIBER ||
+			hw->device_id == E1000_DEV_ID_I350_FIBER) {
+			e1000_get_current_media_type_82575(hw);
+			adapter->media_type_set = 1;
+		}
+	}
+#endif	// CONFIG_WG_PLATFORM
+
 	link = igb_has_link(adapter);
 
 	/* Force link down if we have fiber to swap to */
@@ -4801,6 +4883,9 @@
 		if (hw->dev_spec._82575.media_changed) {
 			hw->dev_spec._82575.media_changed = false;
 			adapter->flags |= IGB_FLAG_MEDIA_RESET;
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG92243
+			adapter->media_type_set = 0;
+#endif
 			igb_reset(adapter);
 		}
 
@@ -4815,6 +4900,9 @@
 						   &adapter->link_duplex);
 
 			ctrl = E1000_READ_REG(hw, E1000_CTRL);
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG92243
+			adapter->media_type_set = 0;
+#endif
 			/* Links status message must follow this format */
 			netdev_info(netdev,
 				"igb: %s NIC Link is Up %d Mbps %s, Flow Control: %s\n",
@@ -4878,6 +4966,9 @@
 				}
 			}
 
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG92243
+			adapter->media_type_set = 0;
+#endif
 			/* Links status message must follow this format */
 			netdev_info(netdev, "igb: %s NIC Link is Down\n",
 			       netdev->name);
@@ -4915,7 +5006,13 @@
 		}
 	}
 
+#ifdef	CONFIG_WG_PLATFORM	// WG:XD BUG84635 XTM-2520 lockup
+	local_bh_disable();
 	igb_update_stats(adapter);
+	local_bh_enable();
+#else	// CONFIG_WG_PLATFORM
+	igb_update_stats(adapter);
+#endif	// CONFIG_WG_PLATFORM
 
 	for (i = 0; i < adapter->num_tx_queues; i++) {
 		struct igb_ring *tx_ring = adapter->tx_ring[i];
@@ -5541,6 +5638,15 @@
 	cmd_type |= size | IGB_TXD_DCMD;
 	tx_desc->read.cmd_type_len = cpu_to_le32(cmd_type);
 
+#ifdef	CONFIG_WG_PLATFORM // WG:XD JIRA EPA-238 sw10 (igb) Tx timeout
+	if (unlikely(wg_westport)) {
+		local_bh_disable();
+#ifndef CONFIG_WG_KERNEL_4_14 // WG:JB Removed in 4.14
+		netdev_ring(tx_ring)->trans_start = jiffies;
+#endif
+		txring_txq(tx_ring)->trans_start = jiffies;
+	}
+#endif
 	netdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);
 	/* set the timestamp */
 	first->time_stamp = jiffies;
@@ -5570,6 +5676,11 @@
 	 * at a time, it syncronizes IO on IA64/Altix systems
 	 */
 	mmiowb();
+#ifdef	CONFIG_WG_PLATFORM // WG:XD JIRA EPA-238 sw10 (igb) Tx timeout
+	if (unlikely(wg_westport)) {
+		local_bh_enable();
+	}
+#endif
 
 	return;
 
@@ -5806,8 +5917,16 @@
 {
 	struct igb_adapter *adapter = netdev_priv(netdev);
 
+#ifndef	CONFIG_WG_PLATFORM	// WG:XD BUG84635 XTM-2520 lockup
 	if (!test_bit(__IGB_RESETTING, &adapter->state))
 		igb_update_stats(adapter);
+#else	// CONFIG_WG_PLATFORM
+	if (!test_bit(__IGB_RESETTING, &adapter->state)) {
+		local_bh_disable();
+		igb_update_stats(adapter);
+		local_bh_enable();
+	}
+#endif	// CONFIG_WG_PLATFORM
 
 #ifdef HAVE_NETDEV_STATS_IN_NETDEV
 	/* only return the current stats */
@@ -5832,12 +5951,23 @@
 	struct pci_dev *pdev = adapter->pdev;
 	int max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;
 
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Bump frame size on sw devices
+	if (max_frame < (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN))
+		max_frame = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;
+	if (wg_seattle | wg_westport)
+	if (memcmp(netdev->name, "sw", 2) == 0)
+		max_frame += VLAN_HLEN;
+	printk(KERN_INFO "%s: %-5s Max Frame %d\n",
+	       __FUNCTION__, netdev->name, max_frame);
+#endif	// CONFIG_WG_PLATFORM
 	if ((new_mtu < 68) || (max_frame > MAX_JUMBO_FRAME_SIZE)) {
 		dev_err(pci_dev_to_dev(pdev), "Invalid MTU setting\n");
 		return -EINVAL;
 	}
 
+#ifndef CONFIG_WG_PLATFORM_BACKPORT	// WG:XD FBX-20414
 #define MAX_STD_JUMBO_FRAME_SIZE 9238
+#endif
 	if (max_frame > MAX_STD_JUMBO_FRAME_SIZE) {
 		dev_err(pci_dev_to_dev(pdev), "MTU > 9216 not supported.\n");
 		return -EINVAL;
@@ -6614,8 +6744,13 @@
 		E1000_WRITE_REG(hw, E1000_VMVIR(vf), 0);
 }
 
+#ifdef	CONFIG_WG_KERNEL_4_14
+static int igb_ndo_set_vf_vlan(struct net_device *netdev,
+			       int vf, u16 vlan, u8 qos, __be16 proto)
+#else
 static int igb_ndo_set_vf_vlan(struct net_device *netdev,
 			       int vf, u16 vlan, u8 qos)
+#endif
 {
 	int err = 0;
 	struct igb_adapter *adapter = netdev_priv(netdev);
@@ -6781,9 +6916,15 @@
 	igb_clear_vf_vfta(adapter, vf);
 #ifdef IFLA_VF_MAX
 	if (adapter->vf_data[vf].pf_vlan)
+#ifdef	CONFIG_WG_KERNEL_4_14
+		igb_ndo_set_vf_vlan(adapter->netdev, vf,
+				    adapter->vf_data[vf].pf_vlan,
+				    adapter->vf_data[vf].pf_qos, 0);
+#else
 		igb_ndo_set_vf_vlan(adapter->netdev, vf,
 				    adapter->vf_data[vf].pf_vlan,
 				    adapter->vf_data[vf].pf_qos);
+#endif
 	else
 		igb_clear_vf_vfta(adapter, vf);
 #endif
@@ -7491,6 +7632,24 @@
 		size -= IGB_TS_HDR_LEN;
 	}
 #endif /* HAVE_PTP_1588_CLOCK */
+#if defined(CONFIG_WG_PLATFORM) && defined (CONFIG_X86) // WG:XD FBX-21025
+/* wg_pss_untag is only active if CONFIG_X86 is defined. All wg_dsa related igb patches are
+ * for X86 platforms only. PPC32 and PPC64 platforms do use wg_dsa driver however they don't
+ * have igb Eth card. ARM64 platforms may have igb cards however they use kernel_dsa driver
+ * instead.
+ */
+	if (unlikely(wg_pss_untag)) {
+		int pss;
+		skb->len = size; // FBX-13194, set skb->len for wg_pss ports to calculate rx_bytes
+		pss = wg_pss_untag(skb, va);
+		skb->len = 0;	 // FBX-13194, skb->len will get officially set in skb_add_rx_frag()
+		if (likely(pss > 0)) {
+			// Skip past Marvell header
+			size -= pss;
+			va   += pss;
+		}
+	}
+#endif	// CONFIG_WG_PLATFORM
 
 	if (likely(size <= IGB_RX_HDR_LEN)) {
 		memcpy(__skb_put(skb, size), va, ALIGN(size, sizeof(long)));
@@ -8072,6 +8231,8 @@
 }
 
 #endif /* IGB_NO_LRO */
+
+
 /**
  * igb_process_skb_fields - Populate skb header fields from Rx descriptor
  * @rx_ring: rx descriptor ring packet is being transacted on
@@ -8719,6 +8880,17 @@
 	enable = !!(features & NETIF_F_HW_VLAN_RX);
 #endif /* NETIF_F_HW_VLAN_CTAG_RX */
 #endif /* HAVE_VLAN_RX_REGISTER */
+#ifdef	CONFIG_WG_PLATFORM // WG:JB Disable VLAN assist if Marvell headers
+	if (netdev == wg_dsa_dev[0]) {
+		/* disable VLAN tag insert/strip */
+		ctrl = E1000_READ_REG(hw, E1000_CTRL);
+		ctrl &= ~E1000_CTRL_VME;
+		E1000_WRITE_REG(hw, E1000_CTRL, ctrl);
+		printk(KERN_INFO "%s: Blocking HW_VLAN_CTAG_RX on %s\n",
+		       __FUNCTION__, netdev->name);
+		return;
+	}
+#endif
 
 	if (enable) {
 		/* enable VLAN tag insert/strip */
