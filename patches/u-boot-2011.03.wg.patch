WatchGuard patches to sources for u-boot-2011.03 as of
Mon May  9 14:05:41 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- u-boot-2011.03/Makefile.orig	2022-05-09 14:05:09.420141507 -0700
+++ u-boot-2011.03/Makefile	2022-05-09 14:05:10.644091874 -0700
@@ -30,6 +30,7 @@
 else
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL)$(EXTRAVERSION)
 endif
+PERFORCE_FILE = $(obj)include/perforce_autogenerated.h
 TIMESTAMP_FILE = $(obj)include/timestamp_autogenerated.h
 VERSION_FILE = $(obj)include/version_autogenerated.h
 
@@ -134,12 +135,6 @@
 
 #########################################################################
 
-# The "tools" are needed early, so put this first
-# Don't include stuff already done in $(LIBS)
-SUBDIRS	= tools \
-	  examples/standalone \
-	  examples/api
-
 .PHONY : $(SUBDIRS)
 
 ifeq ($(obj)include/config.mk,$(wildcard $(obj)include/config.mk))
@@ -159,11 +154,22 @@
 ifeq ($(HOSTARCH),$(ARCH))
 CROSS_COMPILE ?=
 endif
+CROSS_COMPILE ?=/opt/freescale/usr/local/gcc-4.3.74-eglibc-2.8.74-dp-2/powerpc-none-linux-gnuspe/bin/powerpc-none-linux-gnuspe-
 
 # load other configuration
 include $(TOPDIR)/config.mk
 
-#########################################################################
+# The "tools" are needed early, so put this first
+# Don't include stuff already done in $(LIBS)
+SUBDIRS	= tools \
+	  examples/standalone \
+	  examples/api
+
+ifdef CONFIG_SERCOMM_MFG
+SUBDIRS += sc_mfg_standalone
+endif
+
+########################################################################
 # U-Boot objects....order is important (i.e. start must be first)
 
 OBJS  = $(CPUDIR)/start.o
@@ -261,8 +267,23 @@
 LIBS += $(CPUDIR)/s5p-common/libs5p-common.o
 endif
 
+# SC MFG Test Code
+ifeq ($(SC_MFG_BUILD), y)
+ifeq ($(SC_MFG_AS_STANDALONE), y)
+LIBS += sc_mfg_cmd/libscmfg_external.a
+endif
+ifeq ($(SC_MFG_NONE_STANDALONE), y)
+LIBS += sc_mfg_src/libscmfg_internal.a
+endif
+endif
+
+# SC CMD For Debug
+ifeq ($(SC_DEBUG_CODE_ENABLE), y)
+LIBS += sc_debug_cmd/libsccmd.a
+endif
+
 LIBS := $(addprefix $(obj),$(sort $(LIBS)))
-.PHONY : $(LIBS) $(TIMESTAMP_FILE) $(VERSION_FILE)
+.PHONY : $(LIBS) $(PERFORCE_FILE) $(TIMESTAMP_FILE) $(VERSION_FILE)
 
 LIBBOARD = board/$(BOARDDIR)/lib$(BOARD).o
 LIBBOARD := $(addprefix $(obj),$(LIBBOARD))
@@ -402,13 +423,13 @@
 $(obj)u-boot.lds: $(LDSCRIPT)
 		$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - <$^ >$@
 
-$(NAND_SPL):	$(TIMESTAMP_FILE) $(VERSION_FILE) depend
+$(NAND_SPL):	$(PERFORCE_FILE) $(TIMESTAMP_FILE) $(VERSION_FILE) depend
 		$(MAKE) -C nand_spl/board/$(BOARDDIR) all
 
 $(U_BOOT_NAND):	$(NAND_SPL) $(obj)u-boot.bin
 		cat $(obj)nand_spl/u-boot-spl-16k.bin $(obj)u-boot.bin > $(obj)u-boot-nand.bin
 
-$(ONENAND_IPL):	$(TIMESTAMP_FILE) $(VERSION_FILE) $(obj)include/autoconf.mk
+$(ONENAND_IPL):	$(PERFORCE_FILE) $(TIMESTAMP_FILE) $(VERSION_FILE) $(obj)include/autoconf.mk
 		$(MAKE) -C onenand_ipl/board/$(BOARDDIR) all
 
 $(U_BOOT_ONENAND):	$(ONENAND_IPL) $(obj)u-boot.bin
@@ -427,12 +448,16 @@
 		@LC_ALL=C date +'#define U_BOOT_DATE "%b %d %C%y"' > $@
 		@LC_ALL=C date +'#define U_BOOT_TIME "%T"' >> $@
 
+$(PERFORCE_FILE):
+		@( printf '#define PERFORCE_CHANGE "%s"\n' \
+		 '$(shell echo ${PERFORCE_CHANGE_NUM})' )>> $@
+
 updater:
 		$(MAKE) -C tools/updater all
 
 # Explicitly make _depend in subdirs containing multiple targets to prevent
 # parallel sub-makes creating .depend files simultaneously.
-depend dep:	$(TIMESTAMP_FILE) $(VERSION_FILE) \
+depend dep:	$(PERFORCE_FILE) $(TIMESTAMP_FILE) $(VERSION_FILE) \
 		$(obj)include/autoconf.mk \
 		$(obj)include/generated/generic-asm-offsets.h
 		for dir in $(SUBDIRS) $(CPUDIR) $(dir $(LDSCRIPT)) ; do \
@@ -497,7 +522,7 @@
 else	# !config.mk
 all $(obj)u-boot.hex $(obj)u-boot.srec $(obj)u-boot.bin \
 $(obj)u-boot.img $(obj)u-boot.dis $(obj)u-boot \
-$(filter-out tools,$(SUBDIRS)) $(TIMESTAMP_FILE) $(VERSION_FILE) \
+$(filter-out tools,$(SUBDIRS)) $(PERFORCE_FILE) $(TIMESTAMP_FILE) $(VERSION_FILE) \
 updater depend dep tags ctags etags cscope $(obj)System.map:
 	@echo "System not configured - see README" >&2
 	@ exit 1
@@ -511,7 +536,8 @@
 gdbtools: gdb
 
 tools-all: easylogo env gdb
-	$(MAKE) -C tools HOST_TOOLS_ALL=y
+	mkdir $(OBJTREE)/include
+	$(MAKE) -C tools HOST_TOOLS_ALL=y HOST_EXTRACPPFLAGS="$(HOST_EXTRACPPFLAGS) -DHOST_ONLY_BUILD"
 
 .PHONY : CHANGELOG
 CHANGELOG:
@@ -1141,7 +1167,7 @@
 	@rm -f $(obj)onenand_ipl/onenand-{ipl,ipl.bin,ipl.map}
 	@rm -f $(ONENAND_BIN)
 	@rm -f $(obj)onenand_ipl/u-boot.lds
-	@rm -f $(TIMESTAMP_FILE) $(VERSION_FILE)
+	@rm -f $(PERFORCE_FILE) $(TIMESTAMP_FILE) $(VERSION_FILE)
 	@find $(OBJTREE) -type f \
 		\( -name 'core' -o -name '*.bak' -o -name '*~' \
 		-o -name '*.o'	-o -name '*.a' -o -name '*.exe'	\) -print \
--- u-boot-2011.03/config.mk.orig	2022-05-09 14:05:10.240108256 -0700
+++ u-boot-2011.03/config.mk	2022-05-09 14:05:11.480057974 -0700
@@ -88,7 +88,7 @@
 # exceptions for files that aren't complaint.
 
 HOSTCFLAGS_NOPED = $(filter-out -pedantic,$(HOSTCFLAGS))
-HOSTCFLAGS	+= -pedantic
+#HOSTCFLAGS	+= -pedantic
 
 #########################################################################
 #
@@ -145,6 +145,33 @@
 
 #########################################################################
 
+ifeq ($(CONFIG_SERCOMM_MFG), y)
+# SC MFG Test Tools
+export SC_MFG_BUILD=y
+# SC BIG PAGE NAND
+export SC_NAND_BIG_PAGE=y
+# SC RTC CHIP (SEIKO - S35390)
+export SC_RTC_CHIP=y
+# SC ENET (MARVELL 88E6171R)
+export SC_ENET_DEV=y
+# SC Debug Trace
+export SC_DEBUG=y
+# SC DDR3 DRAM Chip
+export SC_USE_DDR3=y
+# SC no read Board Rev from GPIO
+export SC_NO_BOARD_REV=y
+# SC NOR FLASH BASE
+export SC_NOR_FLASH=y
+# SC H/W Debug Code
+export SC_DEBUG_CODE_ENABLE=n
+# SC MFG AS STANDALONE
+export SC_MFG_AS_STANDALONE=y
+# SC MFG NONE STANDALONE
+export SC_MFG_NONE_STANDALONE=n
+endif
+
+#########################################################################
+
 ifneq (,$(findstring s,$(MAKEFLAGS)))
 ARFLAGS = cr
 else
@@ -181,7 +208,7 @@
 
 CPPFLAGS += -I$(TOPDIR)/include
 CPPFLAGS += -fno-builtin -ffreestanding -nostdinc	\
-	-isystem $(gccincdir) -pipe $(PLATFORM_CPPFLAGS)
+	-isystem $(gccincdir) -pipe $(PLATFORM_CPPFLAGS) -Werror
 
 ifdef BUILD_TAG
 CFLAGS := $(CPPFLAGS) -Wall -Wstrict-prototypes \
@@ -236,6 +263,39 @@
 endif
 endif
 
+ifdef CONFIG_SERCOMM_MFG
+ifeq ($(SC_MFG_BUILD), y)
+CFLAGS += -D_SC_MFG_TEST_
+export SC_MFG_BUILD
+ifeq ($(SC_MFG_AS_STANDALONE), y)
+CFLAGS += -D_SC_MFG_STANDALONE_ -DSC_STANDALONE_BIN_ADDR=0x20000 -DSC_STANDALONE_BIN_SIZE=0x20000
+endif
+endif
+ifeq ($(SC_NAND_BIG_PAGE), y)
+CFLAGS += -D_SC_NAND_BIG_PAGE_
+endif
+ifeq ($(SC_RTC_CHIP), y)
+CFLAGS += -D_SC_RTC_CHIP_
+export SC_RTC_CHIP
+endif
+ifeq ($(SC_ENET_DEV), y)
+CFLAGS += -D_SC_ENET_DEV_
+endif
+ifeq ($(SC_USE_DDR3), y)
+CFLAGS += -D_SC_DRAM_CONFIG_
+endif
+ifeq ($(SC_DEBUG), y)
+CFLAGS += -D_SC_DEBUG_TRACE_
+endif
+ifeq ($(SC_NO_BOARD_REV), y)
+CFLAGS += -D_SC_NO_BOARD_REV_
+endif
+ifeq ($(SC_DEBUG_CODE_ENABLE), y)
+CFLAGS += -D_SC_DEBUG_TOOL_
+export SC_DEBUG_CODE_ENABLE
+endif
+endif
+
 #########################################################################
 
 export	HOSTCC HOSTCFLAGS HOSTLDFLAGS PEDCFLAGS HOSTSTRIP CROSS_COMPILE \
--- u-boot-2011.03/tools/env/fw_env.c.orig	2022-05-09 14:05:10.580094469 -0700
+++ u-boot-2011.03/tools/env/fw_env.c	2022-05-09 14:05:11.844043214 -0700
@@ -54,7 +54,7 @@
 	_min1 < _min2 ? _min1 : _min2; })
 
 struct envdev_s {
-	char devname[16];		/* Device name */
+	char devname[32];		/* Device name */
 	ulong devoff;			/* Device offset */
 	ulong env_size;			/* environment size */
 	ulong erase_size;		/* device erase size */
--- u-boot-2011.03/tools/Makefile.orig	2022-05-09 14:05:10.572094794 -0700
+++ u-boot-2011.03/tools/Makefile	2022-05-09 14:05:11.840043376 -0700
@@ -147,7 +147,8 @@
 		-I $(SRCTREE)/tools \
 		-DCONFIG_SYS_TEXT_BASE=$(CONFIG_SYS_TEXT_BASE) \
 		-DUSE_HOSTCC \
-		-D__KERNEL_STRICT_NAMES
+		-D__KERNEL_STRICT_NAMES \
+		$(HOST_EXTRACPPFLAGS)
 
 
 all:	$(obj).depend $(BINS) $(LOGO-y) subdirs
--- u-boot-2011.03/tools/imximage.h.orig	2022-05-09 14:05:10.584094307 -0700
+++ u-boot-2011.03/tools/imximage.h	2022-05-09 14:05:11.844043214 -0700
@@ -24,7 +24,9 @@
 #ifndef _IMXIMAGE_H_
 #define _IMXIMAGE_H_
 
+#ifndef HOST_ONLY_BUILD
 #include <config.h>
+#endif /* #ifndef HOST_ONLY_BUILD */
 
 #define MAX_HW_CFG_SIZE_V2 121 /* Max number of registers imx can set for v2 */
 #define MAX_HW_CFG_SIZE_V1 60  /* Max number of registers imx can set for v1 */
--- u-boot-2011.03/tools/easylogo/easylogo.c.orig	2022-05-09 14:05:10.576094631 -0700
+++ u-boot-2011.03/tools/easylogo/easylogo.c	2022-05-09 14:05:11.840043376 -0700
@@ -157,7 +157,9 @@
 	if ((file = fopen (filename, "rb")) == NULL)
 		return -1;
 
-	fread (&header, sizeof (header), 1, file);
+	if ((fread (&header, sizeof (header), 1, file)) == 0)
+		if (ferror(file))
+			return -1;
 
 	/* byte swap: tga is little endian, host is ??? */
 	header.ColorMapOrigin = le16_to_cpu (header.ColorMapOrigin);
@@ -193,7 +195,9 @@
 		return -1;
 	}
 
-	fread (image->data, image->size, 1, file);
+	if ((fread (image->data, image->size, 1, file)) == 0)
+		if (ferror(file))
+			return -1;
 
 /* Swapping R and B values */
 
--- u-boot-2011.03/tools/envcrc.c.orig	2022-05-09 14:05:10.580094469 -0700
+++ u-boot-2011.03/tools/envcrc.c	2022-05-09 14:05:11.844043214 -0700
@@ -32,7 +32,9 @@
 #define	__ASSEMBLY__			/* Dirty trick to get only #defines	*/
 #endif
 #define	__ASM_STUB_PROCESSOR_H__	/* don't include asm/processor.		*/
+#ifndef HOST_ONLY_BUILD
 #include <config.h>
+#endif /* #ifndef HOST_ONLY_BUILD */
 #undef	__ASSEMBLY__
 
 #if defined(CONFIG_ENV_IS_IN_FLASH)
--- u-boot-2011.03/board/freescale/mpc8540ads/ddr.c.orig	2022-05-09 14:05:09.976118962 -0700
+++ u-boot-2011.03/board/freescale/mpc8540ads/ddr.c	2022-05-09 14:05:11.220068517 -0700
@@ -18,14 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr1_spd_eeprom_t));
 }
 
-
-unsigned int
-fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
-
 void
 fsl_ddr_get_spd(ddr1_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
--- u-boot-2011.03/board/freescale/mpc8536ds/ddr.c.orig	2022-05-09 14:05:09.976118962 -0700
+++ u-boot-2011.03/board/freescale/mpc8536ds/ddr.c	2022-05-09 14:05:11.220068517 -0700
@@ -17,11 +17,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/mpc8544ds/ddr.c.orig	2022-05-09 14:05:09.976118962 -0700
+++ u-boot-2011.03/board/freescale/mpc8544ds/ddr.c	2022-05-09 14:05:11.224068354 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/mpc8641hpcn/ddr.c.orig	2022-05-09 14:05:09.984118637 -0700
+++ u-boot-2011.03/board/freescale/mpc8641hpcn/ddr.c	2022-05-09 14:05:11.228068193 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_bus_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
@@ -144,7 +139,7 @@
 	/* Get clk_adjust, cpo, write_data_delay, according to the board ddr
 	 * freqency and n_banks specified in board_specific_parameters table.
 	 */
-	ddr_freq = fsl_ddr_get_mem_data_rate() / 1000000;
+	ddr_freq = get_ddr_freq(0) / 1000000;
 	for (j = 0; j < CONFIG_DIMM_SLOTS_PER_CTLR; j++) {
 		if (pdimm[j].n_ranks > 0) {
 			for (i = 0; i < num_params; i++) {
--- u-boot-2011.03/board/freescale/mpc8555cds/ddr.c.orig	2022-05-09 14:05:09.980118799 -0700
+++ u-boot-2011.03/board/freescale/mpc8555cds/ddr.c	2022-05-09 14:05:11.224068354 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr1_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr1_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/p1022ds/ddr.c.orig	2022-05-09 14:05:09.988118475 -0700
+++ u-boot-2011.03/board/freescale/p1022ds/ddr.c	2022-05-09 14:05:11.232068031 -0700
@@ -15,11 +15,6 @@
 #include <asm/fsl_ddr_sdram.h>
 #include <asm/fsl_ddr_dimm_params.h>
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr3_spd_eeprom_t *ctrl_dimms_spd, unsigned int ctrl_num)
 {
 	int ret;
--- u-boot-2011.03/board/freescale/mpc8541cds/ddr.c.orig	2022-05-09 14:05:09.976118962 -0700
+++ u-boot-2011.03/board/freescale/mpc8541cds/ddr.c	2022-05-09 14:05:11.224068354 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr1_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr1_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/mpc8610hpcd/ddr.c.orig	2022-05-09 14:05:09.984118637 -0700
+++ u-boot-2011.03/board/freescale/mpc8610hpcd/ddr.c	2022-05-09 14:05:11.228068193 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_bus_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/p2020ds/ddr.c.orig	2022-05-09 14:05:09.988118475 -0700
+++ u-boot-2011.03/board/freescale/p2020ds/ddr.c	2022-05-09 14:05:11.232068031 -0700
@@ -17,11 +17,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr3_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(generic_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/mpc8572ds/ddr.c.orig	2022-05-09 14:05:09.984118637 -0700
+++ u-boot-2011.03/board/freescale/mpc8572ds/ddr.c	2022-05-09 14:05:11.228068193 -0700
@@ -17,11 +17,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/common/sys_eeprom.c.orig	2022-05-09 14:05:09.956119772 -0700
+++ u-boot-2011.03/board/freescale/common/sys_eeprom.c	2022-05-09 14:05:11.204069166 -0700
@@ -319,21 +319,89 @@
  * (i.e."XX:XX:XX:XX:XX:XX", where "XX" is a two-digit hex number) and
  * stores it in one of the MAC address fields of the EEPROM local copy.
  */
+
+
 static void set_mac_address(unsigned int index, const char *string)
 {
 	char *p = (char *) string;
 	unsigned int i;
+#ifdef CONFIG_LANNER_MFG
+	int j;
+	int flag =0;
+#endif
 
 	if ((index >= MAX_NUM_PORTS) || !string) {
+#ifdef CONFIG_LANNER_MFG
+		printf("Usage: mac <n> XXXXXXXXXXXX\n");
+#else
 		printf("Usage: mac <n> XX:XX:XX:XX:XX:XX\n");
+#endif
 		return;
 	}
 
+#ifdef CONFIG_LANNER_MFG
+	for (i = 0; *p && (i < 6); i++) {
+		e.mac[0][i] = h2i(p[i*2]) *16 + h2i(p[i*2 +1]);
+	}
+	if( index >= 1)
+	{
+		for( i = 0 ; i < index-1 ;i++)
+		{
+			flag = 0;
+			for( j = 5 ; j >= 0 ;j-- )
+			{
+				switch(j)
+				{
+				case 5:
+					if(e.mac[i][j] == 0xff)
+					{
+						flag = flag | (1<<(j-1));
+						e.mac[i+1][j] = 0;
+					}
+					else
+					{
+						e.mac[i+1][j] = e.mac[i][j] + 1;
+					}
+					break;
+				case 4:
+				case 3:
+				case 2:
+				case 1:
+					if(e.mac[i][j] != 0xff)
+					{
+						if((flag & (1<< j)) != 0)
+							e.mac[i+1][j] = e.mac[i][j] + 1 ;
+						else
+							e.mac[i+1][j] = e.mac[i][j];
+					}
+					else
+					{
+						if((flag & (1<< j)) != 0)
+						{
+							flag = flag | (1<<(j-1));
+							e.mac[i+1][j] = 0;
+						}
+						else
+							e.mac[i+1][j] = e.mac[i][j];
+					}
+				break;
+				case 0:
+					e.mac[i+1][j] = e.mac[i][j];
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+#else
 	for (i = 0; *p && (i < 6); i++) {
 		e.mac[index][i] = simple_strtoul(p, &p, 16);
 		if (*p == ':')
 			p++;
 	}
+#endif
+
 
 	update_crc();
 }
--- u-boot-2011.03/board/freescale/mpc8548cds/ddr.c.orig	2022-05-09 14:05:09.976118962 -0700
+++ u-boot-2011.03/board/freescale/mpc8548cds/ddr.c	2022-05-09 14:05:11.224068354 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 			unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/mpc8560ads/ddr.c.orig	2022-05-09 14:05:09.980118799 -0700
+++ u-boot-2011.03/board/freescale/mpc8560ads/ddr.c	2022-05-09 14:05:11.224068354 -0700
@@ -18,14 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr1_spd_eeprom_t));
 }
 
-
-unsigned int
-fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
-
 void
 fsl_ddr_get_spd(ddr1_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
--- u-boot-2011.03/board/freescale/mpc8568mds/ddr.c.orig	2022-05-09 14:05:09.980118799 -0700
+++ u-boot-2011.03/board/freescale/mpc8568mds/ddr.c	2022-05-09 14:05:11.224068354 -0700
@@ -18,12 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/corenet_ds/ddr.c.orig	2022-05-09 14:05:09.956119772 -0700
+++ u-boot-2011.03/board/freescale/corenet_ds/ddr.c	2022-05-09 14:05:11.204069166 -0700
@@ -119,11 +119,6 @@
 	}
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr3_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/freescale/mpc8569mds/ddr.c.orig	2022-05-09 14:05:09.980118799 -0700
+++ u-boot-2011.03/board/freescale/mpc8569mds/ddr.c	2022-05-09 14:05:11.228068193 -0700
@@ -18,12 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr3_spd_eeprom_t));
 }
 
-
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr3_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/stx/stxssa/ddr.c.orig	2022-05-09 14:05:10.160111500 -0700
+++ u-boot-2011.03/board/stx/stxssa/ddr.c	2022-05-09 14:05:11.356063002 -0700
@@ -18,14 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr1_spd_eeprom_t));
 }
 
-
-unsigned int
-fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
-
 void
 fsl_ddr_get_spd(ddr1_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
--- u-boot-2011.03/board/stx/stxgp3/ddr.c.orig	2022-05-09 14:05:10.160111500 -0700
+++ u-boot-2011.03/board/stx/stxgp3/ddr.c	2022-05-09 14:05:11.356063002 -0700
@@ -18,14 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr1_spd_eeprom_t));
 }
 
-
-unsigned int
-fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
-
 void
 fsl_ddr_get_spd(ddr1_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
--- u-boot-2011.03/board/sbc8560/ddr.c.orig	2022-05-09 14:05:10.144112149 -0700
+++ u-boot-2011.03/board/sbc8560/ddr.c	2022-05-09 14:05:11.344063488 -0700
@@ -18,14 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr1_spd_eeprom_t));
 }
 
-
-unsigned int
-fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
-
 void
 fsl_ddr_get_spd(ddr1_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
--- u-boot-2011.03/board/sbc8548/ddr.c.orig	2022-05-09 14:05:10.144112149 -0700
+++ u-boot-2011.03/board/sbc8548/ddr.c	2022-05-09 14:05:11.344063488 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 			unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/socrates/ddr.c.orig	2022-05-09 14:05:10.156111662 -0700
+++ u-boot-2011.03/board/socrates/ddr.c	2022-05-09 14:05:11.352063165 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/sbc8641d/ddr.c.orig	2022-05-09 14:05:10.144112149 -0700
+++ u-boot-2011.03/board/sbc8641d/ddr.c	2022-05-09 14:05:11.344063488 -0700
@@ -18,11 +18,6 @@
 	i2c_read(i2c_address, 0, 1, (uchar *)spd, sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_bus_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/xes/xpedite550x/ddr.c.orig	2022-05-09 14:05:10.204109715 -0700
+++ u-boot-2011.03/board/xes/xpedite550x/ddr.c	2022-05-09 14:05:11.380062028 -0700
@@ -46,11 +46,6 @@
 	}
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 /*
  *     There are traditionally three board-specific SDRAM timing parameters
  *     which must be calculated based on the particular PCB artwork.  These are:
--- u-boot-2011.03/board/xes/xpedite517x/ddr.c.orig	2022-05-09 14:05:10.200109878 -0700
+++ u-boot-2011.03/board/xes/xpedite517x/ddr.c	2022-05-09 14:05:11.380062028 -0700
@@ -32,11 +32,6 @@
 		sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_bus_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 			unsigned int ctrl_num)
 {
@@ -144,7 +139,7 @@
 	unsigned int datarate;
 
 	get_sys_info(&sysinfo);
-	datarate = fsl_ddr_get_mem_data_rate() / 1000000;
+	datarate = get_ddr_freq(0) / 1000000;
 
 	for (i = 0; i < ARRAY_SIZE(bopts_ctrl[ctrl_num]); i++) {
 		if ((bopts[i].datarate_mhz_low <= datarate) &&
--- u-boot-2011.03/board/xes/xpedite537x/ddr.c.orig	2022-05-09 14:05:10.204109715 -0700
+++ u-boot-2011.03/board/xes/xpedite537x/ddr.c	2022-05-09 14:05:11.380062028 -0700
@@ -33,11 +33,6 @@
 		 sizeof(ddr2_spd_eeprom_t));
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 		      unsigned int ctrl_num)
 {
--- u-boot-2011.03/board/xes/xpedite520x/ddr.c.orig	2022-05-09 14:05:10.200109878 -0700
+++ u-boot-2011.03/board/xes/xpedite520x/ddr.c	2022-05-09 14:05:11.380062028 -0700
@@ -27,11 +27,6 @@
 	}
 }
 
-unsigned int fsl_ddr_get_mem_data_rate(void)
-{
-	return get_ddr_freq(0);
-}
-
 void fsl_ddr_get_spd(ddr2_spd_eeprom_t *ctrl_dimms_spd,
 			unsigned int ctrl_num)
 {
--- u-boot-2011.03/common/env_common.c.orig	2022-05-09 14:05:10.232108580 -0700
+++ u-boot-2011.03/common/env_common.c	2022-05-09 14:05:11.408060893 -0700
@@ -120,6 +120,12 @@
 #ifdef  CONFIG_CLOCKS_IN_MHZ
 	"clocks_in_mhz=1\0"
 #endif
+#if defined(CONFIG_LANNER_MFG) || defined (CONFIG_SERCOMM_MFG)
+	"bootcmd_rtctest="      CONFIG_RTC_TEST         "\0"
+	"bootcmd_norflash_test="        CONFIG_NOR_TEST "\0"
+	"bootcmd_nandflash_test="       CONFIG_NAND_TEST "\0"
+	"bootcmd_dram_test="    CONFIG_DRAM_TEST "\0"
+#endif
 #if defined(CONFIG_PCI_BOOTDELAY) && (CONFIG_PCI_BOOTDELAY > 0)
 	"pcidelay="	MK_STR(CONFIG_PCI_BOOTDELAY)	"\0"
 #endif
--- u-boot-2011.03/common/cmd_date.c.orig	2022-05-09 14:05:10.216109230 -0700
+++ u-boot-2011.03/common/cmd_date.c	2022-05-09 14:05:11.396061380 -0700
@@ -103,6 +103,94 @@
 	return rcode;
 }
 
+#ifdef CONFIG_XTM330
+extern int testlog (int offset, unsigned char data);
+int do_rtc_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct rtc_time tm1;
+	struct rtc_time tm2;
+	int rcode = 0;
+	int old_bus;
+	int test_time = 1 ;
+	int current = 0;
+	test_time  = simple_strtoul(argv[1], NULL, 10);
+	printf("RTC Test:\n");
+	testlog(2,0);
+	if(test_time < 0  && test_time >= 60)
+	{
+		testlog(2,1);
+		printf("Test time error\n");
+		return 1;
+	}
+	/* switch to correct I2C bus */
+	old_bus = I2C_GET_BUS();
+	I2C_SET_BUS(CONFIG_SYS_RTC_BUS_NUM);
+	rcode = rtc_get (&tm1);
+
+	if (rcode) {
+		puts("## Get date failed\n");
+		return 1;
+	}
+
+	printf ("Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d\n",
+		tm1.tm_year, tm1.tm_mon, tm1.tm_mday,
+		(tm1.tm_wday<0 || tm1.tm_wday>6) ?
+			"unknown " : RELOC(weekdays[tm1.tm_wday]),
+		tm1.tm_hour, tm1.tm_min, tm1.tm_sec);
+
+	//system wait time
+	udelay(1000000*test_time);
+
+	rcode = rtc_get (&tm2);
+
+	if (rcode) {
+		puts("## Get date failed\n");
+		return 1;
+	}
+
+	printf ("Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d\n",
+		tm2.tm_year, tm2.tm_mon, tm2.tm_mday,
+		(tm2.tm_wday<0 || tm2.tm_wday>6) ?
+			"unknown " : RELOC(weekdays[tm2.tm_wday]),
+		tm2.tm_hour, tm2.tm_min, tm2.tm_sec);
+
+	if((tm1.tm_sec + test_time) < 60 )
+	{
+		if((tm1.tm_sec + test_time) == tm2.tm_sec)
+			current = 1;
+	}
+	else
+	{
+		if((tm1.tm_min + 1) == 60 )
+		{
+			if(tm2.tm_min == 0 )
+			{
+				if(((tm1.tm_sec + test_time)-60 ) == tm2.tm_sec)
+					current = 1;
+			}
+		}
+		else if((tm1.tm_min + 1) == tm2.tm_min)
+		{
+			if(((tm1.tm_sec + test_time)-60 ) == tm2.tm_sec)
+				current = 1;
+		}
+	}
+
+	if(current  == 1 )
+	{
+		printf("PASS\n");
+		testlog(2,99);
+	}
+	else
+	{
+		printf("FAIL\n");
+		testlog(2,2);
+	}
+	return 0;
+
+}
+#endif /* CONFIG_XTM330 */
+
 /*
  * simple conversion of two-digit string with error checking
  */
@@ -224,3 +312,11 @@
 	"  - with numeric argument: set the system date & time\n"
 	"  - with 'reset' argument: reset the RTC"
 );
+
+#ifdef CONFIG_XTM330
+U_BOOT_CMD(
+        rtc_test,       2,      1,      do_rtc_test,
+        "simple rtc read test for second",
+        "waittime\n"
+);
+#endif /* CONFIG_XTM330 */
--- u-boot-2011.03/common/cmd_pci.c.orig	2022-05-09 14:05:10.224108905 -0700
+++ u-boot-2011.03/common/cmd_pci.c	2022-05-09 14:05:11.400061218 -0700
@@ -507,3 +507,50 @@
 	"pci write[.b, .w, .l] b.d.f address value\n"
 	"    - write to CFG address"
 );
+
+#ifdef CONFIG_XTM330
+extern int testlog (int offset, unsigned char data);
+int do_pci_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int Device;
+        int Function=0;
+        unsigned char HeaderType;
+        unsigned short VendorID;
+        unsigned short deviceID;
+        int bus;
+        pci_dev_t dev;
+	int count = 0;
+
+        printf("PCI Device Detection: \n");
+
+        for (bus = 0 ; bus < 2 ;bus++)
+        {
+
+                for (Device = 0; Device < PCI_MAX_PCI_DEVICES; Device++) {
+                        HeaderType = 0;
+                        VendorID = 0;
+                        dev = PCI_BDF(bus, Device, Function);
+                        pci_read_config_word(dev, PCI_VENDOR_ID, &VendorID);
+                        if ((VendorID == 0xFFFF) || (VendorID == 0x0000))
+                                continue;
+			else
+				count++;
+
+                        pci_read_config_word(dev, PCI_DEVICE_ID, &deviceID);
+
+                        printf("PCIe Device ID =0x%04x ,Vendor = 0x%04x \n",VendorID,deviceID);
+                }
+		if(count)
+			testlog(9+bus,99);
+		else
+			testlog(9+bus,0);
+        }
+        return 0;
+}
+
+U_BOOT_CMD(
+        pci_test,       1,      1,      do_pci_test,
+        "PCI Device Detection:",
+        "pci_test "
+);
+#endif /* CONFIG_XTM330 */
--- u-boot-2011.03/common/cmd_bootm.c.orig	2022-05-09 14:05:10.216109230 -0700
+++ u-boot-2011.03/common/cmd_bootm.c	2022-05-09 14:05:11.396061380 -0700
@@ -226,7 +226,11 @@
 			&images, &images.os.image_start, &images.os.image_len);
 	if (images.os.image_len == 0) {
 		puts ("ERROR: can't get kernel image!\n");
+#ifdef CONFIG_WG_BOOTMENU
+		do_reset (NULL, 0, 0, NULL);
+#else
 		return 1;
+#endif
 	}
 
 	/* get image parameters */
@@ -967,7 +971,11 @@
 	default:
 		printf ("Wrong Image Format for %s command\n", cmdtp->name);
 		show_boot_progress (-108);
+#ifdef CONFIG_WG_BOOTMENU
+		do_reset (NULL, 0, 0, NULL);
+#else
 		return NULL;
+#endif
 	}
 
 	debug ("   kernel data at 0x%08lx, len = 0x%08lx (%ld)\n",
--- u-boot-2011.03/common/Makefile.orig	2022-05-09 14:05:10.216109230 -0700
+++ u-boot-2011.03/common/Makefile	2022-05-09 14:05:11.392061542 -0700
@@ -27,6 +27,7 @@
 
 # core
 COBJS-y += main.o
+COBJS-$(CONFIG_WG_BOOTMENU) += wgmenu.o
 COBJS-y += console.o
 COBJS-y += command.o
 COBJS-y += dlmalloc.o
@@ -47,6 +48,7 @@
 COBJS-y += cmd_version.o
 
 # environment
+COBJS-$(CONFIG_XTM330) += random.o
 COBJS-y += env_common.o
 COBJS-$(CONFIG_ENV_IS_IN_DATAFLASH) += env_dataflash.o
 COBJS-$(CONFIG_ENV_IS_IN_EEPROM) += env_eeprom.o
@@ -165,6 +167,8 @@
 COBJS-$(CONFIG_UPDATE_TFTP) += update.o
 COBJS-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
 
+COBJS-$(CONFIG_XTM330) += cmd_show.o
+
 
 COBJS	:= $(sort $(COBJS-y))
 XCOBJS	:= $(sort $(XCOBJS-y))
--- u-boot-2011.03/common/cmd_mem.c.orig	2022-05-09 14:05:10.224108905 -0700
+++ u-boot-2011.03/common/cmd_mem.c	2022-05-09 14:05:11.400061218 -0700
@@ -29,6 +29,9 @@
 
 #include <common.h>
 #include <command.h>
+#ifdef CONFIG_XTM330
+#include <random.h>
+#endif /* CONFIG_XTM330 */
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
@@ -618,6 +621,10 @@
  * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
  * interrupted by ctrl-c or by a failure of one of the sub-tests.
  */
+#ifdef CONFIG_LANNER_MFG
+extern int testlog (int offset, unsigned char data);
+#endif
+
 int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	vu_long	*addr, *start, *end;
@@ -692,6 +699,11 @@
 		if (iteration_limit && iterations > iteration_limit) {
 			printf("Tested %d iteration(s) with %lu errors.\n",
 				iterations-1, errs);
+#ifdef CONFIG_LANNER_MFG
+			if (errs != 0)
+			    testlog( 13, 99);
+#endif
+
 			return errs != 0;
 		}
 
@@ -728,6 +740,9 @@
 				"expected %08lx, actual %08lx\n",
 					  val, readback);
 			    errs++;
+#ifdef CONFIG_LANNER_MFG
+			    testlog (13 ,errs);
+#endif
 			    if (ctrlc()) {
 				putc ('\n');
 				return 1;
@@ -741,6 +756,9 @@
 				"Is %08lx, should be %08lx\n",
 					readback, ~val);
 			    errs++;
+#ifdef CONFIG_LANNER_MFG
+			    testlog (13 ,errs);
+#endif
 			    if (ctrlc()) {
 				putc ('\n');
 				return 1;
@@ -811,6 +829,9 @@
 				" expected 0x%.8lx, actual 0x%.8lx\n",
 				(ulong)&start[offset], pattern, temp);
 			errs++;
+#ifdef CONFIG_LANNER_MFG
+			testlog (13 ,errs);
+#endif
 			if (ctrlc()) {
 			    putc ('\n');
 			    return 1;
@@ -833,6 +854,9 @@
 				" 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx\n",
 				(ulong)&start[offset], pattern, temp);
 			    errs++;
+#ifdef CONFIG_LANNER_MFG
+			    testlog (13 ,errs);
+#endif
 			    if (ctrlc()) {
 				putc ('\n');
 				return 1;
@@ -875,6 +899,9 @@
 				" expected 0x%.8lx, actual 0x%.8lx)\n",
 				(ulong)&start[offset], pattern, temp);
 			errs++;
+#ifdef CONFIG_LANNER_MFG
+			testlog (13 ,errs);
+#endif
 			if (ctrlc()) {
 			    putc ('\n');
 			    return 1;
@@ -897,6 +924,9 @@
 				" expected 0x%.8lx, actual 0x%.8lx)\n",
 				(ulong)&start[offset], anti_pattern, temp);
 			errs++;
+#ifdef CONFIG_LANNER_MFG
+			testlog (13 ,errs);
+#endif
 			if (ctrlc()) {
 			    putc ('\n');
 			    return 1;
@@ -917,6 +947,10 @@
 		if (iteration_limit && iterations > iteration_limit) {
 			printf("Tested %d iteration(s) with %lu errors.\n",
 				iterations-1, errs);
+			if (errs != 0)
+#ifdef CONFIG_LANNER_MFG
+				testlog( 13, 99);
+#endif
 			return errs != 0;
 		}
 		++iterations;
@@ -942,6 +976,9 @@
 					"found %08lX, expected %08lX\n",
 					(uint)addr, readback, val);
 				errs++;
+#ifdef CONFIG_LANNER_MFG
+				testlog (13 ,errs);
+#endif
 				if (ctrlc()) {
 					putc ('\n');
 					return 1;
@@ -968,6 +1005,866 @@
 	return 0;	/* not reached */
 }
 
+#ifdef CONFIG_XTM330
+vu_long	*addr_lanner, *start_lanner, *end_lanner;
+#define SPINSZ 0x800000
+
+
+void random_init(void)
+{
+	vu_long *addr;
+	int timeout =0;
+	addr = (vu_long *)0xffe3a01c;
+	*addr = 1;
+	addr = (vu_long *)0xffe3a02c;
+	while ( (*addr & 1) == 0 && timeout < 500)
+		timeout++;
+
+	if(timeout >= 499 )
+		printf("random initial failed\n");
+	
+	addr = (vu_long *)0xffe3a014;
+	*addr = 0;
+}
+ulong random_freescale(void)
+{
+	
+	ulong *addr;
+	ulong random_value;
+	addr = (ulong *)0xffe3a800;
+	random_value = *addr;
+	addr = (ulong *)0xffe3a804;
+	random_value = *addr;
+	return random_value;
+}
+
+int movinv1(int iter,ulong p1,ulong p2)
+{
+
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,i;
+
+                
+//	printf ("\rPattern %08lX  Writing..."
+//		"%12s"
+//		"\b\b\b\b\b\b\b\b\b\b",
+//		p1, "");
+
+	pat = p1;
+	pe = end_lanner;
+	p = start_lanner;
+
+		while (p < pe) {
+			WATCHDOG_RESET();
+			*p = pat;
+			p++;
+		}
+
+//	puts ("Testing... ");
+	for( i =0 ;i< iter;i++)
+	{
+
+		pat = p1;
+		pe = end_lanner;
+		p = start_lanner;
+		for (; p < pe; p++) {
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = p2;
+		}
+
+		pat = p1;
+		pat = p2;
+		pe = start_lanner;
+		p = end_lanner-1;
+		do {
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = p1;
+		} while (p-- > pe);
+	}	
+	return errs;
+}
+
+
+int movinv32(int iter, ulong p1, ulong lb, ulong hb, int sval, int off)
+{
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,done=0,k;
+
+	ulong p3 = sval << 31;
+//MOVE 32 STEP 1
+	pat = p1;
+	k=off;
+	pe = start_lanner;
+	p = start_lanner;
+	done =0;
+//	printf ("\rPattern %08lX  Writing..."
+//		"%12s"
+//		"\b\b\b\b\b\b\b\b\b\b",
+//		p1, "");
+
+	do{
+		/* Check for overflow */
+		if ((pe + SPINSZ) > pe) {
+			pe += SPINSZ;
+		} else {
+			pe = end_lanner;
+		}
+                        
+		if (pe >= end_lanner) {
+			pe = end_lanner;
+			done++;
+		}
+		if (p == pe) {
+			break;
+		}
+		while (p < pe) {
+			WATCHDOG_RESET();
+			*p = pat;
+			if (++k >= 32) {
+				pat = lb;
+				k = 0;
+			} else {
+				pat = pat << 1;
+				pat |= sval;
+			}
+			p++;
+		}
+	}while(!done);
+
+	
+//MOVE 32 STEP 2
+//	puts ("Testing...");
+	pat = p1;
+	k=off;
+	pe = start_lanner;
+	p = start_lanner;
+	done =0;
+
+	do{
+		/* Check for overflow */
+		if ((pe + SPINSZ) > pe) {
+			pe += SPINSZ;
+		} else {
+			pe = end_lanner;
+		}
+                        
+		if (pe >= end_lanner) {
+			pe = end_lanner;
+			done++;
+		}
+		if (p == pe) {
+			break;
+		}
+		while(p <  pe){
+			WATCHDOG_RESET();
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = ~pat ;
+			if(++k >= 32)
+			{
+				pat = lb;
+				k=0;
+			}
+			else
+			{
+				pat = pat << 1;
+				pat |= sval;
+			}
+			p++;
+		}
+	}while(!done);
+		
+//MOVE 32 STEP 3
+	pat =lb;
+	if( 0!= ( k=(k-1) &31))	
+	{
+		pat = (pat << k);
+		if(sval)
+			pat |= ((sval << k) - 1);
+	}
+	k++;
+
+//MOVE 32 STEP 4
+		
+//	puts ("Testing2...");
+	pe = start_lanner;
+	p = end_lanner-1;
+	done = 0;
+	do{
+		WATCHDOG_RESET();
+		readback = *p;
+		if (readback != ~pat) {
+			printf ("\nMem error @ 0x%08X: "
+				"found %08lX, expected %08lX\n",
+				(uint)p, readback, ~pat);
+			errs++;
+			if (ctrlc()) {
+				putc ('\n');
+				return errs;
+			}
+		}
+		*p = pat ;
+		if(--k <= 0)
+		{
+			pat = hb;
+			k=32;
+		}
+		else
+		{
+			pat = pat >> 1;
+			pat |= p3;
+		}
+	}while( p-- > pe);
+	return errs;
+}
+
+int modtst(int offset, int iter, ulong p1, ulong p2)
+{
+
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,i,k;
+
+//MOVE 32 STEP 1
+
+//	printf ("\rPattern %08lX  Writing..."
+//		"%12s"
+//		"\b\b\b\b\b\b\b\b\b\b",
+//		p1, "");
+
+	pat = p1;
+	pe = end_lanner;
+	p = start_lanner + offset;
+
+                        
+	for (; p < pe; p += 20) {
+		*p = pat;
+	}
+	
+//	puts("Testing...");
+	for( i =0; i < iter ;i++)
+	{
+		pat = p2;
+		pe = end_lanner;
+		p = start_lanner;
+		k=0;
+		
+		for (; p < pe; p++) {
+			if (k != offset) {
+				*p = pat;
+			}
+			if (++k > 19) {
+				k = 0;
+			}
+		}
+	}
+
+	
+	pat = p1;
+	pe = end_lanner;
+	p = start_lanner + offset;
+	for (; p < pe; p += 20)
+	{
+		readback = *p;
+		if (readback != pat) {
+			printf ("\nMem error @ 0x%08X: "
+				"found %08lX, expected %08lX\n",
+				(uint)p, readback, pat);
+			errs++;
+			if (ctrlc()) {
+				putc ('\n');
+				return errs;
+			}
+		}
+		*p = p1;
+	}
+	return errs;
+}
+
+int  movinvr(void)
+{
+
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0,i;
+
+
+	int seed1,seed2;
+	seed1 = 521288629;
+	seed2 = 362436069;
+	rand_seed(seed1, seed2);
+//	printf ("\rPattern rand()  Writing..."
+//		"%12s"
+//		"\b\b\b\b\b\b\b\b\b\b",
+//		"");
+
+	
+	pe = end_lanner;
+	p = start_lanner;
+	for (; p < pe; p++) {
+		WATCHDOG_RESET();
+		*p = rand();
+	}
+
+//	puts("Testing...");
+	for( i =0 ; i < 2 ;i++)
+	{
+		rand_seed(seed1, seed2);
+		pe = end_lanner;
+		p = start_lanner;
+                                
+		for (; p < pe; p++) {
+			pat = rand();
+			if (i) {
+				pat = ~pat;
+			}
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+			*p = ~pat;
+		}
+	}
+	return errs;
+}
+
+
+int block_move(int iter)
+{
+	vu_long	*pe,*pp,*p;
+	ulong	errs = 0;
+	ulong	readback;
+	ulong	p2;
+	int count ;
+	int i;
+	int len;
+	count = (( end_lanner - start_lanner ) / 64 );
+	addr_lanner=start_lanner;
+	int done =0;
+	
+
+//	puts ("Writing...");
+		pe = start_lanner;
+		p = start_lanner;
+                done = 0;
+                do {
+                        /* Check for overflow */
+                        if ((pe + 0x8000000) > pe) {
+                                pe += 0x8000000;
+                        } else {
+                                pe = end_lanner;
+                        }
+                        if (pe >= end_lanner) {
+                                pe = end_lanner;
+                                done++;
+                        }
+                        if (p == pe) {
+                                break;
+                        }
+
+                        count  = ((ulong)pe - (ulong)p) / 64;
+//			printf("count = %d \n",count);
+                        int tmp_edx;
+                        int tmp_eax=1;
+                        do {
+                                tmp_edx = ~tmp_eax;
+                                for ( i=0; i < 16; i++) {
+                                        switch(i) {
+                                                case 4:
+                                                case 5:
+                                                case 10:
+                                                case 11:
+                                                case 14:
+                                                case 15:
+                                                        *p++ = tmp_edx;
+                                                        break;
+                                                default:
+                                                        *p++ = tmp_eax;
+                                                        break;
+                                        }
+                                }
+                                tmp_eax = (tmp_eax << 1) | (( tmp_eax >>31)&0x01);
+                        }while (--count >0);
+                } while (!done);
+//	puts ("Moving...");
+		pe = start_lanner;
+		p = start_lanner;
+		done = 0;
+		do {
+			/* Check for overflow */
+			if ((pe + 0x8000000) > pe) {
+				pe += 0x8000000;
+			} else {
+				pe = end_lanner;
+			}
+			if (pe >= end_lanner) {
+				pe = end_lanner;
+				done++;
+			}
+			if (p == pe) {
+				break;
+			}
+			pp = p + ((pe - p) / 2);
+			len  = ((ulong)pe -(ulong) p) / 8;
+			for( i =0 ;i< iter ;i++)
+			{
+				memcpy((ulong *)pp,(ulong *) p, len);
+				memcpy((ulong *)(p+8), (ulong *)pp, (len-8));
+				memcpy((ulong *)p,(ulong *)(pp+(len-8)), 8);
+			}
+			p = pe;
+		} while (!done);
+                pe = start_lanner;
+                p = start_lanner;
+                done = 0;
+                do {
+                        /* Check for overflow */
+                        if ((pe + 0x8000000) > pe) {
+                                pe += 0x8000000;
+                        } else {
+                                pe = end_lanner;
+                        }
+                        if (pe >= end_lanner) {
+                                pe = end_lanner;
+                                done++;
+                        }
+                        if (p == pe) {
+                                break;
+                        }
+                        while (p < pe) {
+				readback = *p;
+				p2 = *(++p);
+                                if (readback != p2) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, p2);
+				errs++;
+                                }
+                                p++;
+                        }
+
+		} while (!done);
+
+//	printf("\n");
+	return errs;
+}
+
+int bit_fade(void)//default 90Min
+{
+	
+	vu_long *pe,*p;
+	ulong pat ,readback;
+	int errs=0;
+
+                
+	pat = 0;
+	while(1)
+	{
+		pe = end_lanner;
+		p = start_lanner;
+
+			while (p < pe) {
+				WATCHDOG_RESET();
+				*p = pat;
+				p++;
+			}
+
+		//udelay(90000000);
+//		udelay(5400000000);//90min
+		udelay(450000000);//15min
+		udelay(450000000);//15min
+		udelay(450000000);//15min
+		udelay(450000000);//15min
+		udelay(450000000);//15min
+		udelay(450000000);//15min
+	
+//		puts ("Testing... ");
+		pe = end_lanner;
+		p = start_lanner;
+		do {
+			readback = *p;
+			if (readback != pat) {
+				printf ("\nMem error @ 0x%08X: "
+					"found %08lX, expected %08lX\n",
+					(uint)p, readback, pat);
+				errs++;
+				if (ctrlc()) {
+					putc ('\n');
+					return errs;
+				}
+			}
+		} while (p-- > pe);
+
+		if(pat == 0)
+			pat = -1;
+		else{
+			break;
+		}
+	}
+	return errs;
+}
+
+static ulong roundup_memtest(ulong value, ulong mask)
+{
+        return (value + mask) & ~mask;
+}
+
+int addr_tst1(void)
+{
+        int i, j, k;
+	vu_long *pt,*end,*p;
+        ulong mask, bank,p1,readback;
+	int errs=0;
+
+
+        /* Test the global address bits */
+        for (p1=0, j=0; j<2; j++) {
+
+                /* Set pattern in our lowest multiple of 0x20000 */
+                p = (ulong *)roundup_memtest((ulong)start_lanner, 0x1ffff);
+                *p = p1;
+
+                /* Now write pattern compliment */
+                p1 = ~p1;
+                end = end_lanner;
+                for (i=0; i<100; i++) {
+                        mask = 4;
+                        do {
+                                pt = (ulong *)((ulong)p | mask);
+                                if ((uintptr_t)pt == (uintptr_t)p) {
+                                        mask = mask << 1;
+                                        continue;
+                                }
+                                if ((uintptr_t)pt >= (uintptr_t)end) {
+                                        break;
+                                }
+                                *pt = p1;
+				readback = *p;
+				if (readback != ~p1) {
+					printf ("\nMem error @ 0x%08X: "
+						"found %08lX, expected %08lX\n",
+						(uint)p, readback, p1);
+						errs++;
+					i = 1000;
+					if (ctrlc()) {
+						putc ('\n');
+						return errs;
+					}
+				}
+                                mask = mask << 1;
+                        } while(mask);
+                }
+        }
+	
+	bank =0x40000;
+	if((end_lanner -start_lanner ) > 0x100000 )
+		bank =0x100000;
+		
+
+        for (p1=0, k=0; k<2; k++) {
+
+                        p = start_lanner;
+                        /* Force start address to be a multiple of 256k */
+                        p = (ulong *)roundup_memtest((ulong)p, bank - 1);
+                        end = end_lanner;
+                        while ((uintptr_t)p < (uintptr_t)end) {
+                                *p = p1;
+
+                                p1 = ~p1;
+                                for (i=0; i<200; i++) {
+                                        mask = 4;
+                                        do {
+                                                pt = (ulong *)
+                                                    ((ulong)p | mask);
+                                                if ((uintptr_t)pt == (uintptr_t)p) {
+                                                        mask = mask << 1;
+                                                        continue;
+                                                }
+                                                if ((uintptr_t)pt >= (uintptr_t)end) {
+                                                        break;
+                                                }
+                                                *pt = p1;
+						readback = *p;
+						if (readback != ~p1) {
+							printf ("\nMem error @ 0x%08X: "
+								"found %08lX, expected %08lX\n",
+								(uint)p, readback, ~p1);
+								errs++;
+							i = 200;
+							if (ctrlc()) {
+								putc ('\n');
+								return errs;
+							}
+                                                }
+                                                mask = mask << 1;
+                                        } while(mask);
+                                }
+                                if ((uintptr_t)(p + bank/4) > (uintptr_t)p) {
+                                        p += bank/4;
+                                } else {
+                                        p = end;
+                                }
+                                p1 = ~p1;
+                        }
+                p1 = ~p1;
+        }
+	return errs;
+}
+
+
+
+int addr_tst2(void)
+{
+        vu_long *pe,*p;
+        ulong pat ,readback;
+        int errs=0;
+
+        pe = end_lanner;
+        p = start_lanner;
+	while (p < pe) {
+		WATCHDOG_RESET();
+		*p =(ulong)p;
+		p++;
+	}
+
+	
+        pe = end_lanner;
+        p = start_lanner;
+	for (; p < pe; p++) {
+		readback = *p;
+        	pat = (ulong)p;                
+		if (readback != pat) {
+			printf ("\nMem error @ 0x%08X: "
+				"found %08lX, expected %08lX\n",
+				(uint)p, readback, pat);
+				errs++;
+			if (ctrlc()) {
+				putc ('\n');
+				return errs;
+			}
+		}
+	}
+	return errs;
+
+}
+
+
+/*
+ * Perform a memory test. A more complete alternative test can be
+ * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
+ * interrupted by ctrl-c or by a failure of one of the sub-tests.
+ */
+extern int testlog (int offset, unsigned char data);
+int do_ram_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong	errs = 0;
+	int iterations = 1;
+	int iteration_limit;
+	int i;
+	int count=0;
+	int error_count =0;
+
+	ulong	pattern;
+
+	if (argc > 1)
+		start_lanner = (ulong *)simple_strtoul(argv[1], NULL, 16);
+	else
+		start_lanner = (ulong *)0x1000;
+
+	if (argc > 2)
+		end_lanner = (ulong *)simple_strtoul(argv[2], NULL, 16);
+	else
+		end_lanner = (ulong *)0x3fd90000;
+
+	if (argc > 3)
+		iteration_limit = (ulong)simple_strtoul(argv[3], NULL, 16);
+	else
+		iteration_limit = 1;
+
+		printf("RAM Test:\n");
+		printf("iteration_limit =%d \n",iteration_limit);
+                random_init();
+
+		if (iteration_limit && iterations > iteration_limit) {
+			printf("Tested %d iteration(s) with %lu errors.\n",
+				iterations-1, errs);
+			return errs != 0;
+		}
+	testlog(20,0);
+	//Address test, walking ones
+	printf("Test 0 [Address test, own address]		:");
+	count = addr_tst1();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+
+	//Address test, own address
+	printf("Test 1 [Address test, own address]		:");
+	count = addr_tst2();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+	//Moving inversions, ones & zeros
+	printf("TEST 2 [Moving inversions, ones & zeros]	:");
+	pattern = 0 ;
+	count =  movinv1(iteration_limit,pattern,~pattern);
+	count +=  movinv1(iteration_limit,~pattern,pattern);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+	//Moving inversions, 8 bit pattern
+	printf("Test 3 [Moving inversions, 8 bit pattern]	:");
+	pattern = 0x80808080 ;
+	count =  movinv1(iteration_limit,pattern,~pattern);
+	count +=  movinv1(iteration_limit,~pattern,pattern);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+	//Moving inversions, random pattern
+	printf("Test 4 [Moving inversions, random pattern]	:");
+	pattern = random_freescale();
+	count = movinv1(iteration_limit,pattern,~pattern);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+
+	//Block move, 64 moves
+	printf("Test 5 [Block move, 64 moves]			:");
+	count += block_move(iteration_limit);
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+
+	//Moving inversions, 32 bit pattern
+	printf("Test 6 [Moving inversions, 32 bit pattern]	:");
+	
+	for( i = 0 ,pattern =1 ; pattern; pattern=pattern<<1,i++)
+	{
+		count = (movinv32(iteration_limit,pattern, 1, 0x80000000, 0, i));
+		count += (movinv32(iteration_limit,~pattern, 0xfffffffe, 0x7fffffff, 1, i));
+	}
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+	//Random number sequence
+	printf("Test 7 [Random number sequence]			:");
+	count = movinvr();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+	//Modulo 20, ones & zeros
+	printf("Test 8 [Modulo 20, ones & zeros]		:");
+	pattern = 0;
+	for(i=0 ;i< 20 ;i++)
+	{
+		count = modtst(i ,iteration_limit,pattern,~pattern);
+		count += modtst(i ,iteration_limit,~pattern,pattern);
+	}
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+	}
+	else
+		printf("PASS\n");
+
+
+
+	//Bit fade test, 90 min, 2 patterns
+	printf("Test 9 [Bit fade test, 90 min, 2 patterns]	:");
+	count = bit_fade();
+	if(count != 0)
+	{
+		printf("FAIL\n");
+		error_count += count ;
+		testlog(20,error_count);
+	}
+	else
+	{
+		printf("PASS\n");
+		testlog(20,99);
+	}
+	return 0;
+}
+#endif /* CONFIG_XTM330 */
 
 /* Modify memory.
  *
@@ -1360,3 +2257,11 @@
 	"srcaddr dstaddr [dstsize]"
 );
 #endif /* CONFIG_CMD_UNZIP */
+
+#ifdef CONFIG_XTM330
+U_BOOT_CMD(
+        ram_test,       4,      1,      do_ram_test,
+        "simple test",
+        "[start [end [iterations]]]"
+);
+#endif /* CONFIG_XTM330 */
--- u-boot-2011.03/common/miiphyutil.c.orig	2022-05-09 14:05:10.236108418 -0700
+++ u-boot-2011.03/common/miiphyutil.c	2022-05-09 14:05:11.472058298 -0700
@@ -481,3 +481,120 @@
 	}
 }
 #endif
+
+#ifdef CONFIG_WG_COMMON
+unsigned int RubyPhyReadReg (unsigned int interSMIaddr, unsigned int phyAddr,
+                                                        unsigned int phyReg, unsigned int *retVal)
+{
+        uint16_t regData;
+        int ix;
+
+        for(ix = 0 ; ix < SMI_TIMEOUT ; ix++)
+        {
+		miiphy_read("eTSEC1",  phyAddr, R_mSMI_REG0, &regData);
+                if(!(regData & R_SMI_BUSY))     /* xgi: until mSMI not busy, break to use mSMI port*/
+                        break;
+        }
+
+        if(ix == SMI_TIMEOUT)
+        {
+                printf("TimeOut Passed, mSMI stil in busy\n");
+        return 0;
+        }
+
+        regData =( ((interSMIaddr&=0x1f)) << 5 | (phyReg &=0x1f) | R_SMI_READ_OPCODE | R_SMI_22mode
+                        |R_SMI_go );
+
+	miiphy_write("eTSEC1",phyAddr, R_mSMI_REG0, regData);
+
+
+    for(ix = 0 ; ix < SMI_TIMEOUT ; ix++)
+        {
+		miiphy_read("eTSEC1",  phyAddr, R_mSMI_REG0, &regData);
+                if(!(regData & R_SMI_READ_VALID))       /* xgi: readvalid, so, break */
+                        break;
+        }
+    if(ix == SMI_TIMEOUT)
+        {
+                printf("TimeOut. mSMI Readvalid is not valid\n");
+        return 0;
+    }
+    miiphy_read("eTSEC1",  phyAddr, R_mSMI_REG1, &regData);
+
+    *retVal = 0xffff & regData;
+
+    return 1;
+}
+
+int RubyPhyWriteReg (unsigned int interSMIaddr, unsigned int phyAddr,
+                                                         unsigned int phyReg, unsigned int Val)
+{
+        uint16_t  regData, ix;
+
+        for(ix = 0 ; ix < SMI_TIMEOUT ; ix++)
+        {
+    		miiphy_read("eTSEC1",  phyAddr, R_mSMI_REG0, &regData);
+                if(!(regData & R_SMI_BUSY))     /* xgi: until mSMI not busy, break to use mSMI port*/
+                        break;
+        }
+        if(ix == SMI_TIMEOUT)
+        {
+                printf("TimeOut Passed Phy is busy\n");
+        return 0;
+        }
+        Val&=0xffff;
+	miiphy_write("eTSEC1",phyAddr, R_mSMI_REG1, Val);
+
+        regData =( ((interSMIaddr&=0x1f)) << 5 | (phyReg &=0x1f) | R_SMI_WRITE_OPCODE | R_SMI_22mode
+                        |R_SMI_go );
+
+	miiphy_write("eTSEC1",phyAddr, R_mSMI_REG0, regData);
+	
+
+    return 1;
+}
+
+unsigned int SMIRW(
+        int rw,                                 /* 0:read,   1:write */
+        int DevSMIAddr,   /* not used for 1112 type */
+        int Reg,                        /* for all */
+        int Val,
+        int MACchipSmiAddr,
+        int MasterSmiNum,
+        int PortSmiAddr,
+        uint16_t * readVal
+
+)
+{
+         int  retSta;
+         int  retVal,retBuf = 0;
+         if ((0<= PortSmiAddr) && (PortSmiAddr<=0xf)) { /* opal PHY */
+
+        retSta= RubyPhyReadReg (/* interSMIa*/ 0x1b, /* chipSmiAddr */DevSMIAddr, 4, (uint *)&retVal);
+        retBuf=retVal;
+        retSta= RubyPhyWriteReg (0x1b, DevSMIAddr, 4, (retBuf&0xBFFF)); /* clear bit 14 */
+
+        }
+
+        udelay(100);
+
+        if (rw==0){
+                retSta= RubyPhyReadReg (PortSmiAddr, DevSMIAddr, Reg, (uint *)&retVal);  
+        }else {
+                retSta= RubyPhyWriteReg (PortSmiAddr, DevSMIAddr, Reg, Val);
+        }
+        if ((0<=PortSmiAddr) & (PortSmiAddr<=0xf)) { /* recovey ppu for opal PHY */
+                retSta= RubyPhyWriteReg (0x1b,DevSMIAddr, 4, retBuf);/* recovery */
+        }
+        if (retSta == 1 ) {
+                if (rw==0){
+                *readVal=retVal;
+        }
+        else {
+                /* printf (" access ok\n" );  */
+        }
+        return 0;
+        }
+        return 0;
+}
+#endif /* CONFIG_WG_COMMON */
--- u-boot-2011.03/common/cmd_nand.c.orig	2022-05-09 14:05:10.224108905 -0700
+++ u-boot-2011.03/common/cmd_nand.c	2022-05-09 14:05:11.400061218 -0700
@@ -27,6 +27,9 @@
 #include <asm/byteorder.h>
 #include <jffs2/jffs2.h>
 #include <nand.h>
+#ifdef CONFIG_XTM330
+#include <random.h>
+#endif /* CONFIG_XTM330 */
 
 #if defined(CONFIG_CMD_MTDPARTS)
 
@@ -895,3 +898,106 @@
 	"boot from NAND device",
 	"[partition] | [[[loadAddr] dev] offset]"
 );
+
+#ifdef CONFIG_XTM330
+extern int testlog (int offset, unsigned char data);
+int do_nand_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        int i, ret = 0;
+        size_t off, size,rwsize,off_tmp;
+        nand_info_t *nand;
+	nand_erase_options_t opts;
+
+	u_char *datbuf, *rdatbuf;
+	int count;
+
+	if( argc < 2 )
+		return cmd_usage(cmdtp);
+
+	printf("NAND Flash Test:\n");
+	testlog(10,0);
+
+	/* the following commands operate on the current device */
+	if (nand_curr_device < 0 || nand_curr_device >= CONFIG_SYS_MAX_NAND_DEVICE ||
+	    !nand_info[nand_curr_device].name) {
+		puts("\nno devices available\n");
+		return 1;
+	}
+	nand = &nand_info[nand_curr_device];
+
+	datbuf = malloc(0x20000);
+	rdatbuf = malloc(0x20000);
+	for( i = 0 ; i < 0x20000;i++)
+		datbuf[i] = (uchar)rand();
+
+
+	off = simple_strtoul(argv[1], NULL, 16);
+	size = simple_strtoul(argv[2], NULL, 16);
+	memset(&opts, 0, sizeof(opts));
+	opts.offset = off;
+	opts.length = size;
+	opts.jffs2  = 0;
+	opts.quiet  = 0;
+	ret = nand_erase_opts(nand, &opts);
+	if(ret != 0)
+	{
+		printf("FAIL\n");
+		testlog(10,1);
+		free(datbuf);
+		free(rdatbuf);
+		return 1;
+	}
+
+	rwsize= 0x20000;
+	off_tmp = off;
+	for( i =0 ; i< (size / 0x20000);i++)
+	{
+		ret = nand_write_skip_bad(nand, off_tmp, &rwsize,(u_char *)datbuf, 0);
+		if(ret != 0)
+		{
+			printf("FAIL\n");
+			testlog(10,2);
+			free(datbuf);
+			free(rdatbuf);
+			return 1;
+		}
+		off_tmp+= 0x20000;
+	}
+
+	off_tmp = off;
+	for( i =0 ; i< (size / 0x20000);i++)
+	{
+		memset(rdatbuf, 0, sizeof(0x20000));
+		ret = nand_read_skip_bad(nand, off_tmp, &rwsize,(u_char *)rdatbuf);
+		if(ret != 0)
+		{
+			printf("FAIL\n");
+			testlog(10,3);
+			return 1;
+		}
+		count = 0x20000-1;
+		while(count -- > 0){
+			if(rdatbuf[count] != datbuf[count])
+			{
+				free(datbuf);
+				free(rdatbuf);
+				printf("FAIL\n");
+				testlog(10,4);
+				return 1;
+			}
+		}
+		off_tmp+= 0x20000;
+	}
+	free(datbuf);
+	free(rdatbuf);
+	testlog(10,99);
+	printf("PASS\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+	nand_test,	4,	1,	do_nand_test,
+	"simple nand test",
+	"[off [length ]]"
+);
+#endif /* CONFIG_XTM330 */
--- u-boot-2011.03/common/main.c.orig	2022-05-09 14:05:10.236108418 -0700
+++ u-boot-2011.03/common/main.c	2022-05-09 14:05:11.472058298 -0700
@@ -34,6 +34,11 @@
 #include <malloc.h>		/* for free() prototype */
 #endif
 
+#ifdef CONFIG_WG_BOOTMENU
+#include <wgmenu.h>
+#include <sha1.h>
+#endif
+
 #ifdef CONFIG_SYS_HUSH_PARSER
 #include <hush.h>
 #endif
@@ -209,6 +214,15 @@
 {
 	int abort = 0;
 
+#ifdef CONFIG_WG_BOOTMENU
+	wgmenu_show();
+	int wg_break = 0;
+	int wg_keypress = 0;
+	int wg_selected = 0;
+	const char wg_pw_hash[] = { 0xe5, 0x97, 0x30, 0x1a, 0x1d, 0x89, 0xff, 0x3f, 0x6d, 0x31, 0x8d, 0xbf, 0x4d, 0xba, 0x0a, 0x5a, 0xbc, 0x5e, 0xcb, 0xea};
+	char wg_csum_output[20];
+#endif
+
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
 #else
@@ -236,6 +250,54 @@
 		/* delay 100 * 10ms */
 		for (i=0; !abort && i<100; ++i) {
 			if (tstc()) {	/* we got a key press	*/
+# ifdef CONFIG_WG_BOOTMENU
+				/* Carriage return breaks us out of while() */
+				while (wg_keypress != 13) {
+					wg_keypress = getc();
+					wgmenu_hook(wg_keypress);
+					wg_selected = wgmenu_selected();
+					if (wg_keypress == 3) {	// CTRL+C
+						int wg_pw_len = 0;
+						wgmenu_exit();
+						printf("\x0D"); // go to the beginning of the line
+						printf("\e[2K"); // clear the line
+						wg_pw_len = readline("password> ");
+						/* This if statement will not break from while if
+						 * we type a carriage return. */
+						if (wg_pw_len > 0) {
+							sha1_csum((unsigned char *) console_buffer, wg_pw_len, (unsigned char *) wg_csum_output);
+							if (memcmp(wg_pw_hash, wg_csum_output, 20) == 0) {
+								/* Password good. Assert abort and break
+								 * to prompt. */
+								abort = 1;
+								bootdelay = 0;
+								wg_break = 1;
+								break;
+							} else {
+								/* Bad password. */
+								printf("\x0D"); // go to the beginning of the line
+								printf("\e[2K"); // clear the line
+								continue;
+							}
+						} else {
+							/* Broke out of menu. Start the menu over.
+							 * Tell me how you got here, becuase this shouldn't happen. */
+							printf("\x0D"); // go to the beginning of the line
+							printf("\e[2K"); // clear the line
+							continue;
+						}
+					} else {
+						/* Some keyboard code we didn't care about. Start
+						 * the menu over. */
+						continue;
+					}
+					udelay(10000);
+				}
+				bootdelay = 0;
+				wg_break = 1;
+				wgmenu_exit();
+				break;
+# else /* !CONFIG_WG_BOOTMENU */
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
 # ifdef CONFIG_MENUKEY
@@ -243,12 +305,42 @@
 # else
 				(void) getc();  /* consume input	*/
 # endif
+# endif /* CONFIG_WG_BOOTMENU */
 				break;
 			}
 			udelay(10000);
 		}
 
+#ifdef CONFIG_WG_BOOTMENU
+		if (!wg_break) {
+#endif /* CONFIG_WG_BOOTMENU */
 		printf("\b\b\b%2d ", bootdelay);
+#ifdef CONFIG_WG_BOOTMENU
+		}
+		if(getenv("Burn_In_Time") == NULL) {
+			if ((bootdelay == 0) && (abort != 1)) {
+				if (wg_selected >= 0) {
+					printf("\x0D"); // go to the beginning of the line
+					printf("\e[2K"); // clear the line
+					switch (wg_selected) {
+						case 1:
+							setenv("bootcmd", "run wgBootSysB");
+							printf("Booting SYSB");
+							break;
+						case 2:
+							setenv("bootcmd", "run wgBootRecovery");
+							printf("Booting Recovery");
+							break;
+						case 0:
+						default:
+							setenv("bootcmd", "run wgBootSysA");
+							printf("Booting SYSA");
+							break;
+					}
+				}
+			}
+		}
+#endif /* CONFIG_WG_BOOTMENU */
 	}
 
 	putc('\n');
@@ -265,6 +357,91 @@
 
 /****************************************************************************/
 
+#if defined(CONFIG_XTM330) || defined (CONFIG_XTM2_3)
+extern void hw_diagnose_n_dump(void);
+#endif
+
+#ifdef CONFIG_XTM2_3
+
+#define BUTTON_RESET			(0x01)
+/*
+* Read button status by given gpio number
+*/
+int read_btn_status(unsigned int btn)
+{
+	unsigned int reg_val;
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	reg_val = pgpio->gpdat;
+	/* Low active */
+	if (reg_val & (1 << (31 - btn)) )
+	return 0;
+	else
+	return 1;
+}
+
+int
+detect_SYSB_keypress(void)
+{
+	int status = 0;
+	int i;
+	for(i = 0; i < 3; i++) {
+
+	        if (read_btn_status(BUTTON_RESET)) {
+			printf("booting into SYSB ... \n");
+			status = 1;
+			break;
+		} 
+        	udelay(100);
+	}
+
+	return status;	
+}
+#endif // if CONFIG_XTM2_3
+
+#if defined(CONFIG_XTM330) && defined(CONFIG_XTM330_LCM)
+extern unsigned char detect_keypress(void);
+extern int lcd_puts (int line, char * text);
+extern int lcd_clear (void);
+#endif
+
+/*
+ * Seperated out to make the distingish between LANNER & SERCOMM calls
+*/
+int
+handle_flags(int flags, char **pS)
+{
+	int mfg_test = 0;
+
+	switch (flags)
+	{
+	case 2: /* RTC */
+		*pS = getenv ("bootcmd_rtctest");
+		mfg_test = 1;
+		break;
+	case 7: /* NOR FLASH */
+		*pS = getenv ("bootcmd_norflash_test");
+		mfg_test = 1;
+		break;
+	case 10:/* NAND FLASH */
+		*pS = getenv ("bootcmd_nandflash_test");
+		mfg_test = 1;
+		break;
+	case 20: /* DRAM */
+		*pS = getenv ("bootcmd_dram_test");
+		mfg_test = 1;
+		break;
+	case 0: /*Default setting */
+	default:
+		*pS = getenv ("bootcmd");
+		break;
+	}
+
+	printf("mfg_test = %d\n", mfg_test);
+	return mfg_test;
+}
+
+
 void main_loop (void)
 {
 #ifndef CONFIG_SYS_HUSH_PARSER
@@ -274,8 +451,22 @@
 	int flag;
 #endif
 
+#if defined(CONFIG_LANNER_MFG) || defined (CONFIG_SERCOMM_MFG)
+//WatchGuard TEST TOOLS
+       char *ss;
+       int select_flags = 0;
+
+       int mfg_test = 0;
+ #ifdef CONFIG_XTM2_3
+       int sysbReq;
+ #endif
+ #if defined(CONFIG_XTM330) && defined (CONFIG_XTM330_LCM)
+       int key, Key_Valid = 0;
+ #endif
+#endif /* #ifdef CONFIG_LANNER_MFG || CONFIG_SERCOMM_MFG */
+
 #if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
-	char *s;
+	char *s = NULL;
 	int bootdelay;
 #endif
 #ifdef CONFIG_PREBOOT
@@ -383,10 +574,84 @@
 	}
 	else
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
+
+#if defined(CONFIG_LANNER_MFG) || defined (CONFIG_SERCOMM_MFG)
+	if(getenv("Burn_In_Time") == NULL)
+	{
 		s = getenv ("bootcmd");
+	}
+	else
+	{
+		ss = getenv("Burn_In_Time");
+		select_flags = ss ? (int)simple_strtol(ss, NULL, 10) : 0 ;
+		mfg_test = handle_flags(select_flags, &s);
 
+#if defined(CONFIG_XTM330) || defined (CONFIG_XTM2_3)
+		hw_diagnose_n_dump();
+#endif
+	}
+#else
+		s = getenv ("bootcmd");
+#endif
 	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
+#ifdef CONFIG_XTM2_3
+	sysbReq = detect_SYSB_keypress();
+	if(sysbReq == 1) {
+		if(getenv("Burn_In_Time") != NULL) {
+			 /* Assuming that mfgsys is the only user of "Burn_In_Time" */
+			setenv("bootcmd", "run wgBootSercomm");
+		} else {
+			setenv("bootcmd", "run wgBootSysB");
+		}
+
+		s = getenv ("bootcmd");
+		printf("string = %s\n", s);
+		run_command (s, 0);
+	}
+#endif
+
+#if defined(CONFIG_XTM330) && defined(CONFIG_XTM330_LCM)
+		key = detect_keypress();
+		switch (key) {
+		case 'a': /* UP arrow pressed   - boot sysB */
+		case 'A': /* UP arrow depressed - boot sysB */
+			udelay(2000); /* wierd problem with LCM HW: needs more delay in case of UP arrow */
+			printf("Booting SysB\n");
+			lcd_clear();
+			udelay(1200); /* need some delay before it displays after clear */
+			lcd_puts (0, "Recovery Mode");
+			lcd_puts (1, "Starting ...");
+			setenv("bootcmd", "run wgBootSysB");
+			Key_Valid = 1;
+			break;
+		case 'b': /* DOWN arrow pressed   - boot SyaA Safe */
+		case 'B': /* DOWN arrow depressed - boot sysA Safe */
+			printf("Booting Recovery\n");
+			lcd_clear();
+			udelay(1300); /* need some delay before it displays after clear */
+			lcd_puts (0, "Safe Mode");
+			lcd_puts (1, "Starting ...");
+			setenv("bootcmd", "run wgBootRecovery");
+			Key_Valid = 1;
+			break;
+#if 0
+		/* more cases */
+		case 'C': /* Left Arrow detected */
+		case 'D': /* Right arrow detected */
+		case 'X': /* Times out */
+		case 'Y': /* NO KEY pressed */
+#endif
+		default:
+			// NOP
+			break;
+		}
+		if ( Key_Valid == 1) {
+			s = getenv ("bootcmd");
+			run_command (s, 0);
+		}
+#endif
+
 	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
 # ifdef CONFIG_AUTOBOOT_KEYED
 		int prev = disable_ctrlc(1);	/* disable Control C checking */
@@ -397,6 +662,21 @@
 # else
 		parse_string_outer(s, FLAG_PARSE_SEMICOLON |
 				    FLAG_EXIT_FROM_LOOP);
+
+ #if defined (CONFIG_LANNER_MFG) || defined (CONFIG_SERCOMM_MFG)
+		if (mfg_test == 1) {
+			setenv ("Burn_In_Time","0" );	/* make i go to default  case*/
+			/*
+			 * Save current environment with alt_loadaddr,
+			 * and cleared testaddr.
+			 */
+			
+			saveenv();
+			s = getenv ("bootcmd");
+			parse_string_outer(s, FLAG_PARSE_SEMICOLON |
+				    FLAG_EXIT_FROM_LOOP);
+		}
+ # endif // defined (CONFIG_LANNER_MFG) || defined (CONFIG_SERCOMM_MFG)
 # endif
 
 # ifdef CONFIG_AUTOBOOT_KEYED
@@ -438,6 +718,7 @@
 #endif
 		len = readline (CONFIG_SYS_PROMPT);
 
+
 		flag = 0;	/* assume no special flags for now */
 		if (len > 0)
 			strcpy (lastcommand, console_buffer);
--- u-boot-2011.03/common/env_embedded.c.orig	2022-05-09 14:05:10.232108580 -0700
+++ u-boot-2011.03/common/env_embedded.c	2022-05-09 14:05:11.408060893 -0700
@@ -25,7 +25,9 @@
 #define	__ASSEMBLY__			/* Dirty trick to get only #defines	*/
 #endif
 #define	__ASM_STUB_PROCESSOR_H__	/* don't include asm/processor.		*/
+#ifndef HOST_ONLY_BUILD
 #include <config.h>
+#endif /* #ifndef HOST_ONLY_BUILD */
 #undef	__ASSEMBLY__
 #include <environment.h>
 
@@ -177,6 +179,12 @@
 #ifdef	CONFIG_CLOCKS_IN_MHZ
 	"clocks_in_mhz=" "1"				"\0"
 #endif
+#if defined(CONFIG_LANNER_MFG) || defined (CONFIG_SERCOMM_MFG)
+	"bootcmd_rtctest="      CONFIG_RTC_TEST         "\0"
+	"bootcmd_norflash_test="        CONFIG_NOR_TEST "\0"
+	"bootcmd_nandflash_test="       CONFIG_NAND_TEST "\0"
+	"bootcmd_dram_test="    CONFIG_DRAM_TEST "\0"
+#endif
 #if defined(CONFIG_PCI_BOOTDELAY) && (CONFIG_PCI_BOOTDELAY > 0)
 	"pcidelay="	MK_STR(CONFIG_PCI_BOOTDELAY)	"\0"
 #endif
--- u-boot-2011.03/common/cmd_flash.c.orig	2022-05-09 14:05:10.220109067 -0700
+++ u-boot-2011.03/common/cmd_flash.c	2022-05-09 14:05:11.396061380 -0700
@@ -27,6 +27,11 @@
 #include <common.h>
 #include <command.h>
 
+#ifdef CONFIG_WG_COMMON
+#include <malloc.h>
+#include <random.h>
+#endif /* CONFIG_WG_COMMON */
+
 #ifdef CONFIG_HAS_DATAFLASH
 #include <dataflash.h>
 #endif
@@ -216,6 +221,15 @@
 
 	*s_count = 0;
 
+#if  (defined(CONFIG_XTM330) && !defined(CONFIG_FAILSAFE))
+/* Always protect Failsafe location while system is in NORMAL mode */
+	if (addr_last >= (CONFIG_SYS_TEXT_BASE+0x80000)) {
+		puts ("Error: Cannot unprotect/erase FailSafe bootloader in Normal mode\n");
+		rcode = 1;
+		return rcode;
+	}
+#endif
+
 	for (bank=0; bank < CONFIG_SYS_MAX_FLASH_BANKS; ++bank) {
 		s_first[bank] = -1;	/* first sector to erase	*/
 		s_last [bank] = -1;	/* last  sector to erase	*/
@@ -258,7 +272,7 @@
 				if (addr_last > b_end) {
 					s_last[bank] = s_end;
 				} else {
-					puts ("Error: end address"
+					printf ("Error: end address"
 						" not on sector boundary\n");
 					rcode = 1;
 					break;
@@ -287,6 +301,224 @@
 
 	return rcode;
 }
+
+
+#if defined(CONFIG_XTM330) || defined (CONFIG_XTM2_3)
+
+#define FL_PART_MAX_USAGE	0x700	/* (MFG results + DUMPLOGS ) */
+#define DUMP_SIZE		0x200
+#define DUMP_OFFSET_START	0x500
+#define DUMP_OFFSET_END		(FL_PART_MAX_USAGE)
+
+/*
+ *  Mukund J
+ * about@
+ *  - chelan used only first 25 bytes to record its MFG DATA.
+ *  - rest of it opne to world
+ *  - I decied to leave foirst 0x500 for MFG test expansion :)
+ *
+ * Info:
+ * So called bootopt partition is being used.
+ *  partition size == 704 KB 	(chelan = xtm330)
+ *  partition size == 64 KB 	(necaslte/newport = xtm2/3)
+ *
+ * Arguments:
+ *	buf: buffer pointer
+ *	size: size if buffer (max = 511 bytes) 1FFH
+ */
+int dumplog (const char *buf)
+{
+	int rcode = -1;
+	char log[0x700];
+	int fl_offset = 0;
+	int size = 0;
+
+	ulong flash_start,flash_end;
+	
+	if (!buf)
+		return rcode;
+	size = strlen(buf);
+
+	if (size >= DUMP_SIZE)	/* Max size limitation */
+		return rcode;
+
+	fl_offset = TEST_RESULT_OFFSET;
+	flash_start = CONFIG_SYS_FLASH_BASE + fl_offset;
+	flash_end   = CONFIG_SYS_FLASH_BASE + fl_offset + CONFIG_SYS_FLASH_SECT_SIZE - 1 ;
+
+	if( flash_sect_protect (0, flash_start, flash_end) != 0 )
+	{
+		printf("\nunprotect FAILED\n");
+		return rcode;
+	}
+        
+	/* Just GRAB the testlog data */
+	memcpy(log,(void *)(unsigned)flash_start, FL_PART_MAX_USAGE);
+
+	/* copy the recieved buffer over to log buffer */
+	memcpy(&log[DUMP_OFFSET_START], buf, size);
+	rcode = flash_sect_erase (flash_start, flash_end);
+	rcode = flash_write (log, flash_start, FL_PART_MAX_USAGE);
+
+	return rcode;
+}
+
+extern int board_add_ram_info_dump(char *buffer);
+
+void hw_diagnose_n_dump(void)
+{
+
+	/* grab the dat ainto this buffer */
+	int cnt = 0, temp;
+	char buffer[200];
+	char str[32];    
+	sys_info_t sysinfo;
+	int check;
+
+	memset(buffer, 0x0, sizeof(buffer));
+
+	get_sys_info(&sysinfo);
+
+	cnt = 0;
+	cnt = sprintf(buffer, "DDR: %s MT/s data rate\n",
+		strmhz(str, sysinfo.freqDDRBus));
+	cnt += sprintf((buffer + cnt), "CCB: %s MT/s data rate\n",
+		strmhz(str, sysinfo.freqSystemBus));
+	cnt += sprintf((buffer + cnt), "LOCAL: %s MT/s data rate\n",
+		strmhz(str, sysinfo.freqLocalBus));
+
+	/* Grab the DDR specifics */
+	temp = cnt;
+	cnt += board_add_ram_info_dump(&buffer[cnt]);
+	/* HACK: We need the MFG data to be store somehwere in NOR 
+	 * WHY: lazy, did not want to write a bunch of code in Linux :)
+	 */
+	check = dumplog (buffer);
+	if (check != ERR_OK)
+		printf ("Warning: dumplog failed, errno = %d\n", check);
+
+}
+
+
+int testlog (int offset, unsigned char data)
+{
+	int rcode = -1;
+	char log[0x700];
+	int fl_offset = 0;
+        
+	ulong flash_start,flash_end;
+
+	fl_offset = TEST_RESULT_OFFSET;
+	flash_start = CONFIG_SYS_FLASH_BASE + fl_offset;
+	flash_end   = CONFIG_SYS_FLASH_BASE + fl_offset + CONFIG_SYS_FLASH_SECT_SIZE - 1 ;
+
+	// printf("\nflash_start = 0x%08x, flash_end = 0x%08x, data = %c\n",
+	//			data, flash_start, flash_end, data);
+
+	if( flash_sect_protect (0, flash_start, flash_end) != 0 )
+	{
+		printf("\nunprotect-t FAILED\n");
+		return 1;
+	}
+        
+	/* Just GRAB the testlog data */
+	memcpy(log,(void *)(unsigned)flash_start, FL_PART_MAX_USAGE);
+
+	/* copy the test result */
+	log[offset] = data;
+	rcode = flash_sect_erase(flash_start, flash_end);
+	rcode = flash_write (log, flash_start, FL_PART_MAX_USAGE);
+
+	return rcode;
+}
+
+int do_flash_test (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+        flash_info_t *info;
+        int i, n, sect_first, sect_last;
+        int rcode = 0;
+	uchar *datbuf;
+	int size;
+	int rc;
+	printf("NOR Flash Test:\n");
+	testlog(7,0);
+        if ((n = abbrev_spec(argv[1], &info, &sect_first, &sect_last)) != 0) {
+                if (n < 0) {
+			printf("\nAbbrev Spec FAIL\n");
+			testlog(7,1);
+                        return 1;
+                }
+                printf("%sProtect Flash Sectors %d-%d in Bank # %zu\n",
+                        "Un-", sect_first, sect_last,
+                        (info-flash_info)+1);
+                for (i = sect_first; i <= sect_last; i++) {
+                        info->protect[i] = 0;
+                }
+        }
+        if (addr_spec(argv[1], argv[2], (ulong *)&sect_first,(ulong *)&sect_last) < 0){
+		printf("\nSpec FAIL\n");
+		testlog(7,2);
+                return 1;
+        }
+
+        if (sect_first >= sect_last) {
+		printf("\nLimit FAIL\n");
+		testlog(7,3);
+                return 1;
+        }
+	if( flash_sect_protect (0, sect_first, sect_last) != 0 )
+	{
+		printf("\nSec unprotect FAIL\n");
+		testlog(7,4);
+		return 1;
+	}
+
+	rcode = flash_sect_erase(sect_first, sect_last);
+	if(rcode < 0 )
+	{
+		printf("\nFlash Erase FAIL\n");
+		testlog(7,5);
+        	return rcode;
+	}
+	
+	size = sect_last - sect_first + 1;
+
+	datbuf = malloc(size);
+	for( i = 0 ;i< size ;i++)
+		datbuf[i] = (uchar)rand();
+
+	
+	rc = flash_write ((char *)datbuf, sect_first, size);
+
+	if( rc != 0 )
+	{
+		printf("\nFlash Write FAIL\n");
+		testlog(7,6);
+		free(datbuf);
+		return 1;
+	}
+
+	for(i= 0;i< size;i++)
+	{
+		if(datbuf[i] != *(u_char *)sect_first)
+		{
+			printf("Address %x diff buf = %x data =%x ",sect_first,datbuf[i],*(u_char *)sect_first);
+			printf("\nCompare FAIL\n");
+			testlog(7,7);
+			free(datbuf);
+			return 1;
+		}
+		sect_first++;
+	}
+
+	printf("\n PASS\n");
+	testlog(7,99);
+
+	free(datbuf);
+	return 0;
+}
+#endif /* CONFIG_XTM330 or CONFIG_XTM2_3 */
+
 #endif /* CONFIG_SYS_NO_FLASH */
 
 int do_flinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
@@ -737,6 +969,14 @@
 	"protect off all\n    - make all FLASH banks writable"
 );
 
+#ifdef CONFIG_XTM330
+U_BOOT_CMD(
+        flash_test,   3,   0,  do_flash_test,
+        "simple flash test",
+        "start end\n"
+);
+#endif /* CONFIG_XTM330 */
+
 #undef	TMP_ERASE
 #undef	TMP_PROT_ON
 #undef	TMP_PROT_OFF
--- u-boot-2011.03/arch/powerpc/include/asm/config_mpc85xx.h.orig	2022-05-09 14:05:09.716129504 -0700
+++ u-boot-2011.03/arch/powerpc/include/asm/config_mpc85xx.h	2022-05-09 14:05:10.928080358 -0700
@@ -86,7 +86,7 @@
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 
-#elif defined(CONFIG_P1011)
+#elif defined(CONFIG_P1011) || defined(CONFIG_XTM2)
 #define CONFIG_MAX_CPUS			1
 #define CONFIG_SYS_FSL_NUM_LAWS		12
 #define CONFIG_TSECV2
@@ -115,7 +115,7 @@
 #define CONFIG_TSECV2
 #define CONFIG_SYS_FSL_SEC_COMPAT	4
 
-#elif defined(CONFIG_P1020)
+#elif defined(CONFIG_P1020) || defined(CONFIG_XTM3)
 #define CONFIG_MAX_CPUS			2
 #define CONFIG_SYS_FSL_NUM_LAWS		12
 #define CONFIG_TSECV2
@@ -145,7 +145,7 @@
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC111
 #define CONFIG_SYS_FSL_ERRATUM_ESDHC_A001
 
-#elif defined(CONFIG_P2020)
+#elif defined(CONFIG_P2020) || defined(CONFIG_XTM330)
 #define CONFIG_MAX_CPUS			2
 #define CONFIG_SYS_FSL_NUM_LAWS		12
 #define CONFIG_SYS_FSL_SEC_COMPAT	2
--- u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/ddr/util.c.orig	2022-05-09 14:05:09.700130153 -0700
+++ u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/ddr/util.c	2022-05-09 14:05:10.916080844 -0700
@@ -8,10 +8,16 @@
 
 #include <common.h>
 #include <asm/fsl_law.h>
+#include <div64.h>
 
 #include "ddr.h"
 
-unsigned int fsl_ddr_get_mem_data_rate(void);
+/* To avoid 64-bit full-divides, we factor this here */
+#define ULL_2e12 2000000000000ULL
+#define UL_5pow12 244140625UL
+#define UL_2pow13 (1UL << 13)
+
+#define ULL_8Fs 0xFFFFFFFFULL
 
 /*
  * Round mclk_ps to nearest 10 ps in memory controller code.
@@ -22,35 +28,51 @@
  */
 unsigned int get_memory_clk_period_ps(void)
 {
-	unsigned int mclk_ps;
+	unsigned int data_rate = get_ddr_freq(0);
+	unsigned int result;
+
+	/* Round to nearest 10ps, being careful about 64-bit multiply/divide */
+	unsigned long long mclk_ps = ULL_2e12;
+
+	/* Add 5*data_rate, for rounding */
+	mclk_ps += 5*(unsigned long long)data_rate;
 
-	mclk_ps = 2000000000000ULL / fsl_ddr_get_mem_data_rate();
-	/* round to nearest 10 ps */
-	return 10 * ((mclk_ps + 5) / 10);
+	/* Now perform the big divide, the result fits in 32-bits */
+	do_div(mclk_ps, data_rate);
+	result = mclk_ps;
+
+	/* We still need to round to 10ps */
+	return 10 * (result/10);
 }
 
 /* Convert picoseconds into DRAM clock cycles (rounding up if needed). */
 unsigned int picos_to_mclk(unsigned int picos)
 {
-	const unsigned long long ULL_2e12 = 2000000000000ULL;
-	const unsigned long long ULL_8Fs = 0xFFFFFFFFULL;
-	unsigned long long clks;
-	unsigned long long clks_temp;
+	unsigned long long clks, clks_rem;
 
+	/* Short circuit for zero picos */
 	if (!picos)
 		return 0;
 
-	clks = fsl_ddr_get_mem_data_rate() * (unsigned long long) picos;
-	clks_temp = clks;
-	clks = clks / ULL_2e12;
-	if (clks_temp % ULL_2e12) {
+	/* First multiply the time by the data rate (32x32 => 64) */
+	clks = picos * (unsigned long long)get_ddr_freq(0);
+
+	/*
+	 * Now divide by 5^12 and track the 32-bit remainder, then divide
+	 * by 2*(2^12) using shifts (and updating the remainder).
+	 */
+	clks_rem = do_div(clks, UL_5pow12);
+	clks_rem <<= 13;
+	clks_rem |= clks & (UL_2pow13-1);
+	clks >>= 13;
+
+	/* If we had a remainder, then round up */
+	if (clks_rem)
 		clks++;
-	}
 
-	if (clks > ULL_8Fs) {
+	/* Clamp to the maximum representable value */
+	if (clks > ULL_8Fs)
 		clks = ULL_8Fs;
-	}
-
 	return (unsigned int) clks;
 }
 
@@ -109,6 +131,64 @@
 			 unsigned int memctl_interleaved,
 			 unsigned int ctrl_num);
 
+
+#if defined(CONFIG_XTM330) || defined (CONFIG_XTM2_3)
+
+int board_add_ram_info_dump(char *buffer)
+{
+#if defined(CONFIG_MPC85xx)
+	volatile ccsr_ddr_t *ddr = (void *)(CONFIG_SYS_MPC85xx_DDR_ADDR);
+#elif defined(CONFIG_MPC86xx)
+	volatile ccsr_ddr_t *ddr = (void *)(CONFIG_SYS_MPC86xx_DDR_ADDR);
+#endif
+#if (CONFIG_NUM_DDR_CONTROLLERS > 1)
+	uint32_t cs0_config = in_be32(&ddr->cs0_config);
+#endif
+	uint32_t sdram_cfg = in_be32(&ddr->sdram_cfg);
+	int cas_lat;
+	int cnt = 0;
+
+	cnt = sprintf(buffer, "(DDR");
+	switch ((sdram_cfg & SDRAM_CFG_SDRAM_TYPE_MASK) >>
+		SDRAM_CFG_SDRAM_TYPE_SHIFT) {
+	case SDRAM_TYPE_DDR1:
+		cnt += sprintf((buffer+cnt), "1");
+		break;
+	case SDRAM_TYPE_DDR2:
+		cnt += sprintf((buffer+cnt), "2");
+		break;
+	case SDRAM_TYPE_DDR3:
+		cnt += sprintf((buffer+cnt), "3");
+		break;
+	default:
+		cnt += sprintf((buffer+cnt), "?");
+		break;
+	}
+
+	if (sdram_cfg & SDRAM_CFG_32_BE) {
+		cnt += sprintf((buffer+cnt), ", 32-bit");
+	} else {
+		cnt += sprintf((buffer+cnt), ", 64-bit");
+	}
+
+	/* Calculate CAS latency based on timing cfg values */
+	cas_lat = ((in_be32(&ddr->timing_cfg_1) >> 16) & 0xf) + 1;
+	if ((in_be32(&ddr->timing_cfg_3) >> 12) & 1)
+		cas_lat += (8 << 1);
+	cnt += sprintf((buffer+cnt), ", CL=%d", cas_lat >> 1);
+	if (cas_lat & 0x1)
+		cnt += sprintf((buffer+cnt), ".5");
+
+	if (sdram_cfg & SDRAM_CFG_ECC_EN)
+		cnt += sprintf((buffer+cnt), ", ECC on)");
+	else
+		cnt += sprintf((buffer+cnt), ", ECC off)");
+	cnt += sprintf((buffer+cnt), "\n");
+
+	return cnt;
+}
+#endif // endof CONFIG_XTM330 or CONFIG_XTM2_3
+
 void board_add_ram_info(int use_default)
 {
 #if defined(CONFIG_MPC85xx)
--- u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/ddr/ddr.h.orig	2022-05-09 14:05:09.700130153 -0700
+++ u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/ddr/ddr.h	2022-05-09 14:05:10.916080844 -0700
@@ -80,5 +80,4 @@
 extern unsigned int mclk_to_picos(unsigned int mclk);
 extern unsigned int get_memory_clk_period_ps(void);
 extern unsigned int picos_to_mclk(unsigned int picos);
-extern unsigned int fsl_ddr_get_mem_data_rate(void);
 #endif
--- u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/ddr/ctrl_regs.c.orig	2022-05-09 14:05:09.700130153 -0700
+++ u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/ddr/ctrl_regs.c	2022-05-09 14:05:10.916080844 -0700
@@ -236,7 +236,7 @@
 	 * tAXPD=1, need design to confirm.
 	 */
 	int tXP = max((get_memory_clk_period_ps() * 3), 7500); /* unit=ps */
-	unsigned int data_rate = fsl_ddr_get_mem_data_rate();
+	unsigned int data_rate = get_ddr_freq(0);
 	tmrd_mclk = 4;
 	/* set the turnaround time */
 	trwt_mclk = 1;
--- u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/cpu.c.orig	2022-05-09 14:05:09.696130315 -0700
+++ u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/cpu.c	2022-05-09 14:05:10.912081006 -0700
@@ -68,6 +68,8 @@
 	CPU_TYPE_ENTRY(P1010, P1010_E, 1),
 	CPU_TYPE_ENTRY(P1011, P1011, 1),
 	CPU_TYPE_ENTRY(P1011, P1011_E, 1),
+	CPU_TYPE_ENTRY(XTM2, P1011, 1),
+	CPU_TYPE_ENTRY(XTM2, P1011_E, 1),
 	CPU_TYPE_ENTRY(P1012, P1012, 1),
 	CPU_TYPE_ENTRY(P1012, P1012_E, 1),
 	CPU_TYPE_ENTRY(P1013, P1013, 1),
@@ -76,6 +78,8 @@
 	CPU_TYPE_ENTRY(P1013, P1013_E, 1),
 	CPU_TYPE_ENTRY(P1020, P1020, 2),
 	CPU_TYPE_ENTRY(P1020, P1020_E, 2),
+	CPU_TYPE_ENTRY(XTM3, P1020, 2),
+	CPU_TYPE_ENTRY(XTM3, P1020_E, 2),
 	CPU_TYPE_ENTRY(P1021, P1021, 2),
 	CPU_TYPE_ENTRY(P1021, P1021_E, 2),
 	CPU_TYPE_ENTRY(P1022, P1022, 2),
@@ -84,6 +88,8 @@
 	CPU_TYPE_ENTRY(P2010, P2010_E, 1),
 	CPU_TYPE_ENTRY(P2020, P2020, 2),
 	CPU_TYPE_ENTRY(P2020, P2020_E, 2),
+	CPU_TYPE_ENTRY(XTM330, P2020, 2),
+	CPU_TYPE_ENTRY(XTM330, P2020_E, 2),
 	CPU_TYPE_ENTRY(P2040, P2040, 4),
 	CPU_TYPE_ENTRY(P2040, P2040_E, 4),
 	CPU_TYPE_ENTRY(P3041, P3041, 4),
--- u-boot-2011.03/arch/powerpc/cpu/mpc85xx/Makefile.orig	2022-05-09 14:05:09.684130802 -0700
+++ u-boot-2011.03/arch/powerpc/cpu/mpc85xx/Makefile	2022-05-09 14:05:10.900081493 -0700
@@ -56,6 +56,9 @@
 COBJS-$(CONFIG_P1013)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1014)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1020)	+= ddr-gen3.o
+COBJS-$(CONFIG_XTM330)	+= ddr-gen3.o
+COBJS-$(CONFIG_XTM2)	+= ddr-gen3.o
+COBJS-$(CONFIG_XTM3)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1021)	+= ddr-gen3.o
 COBJS-$(CONFIG_P1022)	+= ddr-gen3.o
 COBJS-$(CONFIG_P2010)	+= ddr-gen3.o
@@ -88,13 +91,16 @@
 COBJS-$(CONFIG_MPC8569) += mpc8569_serdes.o
 COBJS-$(CONFIG_MPC8572) += mpc8572_serdes.o
 COBJS-$(CONFIG_P1011)	+= p1021_serdes.o
+COBJS-$(CONFIG_XTM2)	+= p1021_serdes.o
 COBJS-$(CONFIG_P1012)	+= p1021_serdes.o
 COBJS-$(CONFIG_P1013)	+= p1022_serdes.o
 COBJS-$(CONFIG_P1020)	+= p1021_serdes.o
+COBJS-$(CONFIG_XTM3)	+= p1021_serdes.o
 COBJS-$(CONFIG_P1021)	+= p1021_serdes.o
 COBJS-$(CONFIG_P1022)	+= p1022_serdes.o
 COBJS-$(CONFIG_P2010)	+= p2020_serdes.o
 COBJS-$(CONFIG_P2020)	+= p2020_serdes.o
+COBJS-$(CONFIG_XTM330)	+= p2020_serdes.o
 COBJS-$(CONFIG_PPC_P3041) += p3041_serdes.o
 COBJS-$(CONFIG_PPC_P4080) += p4080_serdes.o
 COBJS-$(CONFIG_PPC_P5020) += p5020_serdes.o
--- u-boot-2011.03/arch/powerpc/cpu/mpc85xx/start.S.orig	2022-05-09 14:05:09.692130477 -0700
+++ u-boot-2011.03/arch/powerpc/cpu/mpc85xx/start.S	2022-05-09 14:05:10.908081168 -0700
@@ -384,6 +384,48 @@
 #ifdef CONFIG_SYS_RAMBOOT
 	b	_start_cont
 #else
+#if defined (CONFIG_XTM330) || defined (CONFIG_FAILSAFE)
+/* Check JP5 GPIO to determinate what's our next steps */
+	lis     r6,FSL_BOOKE_MAS0(0, 1, 0)@h
+	ori     r6,r6,FSL_BOOKE_MAS0(0, 1, 0)@l
+
+	lis     r7,FSL_BOOKE_MAS1(1, 0, 0, 1, BOOKE_PAGESZ_4K)@h
+	ori     r7,r7,FSL_BOOKE_MAS1(1, 0, 0, 1, BOOKE_PAGESZ_4K)@l
+
+	lis     r8,FSL_BOOKE_MAS2(CONFIG_SYS_CCSRBAR_DEFAULT+0xf000 , (MAS2_I|MAS2_G))@h
+	ori     r8,r8,FSL_BOOKE_MAS2(CONFIG_SYS_CCSRBAR_DEFAULT+0xf000, (MAS2_I|MAS2_G))@l
+
+	lis     r9,FSL_BOOKE_MAS3(CONFIG_SYS_CCSRBAR_DEFAULT+0xf000, 0, (MAS3_SW|MAS3_SR))@h
+	ori     r9,r9,FSL_BOOKE_MAS3(CONFIG_SYS_CCSRBAR_DEFAULT+0xf000, 0, (MAS3_SW|MAS3_SR))@l
+
+	mtxer   r3
+
+	mtspr   MAS0,r6
+	mtspr   MAS1,r7
+	mtspr   MAS2,r8
+	mtspr   MAS3,r9
+	mtspr   MAS7,r3
+	isync
+	msync
+	tlbwe
+
+	lis     r3, (CONFIG_SYS_CCSRBAR_DEFAULT +0xfc00+8)@h
+	ori     r3, r3, (CONFIG_SYS_CCSRBAR_DEFAULT +0xfc00+8)@l
+	lwz     r4, 0x0000(r3)
+
+	lis     r3, 0x80000000@h
+	ori     r3, r3, 0x80000000@l
+	and.    r4, r4, r3
+	bne     3f
+
+	lis     r3,0xeff00000@h
+	ori     r3,r3,0xeff00000@l
+	addi    r3,r3,_start_cont - _start + _START_OFFSET
+	mtlr    r3
+	blr
+3:
+/* Check GPIO end */
+#endif /* CONFIG_XTM330 || CONFIG_FAILSAFE */
 	/* Calculate absolute address in FLASH and jump there		*/
 	/*--------------------------------------------------------------*/
 	lis	r3,CONFIG_SYS_MONITOR_BASE@h
--- u-boot-2011.03/arch/powerpc/config.mk.orig	2022-05-09 14:05:09.660131776 -0700
+++ u-boot-2011.03/arch/powerpc/config.mk	2022-05-09 14:05:10.880082304 -0700
@@ -23,7 +23,11 @@
 
 CROSS_COMPILE ?= ppc_8xx-
 
+ifdef CONFIG_XTM2_3
+STANDALONE_LOAD_ADDR = 0x1000000
+else
 STANDALONE_LOAD_ADDR = 0x40000
+endif
 LDFLAGS_FINAL += --gc-sections
 PLATFORM_RELFLAGS += -mrelocatable -ffunction-sections -fdata-sections
 PLATFORM_CPPFLAGS += -DCONFIG_PPC -D__powerpc__
--- u-boot-2011.03/boards.cfg.orig	2022-05-09 14:05:10.216109230 -0700
+++ u-boot-2011.03/boards.cfg	2022-05-09 14:05:11.392061542 -0700
@@ -529,6 +529,14 @@
 P2020RDB_SDCARD              powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2020RDB,SDCARD
 P2020RDB_SPIFLASH            powerpc     mpc85xx     p1_p2_rdb           freescale      -           P1_P2_RDB:P2020RDB,SPIFLASH
 P4080DS                      powerpc     mpc85xx     corenet_ds          freescale
+XTM330                       powerpc     mpc85xx     xtm330              freescale      -           XTM330:XTM330,WG_COMMON
+XTM330_failsafe              powerpc     mpc85xx     xtm330              freescale      -           XTM330:XTM330,WG_COMMON,FAILSAFE
+XTM2                         powerpc     mpc85xx     xtm2_3              freescale      -           XTM2_3:XTM2,XTM2_3,WG_COMMON
+XTM2_failsafe                powerpc     mpc85xx     xtm2_3              freescale      -           XTM2_3:XTM2,XTM2_3,WG_COMMON,FAILSAFE
+XTM2_1M                      powerpc     mpc85xx     xtm2_3              freescale      -           XTM2_3:XTM2_1M,XTM2,XTM2_3,WG_COMMON
+XTM3                         powerpc     mpc85xx     xtm2_3              freescale      -           XTM2_3:XTM3,XTM2_3,WG_COMMON
+XTM3_failsafe                powerpc     mpc85xx     xtm2_3              freescale      -           XTM2_3:XTM3,XTM2_3,WG_COMMON,FAILSAFE
+XTM3_1M                      powerpc     mpc85xx     xtm2_3              freescale      -           XTM2_3:XTM3_1M,XTM3,XTM2_3,WG_COMMON
 mpq101                       powerpc     mpc85xx     mpq101              mercury        -           mpq101
 stxgp3                       powerpc     mpc85xx     stxgp3              stx
 stxssa                       powerpc     mpc85xx     stxssa              stx            -           stxssa
--- u-boot-2011.03/include/exports.h.orig	2022-05-09 14:05:10.508097389 -0700
+++ u-boot-2011.03/include/exports.h	2022-05-09 14:05:11.780045809 -0700
@@ -4,6 +4,10 @@
 #ifndef __ASSEMBLY__
 
 #include <common.h>
+#if defined (CONFIG_SERCOMM_MFG)
+#include <nand.h>
+#include "../drivers/rtc/s35390.h"
+#endif
 
 /* These are declarations of exported functions available in C code */
 unsigned long get_version(void);
@@ -29,6 +33,33 @@
 int i2c_write (uchar, uint, int , uchar* , int);
 int i2c_read (uchar, uint, int , uchar* , int);
 #endif
+#if defined (CONFIG_SERCOMM_MFG)
+int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+void * memcpy(void *,const void *,__kernel_size_t);
+void pciinfo(int, int);
+unsigned long long get_ticks(void);
+void * memset(void *,int,__kernel_size_t);
+int nand_erase_opts(nand_info_t *meminfo, const nand_erase_options_t *opts);
+int nand_read_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
+		       u_char *buffer);
+int nand_write_skip_bad(nand_info_t *nand, loff_t offset, size_t *length,
+			u_char *buffer, int withoob);
+int flash_sect_protect(int flag, ulong addr_first, ulong addr_last);
+int flash_write(char *, ulong, ulong);
+int flash_sect_erase(ulong addr_first, ulong addr_last);
+ulong usec2ticks(unsigned long usec);
+void flush_dcache(void);
+void invalidate_icache(void);
+void icache_disable(void);
+void dcache_disable(void);
+int memcmp(const void *,const void *,__kernel_size_t);
+ulong get_tbclk(void);
+nand_info_t *sc_get_nand_info_ptr(void);
+void sc_i2c_init(int speed, int slaveadd);
+void sc_rtc_init(void);
+int sc_rtc_get_time(SC_RTC_TIME * time);
+int sc_rtc_set_time(SC_RTC_TIME * time);
+#endif
 #include <spi.h>
 
 void app_startup(char * const *);
--- u-boot-2011.03/include/version.h.orig	2022-05-09 14:05:10.540096091 -0700
+++ u-boot-2011.03/include/version.h	2022-05-09 14:05:11.808044673 -0700
@@ -26,6 +26,23 @@
 
 #ifndef DO_DEPS_ONLY
 #include "version_autogenerated.h"
+#include "timestamp_autogenerated.h"
+#include "perforce_autogenerated.h"
 #endif
 
+#ifdef CONFIG_WG_COMMON
+#  define BUILD_VER PERFORCE_CHANGE " " U_BOOT_DATE
+#  if defined (CONFIG_XTM330)
+#    define BOARD_VER "XTM330 P2020"
+#  elif defined(CONFIG_XTM2_3)
+#    if defined (CONFIG_XTM2)
+#      define BOARD_VER "XTM2 P1011"
+#    elif defined (CONFIG_XTM3)
+#      define BOARD_VER "XTM3 P1020"
+#    endif
+#  endif
+#define BOARD_VERSION BOARD_VER " " BUILD_VER
+#endif /* CONFIG_WG_COMMON */
+
+
 #endif	/* __VERSION_H__ */
--- u-boot-2011.03/include/miiphy.h.orig	2022-05-09 14:05:10.524096740 -0700
+++ u-boot-2011.03/include/miiphy.h	2022-05-09 14:05:11.792045322 -0700
@@ -123,4 +123,30 @@
 #define ESTATUS_1000XF		0x8000
 #define ESTATUS_1000XH		0x4000
 
-#endif
+#ifdef CONFIG_WG_COMMON
+#define R_mSMI_REG0          0x0
+#define R_mSMI_REG1          0x1
+#define R_SMI_READ_OPCODE (2<<10)
+#define R_SMI_WRITE_OPCODE (1<<10)
+#define R_SMI_READ_VALID (1<<15)
+#define R_SMI_BUSY  (1<<15)             
+#define R_SMI_22mode    (1<<12)
+#define R_SMI_45mode    0
+#define R_SMI_go        (1<<15) 
+#define SMI_TIMEOUT     1000
+#define DLAY    udelay(1000);
+
+unsigned int SMIRW(
+        int rw,                                 /* 0:read,   1:write */
+        int DevSMIAddr,   /* not used for 1112 type */
+        int Reg,                        /* for all */
+        int Val,
+        int MACchipSmiAddr,
+        int MasterSmiNum,
+        int PortSmiAddr,
+        uint16_t *readVal
+
+);
+#endif /* CONFIG_WG_COMMON */
+
+#endif /* _miiphy_h_ */
--- u-boot-2011.03/include/common.h.orig	2022-05-09 14:05:10.400101768 -0700
+++ u-boot-2011.03/include/common.h	2022-05-09 14:05:11.672050188 -0700
@@ -192,7 +192,7 @@
 
 #if defined(CONFIG_ENV_IS_EMBEDDED)
 #define TOTAL_MALLOC_LEN	CONFIG_SYS_MALLOC_LEN
-#elif ( ((CONFIG_ENV_ADDR+CONFIG_ENV_SIZE) < CONFIG_SYS_MONITOR_BASE) || \
+#elif ( ((CONFIG_ENV_ADDR+CONFIG_ENV_SIZE) <= CONFIG_SYS_MONITOR_BASE) || \
 	(CONFIG_ENV_ADDR >= (CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)) ) || \
       defined(CONFIG_ENV_IS_IN_NVRAM)
 #define	TOTAL_MALLOC_LEN	(CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)
@@ -538,6 +538,10 @@
 #if defined(CONFIG_MPC86xx)
 typedef MPC86xx_SYS_INFO sys_info_t;
 void   get_sys_info  ( sys_info_t * );
+static inline ulong get_ddr_freq(ulong dummy)
+{
+	return get_bus_freq(dummy);
+}
 #endif
 
 #if defined(CONFIG_4xx) || defined(CONFIG_IOP480)
--- u-boot-2011.03/include/dtt.h.orig	2022-05-09 14:05:10.508097389 -0700
+++ u-boot-2011.03/include/dtt.h	2022-05-09 14:05:11.776045970 -0700
@@ -52,6 +52,7 @@
 #endif
 #endif /* CONFIG_DTT_ADM1021 */
 
+extern int _dtt_init(int sensor, int test, void *lookup);
 extern int dtt_init (void);
 extern int dtt_read(int sensor, int reg);
 extern int dtt_write(int sensor, int reg, int val);
--- u-boot-2011.03/include/_exports.h.orig	2022-05-09 14:05:10.396101930 -0700
+++ u-boot-2011.03/include/_exports.h	2022-05-09 14:05:11.668050351 -0700
@@ -21,6 +21,33 @@
 EXPORT_FUNC(simple_strtoul)
 EXPORT_FUNC(simple_strtol)
 EXPORT_FUNC(strcmp)
+#ifdef CONFIG_SERCOMM_MFG
+EXPORT_FUNC(do_go)
+EXPORT_FUNC(memcpy)
+EXPORT_FUNC(pciinfo)
+EXPORT_FUNC(get_ticks)
+EXPORT_FUNC(memset)
+EXPORT_FUNC(nand_erase_opts)
+EXPORT_FUNC(nand_write_skip_bad)
+EXPORT_FUNC(nand_read_skip_bad)
+EXPORT_FUNC(flash_sect_protect)
+EXPORT_FUNC(flash_write)
+EXPORT_FUNC(flash_sect_erase)
+EXPORT_FUNC(usec2ticks)
+EXPORT_FUNC(flush_dcache)
+EXPORT_FUNC(invalidate_icache)
+EXPORT_FUNC(icache_disable)
+EXPORT_FUNC(dcache_disable)
+EXPORT_FUNC(icache_enable)
+EXPORT_FUNC(dcache_enable)
+EXPORT_FUNC(memcmp)
+EXPORT_FUNC(get_tbclk)
+EXPORT_FUNC(sc_get_nand_info_ptr)
+EXPORT_FUNC(sc_i2c_init)
+EXPORT_FUNC(sc_rtc_init)
+EXPORT_FUNC(sc_rtc_get_time)
+EXPORT_FUNC(sc_rtc_set_time)
+#endif // CONFIG_SERCOMM_MFG
 EXPORT_FUNC(i2c_write)
 EXPORT_FUNC(i2c_read)
 EXPORT_FUNC(spi_init)
--- u-boot-2011.03/drivers/hwmon/lm63.c.orig	2022-05-09 14:05:10.276106796 -0700
+++ u-boot-2011.03/drivers/hwmon/lm63.c	2022-05-09 14:05:11.520056352 -0700
@@ -33,17 +33,27 @@
 #define DTT_I2C_DEV_CODE 0x4C	/* National LM63 device */
 
 #define DTT_READ_TEMP_RMT_MSB	0x01
+#define DTT_ALERT_STATUS	0x02
 #define DTT_CONFIG		0x03
 #define DTT_READ_TEMP_RMT_LSB	0x10
 #define DTT_TACHLIM_LSB		0x48
 #define DTT_TACHLIM_MSB		0x49
 #define DTT_FAN_CONFIG		0x4A
+#define DTT_TACH_CONFIG		0x4B
 #define DTT_PWM_FREQ		0x4D
 #define DTT_PWM_LOOKUP_BASE	0x50
+#define DTT_RMT_TEMP_FILTER	0xBF
+
+#define LM63_REG_REMOTE_HIGH_MSB        0x07
+#define LM63_REG_REMOTE_HIGH_LSB        0x13
+#define LM63_REG_REMOTE_LOW_MSB         0x08
+#define LM63_REG_REMOTE_LOW_LSB         0x14
+#define LM63_REG_REMOTE_TCRIT           0x19
+#define LM63_REG_REMOTE_TCRIT_HYST      0x21
 
 struct pwm_lookup_entry {
-	u8 temp;
-	u8 pwm;
+        u8 temp;
+        u8 pwm;
 };
 
 /*
@@ -93,18 +103,33 @@
 	return 0;
 }				/* dtt_write() */
 
-static int _dtt_init(int sensor)
+int _dtt_init(int sensor, int test, void *lookup)
 {
 	int i;
 	int val;
 
+	struct pwm_lookup_entry *lookup_p = lookup;
 	struct pwm_lookup_entry pwm_lookup[] = CONFIG_DTT_PWM_LOOKUPTABLE;
 
 	/*
 	 * Set PWM Frequency to 2.5% resolution
 	 */
-	val = 20;
-	if (dtt_write(sensor, DTT_PWM_FREQ, val) != 0)
+	if (!test) {
+		val = 7;
+		if (dtt_write(sensor, DTT_PWM_FREQ, val) != 0)
+			return 1;
+	}
+
+	val = 0x20;
+	if (dtt_write(sensor, DTT_FAN_CONFIG, val) != 0)
+		return 1;
+
+	val = 0x06;
+	if (dtt_write(sensor, DTT_RMT_TEMP_FILTER, val) != 0)
+		return 1;
+
+	val = 0x00;
+	if (dtt_write(sensor, DTT_TACH_CONFIG, val) != 0)
 		return 1;
 
 	/*
@@ -119,15 +144,37 @@
 	/*
 	 * Setup PWM Lookup-Table
 	 */
-	for (i = 0; i < sizeof(pwm_lookup) / sizeof(struct pwm_lookup_entry);
-	     i++) {
-		int address = DTT_PWM_LOOKUP_BASE + 2 * i;
-		val = pwm_lookup[i].temp;
-		if (dtt_write(sensor, address, val) != 0)
-			return 1;
-		val = pwm_lookup[i].pwm;
-		if (dtt_write(sensor, address + 1, val) != 0)
+	if (test) {
+
+		if (lookup_p == NULL)
 			return 1;
+		printf (" PWM Lookup-Table setup: printing custom ...\n");
+		for (i = 0; i < 3; i++) {
+			printf ("t=%d, p=%d\n", lookup_p[i].temp, lookup_p[i].pwm);
+		}
+
+		for (i = 0; i < 3; i++) {
+			int address = DTT_PWM_LOOKUP_BASE + 2 * i;
+			val = lookup_p[i].temp;
+			if (dtt_write(sensor, address, val) != 0)
+				return 1;
+			val = lookup_p[i].pwm;
+			if (dtt_write(sensor, address + 1, val) != 0)
+				return 1;
+		}
+	} else {
+
+		printf (" PWM Lookup-Table setup: default\n");
+		for (i = 0; i < sizeof(pwm_lookup) / sizeof(struct pwm_lookup_entry);
+		     i++) {
+			int address = DTT_PWM_LOOKUP_BASE + 2 * i;
+			val = pwm_lookup[i].temp;
+			if (dtt_write(sensor, address, val) != 0)
+				return 1;
+			val = pwm_lookup[i].pwm;
+			if (dtt_write(sensor, address + 1, val) != 0)
+				return 1;
+		}
 	}
 
 	/*
@@ -140,7 +187,7 @@
 	/*
 	 * Enable Tach input
 	 */
-	val = dtt_read(sensor, DTT_CONFIG) | 0x04;
+	val = dtt_read(sensor, DTT_CONFIG) | 0x05;
 	if (dtt_write(sensor, DTT_CONFIG, val) != 0)
 		return 1;
 
@@ -163,7 +210,7 @@
 	const char *const header = "DTT:   ";
 
 	for (i = 0; i < sizeof(sensors); i++) {
-		if (_dtt_init(sensors[i]) != 0)
+		if (_dtt_init(sensors[i], 0, NULL) != 0)
 			printf("%s%d FAILED INIT\n", header, i + 1);
 		else
 			printf("%s%d is %i C\n", header, i + 1,
--- u-boot-2011.03/drivers/mtd/nand/nand.c.orig	2022-05-09 14:05:10.292106148 -0700
+++ u-boot-2011.03/drivers/mtd/nand/nand.c	2022-05-09 14:05:11.532055865 -0700
@@ -39,6 +39,13 @@
 static const char default_nand_name[] = "nand";
 static __attribute__((unused)) char dev_name[CONFIG_SYS_MAX_NAND_DEVICE][8];
 
+#ifdef CONFIG_XTM2_3
+nand_info_t *sc_get_nand_info_ptr(void)
+{
+	return &nand_info[0];
+}                                                                                                                                                                                                                
+#endif
+
 static void nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
 			   ulong base_addr)
 {
--- u-boot-2011.03/drivers/rtc/Makefile.orig	2022-05-09 14:05:10.344104039 -0700
+++ u-boot-2011.03/drivers/rtc/Makefile	2022-05-09 14:05:11.580053918 -0700
@@ -65,6 +65,7 @@
 COBJS-$(CONFIG_RTC_S3C24X0) += s3c24x0_rtc.o
 COBJS-$(CONFIG_RTC_S3C44B0) += s3c44b0_rtc.o
 COBJS-$(CONFIG_RTC_X1205) += x1205.o
+COBJS-$(CONFIG_RTC_S35390) += s35390.o
 
 COBJS	:= $(sort $(COBJS-y))
 SRCS	:= $(COBJS:.o=.c)
--- u-boot-2011.03/drivers/net/tsec.c.orig	2022-05-09 14:05:10.336104363 -0700
+++ u-boot-2011.03/drivers/net/tsec.c	2022-05-09 14:05:11.572054243 -0700
@@ -148,7 +148,7 @@
 	priv->phyaddr = tsec_info->phyaddr;
 	priv->flags = tsec_info->flags;
 
-	sprintf(dev->name, tsec_info->devname);
+	sprintf(dev->name, "%s", tsec_info->devname);
 	dev->iobase = 0;
 	dev->priv = priv;
 	dev->init = tsec_init;
@@ -313,6 +313,33 @@
 			CONFIG_TSEC_TBICR_SETTINGS);
 }
 
+#ifdef CONFIG_XTM330
+static int miimcfg_config(void)
+{
+
+	if(CONFIG_DDR_CLK_FREQ == 66666666 )
+	{
+#ifdef CONFIG_FSL_CORENET
+		return MIIMCFG_INIT_VALUE;
+#else
+		volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+		int div;
+		div = ((gur->porpllsr) & 0x0000003e);
+		div >>= 1;
+#endif
+		if( div == 6 )
+			return 3;
+		else if(div == 8 )
+			return 4;
+		else
+			return MIIMCFG_INIT_VALUE;
+			
+	}
+	else
+		return MIIMCFG_INIT_VALUE;
+}
+#endif /* CONFIG_XTM330 */
+
 /* Discover which PHY is attached to the device, and configure it
  * properly.  If the PHY is not recognized, then return 0
  * (failure).  Otherwise, return 1
@@ -330,7 +357,12 @@
 	/* Reset MII (due to new addresses) */
 	priv->phyregs->miimcfg = MIIMCFG_RESET;
 	asm("sync");
+#ifndef CONFIG_XTM330
 	priv->phyregs->miimcfg = MIIMCFG_INIT_VALUE;
+#else
+	priv->phyregs->miimcfg = miimcfg_config(); 
+#endif /* !CONFIG_XTM330 */
+	
 	asm("sync");
 	while (priv->phyregs->miimind & MIIMIND_BUSY) ;
 
@@ -1885,7 +1917,11 @@
 
 	phyregs->miimcfg = MIIMCFG_RESET;
 
+#ifndef CONFIG_XTM330
 	phyregs->miimcfg = MIIMCFG_INIT_VALUE;
+#else
+	phyregs->miimcfg = miimcfg_config(); 
+#endif /* !CONFIG_XTM330 */
 
 	while (phyregs->miimind & MIIMIND_BUSY) ;
 
--- u-boot-2011.03/drivers/pci/pci.c.orig	2022-05-09 14:05:10.336104363 -0700
+++ u-boot-2011.03/drivers/pci/pci.c	2022-05-09 14:05:11.572054243 -0700
@@ -161,7 +161,6 @@
 		if (bus >= hose->first_busno && bus <= hose->last_busno)
 			return hose;
 
-	printf("pci_bus_to_hose() failed\n");
 	return NULL;
 }
 
--- u-boot-2011.03/mfgtools_cmd/macs.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/macs.h	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,151 @@
+
+/*
+ * MAC related headers: mainly for switch based platforms. NON-switch based platforms
+ *  might never need this.
+ *
+ * Split macs strctures adn functions from flash to make avoid #defining MACROS
+ *  specific to mac related funtionality(i.e. usage of struct mac_addr_info_st,
+ *  calls to mfg_write/read_macs).
+ * This will make the Makefiles more cleaner and just have as necessary MACROS as needed.
+ */
+
+#ifndef __MACS_H__
+#define __MACS_H__
+
+#define DIXIE_MAX_NUM_MACS 9
+#define DIXIE_MIN_NUM_MACS 3
+#define MAX_NUM_MACS DIXIE_MAX_NUM_MACS
+#define MIN_NUM_MACS DIXIE_MIN_NUM_MACS
+
+#ifndef NUM_MACS
+ #define NUM_MACS 8 /* some default value */
+#endif
+
+typedef struct mac_string_st {
+    char    mac[ 18 ];  /* big enough for a null terminate mac address string */
+    char    __pad[ 2];  /* Stupid alignment */
+} mac_string;
+
+
+/*
+ * Internal struture to read/write macs to different interface in a
+ * platform specific way.
+ */
+struct mac_addr_info_st {
+
+    union {
+        /* This array always starts with ethernets e.g. eth0->interface[0],
+            eth3->interface[3] followed by special interfaces if needed like
+            wireless on Edge and XTM2 
+        */
+        struct mac_string_st interface[MAX_NUM_MACS];
+
+	/*
+	 * The generic interface to which allows no change in API.
+	 * This has to exit @ all times.
+	 * Typically, the macs should fall right in order. But, under some 
+	 * special circumstances, they won't. Only platform will be agnostic 
+	 * of such details and it bears the responsibily of merging those gaps.
+	 *
+	 * Example: richland has only 6 wired macs and 2 wireless MACs
+	 * In such a case, richland impl of platform_mfg_read_macs / platform_mfg_write_macs
+	 * should be the overlay functions that convert data read from flash to generic
+	 * struct (which is the user facing data)
+	 */
+        struct {
+            struct mac_string_st eth0;
+            struct mac_string_st eth1;
+            struct mac_string_st eth2;
+            struct mac_string_st eth3;
+            struct mac_string_st eth4;
+            struct mac_string_st eth5;
+            struct mac_string_st eth6;
+            struct mac_string_st eth7;
+            struct mac_string_st eth8;
+
+            struct mac_string_st ath0;
+            struct mac_string_st ath1;
+	};
+
+	/*
+	 * Allow XTM 2-series(richland) to have 6 MACs for wired interfaces and
+	 * 2 MACs for wireless interfaces.
+	 */
+        struct {
+            struct mac_string_st eth0;
+            struct mac_string_st eth1;
+            struct mac_string_st eth2;
+            struct mac_string_st eth3;
+            struct mac_string_st eth4;
+            struct mac_string_st eth5;
+            struct mac_string_st ath0;
+            struct mac_string_st ath1;
+	} richland;
+
+	/*
+	 * Allow XTM 25-series(newcastle) to have 5 MACs for wired interfaces and
+	 * 2 MACs for wireless interfaces.
+	 */
+        struct {
+            struct mac_string_st eth0;
+            struct mac_string_st eth1;
+            struct mac_string_st eth2;
+            struct mac_string_st eth3;
+            struct mac_string_st eth4;
+            struct mac_string_st eth5; /* present for backward compatible reasons:
+					  check again and try to remove later */
+            struct mac_string_st ath0;
+            struct mac_string_st ath1;
+	} newcastle;
+
+	/*
+	 * Allow XTM 33-series(newport) to have 5 MACs for wired interfaces and
+	 * 2 MACs for wireless interfaces.
+	 */
+        struct {
+            struct mac_string_st eth0;
+            struct mac_string_st eth1;
+            struct mac_string_st eth2;
+            struct mac_string_st eth3;
+            struct mac_string_st eth4;
+            struct mac_string_st eth5; /* present for backward compatible reasons:
+					  check again and try to remove later */
+            struct mac_string_st ath0;
+            struct mac_string_st ath1;
+	} newport;
+
+	/*
+	 * Allow XTM 330-series(chelan2) to have 7 MACs for wired interfaces
+	 */
+        struct {
+            struct mac_string_st eth0;
+            struct mac_string_st eth1;
+            struct mac_string_st eth2;
+            struct mac_string_st eth3;
+            struct mac_string_st eth4;
+            struct mac_string_st eth5;
+            struct mac_string_st eth6;
+	} chelan2;
+
+	/*
+	 * Allow T10 (dixie) to have 3 MACs for wired interfaces
+	 */
+        struct {
+            struct mac_string_st eth0;
+            struct mac_string_st eth1;
+            struct mac_string_st eth2;
+	} dixie;
+    };
+};
+
+/* External/Exported Functions */
+int mfg_write_macs(struct mac_addr_info_st *macs); 
+
+/** This function either returns MAC adresses for all interfaces or it will fail 
+    if there is problem or given platform has no way how to read them back
+
+    - @retval 0 in case of success or -1 in case of error. (errno may be set)
+ */
+int mfg_read_macs(struct mac_addr_info_st *macs); 
+
+#endif // #endof __MACS_H__
--- u-boot-2011.03/mfgtools_cmd/md5.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/md5.h	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,87 @@
+/**
+ *
+ * @file md5.h
+ *
+ * @brief md5 checksum
+ *
+ * @author Maury Miller
+ * Copyright &copy; 2005, WatchGuard Technologies, Inc.
+ * All Rights Reserved
+ *
+ * @date Tue Nov 8 2005
+ *
+ * @par Function:
+ *
+ *      Header file for md5 functions.
+ *        
+ */
+
+#ifndef WGUT_MD5_H_
+#define WGUT_MD5_H_
+
+// #include <endian.h>
+#include <linux/types.h>
+
+#define MD5HEX_LEN   16
+#define MD5ASCII_LEN 32
+
+typedef struct {
+    u_int32_t buf[4];
+    u_int32_t bits[2];
+    u_int32_t in[64];
+} wgut_MD5_CTX;
+
+/*
+** md5buf()
+**
+** INPUT: md5 == pointer to 16-byte buffer to hold final MD5
+**        buf == pointer to memory location to sum
+**        len == size of memory 
+**
+** OUTPUT: md5 will be calculated and stored in *md5
+**
+*/
+void wgut_md5buf(unsigned char *md5, void *buf, size_t buflen);
+
+
+/*
+ * convert ASCII to hex 
+*/
+extern void wgut_ASCII2HEX(unsigned char *md5buf, const unsigned char *ascii, int length);
+
+#define wgut_ascii2hex wgut_ASCII2HEX
+
+#define ASCII2MD5(md5buf, ascii) \
+    wgut_ASCII2HEX((md5buf), (ascii), MD5HEX_LEN)
+    
+/* convert 16-byte hex to ASCII
+ *
+ * NOTE: No NULL-terminator is written to 'ascii' -- you must terminate
+ * after the call if you wish!!!
+*/
+void wgut_HEX2ASCII(unsigned char *ascii, const unsigned char *md5buf, int n);
+
+#define wgut_hex2ascii wgut_HEX2ASCII
+
+
+#define MD52ASCII(ascii, md5buf) \
+    wgut_HEX2ASCII((ascii), (md5buf), MD5HEX_LEN)
+
+/*
+ * NOTE: this string is built from right-to-left - so, it is safe
+ * to use a single buffer for dual-purpose, ie:
+ *
+ *    wgut_MD5_CTX md5;
+ *    char buf[33];  // note: room for NULL-terminator
+ *    wgut_MD5Init(&md5);
+ *    wgut_MD5Update(&md5, foobar, foobar_length);
+ *    wgut_MD5Final(buf, &md5);
+ *    MD52ASCII(buf, buf);
+ *    buf[32] = 0;
+ */
+
+void wgut_MD5Init(wgut_MD5_CTX *ctx);
+void wgut_MD5Update(wgut_MD5_CTX *ctx, unsigned char *buf, size_t len);
+void wgut_MD5Final(unsigned char digest[16], wgut_MD5_CTX *ctx);
+
+#endif /* WGUT_MD5_H_ */
--- u-boot-2011.03/mfgtools_cmd/crc16.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/crc16.h	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,15 @@
+/*
+ * crc16 routines for validatiing WG Serial number
+ */
+
+#ifndef __CRC16_H__
+#define __CRC16_H__
+
+#if 0
+#include <sys/types.h>
+#endif
+#include <linux/types.h>
+
+u_int16_t mfg_serial_crc_byte(u_int16_t crc, const u_int8_t nextbyte);
+
+#endif /* __CRC16_H__ */
--- u-boot-2011.03/mfgtools_cmd/mfgtools-private.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/mfgtools-private.h	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,170 @@
+
+#ifndef __MFGTOOLS_PRIVATE__
+#define __MFGTOOLS_PRIVATE__
+
+#include "macs.h"
+
+#define SERIAL_LENGTH               (100)
+#define WG_SERIAL_LENGTH            13
+#define OEM_SERIAL_LENGTH           18
+
+#define MFG_BLOCK_DATA_SIZE     ( 6 * 1024 )          // The size of the data entry for each block
+#define MFG_MAGIC_HEADER_SIG    ( 0x12611920 )        // The magic number to look for
+#define MFG_MAGIC_HEADER_CLIENT_AUTHSIG ( 0x12611925 )  // magic number to serve as CLIENT_AUTH version number (serves for both client_auth and client_auth_key)
+
+/*! 
+ * Each info block in the mfg partition has a header
+ */
+typedef struct {
+    char checksum[16];              /*! This is the md5 checksum */
+    int  length;                    /*! The length of the data to follow */
+    int  signature;                 /*! The 'magic' signature */
+} mfg_blk_hdr_st;
+
+
+/*! 
+ * Each info block are stored with a header + max 6K of data 
+ */
+typedef struct {
+    mfg_blk_hdr_st hdr;             /*! Header  */
+    char data[MFG_BLOCK_DATA_SIZE]; /*! Storage */
+} mfg_info_blk_st;
+
+
+/*!
+ * Allthough this isn't used anywhere, it is used to show the layout of 
+ * the manufactoring file (or partition), we use the offsetof macro to 
+ * find the correct offset into the file
+ * 
+ * don't go bigger than 64k or you'll have to do some debugging....
+ * (this is a little less than 33KB, 0x9060)
+ *
+ * This file is re-opened and data re-read, or written every time a call
+ * requires it. This is because each entry may be written and updated in the 
+ * mean time by other entities like httpd / ftpd. 
+ *
+ * TODO: Does this file/partition need some synchronization?
+ */
+typedef struct {
+    mfg_info_blk_st serial;          /*! Serial Number */
+    mfg_info_blk_st macs;            /*! HW addresses for network interfaces */
+    mfg_info_blk_st client_auth;     /*! ssl authentication data */
+    mfg_info_blk_st client_auth_key; /*! ssl authentication key */
+} mfg_param_blk_st;
+
+struct mfg_ctx_st;
+typedef struct mfg_ctx_st mfg_ctx_t;
+
+typedef enum {
+    MFG_CONFIG_SERIAL  = 0, 
+    MFG_CONFIG_MACS    = 1,
+    MFG_CONFIG_CLIENT_AUTH  = 2,
+    MFG_CONFIG_CLIENT_AUTH_KEY  = 3
+} mfg_config_t;
+
+
+#if 0
+typedef struct mfg_ctx_st *(*mfg_config_init_fn)( void );
+
+typedef void (*mfg_config_cleanup_fn) ( struct mfg_ctx_st *ctx );
+
+typedef int (*mfg_config_read_fn)     ( struct mfg_ctx_st *ctx, 
+        mfg_config_t cfg, char *data, int *length );
+
+typedef int (*mfg_config_update_fn)   ( struct mfg_ctx_st *ctx, 
+        mfg_config_t cfg, const char *data, int length );
+
+typedef int (*mfg_config_have_fn)     ( struct mfg_ctx_st *ctx, 
+        mfg_config_t cfg );
+
+typedef int (*mfg_config_invalidate_fn) ( struct mfg_ctx_st *ctx, 
+        mfg_config_t cfg );
+#endif
+
+typedef enum {
+    MFG_SUCCESS         =  0,
+    MFG_ERROR           = -1,
+    MFG_BAD_CHECKSUM    = -2,
+    MFG_BAD_MAGIC       = -3,
+    MFG_BAD_SIZE        = -4,
+    MFG_BAD_DEVICE      = -5
+} mfg_return_t;
+
+#if 0
+typedef struct {
+    mfg_config_init_fn       config_init;
+    mfg_config_cleanup_fn    config_cleanup;
+    mfg_config_read_fn       config_read;
+    mfg_config_update_fn     config_update;
+    mfg_config_have_fn       config_have;
+    mfg_config_invalidate_fn config_invalidate;
+} mfg_callback_st;
+#endif
+
+/*  struct to represet the Ethernet Chip and routine to read/extract HW MAC ADDRESS from that Ethernet Chip */
+struct ether_mac_tools {
+
+    const char *vendor;
+
+    uint32_t  vendor_id;
+    uint32_t  device_id;
+
+    int (*fetch_mac) (unsigned char *mac);
+};
+
+
+#if 0
+mfg_callback_st *mfg_config_funcs( void );
+
+/* local platform exports: __attribute__ ((visibility("hidden"))) */
+int platform_mfg_read_macs( struct mac_addr_info_st *macs );
+int platform_mfg_write_macs( struct mac_addr_info_st *macs );
+int platform_mfg_read_serial(char *serial, int len);
+int platform_mfg_write_serial(char *serial);
+int platform_mfg_read_oem_serial(char *serial, int len);
+int platform_mfg_write_oem_serial(char *serial);
+int mfg_valid_serial(const char *str);
+#endif
+
+/* local mfgtools exports: __attribute__ ((visibility("hidden"))) */
+int mfg_valid_serial(const char *str);
+int read_config_block( mfg_config_t cfg, mfg_info_blk_st *block );
+int update_config_block(mfg_config_t cfg, char *mfg_block, char *data, int len);
+int mfg_update_flashpart(mfg_config_t cfg, char *buff, int len);
+
+#if 0
+int mfg_read_config( mfg_ctx_t *ctx, mfg_config_t cfg, char *data, int *len );
+int mfg_update_config( mfg_ctx_t *ctx, mfg_config_t cfg, const char *data, int length);
+int mfg_invalidate_config( mfg_ctx_t *ctx, mfg_config_t cfg );
+int mfg_have_config( mfg_ctx_t *ctx, mfg_config_t cfg );
+void mfg_cleanup_config( mfg_ctx_t *ctx );
+#endif
+
+/*
+ * stuff imported from __MFG_CONFIG_FLASHMEDIA__.h file
+ * 
+ */
+#define DEFAULT_CONFIG_DEVICE			FLASH_DEV_CFG0_BLOCK
+#define DEFAULT_FLASHMEDIA_CONFIGURATION_OFFSET	( 0x0 )
+
+/*! 
+ * \brief  
+ * 
+ * \vislibility Exported Data structure
+ */
+typedef struct cfg_media_info {
+    char device[20];	/* device file "PATH/name" */
+    int  base_offset;	/* base location of config params */
+
+} cfg_media_info_st;
+
+#if 0
+/* Exported Functions */
+mfg_callback_st *mfg_flashmedia_config_funcs( struct cfg_media_info *);
+#endif
+
+
+
+
+
+#endif // ififdef __MFGTOOLS_PRIVATE__
--- u-boot-2011.03/mfgtools_cmd/md5.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/md5.c	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,412 @@
+/**
+ * $Id:
+ *
+ * @file md5.c
+ *
+ * @brief md5 hashing functions for the usertool library 
+ *
+ * Copyright &copy; 2005, WatchGuard Technologies, Inc.
+ * All Rights Reserved
+ *
+ * @date Tue Feb 12 2014
+ *
+ * @par Function:
+ *
+ *     md5 hashing functions.
+ *
+ */
+
+#include <common.h>
+
+#if 0
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+#endif
+
+#include "md5.h"
+
+static void MD5Transform(u_int32_t buf[4], u_int32_t in[16]);
+
+#if (__BYTE_ORDER == __LITTLE_ENDIAN)
+#define WGbyteReverse(buf, len)   /* Nothing */
+#else
+static void WGbyteReverse(unsigned char *buf, u_int32_t longs);
+
+/**
+ * @brief This function reverses byte order of data.
+ *
+ * @param buf - data to reverse
+ *
+ * @param longs - length of buffer
+ *
+ * @retval none
+ *
+ * Note: this code is harmless on little-endian machines. 
+ */
+static void WGbyteReverse(unsigned char *buf, u_int32_t longs)
+{
+#ifdef DEBUG
+    fprintf(stderr,"WGbyteReverse() lib/wgcrypto/md5.c\n");
+#endif
+
+    u_int32_t t;
+
+    do {
+        t = (u_int32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
+            ((unsigned) buf[1] << 8 | buf[0]);
+        *(u_int32_t *) buf = t;
+        buf += 4;
+    } while (--longs);
+}
+#endif
+
+
+/**
+ * @brief Function performs md5 hash by calling three helper functions
+ *
+ * @param md5 - 16 byte digest
+ *
+ * @param buf - input buffer
+ *
+ * @param buflen - length of buf
+ *
+ * @retval none
+ * 
+ */
+void wgut_md5buf(unsigned char *md5, void *buf, size_t buflen) {
+    wgut_MD5_CTX ctx;
+  
+    wgut_MD5Init(&ctx);
+    wgut_MD5Update(&ctx, buf, buflen);
+    wgut_MD5Final(md5, &ctx);
+}
+
+static char *hextab = "0123456789abcdef";
+
+/*
+ * @brief Function converts hex string to.
+ * NOTE: caller must ensure that 'ascii' is at least 32 bytes long !!!
+ *
+ * @param ascii - buffer with ascii
+ *
+ * @param md5buf - buffer with hex
+ *
+ * @param n - length
+ *
+ * @retval none
+ * 
+ */
+void wgut_HEX2ASCII(unsigned char *ascii, const unsigned char *md5buf, int n) {
+    int i = 0;
+    int l = n - 1;
+    int l2 = n + n - 1;
+
+    for(i=0; i < n; i++) {
+        ascii[l2-(i*2)]   = hextab[  md5buf[l - i] & 0x0f      ];
+        ascii[l2-(i*2)-1] = hextab[ (md5buf[l - i] & 0xf0) >> 4];   
+    }
+}
+
+static unsigned char chrtab[0x100] = {
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+  0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
+/*
+ * @brief Function converts an ascii string to hex.
+ * NOTE: caller must ensure that 'ascii' is at least 32 bytes long !!!
+ *
+ * @param md5buf - buffer with hex
+ *
+ * @param ascii - buffer with ascii
+ *
+ * @param length - length
+ *
+ * @retval none
+ * 
+ */
+void wgut_ASCII2HEX(unsigned char *md5buf, const unsigned char *ascii, int length) {
+    int i = 0;
+    
+    for (i = 0; i < length; i++) {
+        md5buf[i] = (chrtab[ (int)(ascii[i*2]) ] << 4) | 
+            chrtab[(int)(ascii[i*2+1])];
+    }
+
+    return;
+}
+
+/**
+ * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ *
+ * @param ctx - wgut_MD5_CTX
+ *
+ * @retval none
+ * 
+ */
+void wgut_MD5Init(wgut_MD5_CTX *ctx) {
+  memset(ctx, 0, sizeof(wgut_MD5_CTX));
+  ctx->buf[0] = 0x67452301;
+  ctx->buf[1] = 0xefcdab89;
+  ctx->buf[2] = 0x98badcfe;
+  ctx->buf[3] = 0x10325476;
+  
+  ctx->bits[0] = 0;
+  ctx->bits[1] = 0;
+}
+
+
+/**
+ * @brief Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ *
+ * @param ctx - wgut_MD5_CTX
+ *
+ * @param buf - input buffer
+ *
+ * @param len - buffer length
+ *
+ * @retval none
+ * 
+ */
+void wgut_MD5Update(wgut_MD5_CTX *ctx, unsigned char *buf, size_t len) {
+    size_t t;
+
+    if (len == 0)
+        return;
+
+  /* Update bitcount */  
+    t = ctx->bits[0];
+    if ((ctx->bits[0] = (t + (len << 3))&0xffffffffUL) < t)
+        ctx->bits[1]++; 	/* Carry from low to high */
+    ctx->bits[1] += len >> 29;
+  
+    t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */
+  
+    /* Handle any leading odd-sized chunks */
+    if (t) {
+        unsigned char *p = (unsigned char *) ctx->in + t;
+    
+        t = 64 - t;
+        if (len < t) {
+            memmove(p, buf, len);
+            return;
+        }
+
+        memmove(p, buf, t);
+        WGbyteReverse((unsigned char*)ctx->in, 16);
+        MD5Transform(ctx->buf, ctx->in);
+        buf += t;
+        len -= t;
+    }
+    
+    /* Process data in 64-byte chunks */
+    while (len >= 64) {
+        memmove(ctx->in, buf, 64);
+        WGbyteReverse((unsigned char*)ctx->in, 16);
+        MD5Transform(ctx->buf, ctx->in);
+        buf += 64;
+        len -= 64;
+    }
+  
+    /* Handle any remaining bytes of data. */
+  
+    memmove(ctx->in, buf, len);
+}
+
+/**
+ * @brief Final wrapup - pad to 64-byte boundary with the bit pattern 
+ * 1 0* (64-bit count of bits processed, MSB-first)
+ *
+ * @param digest - md5 digest
+ *
+ * @param ctx - wgut_MD5_CTX
+ *
+ * @retval none
+ * 
+ */
+void wgut_MD5Final(unsigned char digest[16], wgut_MD5_CTX *ctx) {
+  unsigned count;
+  unsigned char *p;
+
+  /* Compute number of bytes mod 64 */
+  count = (ctx->bits[0] >> 3) & 0x3F;
+
+  /* Set the first char of padding to 0x80.  This is safe since there is
+     always at least one byte free */
+  p = (unsigned char*)ctx->in + count;
+  *p++ = 0x80;
+
+  /* Bytes of padding needed to make 64 bytes */
+  count = 64 - 1 - count;
+
+  /* Pad out to 56 mod 64 */
+  if (count < 8) {
+    /* Two lots of padding:  Pad the first block to 64 bytes */
+    memset(p, 0, count);
+    WGbyteReverse((unsigned char*)ctx->in, 16);
+    MD5Transform(ctx->buf, ctx->in);
+
+    /* Now fill the next block with 56 bytes */
+    memset(ctx->in, 0, 56);
+  } else {
+    /* Pad block to 56 bytes */
+    memset(p, 0, count - 8);
+  }
+  WGbyteReverse((unsigned char*)ctx->in, 14);
+
+  /* Append length in bits and transform */
+  ctx->in[14] = ctx->bits[0];
+  ctx->in[15] = ctx->bits[1];
+
+  MD5Transform(ctx->buf, ctx->in);
+  WGbyteReverse((unsigned char *) ctx->buf, 4);
+  memmove(digest, ctx->buf, 16);
+  memset(ctx, 0, sizeof(*ctx));        /* In case it's sensitive */
+}
+
+
+/* The four core functions - F1 is optimized somewhat */
+
+/* #define F1(x, y, z) (x & y | ~x & z) */
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+/* This is the central step in the MD5 algorithm. */
+#define MD5STEP(f, w, x, y, z, data, s) \
+	( w += f(x, y, z) + (data),  w = w<<s | (w&0xffffffff)>>(32-s),  w += x )
+
+/*
+ * @brief The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data.  MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ *
+ * @param buf - md5 hash
+ *
+ * @param in - new data
+ *
+ * @retval none
+ * 
+ */
+static void MD5Transform(u_int32_t buf[4], u_int32_t in[16]) {
+  register unsigned long a, b, c, d;
+
+  a = buf[0];
+  b = buf[1];
+  c = buf[2];
+  d = buf[3];
+
+  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+  buf[0] += a;
+  buf[1] += b;
+  buf[2] += c;
+  buf[3] += d;
+}
+
+
+
+
+
+
+
--- u-boot-2011.03/mfgtools_cmd/cmd_wgtools.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/cmd_wgtools.c	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,300 @@
+/*
+ * U-boot - wgtools.c
+ *
+ * Copyright (c) 2005-2008 WatchGuard Technologies.
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <linux/ctype.h>
+#include <errno.h>
+#include <stdio_dev.h>
+#include <exports.h>
+
+#if 0
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#endif
+
+#if 0
+#include <net.h>
+#endif
+
+#include "mfgtools-private.h"
+#include "macs.h"
+
+#define IFNAMSIZ        16
+
+
+extern int console_assign(int file, const char *devname);
+
+
+/* WG Serial tools */
+int do_storeserial(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i=0, j=0;
+	char serial_copy[SERIAL_LENGTH+1];
+	char *name;
+
+	if (argc != 2)
+		return -1;
+
+	/*argv[1] shgould be 'serialnum' */
+	name = argv[1];
+
+	/* strip any white spaces and '-' */
+	while ( name[i] ) {
+		if ( isalnum(name[i]) ) {
+			serial_copy[j]=name[i];
+			j++;
+		}
+		i++;
+	}
+	serial_copy[j]=0;
+
+	/* Validate the serial */
+	if (mfg_valid_serial(serial_copy) == 0) {
+		printf ("Invalid Serial: please recheck your serial\n");
+ 		return -2;
+	}
+
+	/* write the serial */
+	return mfg_update_flashpart(MFG_CONFIG_SERIAL,
+			serial_copy, (strlen(serial_copy) + 1));
+}
+
+U_BOOT_CMD(
+	storeserial, 2, 0, do_storeserial,
+	"store WG serial in WG specific way\n",
+	"[wgserialnum]\n");
+
+int do_readserial(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret;
+	char serial[SERIAL_LENGTH];
+	mfg_info_blk_st block;
+
+	ret = read_config_block( MFG_CONFIG_SERIAL, &block);
+
+	if ( block.hdr.length ) {
+		memmove( serial, block.data, block.hdr.length );
+		printf("WG Serial: %s\n", serial);
+	}
+
+	return ret;
+}
+
+U_BOOT_CMD(
+	readserial, 1, 1, do_readserial,
+	"read WG serial",
+	"");
+
+
+/* WG MAC tools */
+int do_storemacs(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i=0;
+    	int length = sizeof( struct mac_addr_info_st );
+	struct mac_addr_info_st macs;
+	int nr_macs = argc -1;
+
+	if (nr_macs > (MAX_NUM_MACS))
+		return -1;
+	if (nr_macs < (MIN_NUM_MACS))
+		return -1;
+
+	/* do some basic validatation on the input MACS
+	 * i.e. look for the first ':' in the mac address: i.e. 00':'90:0b:1e:7e:34
+	 */
+	for (i=0;i<nr_macs;i++) {
+		if (argv[i+1][2] != ':' ) {
+			printf("Invalid macaddres passed in: %s\n", argv[i+1]);
+			printf("each MAC address provided should be seperated by ':'.\n"
+			       "    example: 00:90:0b:1e:7e:34");
+			return -1;
+		}
+	}
+
+	for (i=0;i<nr_macs;i++) {
+		strcpy(macs.interface[i].mac, argv[i+1]);
+	}
+
+	return mfg_update_flashpart(MFG_CONFIG_MACS, (char *)&macs, length);
+}
+
+U_BOOT_CMD(
+	storemacs, 10, 0, do_storemacs,
+	"store 9 WG MAC addresses in WG specific way",
+	"[mac1] [mac2] [mac3]\n"
+	"	- note: each MAC address provided should be seperated by ':'.\n"
+	"	   example: 00:90:0b:1e:7e:34");
+
+#define MAC_ADDR_EXP(data) \
+    &(data)[0], &(data)[1], &(data)[2], &(data)[3], &(data)[4], &(data)[5]
+ 
+static int showmac( char *device, char *macstr )
+{
+	if (!device || !macstr)
+		return -1;
+
+	if (macstr[2] != ':' ) {
+		return -1;
+	}
+
+	printf("device %s: macaddres: %s\n", device, macstr);
+
+	return 0; 
+}
+
+int do_readmacs(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i=0, ret;
+	mfg_info_blk_st block;
+	struct mac_addr_info_st macs;
+	char temp[IFNAMSIZ];
+
+	/* read the data blob */
+	ret = read_config_block( MFG_CONFIG_MACS, &block);
+	if ( block.hdr.length ) {
+		memmove( &macs, block.data, block.hdr.length );
+
+		/* interpret the mac addresses */
+		for (i=0; i<MAX_NUM_MACS; i++) {
+			sprintf(temp, "eth%d", i);
+			showmac(temp, macs.interface[i].mac);
+		}
+	}
+
+	return ret;
+}
+
+U_BOOT_CMD(
+	readmacs, 1, 1, do_readmacs,
+	"read 3 or 9 WG MAC addresses in WG specific way\n",
+	"");
+
+#define MAC_STR_SIZE	18
+/* returns 1 if the format of mac is valid */
+/* can do more (make sure hex numbers only, no multi/broad-cast mac) if really needed */
+int is_valid_mac(char* buf) {
+	if (strlen(buf) < MAC_STR_SIZE - 1 ||
+		buf[2] != ':' || buf[5] != ':' || buf[8] != ':' || buf[11] != ':' || buf[14] != ':')
+		return 0;
+	else
+		return 1;
+}
+
+#if defined(CONFIG_FBX_T10)
+
+/* WG T10-D MAC tools for mac addr on the DSL chip */
+int do_setdslmac(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i, j;
+	char mac_str[MAC_STR_SIZE];
+
+	if (argc < 2) {
+		printf("mac addr missing, must provide DSL eth0 mac addr to write\n");
+		return -1;
+	}
+
+	if (!is_valid_mac(argv[1])) {
+		printf("invalid mac format, MAC addr should contain ':'\n");
+		return -1;
+	}
+
+	for (i = 0, j = 0; i < MAC_STR_SIZE && argv[1][j] != '\0'; j++)
+		if (argv[1][j] != ':') {
+			mac_str[i] = argv[1][j];
+			i++;
+		}
+	mac_str[MAC_STR_SIZE - 1] = '\0';
+
+	/* printf("\nswitching console to eserial1 to set dsl eth0 mac to: %s\n", mac_str); */
+	console_assign(stdout, "eserial1");
+	printf(" \r");
+	/* printf("sys mac %s\r", argv[1]); */
+	printf("sys mac %s\r", mac_str);
+	for (i = 0; i < 3; i++)
+		udelay (1000000);
+	console_assign(stdout, "serial");
+	/* printf("console switched back to eserial0\n"); */
+
+	printf("cmd sent to the DSL chip, pls wait 30 s for the chip to reboot\n");
+
+	return 0;
+}
+U_BOOT_CMD(
+	setdslmac, 2, 0, do_setdslmac,
+	"set DSL chip eth0 MAC address in WG specific way",
+	"	- note: each MAC address provided should be seperated by ':'.\n"
+	"	           example: setdslmac 00:90:0b:1e:7e:34");
+
+
+
+#define BUFF_LEN	256
+#define LINE_LEN	80
+/* WG T10-D MAC tools for mac addr on the DSL chip */
+int do_readdslmac(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i;
+	char* p;
+	char ch[BUFF_LEN];
+	char line[LINE_LEN];
+
+	/* printf("switching console to eserial1 to run cmd to get DSL mac ...\n"); */
+	console_assign(stdin, "eserial1");
+	console_assign(stdout, "eserial1");
+	printf("ifconfig eth0\r");
+	console_assign(stdout, "serial");
+  
+	for (i = 0; i < BUFF_LEN; i++) {
+		ch[i] = (char) fgetc(stdin);
+		if (ch[i] <= 0)
+			break;
+	}
+	if (i >= BUFF_LEN)
+		i = BUFF_LEN - 1;
+	ch[i] = '\0';
+	console_assign(stdin, "serial");
+
+	p = strstr(ch, "eth0 ");
+	if (!p) {
+		fputs(stdout, "#### DSL chip not ready yet. Please wait and re-try. Feedback received:\n");
+		fputs(stdout, ch);
+		fputs(stdout, "\n");
+		return -1;
+	}
+
+	/* copy one line starting with "eth0" */
+	for (i = 0; i < LINE_LEN && p[i] != '\n' && p[i] != '\0'; i++)
+		line[i] = p[i];
+	if (i >= LINE_LEN)
+		i = LINE_LEN - 1;
+	line[i] = '\0';
+
+	p = strstr(line, "HWaddr");
+	if (!p) {
+		fputs(stdout, "#### error in reading DSL chip eth0 mac addr\n");
+		fputs(stdout, line);
+		return -1;
+	}
+
+	printf("device DSL eth0: macaddress: %s\n", (p + 7));
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	readdslmac, 1, 0, do_readdslmac,
+	"read DSL chip eth0 MAC addresses in WG specific way",
+	""
+	);
+#endif // defined(CONFIG_FBX_T10)
--- u-boot-2011.03/mfgtools_cmd/mfgtools-dixie.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/mfgtools-dixie.c	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,290 @@
+/*******************************************************************
+ * $Id:
+ *
+ * @file mfgtols-dixie.c
+ *
+ * @brief Flash handling function for retreiving manufactoring data.
+ *
+ * @author Mukund Jampala
+ * Copyright &copy; 2005, WatchGuard Technologies, Inc.
+ * All Rights Reserved
+ *
+ * @date Thurday Feb 12, 2014
+ *
+ * @par Function:
+ *     We store manufacturing data in fixed size structures that are
+ *     stored in the flash config partition. The fixed size makes
+ *     it very simple to read/write these and by NOT storing them
+ *     in the data partition they will survive even if the data
+ *     partition gets wiped out
+ *******************************************************************/
+
+#include <malloc.h>
+#include <common.h>
+#include <spi_flash.h>
+#if 0
+#include <u-boot/md5.h>
+#endif
+
+#include "mfgtools-private.h"
+#include "md5.h"
+#if 0
+#include "mfg_config_flashmedia.h"
+#endif
+
+/*
+ * -----------------------------------------------------------------------
+ * Generic framework to support reading/writing sections of configuration
+ * data to block media devices.
+ * -----------------------------------------------------------------------
+ */
+
+/*! 
+ * \brief Hidden data structure used for the config 
+ */
+typedef struct {
+    int fd;			/*! file handler */
+    int commit;                 /*! Commit changes back on close? */
+    mfg_param_blk_st *mfg;      /*! Temporary storage for config data */
+} mfg_ctx_st;
+
+/*
+ * Layered approach for reading config blocks out of /dev/wgrd.cfg0
+ *
+ * So the layered approach is a little complex, but it needs to be there
+ * since writing the flash partition needs to be done in one go on chelan. 
+ * And it may differ on Tacoma w/others. 
+ *
+ * We don't want too many writes, and when we update it then committing 
+ * changes should only require one pass of write_paramblock(). On chelan
+ * this read / write cycle to update the config takes ~3-4 seconds.
+ *
+ * On reads we should only read what we need to and nothing else. This is 
+ * not how it worked in yavin where read_paramblock() was used to read the 
+ * entire configuration. Here it will read the specified block, header and 
+ * size of data stored there.
+ *
+ */
+
+static int get_blockoffset( mfg_config_t cfg) 
+{
+    int retval = -1;
+    
+    switch (cfg) {
+    case MFG_CONFIG_SERIAL:
+        retval = offsetof(mfg_param_blk_st, serial);
+        break;
+    case MFG_CONFIG_MACS:
+        retval = offsetof(mfg_param_blk_st, macs);
+        break;
+    case MFG_CONFIG_CLIENT_AUTH:
+        retval = offsetof(mfg_param_blk_st, client_auth);
+        break;
+    case MFG_CONFIG_CLIENT_AUTH_KEY:
+        retval = offsetof(mfg_param_blk_st, client_auth_key);
+        break;
+    default: /* Bail! */
+        return retval;
+    }
+
+    return retval;
+}
+
+static struct spi_flash *mfg_flash;
+char *mfg_block = NULL;
+
+
+static int validate_config_block(mfg_config_t cfg, char *mfg_block, mfg_info_blk_st *block)
+{
+	int offset = get_blockoffset(cfg);
+	int retval = 0;
+	unsigned char chk[16];
+
+#if 0
+	int blk_size = sizeof( mfg_blk_hdr_st );
+#endif
+
+	if ( !mfg_block || offset == -1 ) {
+		retval = -1;
+		return retval;
+	}
+
+	/* make a copy */
+	memmove(block, mfg_block + offset, sizeof(mfg_info_blk_st));
+
+	/* Avoid endianess mess */
+	block->hdr.signature = ntohl(block->hdr.signature);
+	block->hdr.length    = ntohl(block->hdr.length   );
+            
+	/* 
+	* Check signature 
+	*/
+	if ( block->hdr.signature != MFG_MAGIC_HEADER_SIG ) {
+		printf ("**Error: Invalid magic number");
+		retval = -2;
+	}
+
+	if (retval != 0) 
+		return (retval);
+
+	/* 
+	* Final check: the checksum!
+	*/
+	wgut_md5buf(chk, block->data, block->hdr.length);
+	if (memcmp(chk, block->hdr.checksum, 16)) {
+		printf ("**Error: Checksum failure in data segment \
+			of ");
+		return MFG_BAD_CHECKSUM;
+	}
+
+	/* Null Terminate */
+	*(block->data + block->hdr.length) = '\0';
+	block->hdr.length++;
+
+	return (retval);
+}
+
+int read_config_block( mfg_config_t cfg, mfg_info_blk_st *block ) 
+{
+	int ret = 1;
+	u32 saved_size, saved_offset;
+
+	int mfg_blk_size = sizeof(mfg_param_blk_st);
+#if 0
+	char	*res;
+	ssize_t	len;
+#endif
+
+	if(!block)
+		return 1;
+
+	mfg_flash = spi_flash_probe(CONFIG_ENV_SPI_BUS,
+		CONFIG_ENV_SPI_CS,
+		CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+
+	/* Is the sector larger than the mfg_blk_size */
+	if (CONFIG_MFG_SECT_SIZE > mfg_blk_size) {
+		saved_size = CONFIG_MFG_SECT_SIZE - mfg_blk_size;
+		saved_offset = CONFIG_MFG_OFFSET + mfg_blk_size;
+		mfg_block = malloc(saved_size);
+		if (!mfg_block) {
+			goto done;
+		}
+		ret = spi_flash_read(mfg_flash, saved_offset,
+			saved_size, mfg_block);
+		if (ret)
+			goto done;
+	}
+
+	/* update should happen here */
+	validate_config_block(cfg, mfg_block, block);
+
+	ret = 0;
+	puts("done\n");
+
+ done:
+	if (mfg_block)
+		free(mfg_block);
+	return ret;
+}
+
+int update_config_block(mfg_config_t cfg, char *mfg_block, char *data, int len)
+{
+	int offset = get_blockoffset(cfg);
+	int retval = (-1);
+    
+	/* limit the lenght to max datalength supported */
+	if (len > MFG_BLOCK_DATA_SIZE)
+		return MFG_BAD_SIZE;
+
+        if ( !mfg_block )
+		return 1;
+
+	mfg_info_blk_st *block =
+		(mfg_info_blk_st*) ((char*)mfg_block + offset);
+
+	/* Update the signature in the header */
+	block->hdr.length    = htonl( len );
+	block->hdr.signature = htonl( MFG_MAGIC_HEADER_SIG );
+
+	/* Update data + checksum */
+	memmove( block->data, data, len );
+	wgut_md5buf( (unsigned char*)block->hdr.checksum, data, len );
+
+	retval      = 0;
+	return retval;
+}
+
+/*!
+ * \brief This function updates the flashpart with new data
+ * \param rawdev    [IN]    The raw data partition, e.g. "/dev/wgrd.sysa.kernel
+ * \param mfg_blk   [OUT]   Dat Buffer to be stored
+ * \param len       [IN]    The length of the buffer 'mfg_blk' to be stored
+ *
+ * \return 0 on success, -1 otherwise
+ */
+int mfg_update_flashpart(mfg_config_t cfg, char *mfg_blk, int len)
+{
+	int ret = 1;
+	u32 saved_size, saved_offset, sector = 1;
+
+	int mfg_blk_size = sizeof(mfg_param_blk_st);
+#if 0
+	char	*res;
+#endif
+
+	mfg_flash = spi_flash_probe(CONFIG_ENV_SPI_BUS,
+		CONFIG_ENV_SPI_CS,
+		CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE);
+
+	/* Is the sector larger than the mfg_blk_size */
+	if (CONFIG_MFG_SECT_SIZE > mfg_blk_size) {
+		saved_size = CONFIG_MFG_SECT_SIZE - mfg_blk_size;
+		saved_offset = CONFIG_MFG_OFFSET + mfg_blk_size;
+		mfg_block = malloc(saved_size);
+		if (!mfg_block) {
+			goto done;
+		}
+		ret = spi_flash_read(mfg_flash, saved_offset,
+			saved_size, mfg_block);
+		if (ret)
+			goto done;
+	}
+
+	if (mfg_blk_size > CONFIG_MFG_SECT_SIZE) {
+		sector = mfg_blk_size / CONFIG_MFG_SECT_SIZE;
+		if (mfg_blk_size % CONFIG_MFG_SECT_SIZE)
+			sector++;
+	}
+
+	/* update should happen here */
+	update_config_block(cfg, mfg_block, mfg_blk, len);
+
+	puts("Erasing MFG portion of SPI flash...");
+	ret = spi_flash_erase(mfg_flash, CONFIG_MFG_OFFSET,
+		sector * CONFIG_MFG_SECT_SIZE);
+	if (ret)
+		goto done;
+
+	puts("Writing MFG portion of SPI flash...");
+	ret = spi_flash_write(mfg_flash, CONFIG_MFG_OFFSET,
+		mfg_blk_size, mfg_block);
+	if (ret)
+		goto done;
+
+	if (CONFIG_MFG_SECT_SIZE > mfg_blk_size) {
+		ret = spi_flash_write(mfg_flash, saved_offset,
+			saved_size, mfg_block);
+		if (ret)
+			goto done;
+	}
+
+	ret = 0;
+	puts("done\n");
+
+ done:
+	if (mfg_block)
+		free(mfg_block);
+	return ret;
+}
+
--- u-boot-2011.03/mfgtools_cmd/crc16.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/crc16.c	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,128 @@
+/********************************************************
+ * ----------- CRC 16 calculation ----------------
+ *
+ * @file crc16.c
+ *
+ * @brief functionality for calculating a 16-bit, CRC-16 value for a given
+ *        input buffer.
+ *
+ * @Original authors: Dan Wilder, Steve Huberty, Eivind Naess, Mukund Jampala
+ * @refactor: Mukund Jampala <mukund.jampala@watchguard.com>
+ * Copyright 2013, WatchGuard Technologies, Inc.
+ * All Rights Reserved
+ *
+ * @date Wednesday Apr 09, 2013
+ *
+ * @par Function:
+ *  mfg_serial_crc_byte()
+ ********************************************************/
+
+#include <linux/stddef.h>
+#include <errno.h>
+#include <malloc.h>
+
+#if 0
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#endif
+
+#define STATIC_CRC16
+#ifdef STATIC_CRC16
+/* NEVER define 'STATIC_CRC16':
+ * This is there in place just for documentation reasons.
+ */
+
+/*
+ * This is a precalculated version of mfg_serial_crc_byte() above. At the
+ * cost of 512 more bytes of storage+memory, you get a faster response from
+ * this implementation.
+ */
+u_int16_t const crc16_ccitt[256] = {
+    0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241,
+    0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440,
+    0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40,
+    0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841,
+    0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
+    0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
+    0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
+    0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
+    0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
+    0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
+    0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
+    0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
+    0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
+    0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
+    0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
+    0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
+    0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
+    0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
+    0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
+    0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
+    0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
+    0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
+    0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
+    0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
+    0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
+    0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
+    0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
+    0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
+    0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
+    0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
+    0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
+    0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040,
+};
+
+u_int16_t mfg_serial_crc_byte(u_int16_t crc, const u_int8_t nextbyte) {
+	return crc16_ccitt[nextbyte ^ (crc & 0xff)] ^ (crc >> 8);
+}
+#else
+
+/*!
+ * \brief Calculates a 16-bit, CRC-16 value for a given input byte.
+ *
+ * \param crc       [IN]  A previous crc value.  Use this to continue
+ * calculating a CRC, for example when iterating through a string of bytes.
+ * If you're just beginning, set this to 0.
+ *
+ * \param nextbyte  [IN]  The next byte to process.
+ *
+ * <b>Sample Usage:</b>
+ *      \code
+ *
+ *      char buf[] = "ABCDE";
+ *      p = buf;
+ *      crc = 0;
+ *      while (*p) {
+ *          crc = mfg_serial_crc_byte(crc, (u_int8_t) *p);
+ *          ++p;
+ *      }
+ *
+ *      \endcode
+ *
+ * \return The calculated CRC.
+ */
+u_int16_t mfg_serial_crc_byte(u_int16_t crc, const u_int8_t nextbyte) {
+    u_int8_t index;
+    u_int16_t value;
+    int i;
+
+    value = 0;
+    index = nextbyte ^ (crc & 0xff);
+
+    /*
+     * Iterate through the bits using a CRC-16 ITU X.25/T.30
+     * polynomial (0x8005 reversed -> 0xa001).
+     */
+    for (i = 0; i < 8; ++i) {
+        if ((index ^ value) & 1) {
+            value = (value >> 1) ^ 0xa001;
+        } else {
+            value >>= 1;
+        }
+        index >>= 1;
+    }
+    return value ^ (crc >> 8);
+}
+
+#endif
--- u-boot-2011.03/mfgtools_cmd/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/Makefile	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,56 @@
+#
+# (C) Copyright 2004-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)libmfgtools.o
+
+# core
+COBJS-y += cmd_wgtools.o
+COBJS-y += crc16.o
+COBJS-y += mfgtools-dixie.o
+COBJS-y += wg_serial.o
+COBJS-y += md5.o
+
+COBJS	:= $(sort $(COBJS-y))
+XCOBJS	:= $(sort $(XCOBJS-y))
+SRCS	:= $(COBJS:.o=.c) $(XCOBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+XOBJS	:= $(addprefix $(obj),$(XCOBJS))
+
+CPPFLAGS += -I..
+
+all:	$(LIB) $(XOBJS)
+
+$(LIB): $(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+include $(obj).depend
+
+
+#########################################################################
--- u-boot-2011.03/mfgtools_cmd/wg_serial.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/mfgtools_cmd/wg_serial.c	2022-05-09 14:05:11.820044187 -0700
@@ -0,0 +1,278 @@
+/***************************************************************************
+ * ----------- WG serial/ OEM Serial related functionality ----------------
+ *
+ * @file wg_serial.c
+ *
+ * @brief functionality for reading/writing WG/OEM serials, determining model
+ *    info.
+ *
+ * @Original authors: Dan Wilder, Steve Huberty, Eivind Naess, Mukund Jampala
+ * @refactor: Mukund Jampala <mukund.jampala@watchguard.com>
+ * Copyright 2013, WatchGuard Technologies, Inc.
+ * All Rights Reserved
+ *
+ * @date Wednesday Apr 10, 2013
+ *
+ * @par Function:
+ *   int mfg_write_serial(const char *newserial);
+ *   int mfg_read_serial(char *serial, int len);
+ *   int mfg_valid_serial(const char *str);
+ *
+ ****************************************************************************/
+
+#include <linux/stddef.h>
+
+#include <common.h>
+#include <linux/ctype.h>
+#include <linux/err.h>
+
+#include <errno.h>
+
+#if 0
+#include <fcntl.h> 
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <syslog.h>
+
+#include <wglinux.h>
+#include <usertools/util.h>
+#include <mfgtools/flash.h>
+#endif
+
+#include "mfgtools-private.h"
+#include "crc16.h"
+
+#if 0
+#include "image-private.h"
+#endif
+
+#define FL_UNSIGNED   1
+#define FL_NEG        2
+#define FL_OVERFLOW   4
+#define FL_READDIGIT  8
+
+# define INT32_MIN		(-2147483647-1)
+# define INT32_MAX		(2147483647)
+# define UINT32_MAX		(4294967295U)
+static unsigned long strtoxl(const char *nptr, char **endptr, int ibase, int flags) {
+  const unsigned char *p;
+  char c;
+  unsigned long number;
+  unsigned digval;
+  unsigned long maxval;
+
+  p = (const unsigned char *) nptr;
+  number = 0;
+
+  c = *p++;
+  while (isspace(c)) c = *p++;
+
+  if (c == '-') {
+    flags |= FL_NEG;
+    c = *p++;
+  } else if (c == '+') {
+    c = *p++;
+  }
+
+  if (ibase < 0 || ibase == 1 || ibase > 36) {
+    if (endptr) *endptr = (char *) nptr;
+    return 0L;
+  } else if (ibase == 0) {
+    if (c != '0') {
+      ibase = 10;
+    } else if (*p == 'x' || *p == 'X') {
+      ibase = 16;
+    } else {
+      ibase = 8;
+    }
+  }
+
+  if (ibase == 16) {
+    if (c == '0' && (*p == 'x' || *p == 'X')) {
+      ++p;
+      c = *p++;
+    }
+  }
+
+  maxval = UINT32_MAX / ibase;
+
+  for (;;) {
+    if (isdigit(c)) {
+      digval = c - '0';
+    } else if (isalpha(c)) {
+      digval = toupper(c) - 'A' + 10;
+    } else {
+      break;
+    }
+
+    if (digval >= (unsigned) ibase) break;
+
+    flags |= FL_READDIGIT;
+
+    if (number < maxval || (number == maxval && (unsigned long) digval <= UINT32_MAX % ibase)) {
+      number = number * ibase + digval;
+    } else {
+      flags |= FL_OVERFLOW;
+    }
+
+    c = *p++;
+  }
+
+  --p;
+
+  if (!(flags & FL_READDIGIT)) {
+    if (endptr) p = (const unsigned char *)nptr;
+    number = 0;
+  } else if ((flags & FL_OVERFLOW) || (!(flags & FL_UNSIGNED) && (((flags & FL_NEG) && (number < INT32_MIN)) || (!(flags & FL_NEG) && (number > INT32_MAX))))) {
+#ifndef KERNEL
+    errno = ERANGE;
+#endif
+
+    if (flags & FL_UNSIGNED) {
+      number = UINT32_MAX;
+    } else if (flags & FL_NEG) {
+      number = INT32_MIN;
+    } else {
+      number = INT32_MAX;
+    }
+  }
+
+  if (endptr) *endptr = (char *) p;
+
+  if (flags & FL_NEG) number = (unsigned long) (-(long) number);
+
+  return number;
+}
+
+unsigned long strtoul(const char *nptr, char **endptr, int ibase) {
+  return strtoxl(nptr, endptr, ibase, FL_UNSIGNED);
+}
+
+
+#define MFR_MODEL_SERIAL_LENGTH 9
+#define WGSERIAL_CRC_LEN	4
+
+#if 0
+/*!
+ * \brief Writes the WatchGuard serial number and Returns the status code
+          Validates the 4-digit checksum before writing WG serial to the Hardware.
+ *
+ * \param serial    [IN]   The OEM serial information
+ * 
+ * \return 0 on success, -1 or <> 0 otherwise.
+ */
+int mfg_write_serial( const char *newserial ) 
+{
+    int retval = (-1);
+    int i=0,j=0;
+    char serial_copy[SERIAL_LENGTH+1];
+
+    if ( !newserial ) {
+        errno = EINVAL;
+        return retval;
+    }
+
+    /* strip any white spaces and '-' */
+    while ( newserial[i] ) {
+        if ( isalnum(newserial[i]) ) {
+            serial_copy[j]=newserial[i];
+            j++;
+        }
+        i++;
+    }
+    serial_copy[j]=0;
+
+    if (mfg_valid_serial(serial_copy) == 0) {
+        errno = EINVAL;
+        return retval-1;
+    }
+
+    return platform_mfg_write_serial(serial_copy);
+
+}
+
+/*!
+ * \brief Returns the WatchGuard serial number.
+ *        Tip:  You can override the serial number stored in the
+ *        manufacturing area by putting it in /etc/wg/serial.
+ *
+ * \param serial    [OUT]   The  WatchGuard serial information
+ * \param len       [IN]    Maximum serial buffer capacity.
+ * 
+ * \return 0 on success, -1 or <> 0 otherwise returning serial as the default
+ *    serial
+ */
+int mfg_read_serial(char *serial, int len) {
+
+    int rc   = -1;
+    FILE *fp = NULL;
+    char *pa = NULL;
+
+    /* Input validation */
+    if ( !serial || len <= 0 )
+        return rc;
+
+    memset(serial, 0, len);
+
+    rc = platform_mfg_read_serial(serial, len);
+
+    if ( rc || !strcmp(serial, "UNKNOWN") ) {
+        strncpy(serial, DEFAULT_SERIAL_STRING, len);
+        syslog(LOG_INFO, "Using default serial number");
+    }
+
+    return rc;
+
+}
+#endif
+
+/*!
+ * \brief Validates a WG serial number against its checksum.
+ *
+ * \param str       [IN]    The serial number
+ *
+ * \note Even though the serial string currently looks like a hex
+ *     representation of an integer, the checksum uses the ASCII value of the
+ *     digits of the serial number.  So the decimal value of "A" is 65 not 10.
+ *     Use CRC16 (CCITTish) to generate the checksum for the first 9 digits of
+ *     the serial string.
+ *
+ * \note Supports 13-digit serial number strings whose last 4 digits are the
+ *     checksum of the first 9 digits.  Also allows for a 14-digit string with
+ *     a hyphen between the serial number and the checksum (e.g.
+ *     909912345-ABCD).
+ *
+ * \return 1 if valid, 0 if otherwise
+ * NOTE : Never delete this function as part of refactoring: spokane heavily
+          depends on this.
+ */
+int mfg_valid_serial(const char *str)
+{
+    u_int16_t exp_crc;
+    u_int16_t act_crc;
+    int len;
+    int i;
+
+    /* validate the entire length, accounting for a possible hyphen */
+    len = strlen(str);
+    if ((len != MFR_MODEL_SERIAL_LENGTH + WGSERIAL_CRC_LEN)
+            && (len != MFR_MODEL_SERIAL_LENGTH + WGSERIAL_CRC_LEN + 1)){
+        return(0); 
+    }
+
+    exp_crc = strtoul(str + len - WGSERIAL_CRC_LEN, NULL, 16);
+
+    act_crc = 0;
+    for (i = 0; i < MFR_MODEL_SERIAL_LENGTH; ++i) {
+        act_crc = mfg_serial_crc_byte(act_crc, (u_int8_t) str[i]);
+    }
+
+    if (exp_crc != act_crc) {
+        return(0);
+    }
+
+    return(1);
+}
--- u-boot-2011.03/tools/env/fw_env.config.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/tools/env/fw_env.config	2022-05-09 14:05:10.580094469 -0700
@@ -0,0 +1,11 @@
+# Configuration file for fw_(printenv/saveenv) utility.
+# Up to two entries are valid, in this case the redundant
+# environment sector is assumed present.
+# Notice, that the "Number of sectors" is ignored on NOR.
+
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+/dev/mtd1		0x0000		0x4000		0x4000
+/dev/mtd2		0x0000		0x4000		0x4000
+
+# NAND example
+#/dev/mtd0		0x4000		0x4000		0x20000			2
--- u-boot-2011.03/board/freescale/xtm330/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/Makefile	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,56 @@
+#
+# Copyright 2009 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+CFLAGS += -DBIG
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-$(CONFIG_PCI)  += pci.o
+COBJS-y	+= tlb.o
+COBJS-$(CONFIG_XTM330_LCM)  += lcd.o S6A0069-lcd.o S6A0069-packet.o serial.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- u-boot-2011.03/board/freescale/xtm330/config.mk.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/config.mk	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,31 @@
+#
+# Copyright 2009, 2011 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# xtm330 board
+#
+
+ifndef NAND_SPL
+ifeq ($(CONFIG_NAND), y)
+LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-nand.lds
+endif
+endif
--- u-boot-2011.03/board/freescale/xtm330/S6A0069-private.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/S6A0069-private.h	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,215 @@
+
+#ifndef __PANEL_CHELAN_H__
+#define __PANEL_CHELAN_H__
+
+#include <stdarg.h>
+#include <malloc.h>
+#include <linux/ctype.h>
+#include <common.h>
+
+#if 0
+#define LCM_IO_DEBUG
+#define LCM_DEBUG
+#define DEBUG_LCM
+#endif
+
+/*
+ * MACROS
+ */
+typedef unsigned char UCHAR;
+typedef unsigned short USHORT;
+
+#define DRIVER_API_VERSION  "0.01"
+
+#define STREQ(a,b) (strcmp((a),(b)) == 0)
+#define STRPREFIX(a,b) (strncmp((a),(b),strlen((b))) == 0)
+#define FREE(a) free(a)
+
+#define NO_DBG    0
+#define BASIC_DBG 1
+#define FULL_DBG  2
+
+#ifdef DEBUG_LCM
+
+#define DbgPrint(lvl, fmt, args...) \
+ if (debug_level >= lvl ) \
+  do { printf("DBG: " fmt , ##args); } while (0)
+#define ErrPrint(fmt, args...) \
+ do { printf("ERR: " fmt , ##args); } while (0)
+#define SysErrPrint(errno, fmt, args...) \
+ do { printf("SYSERR: " fmt , ##args); } while (0)
+
+#else /* else DEBUG_LCM */
+
+#define DbgPrint(lvl, fmt, args...)
+#define ErrPrint(fmt, args...)
+#define SysErrPrint(errno, fmt, args...)
+
+#endif /* end DEBUG_LCM */
+
+
+/* 
+ * ALL #defines
+ */
+#define MAX_COMMAND		35
+#define MAX_DATA_LENGTH 	25	/* Data lenght for each PACKET */
+#define READ_BUFFER_SIZE 	2048
+
+/* 
+ * Device port settings
+ */
+#define DEV_LCM "/dev/ttyS1"
+#define DEFAULT_BAUDRATE 19200
+
+/* 
+ * Software version info  
+ */
+#define SW_VERSION       "frontpanel-chelan"
+
+/* All LCD commands */
+enum lcd_commands {
+
+    FETCH_LCD_VERSION = 0,
+    CLEAR_LCD = 1,
+    SET_LINE1 = 2,
+    SET_LINE2 = 3,
+    DISP_LCD_ANY_LOC_1 = 4,
+    DISP_LCD_ANY_LOC_2 = 5,
+    DISP_LCD_ANY_LOC_3 = 6,
+    DISP_LCD_ANY_LOC_4 = 7,
+    SET_LCD_STATUS_1 = 8,
+    SET_LCD_STATUS_2 = 9,
+    SET_LCD_STATUS_3 = 10,
+    SET_LCD_STATUS_4 = 11,
+    SET_CURSOR_STYLE = 12,
+    SET_CURSOR_POS = 13,
+    RESET_LCM = 14,
+    RUN_PING = 15,
+} LCMCMD;
+
+/*
+ * CMD packet strccture
+ */
+typedef struct {
+    UCHAR command;
+    UCHAR data_length;
+    UCHAR data[MAX_DATA_LENGTH];
+    union {
+	UCHAR in_bytes[2];
+	USHORT in_word;
+    } CRC;
+
+    /* Command processing function for this perticular 'command' */
+    int (*cmd_processor) (int, char *data, int data_len);
+    UCHAR data_remaining;
+
+
+} CMD_PACKET;
+#define CMD_SIZE 4
+#define CMD_PACKET_SIZE (sizeof(CMD_PACKET) - sizeof(int *))
+
+/* 
+ * LCD packet command definition
+ */
+
+#define CMD_PING		0
+
+#define CMD_GET_VERSION		1
+
+#define CMD_WRITE_USER_FLASH	2
+
+#define	CMD_READ_USER_FLASH	3
+
+#define CMD_STORE_SETTING	4
+
+#define	CMD_RESET_LCM_MODULE	5
+
+#define	CMD_CLEAR_LCD		6
+
+#define	CMD_DISP_LCD_LINE1	7
+
+#define	CMD_DISP_LCD_LINE2	8
+
+#define	CMD_SET_CURSOR_POSITION	11
+
+#define	CMD_SET_CURSOR_STYLE	12
+
+#define	CMD_SEND_CMD_TO_LCD	22
+
+#define CMD_CONFIG_KEY_MODE	23
+
+#define	CMD_READ_KEY_STATUS	24
+
+#define	CMD_DISP_LCD_ANY_LOCATE	31
+
+#define	CMD_SET_LED_STATUS	32
+
+#define	CMD_SET_BAUDRATE	33
+
+/* 
+ * keypad definition
+ */
+#define KP_S1   0x01
+#define KP_S2   0x02
+#define KP_S3   0x04
+#define KP_S4   0x08
+
+/*
+ * LED Color Enums & Rate Enums
+*/
+typedef enum {
+        S6A_PLAIN_LED = 0,
+        S6A_GREEN_LED = 1,
+        S6A_RED_LED   = 2,
+} LED_COLOR_t;
+
+/*  LED blink rates */
+#define BLINK_RATE_1SEC 1
+
+#define S6A_LED_SOLID_OFF       0
+#define S6A_LED_BLINK_ON        1
+#define S6A_LED_SOLID_ON        1       // ??
+
+/* BAUD rates as per the controller */
+#define DATA_BAUDRATE_19200     0                                                      
+#define DATA_BAUDRATE_115200    1                                                      
+#define DATA_BAUDRATE_28800     2                                                      
+#define DATA_BAUDRATE_38400     3                                                      
+#define DATA_BAUDRATE_57600     4                                                      
+#define DATA_BAUDRATE_9600      5
+
+/*************************
+ ** Internal functions ***
+ ************************/
+/* 
+ * LCD controlling functions
+ */
+int setup_keypad(void);
+int Ser_init (char *devname, int bitrate);
+void Ser_deinit (char *devname);
+
+int set_baudrate (int rate);
+int poll_keypad(UCHAR *key);
+
+int probe_lcm (void);
+char *get_firmware_version (void);
+void show_version (void);
+int writeLCD (const void *cmd);
+int readLCD (void);
+void show_version (void);
+
+
+void clear_display(void);
+int set_led (LED_COLOR_t color, int rate);
+
+int Run_Command (UCHAR command, UCHAR * data, int len);
+void dump_packet (CMD_PACKET * pCMD);
+/* 
+ * Packet handling functions
+ */
+CMD_PACKET *format_packet (CMD_PACKET *cmd, UCHAR CMD, UCHAR * data, 
+		UCHAR data_length, USHORT CRC);
+int packet_available (CMD_PACKET * packet);
+
+
+#endif /* eof __PANEL_CHELAN_H__ */
--- u-boot-2011.03/board/freescale/xtm330/serial.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/serial.h	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,10 @@
+/* exported serial functions */
+
+int lcm_panel_init(void);
+int lcm_serial_tstc (void);
+int lcm_serial_getc (void);
+void lcm_serial_putc (const char c);
+void lcm_serial_puts (const char *s, int len);
+
+int lcd_puts (int line, char * text);
+int lcd_clear (void);
--- u-boot-2011.03/board/freescale/xtm330/xtm330.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/xtm330.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <tsec.h>
+#include <netdev.h>
+#include <rtc.h>
+#include <miiphy.h>
+#include <version.h>
+#include <i2c.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_LAST_STAGE_INIT
+#include "serial.h"
+#endif
+
+#define PCIE_RST_SET            0x00010000
+#define RGMII_PHY_RST_SET       0x00040000
+#define DDR_RESET               0x00020000
+#define USB2_PORT_OUT_EN        0x01000000
+#define USB_RST_CLR             0x00080000
+#define GPIO_DIR                0x210f0000
+#define BOARD_PERI_RST_SET      PCIE_RST_SET 
+
+#define SYSCLK_MASK	0x00200000
+#define BOARDREV_MASK	0x10100000
+#define BOARDREV_B	0x10100000
+#define BOARDREV_C	0x00100000
+#define BOARDREV_D	0x00000000
+
+#define SYSCLK_66	66666666
+#define SYSCLK_50	50000000
+#define SYSCLK_100	100000000
+
+unsigned long get_board_sys_clk(ulong dummy)
+{
+	return SYSCLK_66;
+}
+
+int board_early_init_f (void)
+{
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+/*
+ * Bringing the following peripherals out of reset via GPIOs
+ * 0 = reset and 1 = out of reset
+ * GPIO13 - Reset to RGMII_PHY
+ * GPIO14 - DDR 
+ * GPIO15 - Reset to PCIe slots
+ * GPIO12  - Reset to USB3300 devices 1 = reset and 0 = out of reset
+ */
+//Set 0,1 I 2~7,12~15 O
+	setbits_be32(&pgpio->gpdir, GPIO_DIR);
+	//ALL low 
+	udelay(5);
+	//All high ,USB reset
+	setbits_be32(&pgpio->gpdat,DDR_RESET| RGMII_PHY_RST_SET| PCIE_RST_SET|USB_RST_CLR);
+	udelay(5);
+	//All low ,PHY ,DDR ,PCIE reset,USB out reset
+	clrsetbits_be32(&pgpio->gpdat, USB_RST_CLR |DDR_RESET| RGMII_PHY_RST_SET , BOARD_PERI_RST_SET);
+	udelay(5);
+	//All PHY,DDR,PCIE set to high out reset
+	setbits_be32(&pgpio->gpdat,DDR_RESET| RGMII_PHY_RST_SET| PCIE_RST_SET);
+	return 0;
+}
+
+int checkboard (void)
+{
+	char board_rev = 0; 
+	struct cpu_type *cpu;
+	board_rev = 'A';
+	cpu = gd->cpu;
+	printf ("Board: %sRDB\n", cpu->name);
+#ifdef CONFIG_LANNER_MFG
+	printf ("%s\n",BOARD_VERSION);
+#endif
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+	const u8 temp[7] = { 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x35};
+	const u8 fan[7]  = { 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x3f};
+	int i = 0;
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_16M, 1);
+	//	rtc_reset();
+	// W83793D smartfan default setting
+	i2c_reg_write(0x2d, 0, 0x82);
+	/* Enable Temp 5 smartfan function */
+	i2c_reg_write(0x2d, 0x5, 0x1);
+	for ( i = 0 ; i < 7 ; i++)
+	{
+		/* Set temp level */
+		i2c_reg_write(0x2d, 0x70 + i, temp[i]);
+		/* Set fan level */
+		i2c_reg_write(0x2d, 0x78 + i, fan[i]);
+	}
+	i2c_reg_write(0x2d, 0, 0x80);
+	/* Set Uptime */
+	i2c_reg_write(0x2d, 0xc3, 0x1);
+	/* Set Downtime */
+	i2c_reg_write(0x2d, 0xc4, 0x20);
+	return 0;
+}
+
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct tsec_info_struct tsec_info[4];
+	int num = 0;
+	unsigned short value;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	SET_STD_TSEC_INFO(tsec_info[num], 3);
+	if (is_serdes_configured(SGMII_TSEC3)) {
+		puts("eTSEC3 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+	tsec_eth_init(bis, tsec_info, num);
+	for(num=0; num<2; num++) {	
+		/* Get PHY ID of switch to make sure work well */
+		miiphy_write("eTSEC1", 0x10+num, 0, 0x9a03);
+		miiphy_read("eTSEC1",  0x10+num, 1, &value);
+		if ( (value&0xffff) != 0x1712 ) {
+			printf("Error: Switch setting incorrect: SW1%d value: %x!\n", num, value);
+		}
+		printf("Init SW1%d switch to forwarding mode", num);
+		//Reset and Disable INTx 
+		DLAY SMIRW(1, 0x10+num, 4, 0xa000, 0, 0, 0x1b, 0);
+
+		//set rgmii delay     
+		DLAY SMIRW(1, 0x10+num, 1, 0xc03e, 0, 0, 0x15, 0);	//P15
+		
+#ifndef CONFIG_XTM330
+		DLAY SMIRW(1, 0x10+num, 1, 0xc03e, 0, 0, 0x16, 0);	//P16
+#endif
+        
+		//set LED function
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x10, 0);	//P10
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x11, 0);	//P11   
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x12, 0);	//P12
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x13, 0);	//P13   
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x14, 0);	//P14  
+		printf(".");
+
+		//set port to forwarding mode
+		DLAY SMIRW(1, 0x10+num, 4, 0x007f, 0, 0, 0x10, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x11, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x12, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x13, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x14, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x15, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x16, 0);
+		printf(".");
+
+		//set pvlan table
+		DLAY SMIRW(1, 0x10+num, 6, 0x0020, 0, 0, 0x10, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x11, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x12, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x13, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x14, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x001f, 0, 0, 0x15, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0000, 0, 0, 0x16, 0);
+		printf(".");
+
+		//reset PHY
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x0, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x1, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x2, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x3, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x4, 0);
+		printf(". ");
+#ifdef CONFIG_XTM330
+		DLAY SMIRW(1, 0x10+num, 0 ,0x1940, 0, 0, 0x4, 0);
+#else
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x4, 0);
+#endif
+		printf("Done\n");
+	}
+	return pci_eth_init(bis);
+}
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+extern void ft_pci_board_setup(void *blob);
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+#if defined(CONFIG_PCI)
+	ft_pci_board_setup(blob);
+#endif /* #if defined(CONFIG_PCI) */
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+}
+#endif
+
+#ifdef CONFIG_MP
+extern void cpu_mp_lmb_reserve(struct lmb *lmb);
+
+void board_lmb_reserve(struct lmb *lmb)
+{
+	cpu_mp_lmb_reserve(lmb);
+}
+#endif
+
+#ifdef CONFIG_LAST_STAGE_INIT
+
+ulong sys_start;
+
+int last_stage_init (void)
+{
+
+	/* MARK down the time where platfrom specific code
+	 * gets a change to execute its code for the first time */
+	sys_start = get_timer(0);
+	lcm_panel_init();
+	return 0;
+}
+
+#endif /* CONFIG_LAST_STAGE_INIT */
--- u-boot-2011.03/board/freescale/xtm330/pci.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/pci.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+#include <asm/io.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void ft_pci_board_setup(void *blob)
+{
+	FT_FSL_PCI_SETUP;
+}
--- u-boot-2011.03/board/freescale/xtm330/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/law.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_2M, LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_512M, LAW_TRGT_IF_LBC),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2011.03/board/freescale/xtm330/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/tlb.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+	/* W**G* - Flash/promjet, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 2, BOOKE_PAGESZ_16M, 1),
+
+#if defined(CONFIG_PCI)
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 4, BOOKE_PAGESZ_256K, 1),
+#endif /* #if defined(CONFIG_PCI) */
+
+	/* *I*G - NAND */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_1M, 1),
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L2_ADDR)
+	/* *I*G - L2SRAM */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L2_ADDR, CONFIG_SYS_INIT_L2_ADDR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 7, BOOKE_PAGESZ_256K, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L2_ADDR + 0x40000,
+			CONFIG_SYS_INIT_L2_ADDR_PHYS + 0x40000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 8, BOOKE_PAGESZ_256K, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2011.03/board/freescale/xtm330/serial.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/serial.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,85 @@
+/*
+ * Serial port rsetup for LCM controller
+ */
+
+#include <common.h>
+#include <asm/u-boot.h>
+#include <asm/processor.h>
+#include <command.h>
+
+#if (defined CONFIG_SYS_NS16550_COM2)
+#include <ns16550.h>
+#endif
+
+#include  "S6A0069-private.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern int debug_level;
+
+#if (defined CONFIG_SYS_NS16550_COM2)
+const NS16550_t LCM_COM_PORT = (NS16550_t) CONFIG_SYS_NS16550_COM2;
+#endif
+
+void lcm_serial_putc (const char c)
+{
+	NS16550_putc (LCM_COM_PORT, c);
+}
+
+int
+lcm_serial_getc (void)
+{
+        // DbgPrint (BASIC_DBG, "lcm_serial_getc Invoked\n");
+	udelay(50);
+	return NS16550_getc (LCM_COM_PORT);
+
+}
+
+int
+lcm_serial_tstc (void)
+{
+	return NS16550_tstc (LCM_COM_PORT);
+}
+
+#define LCM_BAUDRATE 19200
+
+void lcm_serial_setbrg (void)
+{
+#ifdef CONFIG_APTIX
+#define MODE_X_DIV 13
+#else
+#define MODE_X_DIV 16
+#endif
+	int clock_divisor = (CONFIG_SYS_NS16550_CLK + (LCM_BAUDRATE * (MODE_X_DIV / 2))) /
+				(MODE_X_DIV * LCM_BAUDRATE);
+
+#if (defined CONFIG_SYS_NS16550_COM2)
+        DbgPrint (BASIC_DBG, "lcm_serial_setbrg: in ifdef, GOOD\n");
+	NS16550_reinit (LCM_COM_PORT, clock_divisor);
+#endif
+}
+
+void lcm_serial_puts (const char *s, int len)
+{
+	int i;
+
+	for (i=0; i<len; i++) {
+		lcm_serial_putc (*s++);
+	}
+}
+
+int lcm_panel_init(void)
+{
+	/* setup the serial port COM2 */
+	lcm_serial_setbrg ();
+	udelay(10000);
+
+	/* set LCM controller BAUDRATE */
+	set_baudrate (DATA_BAUDRATE_19200);
+
+	/* setup Keypad */
+	setup_keypad();
+
+	return 0;
+}
+
--- u-boot-2011.03/board/freescale/xtm330/lcd.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/lcd.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,156 @@
+/*
+ * Mukund J
+ * LCD display / LED controls / Keypad Code
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <command.h>
+#include <asm/immap_85xx.h>
+#include <asm/io.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <version.h>
+
+#include  "S6A0069-private.h"
+#include  "serial.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern int debug_level;
+
+#ifdef DEBUG_XTM330_LCM
+
+static int do_lcd_clear (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret;
+        DbgPrint (BASIC_DBG, "DbgPrint: do_lcd_clear\n");
+
+	ret = Run_Command (CMD_CLEAR_LCD, NULL, 0);
+	return 0;
+}
+
+static int do_lcd_puts (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret;
+	char *display_text;
+
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+
+	display_text = argv[1];
+        DbgPrint (BASIC_DBG, "do_lcd_puts Invoked\n");
+    	ret = Run_Command (CMD_DISP_LCD_LINE1, (UCHAR *) display_text, 0);
+	return 0;
+}
+
+static int do_lcd_putc (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret;
+	char *display_text;
+
+	if (argc < 2)
+		return cmd_usage(cmdtp);
+	display_text = argv[1];
+
+    	ret = Run_Command (CMD_DISP_LCD_LINE1, (UCHAR *) display_text, 0);
+	puts("do_lcd_putc");
+	return 0;
+}
+
+static int do_lcd_getc (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	char c = -1;
+
+	if (lcm_serial_tstc())		/* we got a key press	*/
+		c = lcm_serial_getc ();
+	if (c != -1)
+		DbgPrint (BASIC_DBG, "do_lcd_getc = %c (%d) \n", c, c);
+
+	return 0;
+}
+
+static int do_detect_key (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned char key;
+        while (1) {
+                poll_keypad(&key);
+		if ((key != 'X') && (key != 'Y')) {
+                        printf( "<%s> Detected Valid Key Press, Key = %c\n", __FUNCTION__, key);
+                }
+        }
+
+	return 0;
+}
+
+static int do_ping_flood (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret;
+
+        DbgPrint (BASIC_DBG, "do_ping_flood Invoked\n");
+    	ret = Run_Command (CMD_PING, (UCHAR *) "Prank", 0);
+
+	return 0;
+}
+
+
+U_BOOT_CMD(
+	lcd_cls, 1, 1, do_lcd_clear,
+	"lcd clear display",
+	""
+);
+
+U_BOOT_CMD(
+	lcd_puts, 2, 1, do_lcd_puts,
+	"display string on lcd",
+	"<string> - <string> to be displayed"
+);
+
+U_BOOT_CMD(
+	lcd_putc, 2, 1, do_lcd_putc,
+	"display char on lcd",
+	"<char> - <char> to be displayed"
+);
+
+U_BOOT_CMD(
+	lcd_getc, 2, 1, do_lcd_getc,
+	"fetch char on lcd",
+	""
+);
+
+U_BOOT_CMD(
+	detect_key, 2, 1, do_detect_key,
+	"detect the Key press",
+	""
+);
+
+U_BOOT_CMD(
+	ping_flood, 2, 1, do_ping_flood,
+	"Do the PING flood tets on the LCM",
+	""
+);
+
+#endif /* end of DEBUG_XTM330_LCM */
+
+int lcd_clear (void)
+{
+	int ret;
+	ret = Run_Command (CMD_CLEAR_LCD, NULL, 0);
+	return 0;
+}
+
+int lcd_puts (int line, char * text)
+{
+	int ret;
+	char *display_text = text;
+
+	if (!text)
+		return -1;
+	if (line == 0)
+		 ret = Run_Command (CMD_DISP_LCD_LINE1, (UCHAR *) display_text, 0);
+	else 
+		 ret = Run_Command (CMD_DISP_LCD_LINE2, (UCHAR *) display_text, 0);
+
+	return 0;
+}
+
--- u-boot-2011.03/board/freescale/xtm330/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/ddr.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
+				   unsigned int ctrl_num);
+
+#define DATARATE_667MHZ 666666666
+
+#if 0 /* The Original ddr parameter */
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000003F
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014302
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655A608
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xc70c0000	/* Type = DDR3*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x04401010
+#define CONFIG_SYS_DDR_TIMING_4		0x00220001
+#define CONFIG_SYS_DDR_TIMING_5		0x03402400
+
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_667	0x6f6b4846
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0fa8c8cf
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_667	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_667	0x8000c000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0c300000
+#else /* From customer ddr parameter  */
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000003F
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014302
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655f607
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xc70c0008	/* Type = DDR3*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401010
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x02401400
+
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x5c5be544
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0fa890ce
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00061220
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0a28028a
+#endif
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_667 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_667,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_667,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_667,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_667,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_667,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_667,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_667,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_667,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2,
+/*
+ *  From customer ddr parameter
+ */
+	.ddr_cdr1 =  0x80000000
+};
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+
+phys_size_t fixed_sdram (void)
+{
+	sys_info_t sysinfo;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	size_t ddr_size;
+
+	get_sys_info(&sysinfo);
+	printf("Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, sysinfo.freqDDRBus));
+
+	memcpy(&ddr_cfg_regs, &ddr_cfg_regs_667, sizeof(ddr_cfg_regs));
+
+	ddr_size = CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+
+	set_ddr_laws(0, ddr_size, LAW_TRGT_IF_DDR_1);
+	return ddr_size;
+}
--- u-boot-2011.03/board/freescale/xtm330/S6A0069-lcd.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/S6A0069-lcd.c	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,703 @@
+/********************************************************
+ * ----------- LCD lib for chelan ----------------
+ *
+ * @file panel-chelan.c
+ *
+ * @brief front panel handling and library routines for chelan
+ *
+ * @author: Mukund Jampala <mukund.jampala@watchguard.com>
+ * Copyright 2011, WatchGuard Technologies, Inc.
+ * All Rights Reserved
+ *
+ * @date Wednesday Mar 02, 2011
+ *
+ * @par Function:
+ *  1. library functions for LCD init and configure
+ *  2. Change Baud rates
+ *  3. Fetch the firmware Revision
+ *
+ * Future expansions:
+ *  - save boot state and serial numbers
+ *
+ ********************************************************/
+
+/*
+ * Something about the chip.
+ * From the lanner documents, there is a SUMSUNG S6A0069 Controller is being initialized by lanner coltroller (VC2025).
+ * VC2025 talks to the serial port for user commands and controlling part.
+ *
+ * The S6A0069 LCD controller is pretty close the well known LCD controller HD44780.
+*/
+
+#include <common.h>
+
+#include  "S6A0069-private.h"
+#include  "serial.h"
+
+/* GLOBALS */
+int debug_level = FULL_DBG;
+
+/* Buffer management stuff */
+volatile UCHAR	serial_buffer[READ_BUFFER_SIZE];
+int	head;
+int	tail;
+int	tail_peek;
+
+extern ulong sys_start; /* for keypad detect window MGMT */
+
+void send_packet (CMD_PACKET * pCMD, UCHAR * pdata);
+
+#define FACTORY_KEYPAD_TEST_COUNT 1
+
+int wait_response (CMD_PACKET * pCMD);
+
+	
+int
+setup_keypad(void)
+{
+    CMD_PACKET *pCMD = NULL;
+    CMD_PACKET CMD, CMD_wr;
+    int status = -1;
+    UCHAR data[4];
+
+    data[0] = (KP_S1+KP_S2+KP_S3+KP_S4);
+    data[1] = (KP_S1+KP_S2+KP_S3+KP_S4);
+    data[3] = '\0';
+
+    /* prepare keypad setting */
+    DbgPrint (FULL_DBG, " Setting the Keypad ...\n");
+
+    /* Format the Packet */
+    pCMD = format_packet (&CMD_wr, CMD_CONFIG_KEY_MODE, (UCHAR *) data, 2, 0);
+    if (pCMD == NULL)
+        return status;
+
+    /* Write the comand to LCD Controller */
+    if ((status = writeLCD (pCMD)) < 0)
+        return status;
+    if ((status = wait_response (&CMD))) {
+        DbgPrint (FULL_DBG,  "Timed out waiting for a response.\n");
+    } else {
+        DbgPrint (FULL_DBG,  "Got some Packet ...\n");
+    }
+    DbgPrint (FULL_DBG,  "Send packet completed\n");
+
+    return 0;
+}
+
+UCHAR
+poll_keypad_response (CMD_PACKET * rCMD)
+{
+    CMD_PACKET *pCMD = NULL;
+    CMD_PACKET CMD_wr;
+    int status = -1;
+
+    DbgPrint (FULL_DBG, " Reading the Keypad ...\n");
+
+    /* Format the Packet */
+    pCMD = format_packet (&CMD_wr, CMD_READ_KEY_STATUS, NULL, 0, 0);
+    if (pCMD == NULL)
+	return status;
+
+    DbgPrint (BASIC_DBG, "write Command\n");
+    /* Write the comand to LCD Controller */
+    if ((status = writeLCD (pCMD)) < 0)
+	return status;
+
+    /* Wait for response */
+    if ((status = wait_response (rCMD))) {
+	 DbgPrint (BASIC_DBG, "Timed out waiting for a response.\n");
+    } else {
+	 DbgPrint (BASIC_DBG, "Got some Packet ...\n");
+    }
+
+    return status;
+}
+
+int poll_keypad(UCHAR *key)
+{
+
+    CMD_PACKET CMD;
+    int status = 0;
+
+    if(!poll_keypad_response(&CMD)) {
+#ifdef TEST
+	dump_packet (&CMD);
+#endif
+        switch( CMD.data[0] ) {
+            case KP_S1:
+                DbgPrint (BASIC_DBG, "KP_S1 PRESSED\n");
+                *key = 'a';
+	        break;
+            case KP_S2:
+	        DbgPrint (BASIC_DBG, "KP_S2 PRESSED\n");
+                *key = 'b';
+                break;
+            case KP_S3:
+                DbgPrint (BASIC_DBG, "KP_S3 PRESSED\n");
+                *key = 'c';
+                break;
+            case KP_S4:
+                DbgPrint (BASIC_DBG, "KP_S4 PRESSED\n");
+                *key = 'd';
+                break;
+            case KP_S1+16:
+                DbgPrint (BASIC_DBG, "KP_S1 RELEASED\n");
+                *key = 'A';
+                break;
+            case KP_S2+16:
+                DbgPrint (BASIC_DBG, "KP_S2 RELEASED\n");
+                *key = 'B';
+                break;
+            case KP_S3+16:
+                DbgPrint (BASIC_DBG, "KP_S3 RELEASED\n");
+                *key = 'C';
+                break;
+            case KP_S4+16:
+                DbgPrint (BASIC_DBG, "KP_S4 RELEASED\n");
+                *key = 'D';
+                break;
+            default:
+                DbgPrint (BASIC_DBG, "NO Key activity detected\n");
+		*key = 'Y';
+                break;
+        }
+	if (*key == 'Y')
+        	status = 0;
+	else
+		status = 1;
+
+    } else {
+
+        DbgPrint (FULL_DBG, "Timed out waiting for a response.\n");
+        status = 0;
+    }
+
+    return status;
+}
+
+/* boot time optimization: Make sure we dont wait more than this time */
+#define OLD_CTRL_MAX_KEYPAD_TIMEOUT_MS 3900 /* OLD LCM module */ 
+#define NEW_CTRL_MAX_KEYPAD_TIMEOUT_MS 2500 /* new LCM module */
+
+#define MAX_PINGS 60
+
+/*
+ * @about: Mukund J
+ *	This function is just supposed to detect the key and just that.
+ *	But unfortunately, as the controller is not comming up for a 
+ *	while after the boot, I have do do more. like ...
+ *		So, it init the LCM when it detects a response from 
+ *		the LCM controller for the first time (only).
+ */
+UCHAR detect_keypress(void)
+{
+	int i;
+	UCHAR key;
+	int ret;
+
+	/* time mesurements */
+	ulong keypad_timeo;
+#ifdef TIMINGS_DEBUG
+	ulong ping_detect_t = 0;
+	ulong keypad_detect_t = 0, exit_t = 0;
+#endif
+
+	/* there is no point in KEY-PRESS detection event untill the controller is UP */
+	for (i=0; i<=MAX_PINGS; i++) {
+ 		ret = Run_Command (CMD_PING, (UCHAR *) "T", 0);
+		if (ret != -1 ) {
+			DbgPrint (FULL_DBG, "PING response rec'd: b.out @ i = %d\n", i);
+			/* reinit and turn on the display now and (only once) */
+			lcm_panel_init();
+#ifdef TIMINGS_DEBUG
+			/* DEBUG: When NO key is pressed: sys_start = 84, ping_detect_t = 3508 */
+			ping_detect_t = get_timer(sys_start);
+			DbgPrint (FULL_DBG, "sys_start = %ld, ping_detect_t = %ld\n", sys_start, ping_detect_t);
+#endif
+			udelay(20000); /* assuming other BUGs reported are true,
+					* so add 20 ms delay after lcm init'zed */
+			break;
+		}
+		udelay(20000); /* 20 ms delay between each request */
+	}
+
+	if (i==MAX_PINGS) {
+		printf ("ERROR: NO LCM response detected\n");
+	}
+ 
+	/*
+	 * With the above PING command in place, by the time we to the below loop,
+	 * we already have a GOOD responsive controller. So, all interations can
+	 * be counted as good.
+	 * We intened to exit the loop if no key is pressed or the MAX timeour set is
+	 * reached.
+	 */
+	for(i=0; i<20; i++) {	/* MAX iterations == 20, timeout after that. */
+		DbgPrint (FULL_DBG, "detect_keypress: i = %d\n", i);
+		ret = poll_keypad(&key);
+		if (ret) {
+			/* poll keypad only if: (optimise boot time. litte BIT only)
+			 * 1. (keypad_timeo < OLD_CTRL_MAX_KEYPAD_TIMEOUT_MS) ms timeout
+			 * 2. (interation > 10): atleast give 10 iteration chance to the user
+			 */
+			keypad_timeo = get_timer(sys_start);
+			if ((keypad_timeo > OLD_CTRL_MAX_KEYPAD_TIMEOUT_MS) && (i>10) )
+				break;
+
+			DbgPrint (FULL_DBG, "Key detected = %c, intr = %d\n",
+				key, i);
+#ifdef TIMINGS_DEBUG
+			/* DEBUG: VALID KEY detected: sys_start = 84, keypad_detect_t = 3900 */
+			keypad_detect_t = get_timer(sys_start);
+			DbgPrint (FULL_DBG, "VALID KEY detected: sys_start = %ld, \
+			keypad_detect_t = %ld\n", sys_start, keypad_detect_t);
+#endif
+			return key;
+		}
+		udelay(1200); /* 1.2 ms delay if not key being pressed, wait a bit between each try */
+	}
+
+	/* Display WG logo only when the key is NOT pressed or MAX timeout reached */
+	printf ("WatchGuard\n");
+	/* Finally, Display the Watchguard logo if we get here */
+	lcd_clear();
+	udelay(12000); /* delay needed between clear and display */
+	lcd_puts (0, "    WatchGuard");
+
+#ifdef TIMINGS_DEBUG
+	/* DEBUG: When NO key is pressed: total intr=14: sys_start = 84, exit_t = 4259 */
+	exit_t = get_timer(sys_start);
+	DbgPrint (FULL_DBG, "total intr=%d: sys_start = %ld, exit_t= %ld\n", \
+		sys_start, exit_t);
+#endif	
+	return key;
+}
+
+int
+my_write ( char *str, int len)
+{
+	lcm_serial_puts (str, len);
+	return 0;
+}
+
+#define READ_OVERBUFFER 10
+int
+my_read ( UCHAR *str, int size)
+{
+	int good = 0, bad = 0;
+	int i=0;
+	if (!str)
+		return -1;
+
+	/* for (i=0; i< size; ++i) { */
+	for (i=0; i< (sizeof(CMD_PACKET)); ++i) {
+		if (lcm_serial_tstc()) {	/* we got a key press	*/
+			str[good] = lcm_serial_getc ();
+			good++;
+		} else {
+			bad++;
+		}
+		if (bad)
+			goto exit;
+	}
+exit:
+	str[good] = '\0'; // append with a NULL char {string terminator}
+	return good;
+}
+
+int
+writeLCD (const void *cmd)
+{
+    int ret = -1;
+    CMD_PACKET *cmdt = (CMD_PACKET *) cmd;
+#ifdef LCM_IO_DEBUG
+    unsigned char *data = (unsigned char *) cmd;
+    int i;
+#endif
+
+    DbgPrint (BASIC_DBG, "Send length = %d\n", cmdt->data_length + CMD_SIZE);
+#ifdef LCM_IO_DEBUG
+    printf (" === Packet writeLCD <len=%d> === \n", (cmdt->data_length + CMD_SIZE));
+    for (i = 0; i < (cmdt->data_length + CMD_SIZE); i++) {
+	printf ("%2.2x ", *(data + i));
+        if (!(i % 8))
+           printf ("\n");
+    }
+    printf ("\n");
+#endif
+
+    // u-boot HACK, fix it
+    // ret = my_write ((char *)cmd, (cmdt->data_length) + CMD_SIZE);
+    ret = my_write ((char *)cmd, (cmdt->data_length) + CMD_SIZE);
+    if (ret == -1)
+        DbgPrint (BASIC_DBG, "ERROR writing to the serial port\n");
+
+    DbgPrint (BASIC_DBG, "write-ret = %d\n", ret);
+
+    DbgPrint (BASIC_DBG, "write packet\n");
+    DbgPrint (BASIC_DBG, "write ret = %d\n", ret);
+    DbgPrint (BASIC_DBG, "CMD: command =    %d\n", cmdt->command);
+    DbgPrint (BASIC_DBG, "CMD: data_len =   %d\n", cmdt->data_length);
+    DbgPrint (BASIC_DBG, "CMD: data =       %s\n", cmdt->data);
+
+    return ret;
+}
+
+int
+readLCD (void)
+{
+    UCHAR buffer[READ_BUFFER_SIZE];
+    int BytesRead = 0, i;
+
+    BytesRead = my_read (buffer, READ_BUFFER_SIZE);
+    if (!BytesRead)
+    	return BytesRead;
+    else if (BytesRead != -1)
+        DbgPrint (FULL_DBG, "read bytes = %d\n\n", BytesRead);
+
+#ifdef LCM_IO_DEBUG
+    printf (" === Packet readLCD <len=%d> === \n", BytesRead);
+#endif
+
+    for (i = 0; i < BytesRead; i++) {
+#ifdef LCM_IO_DEBUG
+        printf ("0x%x ", buffer[i]);
+        if (!(i % 8))
+           printf ("\n");
+#endif
+        serial_buffer[head] = buffer[i];
+
+        /* track the HEAD */
+        head++;
+        if (READ_BUFFER_SIZE <= head)
+            head=0;
+    }
+
+    // DbgPrint (FULL_DBG, "read packet\n");
+    // DbgPrint (FULL_DBG, "CMD: command =    %d\n", cmd->command);
+    // DbgPrint (FULL_DBG, "CMD: data_len =   %d\n", cmd->data_length);
+    // DbgPrint (FULL_DBG, "CMD: data =       %s\n", cmd->data);
+
+    return BytesRead;
+
+}
+
+/* 
+ * returns the number of unprocessed bytes in the global buffer.
+*/
+int bytes_avail(void)
+{
+	int l_head;
+  	int ret;
+  
+  	l_head = head;
+  	if((ret = (l_head - (int)tail)) < 0)
+    		ret += READ_BUFFER_SIZE;
+
+  	return(ret);
+}
+
+
+UCHAR fetch_byte(void)
+{
+    UCHAR ret = 0;
+
+    int l_tail = tail;
+    int l_head = head;
+
+    /* See if there are any more bytes available. */
+    if (l_tail != l_head) {
+
+        /* There is at least one more ubyte. */
+        ret = serial_buffer[l_tail];
+
+        /* Increment the pointer and wrap if needed. */
+        l_tail ++;
+        if(READ_BUFFER_SIZE <= l_tail)
+            l_tail = 0;
+
+        tail=l_tail;
+    }
+    return(ret);
+}
+
+
+int peek_bytes_avail(void)
+{
+    int	l_head;
+    int ret;
+  
+    l_head = head;
+    if((ret = (l_head -(int)tail_peek) ) < 0)
+        ret += READ_BUFFER_SIZE;
+
+    return(ret);
+}
+
+
+void sync_peek_pointer(void)
+{
+    tail_peek = tail;
+}
+
+
+void accept_peeked_data(void)
+{
+    tail = tail_peek;
+}
+
+
+UCHAR peek_byte(void)
+{
+    int l_tail_peek;
+    int l_head;
+    UCHAR ret = 0;
+
+    l_tail_peek = tail_peek;
+    l_head = head;
+  
+    /* See if there are any more bytes available. */
+    if (l_tail_peek != l_head) {
+
+    /* There is at least one more ubyte. */
+    ret = serial_buffer[l_tail_peek];
+
+    /* Increment the pointer and wrap if needed. */
+    l_tail_peek ++;
+    if( READ_BUFFER_SIZE <= l_tail_peek)
+        l_tail_peek = 0;
+
+    tail_peek = l_tail_peek;
+
+    }
+
+    return(ret);
+}
+
+/*
+ * wait_response: wait response from LCM-serial module
+ *  input: 
+ * 	none
+ *
+ * output: 
+ *	0     : mean no response from LCM-serial module
+ *	other : mean got correct response
+ */
+int
+wait_response (CMD_PACKET * pCMD)
+{
+    volatile int k;
+    int timed_out = -1;
+
+    for (k = 0; k <= 1000000; k++) {
+	if (packet_available (pCMD)) {
+	     // DbgPrint (FULL_DBG,"package data ****AVAILABLE****\n");
+	     return 0;
+	} else {
+	     // DbgPrint (FULL_DBG,"****** NO DATA ******\n");
+	}
+    }
+
+    return timed_out;
+}
+
+void
+clear_display (void)
+{
+    // CMD_PACKET *cmd;
+    int ret = -1;
+    ret = Run_Command (CMD_CLEAR_LCD, NULL, 0);
+}
+
+char *
+get_firmware_version (void)
+{
+    CMD_PACKET *cmd;
+    CMD_PACKET CMD_wr;
+    int status;
+
+    DbgPrint (FULL_DBG, "<%s>\n", __FUNCTION__);
+    cmd = format_packet (&CMD_wr, CMD_GET_VERSION, NULL, 0, 0);	/* format for Write IO */
+    if (cmd == NULL)
+	return NULL;
+    if (writeLCD (cmd) < 0)	/* Write the comand to LCD Controller */
+	return NULL;
+
+    if ((status = wait_response (cmd))) {
+
+        DbgPrint (FULL_DBG,  "Timed out waiting for a response.\n");
+    } else {
+        DbgPrint (FULL_DBG,  "Got some Packet ...\n");
+    }
+
+    return NULL;		/* TODO: should be returning valid dat ptr instread */
+}
+
+/*
+ * probe_lcm: try to detect lcm-serial module
+ * input: 
+ *	none
+ * output: 
+ *	-1    : mean no lcm-serial modules be detected
+ *	other : mean device number
+ */
+int
+cmd_processor (UCHAR cmd, UCHAR * data, int len)
+{
+    CMD_PACKET *pCMD = NULL;
+    CMD_PACKET CMD, CMD_wr;
+    int data_len = len;
+    int status = -1;
+
+     if ((!len) && (data != NULL)) {  /* SET data & data_len */
+	    data_len = strlen ((const char *) data);
+    }
+
+    /* Format the Packet */
+    pCMD = format_packet (&CMD_wr, cmd, data, data_len, 0);
+    if (pCMD == NULL)
+	return status;
+
+    DbgPrint (BASIC_DBG, "writeLCD being called\n");
+    /* Write the comand to LCD Controller */
+    if ((status = writeLCD (pCMD)) < 0)
+	return status;
+    DbgPrint (BASIC_DBG, "Send packet completed\n");
+
+    /* Wait for response */
+    if ((status = wait_response (&CMD)))
+     {
+	 DbgPrint (BASIC_DBG, "Timed out waiting for a response.\n");
+     }
+    else
+     {
+	 DbgPrint (BASIC_DBG, "Got some Packet ...\n");
+     }
+
+    return status;
+}
+
+/*
+ * Run_Command:
+ *   run the command with this data and assicated data_len.
+ */
+int
+Run_Command (UCHAR command, UCHAR * data, int len)
+{
+    int invalid_cmd = 0;
+
+    switch (command)
+     {
+     case CMD_PING:
+	 DbgPrint (BASIC_DBG, "COMMAND 0 :PING\n");
+	 break;
+     case CMD_GET_VERSION:
+	 DbgPrint (BASIC_DBG, "COMMAND 1 :Get Firmware Version\n");
+	 break;
+     case CMD_WRITE_USER_FLASH:
+	 DbgPrint (BASIC_DBG, "COMMAND 2 :Write User Flash\n");
+	 break;
+     case CMD_READ_USER_FLASH:
+	 DbgPrint (BASIC_DBG, "COMMAND 3 :Read User Flash\n");
+	 break;
+     case CMD_STORE_SETTING:
+	 DbgPrint (BASIC_DBG, "COMMAND 4 :Store Setting\n");
+	 break;
+     case CMD_RESET_LCM_MODULE:
+	 DbgPrint (BASIC_DBG, "COMMAND 5 :Reset LCM-serial Modules\n");
+	 break;
+     case CMD_CLEAR_LCD:
+	 DbgPrint (BASIC_DBG, "COMMAND 6 :Clear LCM Screen\n");
+	 break;
+     case CMD_DISP_LCD_LINE1:
+	 DbgPrint (BASIC_DBG, "COMMAND 7 :Display LCM Line 1\n");
+	 break;
+     case CMD_DISP_LCD_LINE2:
+	 DbgPrint (BASIC_DBG, "COMMAND 8 :Display LCM Line 2\n");
+	 break;
+     case CMD_SET_CURSOR_POSITION:
+	 DbgPrint (BASIC_DBG, "COMMAND 11 :Set Cursor Position\n");
+	 break;
+     case CMD_SET_CURSOR_STYLE:
+	 DbgPrint (BASIC_DBG, "COMMAND 12 :Set Cursor Style\n");
+	 break;
+     case CMD_SEND_CMD_TO_LCD:
+	 DbgPrint (BASIC_DBG,
+		   "COMMAND 22 :Send Command PassThrough To LCM\n");
+	 break;
+     case CMD_CONFIG_KEY_MODE:
+	 DbgPrint (BASIC_DBG, "COMMAND 23 :Config Key Mode\n");
+	 break;
+     case CMD_READ_KEY_STATUS:
+	 DbgPrint (BASIC_DBG, "COMMAND 24 :Read Key Status\n");
+	 break;
+     case CMD_DISP_LCD_ANY_LOCATE:
+	 DbgPrint (BASIC_DBG, "COMMAND 31 :Display On Any Location\n");
+	 break;
+     case CMD_SET_LED_STATUS:
+	 DbgPrint (BASIC_DBG, "COMMAND 32 :Set LED Status/LCD backlight\n");
+	 break;
+     case CMD_SET_BAUDRATE:
+	 DbgPrint (BASIC_DBG, "COMMAND 33 :Set Baudrate\n");
+	 break;
+     default:
+	 invalid_cmd = -1;
+	 DbgPrint (BASIC_DBG, "Invalid Command\n");
+	 break;
+     }
+
+    /* Process only if it is known command */
+    if (invalid_cmd != -1)
+	return cmd_processor (command, data, len);
+
+    return invalid_cmd;
+}
+
+
+
+int
+Ser_init (char *devname, int bitrate)
+{
+	return 0;
+}
+void
+Ser_deinit (char *devname)
+{
+
+}
+
+int
+set_led (LED_COLOR_t color, int rate)
+{
+    	UCHAR data[8]; /* = {1, 100, 1,}; LED packet */
+	int ret;
+ 
+	printf ("color = %d, rate = %d\n", color, rate);
+
+	if(color < S6A_PLAIN_LED || color > S6A_RED_LED )
+		return -1;
+	if ( (rate < S6A_LED_SOLID_OFF) || (rate > S6A_LED_SOLID_ON))
+		return -2;
+
+	data[0] = (UCHAR) color; /* color */
+	data[1] = (UCHAR) 100;	 /* duration ?? */
+	data[2] = (UCHAR) rate;	 /* duration ?? */
+	data[3] = (UCHAR) '\0';	 /* string terminator */
+
+	ret = Run_Command (CMD_SET_LED_STATUS, data, 3);
+	return ret;
+}
+
+int
+set_baudrate (int rate)
+{
+    	UCHAR data[8]; /* = {1, 100, 1,}; LED packet */
+	int ret;
+ 
+	data[0] = (UCHAR) rate;			/* change to preset U-boot baud rate */
+	data[1] = '\0';  			/* string terminator */
+	ret = Run_Command (CMD_SET_BAUDRATE, (UCHAR *) data, 1);
+	return ret;
+}
+
--- u-boot-2011.03/board/freescale/xtm330/S6A0069-packet.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm330/S6A0069-packet.c	2022-05-09 14:05:11.236067868 -0700
@@ -0,0 +1,314 @@
+
+/********************************************************
+ * ----------- LCD packet handling  chelan ----------------
+ *
+ * @file packet.c
+ *
+ * @brief packet formatting and handling and library routines for chelan
+ *
+ * @author: Mukund Jampala <mukund.jampala@watchguard.com>
+ * Copyright 2011, WatchGuard Technologies, Inc.
+ * All Rights Reserved
+ *
+ * @date Wednesday Mar 02, 2011
+ *
+ * @par Function:
+ *  1. LCD controller packet formatting
+ *  2. CRC checking and calculating
+ *
+ ********************************************************/
+
+extern int debug_level;
+
+#include  "S6A0069-private.h"
+
+USHORT
+calculate_crc (unsigned char *buff, USHORT len, USHORT seed)
+{
+    //CRC lookup table to avoid bit-shifting loops.
+    static const USHORT crcLookupTable[256] =
+	{ 0x00000, 0x01189, 0x02312, 0x0329B, 0x04624, 0x057AD, 0x06536,
+	0x074BF,
+	0x08C48, 0x09DC1, 0x0AF5A, 0x0BED3, 0x0CA6C, 0x0DBE5, 0x0E97E,
+	0x0F8F7,
+	0x01081, 0x00108, 0x03393, 0x0221A, 0x056A5, 0x0472C, 0x075B7,
+	0x0643E,
+	0x09CC9, 0x08D40, 0x0BFDB, 0x0AE52, 0x0DAED, 0x0CB64, 0x0F9FF,
+	0x0E876,
+	0x02102, 0x0308B, 0x00210, 0x01399, 0x06726, 0x076AF, 0x04434,
+	0x055BD,
+	0x0AD4A, 0x0BCC3, 0x08E58, 0x09FD1, 0x0EB6E, 0x0FAE7, 0x0C87C,
+	0x0D9F5,
+	0x03183, 0x0200A, 0x01291, 0x00318, 0x077A7, 0x0662E, 0x054B5,
+	0x0453C,
+	0x0BDCB, 0x0AC42, 0x09ED9, 0x08F50, 0x0FBEF, 0x0EA66, 0x0D8FD,
+	0x0C974,
+	0x04204, 0x0538D, 0x06116, 0x0709F, 0x00420, 0x015A9, 0x02732,
+	0x036BB,
+	0x0CE4C, 0x0DFC5, 0x0ED5E, 0x0FCD7, 0x08868, 0x099E1, 0x0AB7A,
+	0x0BAF3,
+	0x05285, 0x0430C, 0x07197, 0x0601E, 0x014A1, 0x00528, 0x037B3,
+	0x0263A,
+	0x0DECD, 0x0CF44, 0x0FDDF, 0x0EC56, 0x098E9, 0x08960, 0x0BBFB,
+	0x0AA72,
+	0x06306, 0x0728F, 0x04014, 0x0519D, 0x02522, 0x034AB, 0x00630,
+	0x017B9,
+	0x0EF4E, 0x0FEC7, 0x0CC5C, 0x0DDD5, 0x0A96A, 0x0B8E3, 0x08A78,
+	0x09BF1,
+	0x07387, 0x0620E, 0x05095, 0x0411C, 0x035A3, 0x0242A, 0x016B1,
+	0x00738,
+	0x0FFCF, 0x0EE46, 0x0DCDD, 0x0CD54, 0x0B9EB, 0x0A862, 0x09AF9,
+	0x08B70,
+	0x08408, 0x09581, 0x0A71A, 0x0B693, 0x0C22C, 0x0D3A5, 0x0E13E,
+	0x0F0B7,
+	0x00840, 0x019C9, 0x02B52, 0x03ADB, 0x04E64, 0x05FED, 0x06D76,
+	0x07CFF,
+	0x09489, 0x08500, 0x0B79B, 0x0A612, 0x0D2AD, 0x0C324, 0x0F1BF,
+	0x0E036,
+	0x018C1, 0x00948, 0x03BD3, 0x02A5A, 0x05EE5, 0x04F6C, 0x07DF7,
+	0x06C7E,
+	0x0A50A, 0x0B483, 0x08618, 0x09791, 0x0E32E, 0x0F2A7, 0x0C03C,
+	0x0D1B5,
+	0x02942, 0x038CB, 0x00A50, 0x01BD9, 0x06F66, 0x07EEF, 0x04C74,
+	0x05DFD,
+	0x0B58B, 0x0A402, 0x09699, 0x08710, 0x0F3AF, 0x0E226, 0x0D0BD,
+	0x0C134,
+	0x039C3, 0x0284A, 0x01AD1, 0x00B58, 0x07FE7, 0x06E6E, 0x05CF5,
+	0x04D7C,
+	0x0C60C, 0x0D785, 0x0E51E, 0x0F497, 0x08028, 0x091A1, 0x0A33A,
+	0x0B2B3,
+	0x04A44, 0x05BCD, 0x06956, 0x078DF, 0x00C60, 0x01DE9, 0x02F72,
+	0x03EFB,
+	0x0D68D, 0x0C704, 0x0F59F, 0x0E416, 0x090A9, 0x08120, 0x0B3BB,
+	0x0A232,
+	0x05AC5, 0x04B4C, 0x079D7, 0x0685E, 0x01CE1, 0x00D68, 0x03FF3,
+	0x02E7A,
+	0x0E70E, 0x0F687, 0x0C41C, 0x0D595, 0x0A12A, 0x0B0A3, 0x08238,
+	0x093B1,
+	0x06B46, 0x07ACF, 0x04854, 0x059DD, 0x02D62, 0x03CEB, 0x00E70,
+	0x01FF9,
+	0x0F78F, 0x0E606, 0x0D49D, 0x0C514, 0x0B1AB, 0x0A022, 0x092B9,
+	0x08330,
+	0x07BC7, 0x06A4E, 0x058D5, 0x0495C, 0x03DE3, 0x02C6A, 0x01EF1,
+	0x00F78
+    };
+
+    //Initial CRC value is 0x0FFFF.
+    register USHORT newCrc;
+#ifdef BIG
+    register USHORT newCrcswap;
+#endif
+    newCrc = seed;
+    //This algorithim is based on the IrDA LAP example.
+    while (len--)
+	newCrc = (newCrc >> 8) ^ crcLookupTable[(newCrc ^ *buff++) & 0xff];
+    //Make this crc match the one's complement that is sent in the packet.
+#ifdef BIG
+    newCrcswap = (((~newCrc) & 0xff00) >> 8) | (((~newCrc) & 0xff) << 8);
+    return (newCrcswap);
+#else
+    return (~newCrc);
+#endif
+
+}
+
+void
+dump_packet (CMD_PACKET * pCMD)
+{
+    int i = 0;
+
+    DbgPrint (BASIC_DBG, " === Packet dump === \n");
+    DbgPrint (BASIC_DBG, "CMD: command =    %d\n", pCMD->command);
+    DbgPrint (BASIC_DBG, "CMD: data_len =   %d\n", pCMD->data_length);
+    DbgPrint (BASIC_DBG, "CMD: data follow:\n");
+    for (i = 0; i < pCMD->data_length; i++)
+	printf ("0x%x ", pCMD->data[i]);
+    printf ("\n");
+}
+
+CMD_PACKET one_packet;
+/*
+ * Format the packet and send it 
+ * to serial port. 
+ */
+CMD_PACKET *
+format_packet (CMD_PACKET *cmd, UCHAR CMD, UCHAR * data, UCHAR data_length, USHORT CRC)
+{
+    USHORT *p;
+
+    memset(cmd, 0, sizeof(CMD_PACKET));
+    DbgPrint (FULL_DBG, "pCMD ptr = %p\n", cmd);
+
+    if (cmd == NULL)
+	return NULL;
+
+    /* Fill up the packet as expected */
+    cmd->command = CMD;
+
+    /* Check if the data lenght is too BIG */
+    cmd->data_length =
+	(data_length > MAX_DATA_LENGTH) ? MAX_DATA_LENGTH : data_length;
+    cmd->data_remaining = (data_length > MAX_DATA_LENGTH) ? (data_length - MAX_DATA_LENGTH) : 0;	/* Should'nt that be something that should go into the LIBRARY-code */
+
+
+    DbgPrint (FULL_DBG, "whats going on\n");
+    if (data != NULL)
+	strncpy ((char *) cmd->data, (const char *) data, cmd->data_length);
+    DbgPrint (FULL_DBG, "whats going on .am i here \n");
+
+    /* Get the CRC pointer */
+    p = (unsigned short *) &(cmd->data[cmd->data_length]);
+    DbgPrint (BASIC_DBG, "address test CRC(indirect) =  %p\n",
+	      &(cmd->data[cmd->data_length]));
+
+    /* calc the CRC and put it in the packet */
+    *p = calculate_crc ((unsigned char *) cmd, (cmd->data_length) + 2,
+			0xFFFF);
+
+#ifdef LCM_DEBUG
+    dump_packet (cmd);
+#endif
+    DbgPrint (BASIC_DBG, "CMD: command =    %d\n", cmd->command);
+    DbgPrint (BASIC_DBG, "CMD: data_len =   %d\n", cmd->data_length);
+    DbgPrint (BASIC_DBG, "CMD: data =       %s\n", cmd->data);
+    DbgPrint (BASIC_DBG, "CMD: CRC =        0x%4x\n", cmd->CRC.in_word);
+    DbgPrint (BASIC_DBG, "CMD: CRC (imme.aft.data) =        0x%04x\n", *p);
+
+    return cmd;
+}
+
+void
+send_packet (CMD_PACKET * pCMD, UCHAR * pdata)
+{
+#ifdef LCM_IO_DEBUG
+    int i;
+#endif
+    unsigned short *p;
+
+    /* Ignore 'pdata' for now. */
+
+    DbgPrint (FULL_DBG, "Enter send_packet\n");
+    DbgPrint (FULL_DBG, "CMD = %2.2x DATA_LEN = %d DATA=", pCMD->command,
+	      pCMD->data_length);
+#ifdef LCM_IO_DEBUG
+    for (i = 0; i < pCMD->data_length; i++)
+	printf ("%c ", pCMD->data[i]);
+    printf ("\n");
+#endif
+    p = (unsigned short *) &(pCMD->data[pCMD->data_length]);
+    *p = calculate_crc ((unsigned char *) pCMD, (pCMD->data_length) + 2,
+			0xFFFF);
+#ifdef LCM_DEBUG
+    dump_packet (pCMD);
+#endif
+    DbgPrint (FULL_DBG, "CMD: command =    %d\n", pCMD->command);
+    DbgPrint (FULL_DBG, "CMD: data_len =   %d\n", pCMD->data_length);
+    DbgPrint (FULL_DBG, "CMD: data =       %s\n", pCMD->data);
+    DbgPrint (FULL_DBG, "CMD: CRC =        0x%4X\n", pCMD->CRC.in_word);
+    DbgPrint (FULL_DBG, "CMD: CRC(imme.aft.data) =        0x%4X\n", *p);
+    /* Packet is READY. Now write it! */
+    writeLCD ((const void *) pCMD);
+
+    DbgPrint (FULL_DBG, "Exit send_packet\n");
+}
+
+extern void sync_peek_pointer(void);
+extern UCHAR peek_byte(void);
+extern UCHAR fetch_byte(void);
+extern int peek_bytes_avail(void);
+extern void accept_peeked_data(void);
+
+
+/*
+ * check_for_packet()
+ * 
+ * Check_for_packet() will see if there is a valid packet in the input buffer.
+ * We do have to imporement this to make sure the operatin we performed is successfull.
+ * We will just check if there is incoming part and if it has a VALID type.
+ *
+ * If there is, it will copy it into incoming_response and return 1. If there
+ * is not it will return 0. incoming packet may get partially filled with
+ * garbage if there is not a valid packet available.
+ * We are not going to do this now. It seems like a OVERHEAD.
+ *
+ */
+int
+packet_available (CMD_PACKET *packet)
+{
+    int nr_bytes;
+    CMD_PACKET tmp;
+    int i;
+
+    nr_bytes = readLCD ();
+
+    /* First off, there must be at least 4 bytes available in the input stream
+     * for there to be a valid command in it (command, length, no data, CRC).
+     */
+    if (nr_bytes < 0)
+	return (0);
+    if (peek_bytes_avail() < 4)
+	return (0);
+
+
+    /* "peek" stuff allows us to look into the RS-232 buffer */
+    sync_peek_pointer();
+
+
+    if( MAX_COMMAND < (0x3F & (tmp.command = peek_byte() ))) {           
+        /* Throw out one byte of garbage. Next pass through should re-sync. */
+        fetch_byte();
+	DbgPrint (BASIC_DBG, "MAX_COMMAND < (0x3F & (tmp.command = peek_byte() case\n");
+	DbgPrint (BASIC_DBG, "tmp.command = %d\n", tmp.command);
+        return(0);
+    }
+
+    /* There is a valid command byte. Get the data_length. The data length
+     * must be within reason.
+     */
+    if ( MAX_DATA_LENGTH < (tmp.data_length = peek_byte() )) {
+
+        /* Throw out one byte of garbage. Next pass through should re-sync. */
+        fetch_byte();
+	// DbgPrint (BASIC_DBG, "MAX_DATA_LENGTH < (tmp.data_length = peek_byte()\n");
+	// DbgPrint (BASIC_DBG, "MAX_DATA_LENGTH  = %d\n", MAX_DATA_LENGTH);
+	// DbgPrint (BASIC_DBG, "tmp.data_length   = %d\n", tmp.data_length);
+        return(0);
+    }
+
+   /* Now there must be at least incoming_response.data_length+sizeof(CRC) bytes
+    * still available for us to continue.
+    */
+
+    if( (int) peek_bytes_avail() < (tmp.data_length + 2) ) {
+        /* It looked like a valid start of a packet, 
+         * but it does not look like the complete packet has been received yet. */
+	// DbgPrint (BASIC_DBG, "peek_bytes_avail() < (tmp.data_length + 2)\n");
+	// DbgPrint (BASIC_DBG, "peek_bytes_avail() = %d\n", peek_bytes_avail());
+	// DbgPrint (BASIC_DBG, "tmp.data_length = %d\n", tmp.data_length);
+        return(0);
+    }
+
+    /* grab the data now */
+    for(i = 0; i < tmp.data_length; i++)
+    {
+        tmp.data[i]= peek_byte();
+    }
+
+    /* Now move over the CRC. */
+    tmp.CRC.in_bytes[0] = peek_byte();
+    tmp.CRC.in_bytes[1] = peek_byte();
+
+    if(tmp.CRC.in_word == calculate_crc((unsigned char *)&tmp, 
+			(tmp.data_length + 2), 0xFFFF))  {
+         /* **good packet**:  time to grab the entire packet */
+         accept_peeked_data();
+
+         memcpy(packet, &tmp, (tmp.data_length)+4);
+         return(1);
+    }
+
+    /* The CRC did not match. Toss out one byte of garbage. */
+    fetch_byte();
+    memcpy(packet, &tmp, (tmp.data_length)+4);
+    return (0);
+}
--- u-boot-2011.03/board/freescale/fbx_T10/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T10/Makefile	2022-05-09 14:05:11.204069166 -0700
@@ -0,0 +1,52 @@
+#
+# Copyright 2010-2011 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- u-boot-2011.03/board/freescale/fbx_T10/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T10/law.c	2022-05-09 14:05:11.204069166 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+#ifndef CONFIG_SDCARD
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_CPLD_BASE_PHYS, LAW_SIZE_128K, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2011.03/board/freescale/fbx_T10/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T10/tlb.c	2022-05-09 14:05:11.208069004 -0700
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+#ifndef CONFIG_NAND_SPL
+#ifndef CONFIG_SDCARD
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 2, BOOKE_PAGESZ_16M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE + 0x1000000,
+			CONFIG_SYS_FLASH_BASE_PHYS + 0x1000000,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 3, BOOKE_PAGESZ_16M, 1),
+#endif
+
+#ifdef CONFIG_PCI
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 4, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_256K, 1),
+#endif /* ifdef CONFIG_PCI */
+#endif
+
+#ifndef CONFIG_SDCARD
+	/* *I*G - Board CPLD  */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 6, BOOKE_PAGESZ_256K, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 7, BOOKE_PAGESZ_1M, 1),
+#endif
+
+#if defined(CONFIG_SYS_RAMBOOT)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 8, BOOKE_PAGESZ_1G, 1)
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2011.03/board/freescale/fbx_T10/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T10/ddr.c	2022-05-09 14:05:11.204069166 -0700
@@ -0,0 +1,250 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_DDR_RAW_TIMING
+#define CONFIG_SYS_DRAM_SIZE	512
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_800 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_800,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_800,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_800,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_800,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_800,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_800,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_800,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_800,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL_800,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_667 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_667,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_667,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_667,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_667,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_667,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_667,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_667,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_667,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL_667,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+fixed_ddr_parm_t fixed_ddr_parm_0[] = {
+	{750, 850, &ddr_cfg_regs_800},
+	{607, 749, &ddr_cfg_regs_667},
+	{0, 0, NULL}
+};
+
+unsigned long get_sdram_size(void)
+{
+	struct cpu_type *cpu;
+	phys_size_t ddr_size;
+
+	cpu = gd->cpu;
+	/* P1014 and it's derivatives support max 16it DDR width */
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E)
+		ddr_size = (CONFIG_SYS_DRAM_SIZE / 2);
+	else
+		ddr_size = CONFIG_SYS_DRAM_SIZE;
+
+	return ddr_size;
+}
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+phys_size_t fixed_sdram(void)
+{
+	int i;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	phys_size_t ddr_size;
+	ulong ddr_freq, ddr_freq_mhz;
+	struct cpu_type *cpu;
+
+#if defined(CONFIG_SYS_RAMBOOT)
+	return CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+#endif
+
+	ddr_freq = get_ddr_freq(0);
+	ddr_freq_mhz = ddr_freq / 1000000;
+
+	printf("Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, ddr_freq));
+
+	for (i = 0; fixed_ddr_parm_0[i].max_freq > 0; i++) {
+		if ((ddr_freq_mhz > fixed_ddr_parm_0[i].min_freq) &&
+		   (ddr_freq_mhz <= fixed_ddr_parm_0[i].max_freq)) {
+			memcpy(&ddr_cfg_regs, fixed_ddr_parm_0[i].ddr_settings,
+							sizeof(ddr_cfg_regs));
+			break;
+		}
+	}
+
+	if (fixed_ddr_parm_0[i].max_freq == 0)
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+					strmhz(buf, ddr_freq));
+
+	cpu = gd->cpu;
+	/* P1014 and it's derivatives support max 16bit DDR width */
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E) {
+		ddr_cfg_regs.ddr_sdram_cfg |= SDRAM_CFG_16_BE;
+		ddr_cfg_regs.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS >> 1;
+		ddr_cfg_regs.ddr_sdram_cfg &= ~0x00180000;
+		ddr_cfg_regs.ddr_sdram_cfg |= 0x001080000;
+	}
+
+	ddr_size = (phys_size_t) (CONFIG_SYS_SDRAM_SIZE * 1024 * 1024);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+
+	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE, ddr_size,
+					LAW_TRGT_IF_DDR_1) < 0) {
+		printf("ERROR setting Local Access Windows for DDR\n");
+		return 0;
+	}
+
+	return ddr_size;
+}
+
+#else /* CONFIG_DDR_RAW_TIMING */
+/*
+ * Samsung K4B2G0846C-HCF8
+ * The following timing are for "downshift"
+ * i.e. to use CL9 part as CL7
+ * otherwise, tAA, tRCD, tRP will be 13500ps
+ * and tRC will be 49500ps
+ */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 268435456u,
+	.capacity = 268435456u,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 14,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tCKmin_X_ps = 1875,
+	.caslat_X = 0x1e << 4,	/* 5,6,7,8 */
+	.tAA_ps = 13125,
+	.tWR_ps = 15000,
+	.tRCD_ps = 13125,
+	.tRRD_ps = 7500,
+	.tRP_ps = 13125,
+	.tRAS_ps = 37500,
+	.tRC_ps = 50625,
+	.tRFC_ps = 160000,
+	.tWTR_ps = 7500,
+	.tRTP_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tFAW_ps = 37500,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR on board";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	struct cpu_type *cpu;
+	int i;
+	popts->clk_adjust = 6;
+	popts->cpo_override = 0x1f;
+	popts->write_data_delay = 2;
+	popts->half_strength_driver_enable = 1;
+	/* Write leveling override */
+	popts->wrlvl_en = 1;
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+	popts->wrlvl_start = 0x8;
+	popts->trwt_override = 1;
+	popts->trwt = 0;
+
+	cpu = gd->cpu;
+	/* P1014 and it's derivatives support max 16it DDR width */
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E)
+		popts->data_bus_width = DDR_DATA_BUS_WIDTH_16;
+
+	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
+		popts->cs_local_opts[i].odt_rd_cfg = FSL_DDR_ODT_NEVER;
+		popts->cs_local_opts[i].odt_wr_cfg = FSL_DDR_ODT_CS;
+	}
+}
+
+#endif /* CONFIG_DDR_RAW_TIMING */
--- u-boot-2011.03/board/freescale/fbx_T10/fbx_T10.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T10/fbx_T10.c	2022-05-09 14:05:11.204069166 -0700
@@ -0,0 +1,341 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <tsec.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <pci.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_ifc.h>
+#include <asm/fsl_pci.h>
+
+#ifndef CONFIG_SDCARD
+#include <hwconfig.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define GPIO15_PCIE_RESET_SET		0x00010000
+#define MUX_CPLD_CAN_UART		0x00
+#define MUX_CPLD_TDM			0x01
+#define MUX_CPLD_SPICS0_FLASH		0x00
+#define MUX_CPLD_SPICS0_SLIC		0x02
+
+#ifndef CONFIG_SDCARD
+struct cpld_data {
+	u8 cpld_ver; /* cpld revision */
+	u8 pcba_ver; /* pcb revision number */
+	u8 twindie_ddr3;
+	u8 res1[6];
+	u8 bank_sel; /* NOR Flash bank */
+	u8 res2[5];
+	u8 usb2_sel;
+	u8 res3[1];
+	u8 porsw_sel;
+	u8 tdm_can_sel;
+	u8 spi_cs0_sel; /* SPI CS0 SLIC/SPI Flash */
+	u8 por0; /* POR Options */
+	u8 por1; /* POR Options */
+	u8 por2; /* POR Options */
+	u8 por3; /* POR Options */
+};
+
+void cpld_show(void)
+{
+	volatile struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+
+	printf("CPLD: V%x.%x PCBA: V%x.0\n",
+		in_8(&cpld_data->cpld_ver) & 0xF0,
+		in_8(&cpld_data->cpld_ver) & 0x0F,
+		in_8(&cpld_data->pcba_ver) & 0x0F);
+
+#ifdef CONFIG_DEBUG
+	printf("twindie_ddr =%x\n",
+		in_8(&cpld_data->twindie_ddr3));
+	printf("bank_sel =%x\n",
+		in_8(&cpld_data->bank_sel));
+	printf("usb2_sel =%x\n",
+		in_8(&cpld_data->usb2_sel));
+	printf("porsw_sel =%x\n",
+		in_8(&cpld_data->porsw_sel));
+	printf("tdm_can_sel =%x\n",
+		in_8(&cpld_data->tdm_can_sel));
+	printf("tdm_can_sel =%x\n",
+		in_8(&cpld_data->tdm_can_sel));
+	printf("spi_cs0_sel =%x\n",
+		in_8(&cpld_data->spi_cs0_sel));
+	printf("bcsr0 =%x\n",
+		in_8(&cpld_data->bcsr0));
+	printf("bcsr1 =%x\n",
+		in_8(&cpld_data->bcsr1));
+	printf("bcsr2 =%x\n",
+		in_8(&cpld_data->bcsr2));
+	printf("bcsr3 =%x\n",
+		in_8(&cpld_data->bcsr3));
+#endif
+}
+#endif
+
+int board_early_init_f (void)
+{
+	ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+#ifndef CONFIG_SDCARD
+	struct fsl_ifc *ifc = (void *)CONFIG_SYS_IFC_ADDR;
+	/* Clock configuration to access CPLD using IFC(GPCM) */
+	setbits_be32(&ifc->ifc_gcr, 1 << IFC_GCR_TBCTL_TRN_TIME_SHIFT);
+#endif
+	/*
+	* Reset PCIe slots via GPIO4
+	*/
+	/*
+	setbits_be32(&pgpio->gpdir, GPIO4_PCIE_RESET_SET);
+	setbits_be32(&pgpio->gpdat, GPIO4_PCIE_RESET_SET);
+	*/
+
+	setbits_be32(&pgpio->gpdir, GPIO15_PCIE_RESET_SET);
+	setbits_be32(&pgpio->gpdat, GPIO15_PCIE_RESET_SET);
+	return 0;
+}
+int board_early_init_r(void)
+{
+#ifndef CONFIG_SDCARD
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_16M, 1);
+
+	set_tlb(1, flashbase + 0x1000000,
+			CONFIG_SYS_FLASH_BASE_PHYS + 0x1000000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel+1, BOOKE_PAGESZ_16M, 1);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+#endif /* ifdef CONFIG_PCI */
+
+int checkboard (void)
+{
+	struct cpu_type *cpu;
+
+	cpu = gd->cpu;
+	printf ("Board: %sRDB ", cpu->name);
+#ifdef CONFIG_PHYS_64BIT
+	puts ("(36-bit addrmap)");
+#endif
+	puts ("\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct tsec_info_struct tsec_info[4];
+	struct cpu_type *cpu;
+	int num = 0;
+
+	cpu = gd->cpu;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	/* P1014 and it's derivatives do not support eTSEC3 */
+	if (cpu->soc_ver != SVR_P1014 && cpu->soc_ver != SVR_P1014_E) {
+		SET_STD_TSEC_INFO(tsec_info[num], 3);
+		num++;
+	}
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+	tsec_eth_init(bis, tsec_info, num);
+
+	return pci_eth_init(bis);
+}
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void fdt_del_flexcan(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"fsl,flexcan-v1.0")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void fdt_del_spi_flash(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"spansion,s25sl12801")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void fdt_del_spi_slic(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"zarlink,le88266")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void fdt_del_tdm(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"fsl,starlite-tdm")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+	struct cpu_type *cpu;
+
+	cpu = gd->cpu;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+#if defined(CONFIG_PCI)
+	FT_FSL_PCI_SETUP;
+#endif
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+	fdt_fixup_dr_usb(blob, bd);
+
+       /* P1014 and it's derivatives don't support CAN and eTSEC3 */
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E) {
+		fdt_del_flexcan(blob);
+		fdt_del_node_and_alias(blob, "ethernet2");
+	}
+#ifndef CONFIG_SDCARD
+	if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "can")) {
+		printf("fdt CAN");
+		fdt_del_tdm(blob);
+		fdt_del_spi_slic(blob);
+	}
+#ifndef CONFIG_SPIFLASH
+	else if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "tdm")) {
+		printf("fdt TDM");
+		fdt_del_flexcan(blob);
+		fdt_del_spi_flash(blob);
+	}
+#endif
+#endif
+	//FIX: improve PCI throughput by modifing PCI hide registers
+	//1. [0xffe09000] = 0x840000d0;
+	//   [0xffe09004] = 0x00000000;
+	*(volatile unsigned long *)0xffe09000 = 0x840000d0;
+	*(volatile unsigned long *)0xffe09004 = 0x00000000;
+
+	//2. [0xffe09000] = 0x840000cc;
+	//   [0xffe09004] = 0x02011001;
+	*(volatile unsigned long *)0xffe09000 = 0x840000cc;
+	*(volatile unsigned long *)0xffe09004 = 0x02011001;
+
+	//3. [0xffe09000] = 0x840000cc;
+	//   show [0xffe09004];
+	*(volatile unsigned long *)0xffe09000 = 0x840000cc;
+	//printf("0xffe09000 = 0x%08x", *(volatile unsigned long *)0xffe09004);
+}
+#endif
+
+#ifndef CONFIG_SDCARD
+int misc_init_r(void)
+{
+	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "can")) {
+		clrbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_CAN1_TDM |
+				MPC85xx_PMUXCR_CAN1_UART |
+				MPC85xx_PMUXCR_CAN2_TDM |
+				MPC85xx_PMUXCR_CAN2_UART);
+		out_8(&cpld_data->tdm_can_sel, MUX_CPLD_CAN_UART);
+	}
+#ifndef CONFIG_SPIFLASH
+		if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "tdm")) {
+			printf("TDM");
+		clrbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_CAN2_UART |
+				MPC85xx_PMUXCR_CAN1_UART);
+		setbits_be32(&gur->pmuxcr,MPC85xx_PMUXCR_CAN2_TDM |
+				MPC85xx_PMUXCR_CAN1_TDM);
+		clrbits_be32(&gur->pmuxcr2, MPC85xx_PMUXCR2_UART_GPIO);
+		setbits_be32(&gur->pmuxcr2, MPC85xx_PMUXCR2_UART_TDM);
+		out_8(&cpld_data->tdm_can_sel, MUX_CPLD_TDM);
+		out_8(&cpld_data->spi_cs0_sel, MUX_CPLD_SPICS0_SLIC);
+		}
+#endif
+	return 0;
+}
+#endif
--- u-boot-2011.03/board/freescale/xtm2_3/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/tlb.c	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+	/* W**G* - Flash/promjet, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 2, BOOKE_PAGESZ_16M, 1),
+
+#if defined(CONFIG_PCI)
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 3, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 4, BOOKE_PAGESZ_256K, 1),
+#endif /* #if defined(CONFIG_PCI) */
+
+	/* *I*G - NAND */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_1M, 1),
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L2_ADDR)
+	/* *I*G - L2SRAM */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L2_ADDR, CONFIG_SYS_INIT_L2_ADDR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 7, BOOKE_PAGESZ_256K, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L2_ADDR + 0x40000,
+			CONFIG_SYS_INIT_L2_ADDR_PHYS + 0x40000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 8, BOOKE_PAGESZ_256K, 1),
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2011.03/board/freescale/xtm2_3/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/law.c	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_2M, LAW_TRGT_IF_LBC),
+#if defined (CONFIG_XTM2)
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_LBC),
+#elif defined (CONFIG_XTM3)
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_512M, LAW_TRGT_IF_LBC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2011.03/board/freescale/xtm2_3/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/Makefile	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,54 @@
+#
+# Copyright 2009 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-$(CONFIG_PCI)  += pci.o
+COBJS-y	+= tlb.o
+COBJS-$(CONFIG_CMD_DTT) += cmd_lm63.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- u-boot-2011.03/board/freescale/xtm2_3/pci.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/pci.c	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+#include <asm/io.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void ft_pci_board_setup(void *blob)
+{
+	FT_FSL_PCI_SETUP;
+}
--- u-boot-2011.03/board/freescale/xtm2_3/config.mk.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/config.mk	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,34 @@
+#
+# Copyright 2009, 2011 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+#
+# xtm2_3 board
+#
+
+ifndef NAND_SPL
+ifeq ($(CONFIG_NAND), y)
+LDSCRIPT := $(TOPDIR)/$(CPUDIR)/u-boot-nand.lds
+endif
+endif
+
+export CONFIG_SERCOMM_MFG=y
+
--- u-boot-2011.03/board/freescale/xtm2_3/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/ddr.c	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
+				   unsigned int ctrl_num);
+
+#define DATARATE_667MHZ 666666666
+
+#if defined (CONFIG_XTM2_1M)
+ /* values specific 'NEWCASTLE' Hardware platform */
+ # define CONFIG_SYS_DDR_CS0_BNDS	0x0000001F
+ # define CONFIG_SYS_DDR_CS0_CONFIG	0x80014202
+#else 
+ /* values specific 'NEWPORT' Hardware platform */
+ # define CONFIG_SYS_DDR_CS0_BNDS	0x0000003F
+ # define CONFIG_SYS_DDR_CS0_CONFIG	0x80014302
+#endif /* CONFIG_XTM2_1M */
+
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8655F607
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0xC70C0008	/* Type = DDR3*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401010
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x02401400
+
+
+#if defined (CONFIG_XTM2_1M)
+ /* values specific 'NEWCASTLE' Hardware platform */
+ # define CONFIG_SYS_DDR_TIMING_3_667	0x00010000
+#else
+ /* values specific 'NEWPORT' Hardware platform */
+ # define CONFIG_SYS_DDR_TIMING_3_667	0x00020000
+#endif /* CONFIG_XTM2_1M */
+
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00330104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x5D5BD544//0x4C4DD544//0x6f6b4846//0x4C4DD544
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0FA890D1
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00061220
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0A280000//0x049D0000//0x0A280000//0x0A28028A
+
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_667 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_667,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_667,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_667,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_667,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_667,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_667,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_667,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_667,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+
+phys_size_t fixed_sdram (void)
+{
+	sys_info_t sysinfo;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	size_t ddr_size;
+
+	get_sys_info(&sysinfo);
+	printf("Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, sysinfo.freqDDRBus));
+
+	memcpy(&ddr_cfg_regs, &ddr_cfg_regs_667, sizeof(ddr_cfg_regs));
+
+	ddr_size = CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+
+	set_ddr_laws(0, ddr_size, LAW_TRGT_IF_DDR_1);
+	return ddr_size;
+}
--- u-boot-2011.03/board/freescale/xtm2_3/xtm2_3.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/xtm2_3.c	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <tsec.h>
+#include <netdev.h>
+#include <rtc.h>
+#include <miiphy.h>
+#include <version.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define PCIE_RST_SET		0x00010000	/* GPIO 15 */
+#define RGMII_PHY_RST_SET	0x00040000	/* GPIO 13 */
+#define DDR_RESET		0x00020000	/* GPIO 14 */
+#define USB_RST_CLR		0x00080000	/* GPIO 12 */
+#define USB2_PORT_OUT_EN	0x01000000
+#define GPIO_DIR		0x060f0000
+#define BOARD_PERI_RST_SET	(PCIE_RST_SET | RGMII_PHY_RST_SET | DDR_RESET)
+
+#define SYSCLK_MASK	0x00200000
+#define BOARDREV_MASK	0x10100000
+#define BOARDREV_B	0x10100000
+#define BOARDREV_C	0x00100000
+#define BOARDREV_D	0x00000000
+
+#define SYSCLK_66	66666666
+#define SYSCLK_50	50000000
+#define SYSCLK_100	100000000
+
+unsigned long get_board_sys_clk(ulong dummy)
+{
+	return SYSCLK_66;
+}
+
+int board_early_init_f (void)
+{
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	setbits_be32(&pgpio->gpdir, GPIO_DIR);
+	clrsetbits_be32(&pgpio->gpdat, USB_RST_CLR, BOARD_PERI_RST_SET);
+	return 0;
+}
+
+int checkboard (void)
+{
+	char board_rev = 0; 
+	struct cpu_type *cpu;
+	board_rev = 'A';
+	cpu = gd->cpu;
+	printf ("Board: %sRDB\n", cpu->name);
+#ifdef CONFIG_WG_COMMON
+	printf ("%s\n",BOARD_VERSION);
+#endif
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_16M, 1);
+	//	rtc_reset();
+	return 0;
+}
+
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct tsec_info_struct tsec_info[4];
+	int num = 0;
+	unsigned short value;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	SET_STD_TSEC_INFO(tsec_info[num], 3);
+	if (is_serdes_configured(SGMII_TSEC3)) {
+		puts("eTSEC3 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+	tsec_eth_init(bis, tsec_info, num);
+	for(num=0; num<1; num++) {	
+		/* Get PHY ID of switch to make sure work well */
+		miiphy_write("eTSEC1", 0x10+num, 0, 0x9a03);
+		miiphy_read("eTSEC1",  0x10+num, 1, &value);
+		if ( (value&0xffff) != 0x1712 ) {
+			printf("Error: Switch setting incorrect: SW1%d value: %x!\n", num, value);
+		}
+		printf("Init SW1%d switch to forwarding mode", num);
+		//Reset and Disable INTx 
+		DLAY SMIRW(1, 0x10+num, 4, 0xa000, 0, 0, 0x1b, 0);
+
+		//set rgmii delay     
+		DLAY SMIRW(1, 0x10+num, 1, 0xc03e, 0, 0, 0x15, 0);	//P15
+		
+		//set LED function
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x10, 0);	//P10
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x11, 0);	//P11   
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x12, 0);	//P12
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x13, 0);	//P13   
+		DLAY SMIRW(1, 0x10+num, 0x16, 0x9038, 0, 0,0x14, 0);	//P14  
+		printf(".");
+
+		//set port to forwarding mode
+		DLAY SMIRW(1, 0x10+num, 4, 0x007f, 0, 0, 0x10, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x11, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x12, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x13, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x14, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x15, 0);
+		DLAY SMIRW(1, 0x10+num, 4 ,0x007f, 0, 0, 0x16, 0);
+		printf(".");
+
+		//set pvlan table
+		DLAY SMIRW(1, 0x10+num, 6, 0x0020, 0, 0, 0x10, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x11, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x12, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x13, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0020, 0, 0, 0x14, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x001f, 0, 0, 0x15, 0);
+		DLAY SMIRW(1, 0x10+num, 6 ,0x0000, 0, 0, 0x16, 0);
+		printf(".");
+
+		//reset PHY
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x0, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x1, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x2, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x3, 0);
+		DLAY SMIRW(1, 0x10+num, 0 ,0x9140, 0, 0, 0x4, 0);
+		printf(". Done\n");
+	}
+	return pci_eth_init(bis);
+}
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+extern void ft_pci_board_setup(void *blob);
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+#if defined(CONFIG_PCI)
+	ft_pci_board_setup(blob);
+#endif /* #if defined(CONFIG_PCI) */
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+}
+#endif
+
+#ifdef CONFIG_MP
+extern void cpu_mp_lmb_reserve(struct lmb *lmb);
+
+void board_lmb_reserve(struct lmb *lmb)
+{
+	cpu_mp_lmb_reserve(lmb);
+}
+#endif
--- u-boot-2011.03/board/freescale/xtm2_3/cmd_lm63.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/xtm2_3/cmd_lm63.c	2022-05-09 14:05:11.232068031 -0700
@@ -0,0 +1,253 @@
+/*
+ * (C) Copyright 2001
+ * Erik Theisen, Wave 7 Optics, etheisen@mindspring.com
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <command.h>
+
+#include <linux/types.h>
+
+#include <dtt.h>
+#include <i2c.h>
+
+struct register_desc {
+	int offset;
+	char desc[40];
+};
+
+struct register_desc reg_table[] =  {
+{ 0, "Local Temperature"},
+{ 1, "Rmt Temp MSB"},
+{ 2, "ALERT Status"},
+{ 3, "Configuration"},
+{ 4, "Conversion Rate"},
+{ 5, "Local High Setpoint"},
+{ 7, "Rmt High Setpoint MSB"},
+{ 8, "Rmt LOW Setpoint MSB"},
+{ 9, "Same as 03"},		// skip later
+{ 0xA, "Same as 04"},		// skip later
+{ 0xB, "Same as 05"},		// skip later
+{ 0xD, "Same as 07"},		// skip later
+{ 0xE, "Same as 08"},		// skip later
+{ 0xF, "One Shot (WO)"},
+{ 0x10, "Rmt Temp LSB"},
+{ 0x11, "Rmt Temp Offset MSB"},
+{ 0x12, "Rmt Temp Offset LSB"},
+{ 0x13, "Rmt High Setpoint LSB"},
+{ 0x14, "Rmt Low Setpoint LSB"},
+{ 0x16, "ALERT Mask"},
+{ 0x19, "Rmt TCRIT Setpoint"},
+{ 0x21, "Rmt TCRIT Hysteresis"},
+{ 0x46, "Tach Count LSB"},
+{ 0x47, "Tach Count MSB"},
+{ 0x48, "Tach Limit LSB"},
+{ 0x49, "Tach Limit MSB"},
+{ 0x4A, "PWM and RPM"},
+{ 0x4B, "Fan Spin-Up Config"},
+{ 0x4C, "PWM Value"},
+{ 0x4D, "PWM Frequency"},
+{ 0x4F, "Lookup tbl Hysteresis"},
+};
+
+int sizeof_table = 0;
+
+struct pwm_lookup_entry {
+        u8 temp;
+        u8 pwm;
+};
+struct pwm_lookup_entry lookup[10]; /* max 10*/
+
+int lookup_curr = 0;
+int lookup_reset = 1;
+
+int
+find_regs_in_table(int reg)
+{
+	int i;
+	for (i=0;i<sizeof_table;i++) {
+		if (reg_table[i].offset == reg)
+			return i;
+	}
+	return -1;
+}
+
+
+int
+dump_lm63_registers(unsigned char sensor)
+{
+	int i;
+
+	printf("dump all registers\n");
+	for (i=0;i<sizeof_table;i++) {
+		printf ("Reg: (%x: %s): 0x%x\n",
+			reg_table[i].offset, reg_table[i].desc, dtt_read(sensor, reg_table[i].offset));
+	}
+	return 0;
+}
+
+int
+lm63_init(void)
+{
+	/* TODO: setup the lm63 controller now */
+	int i;
+	unsigned char sensors[] = CONFIG_DTT_SENSORS;
+	const char *const header = "LM63:   ";
+
+	for (i = 0; i < sizeof(sensors); i++) {
+		if (_dtt_init(sensors[i], 1, (void *)lookup) != 0)
+			printf("%s%d FAILED INIT\n", header, i + 1);
+		else
+			printf("%s%d is %i C\n", header, i + 1,
+			       dtt_get_temp(sensors[i]));
+	}
+
+	return 0;
+}
+
+
+typedef enum {false, true} bool;
+int do_lm63 (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
+{
+	int i;
+	int old_bus;
+	bool alert_status_read = false;
+	bool valid_setup_detect = false;
+	unsigned char sensors[] = CONFIG_DTT_SENSORS;
+
+	/* switch to correct I2C bus */
+	old_bus = I2C_GET_BUS();
+	I2C_SET_BUS(CONFIG_SYS_DTT_BUS_NUM);
+
+	sizeof_table = sizeof(reg_table)/sizeof(struct register_desc);
+	if (argc == 2 && strcmp(argv[1], "dumpregs") == 0)
+		return dump_lm63_registers(sensors[0]);
+	if (argc == 2 && strcmp(argv[1], "init") == 0) {
+		if (!valid_setup_detect)
+			printf ("ERR: no valid setup detected, init however ...\n");
+		return lm63_init();
+	}
+	if (argc == 2 && strcmp(argv[1], "lookupreset") == 0) {
+		lookup_reset = 1;
+		return 0;
+	}
+	if (argc == 2 && strcmp(argv[1], "lookupprint") == 0) {
+		printf ("lookup table print\n");
+		for (i=0; i<5; i++)
+			printf ("entry %d: t=%d, p=%d\n", i, lookup[i].temp, lookup[i].pwm);
+		return 0;
+	}
+
+	switch (argc) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		if (strcmp(argv[1], "readreg") == 0) {
+			int reg = (int)simple_strtoul(argv[2], NULL, 10);
+			int r = find_regs_in_table(reg);
+			if (r)
+				printf ("Reg: (%x: %s): 0x%x\n", reg, reg_table[r].desc,
+					dtt_read(sensors[0], reg_table[r].offset));
+			else
+				printf ("Invalid reg read req\n");
+		}
+		if (strcmp(argv[1], "print") == 0) {
+			if (argc == 3 && strcmp(argv[1], "alert") == 0)
+				alert_status_read = true;
+			if (alert_status_read == true) {
+				printf ("Alert stat = 0x%0x\n", dtt_read(sensors[0], 0x02));
+			} else { /* default case: print regtable */
+				for (i=0;i<sizeof_table;i++)
+					printf ("table[%i] entry = Reg: (%x: %s)\n",
+						i, reg_table[i].offset, reg_table[i].desc);
+			}
+		}
+		return 0;
+	case 4:
+		if (strcmp(argv[1], "setup") == 0) {
+			int reg = (int)simple_strtoul(argv[2], NULL, 10);
+			int val = (int)simple_strtoul(argv[3], NULL, 10);
+			int r = find_regs_in_table(reg);
+			if (r) {
+				printf ("setup: Reg:%x to value %x)\n", reg, val);
+				printf ("You are setting up Reg:%x which is \"%s\"\n",
+					reg, reg_table[r].desc);
+				dtt_write(sensors[0], reg, val);
+				valid_setup_detect = true;
+			} else {
+				printf ("setup: Reg:%x Not Valid \
+					(might have to update the table)\n", reg);
+			}
+		}
+		if (strcmp(argv[1], "addlookup") == 0) {
+			int temp = (int)simple_strtoul(argv[2], NULL, 10);
+			int pwm = (int)simple_strtoul(argv[3], NULL, 10);
+			if (lookup_reset) {
+				lookup_reset = 0;
+				lookup_curr = 0;
+			}
+			if (lookup_curr >= 5) {
+				printf ("ERR: lookup_curr too high: reset the lookup");
+				return 0;
+			}
+			printf ("adding lookup entry: temp=%d, pwm =%d\n", temp, pwm);
+			lookup[lookup_curr].temp = temp;
+			lookup[lookup_curr].pwm = pwm;
+			lookup_curr++;
+		}
+		return 0;
+	default:
+		break;
+	}
+
+	/*
+	 * Loop through sensors, read
+	 * temperature, and output it.
+	 */
+	for (i = 0; i < sizeof (sensors); i++)
+		printf ("DTT%d: %i C\n", i + 1, dtt_get_temp (sensors[i]));
+
+	/* switch back to original I2C bus */
+	I2C_SET_BUS(old_bus);
+
+	return 0;
+}
+/* do_lm63() */
+
+/***************************************************/
+
+U_BOOT_CMD(
+	  lm63,	5,	1,	do_lm63,
+	  "Read temperature from Digital Thermometer and Thermostat",
+	  "lm63                     - reads the temp from sensors(default operation)\n"
+	  "lm63 dumpregs            - dump all registers\n"
+	  "lm63 print [regtable]    - print regtable\n"
+	  "          [alert]       - print alert status registers\n"
+	  "lm63 readreg [reg]     - read a specific register from the regtable\n"
+	  "lm63 addlookup [temp] [pwm] - add lookup entries\n"
+	  "lm63 lookupreset       - reset the lookup table\n"
+	  "lm63 lookupprint       - print the lookup table\n"
+	  "lm63 setup [reg] [val] - setup the registers\n"
+	  "lm63 init              - init lm63 controller (should be followed by setup)"
+);
+
--- u-boot-2011.03/board/freescale/fbx_T15/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T15/Makefile	2022-05-09 14:05:11.208069004 -0700
@@ -0,0 +1,52 @@
+#
+# Copyright 2010-2011 Freescale Semiconductor, Inc.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o
+COBJS-y	+= ddr.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- u-boot-2011.03/board/freescale/fbx_T15/tlb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T15/tlb.c	2022-05-09 14:05:11.208069004 -0700
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR, CONFIG_SYS_INIT_RAM_ADDR,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024 ,
+			CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 1, BOOKE_PAGESZ_1M, 1),
+
+#ifndef CONFIG_NAND_SPL
+#ifndef CONFIG_SDCARD
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 2, BOOKE_PAGESZ_16M, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE + 0x1000000,
+			CONFIG_SYS_FLASH_BASE_PHYS + 0x1000000,
+			MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+			0, 3, BOOKE_PAGESZ_16M, 1),
+#endif
+
+#ifdef CONFIG_PCI
+	/* *I*G* - PCI */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 4, BOOKE_PAGESZ_1G, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 5, BOOKE_PAGESZ_256K, 1),
+#endif /* ifdef CONFIG_PCI */
+#endif
+
+#ifndef CONFIG_SDCARD
+	/* *I*G - Board CPLD  */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 6, BOOKE_PAGESZ_256K, 1),
+
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, 7, BOOKE_PAGESZ_1M, 1),
+#endif
+
+#if defined(CONFIG_SYS_RAMBOOT)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+			MAS3_SX|MAS3_SW|MAS3_SR, 0,
+			0, 8, BOOKE_PAGESZ_1G, 1)
+#endif
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
--- u-boot-2011.03/board/freescale/fbx_T15/law.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T15/law.c	2022-05-09 14:05:11.208069004 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+#ifndef CONFIG_SDCARD
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_CPLD_BASE_PHYS, LAW_SIZE_128K, LAW_TRGT_IF_IFC),
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
--- u-boot-2011.03/board/freescale/fbx_T15/fbx_T15.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T15/fbx_T15.c	2022-05-09 14:05:11.208069004 -0700
@@ -0,0 +1,341 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <tsec.h>
+#include <mmc.h>
+#include <netdev.h>
+#include <pci.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_ifc.h>
+#include <asm/fsl_pci.h>
+
+#ifndef CONFIG_SDCARD
+#include <hwconfig.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define GPIO15_PCIE_RESET_SET		0x00010000
+#define MUX_CPLD_CAN_UART		0x00
+#define MUX_CPLD_TDM			0x01
+#define MUX_CPLD_SPICS0_FLASH		0x00
+#define MUX_CPLD_SPICS0_SLIC		0x02
+
+#ifndef CONFIG_SDCARD
+struct cpld_data {
+	u8 cpld_ver; /* cpld revision */
+	u8 pcba_ver; /* pcb revision number */
+	u8 twindie_ddr3;
+	u8 res1[6];
+	u8 bank_sel; /* NOR Flash bank */
+	u8 res2[5];
+	u8 usb2_sel;
+	u8 res3[1];
+	u8 porsw_sel;
+	u8 tdm_can_sel;
+	u8 spi_cs0_sel; /* SPI CS0 SLIC/SPI Flash */
+	u8 por0; /* POR Options */
+	u8 por1; /* POR Options */
+	u8 por2; /* POR Options */
+	u8 por3; /* POR Options */
+};
+
+void cpld_show(void)
+{
+	volatile struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+
+	printf("CPLD: V%x.%x PCBA: V%x.0\n",
+		in_8(&cpld_data->cpld_ver) & 0xF0,
+		in_8(&cpld_data->cpld_ver) & 0x0F,
+		in_8(&cpld_data->pcba_ver) & 0x0F);
+
+#ifdef CONFIG_DEBUG
+	printf("twindie_ddr =%x\n",
+		in_8(&cpld_data->twindie_ddr3));
+	printf("bank_sel =%x\n",
+		in_8(&cpld_data->bank_sel));
+	printf("usb2_sel =%x\n",
+		in_8(&cpld_data->usb2_sel));
+	printf("porsw_sel =%x\n",
+		in_8(&cpld_data->porsw_sel));
+	printf("tdm_can_sel =%x\n",
+		in_8(&cpld_data->tdm_can_sel));
+	printf("tdm_can_sel =%x\n",
+		in_8(&cpld_data->tdm_can_sel));
+	printf("spi_cs0_sel =%x\n",
+		in_8(&cpld_data->spi_cs0_sel));
+	printf("bcsr0 =%x\n",
+		in_8(&cpld_data->bcsr0));
+	printf("bcsr1 =%x\n",
+		in_8(&cpld_data->bcsr1));
+	printf("bcsr2 =%x\n",
+		in_8(&cpld_data->bcsr2));
+	printf("bcsr3 =%x\n",
+		in_8(&cpld_data->bcsr3));
+#endif
+}
+#endif
+
+int board_early_init_f (void)
+{
+	ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+#ifndef CONFIG_SDCARD
+	struct fsl_ifc *ifc = (void *)CONFIG_SYS_IFC_ADDR;
+	/* Clock configuration to access CPLD using IFC(GPCM) */
+	setbits_be32(&ifc->ifc_gcr, 1 << IFC_GCR_TBCTL_TRN_TIME_SHIFT);
+#endif
+	/*
+	* Reset PCIe slots via GPIO4
+	*/
+	/*
+	setbits_be32(&pgpio->gpdir, GPIO4_PCIE_RESET_SET);
+	setbits_be32(&pgpio->gpdat, GPIO4_PCIE_RESET_SET);
+	*/
+
+	setbits_be32(&pgpio->gpdir, GPIO15_PCIE_RESET_SET);
+	setbits_be32(&pgpio->gpdat, GPIO15_PCIE_RESET_SET);
+	return 0;
+}
+int board_early_init_r(void)
+{
+#ifndef CONFIG_SDCARD
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, BOOKE_PAGESZ_16M, 1);
+
+	set_tlb(1, flashbase + 0x1000000,
+			CONFIG_SYS_FLASH_BASE_PHYS + 0x1000000,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel+1, BOOKE_PAGESZ_16M, 1);
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+#endif /* ifdef CONFIG_PCI */
+
+int checkboard (void)
+{
+	struct cpu_type *cpu;
+
+	cpu = gd->cpu;
+	printf ("Board: %sRDB ", cpu->name);
+#ifdef CONFIG_PHYS_64BIT
+	puts ("(36-bit addrmap)");
+#endif
+	puts ("\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct tsec_info_struct tsec_info[4];
+	struct cpu_type *cpu;
+	int num = 0;
+
+	cpu = gd->cpu;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	/* P1014 and it's derivatives do not support eTSEC3 */
+	if (cpu->soc_ver != SVR_P1014 && cpu->soc_ver != SVR_P1014_E) {
+		SET_STD_TSEC_INFO(tsec_info[num], 3);
+		num++;
+	}
+#endif
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+	tsec_eth_init(bis, tsec_info, num);
+
+	return pci_eth_init(bis);
+}
+#endif
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+void fdt_del_flexcan(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"fsl,flexcan-v1.0")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void fdt_del_spi_flash(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"spansion,s25sl12801")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void fdt_del_spi_slic(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"zarlink,le88266")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void fdt_del_tdm(void *blob)
+{
+	int nodeoff = 0;
+
+	while ((nodeoff = fdt_node_offset_by_compatible(blob, 0,
+				"fsl,starlite-tdm")) >= 0) {
+		fdt_del_node(blob, nodeoff);
+	}
+}
+
+void ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+	struct cpu_type *cpu;
+
+	cpu = gd->cpu;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+#if defined(CONFIG_PCI)
+	FT_FSL_PCI_SETUP;
+#endif
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+	fdt_fixup_dr_usb(blob, bd);
+
+       /* P1014 and it's derivatives don't support CAN and eTSEC3 */
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E) {
+		fdt_del_flexcan(blob);
+		fdt_del_node_and_alias(blob, "ethernet2");
+	}
+#ifndef CONFIG_SDCARD
+	if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "can")) {
+		printf("fdt CAN");
+		fdt_del_tdm(blob);
+		fdt_del_spi_slic(blob);
+	}
+#ifndef CONFIG_SPIFLASH
+	else if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "tdm")) {
+		printf("fdt TDM");
+		fdt_del_flexcan(blob);
+		fdt_del_spi_flash(blob);
+	}
+#endif
+#endif
+	//FIX: improve PCI throughput by modifing PCI hide registers
+	//1. [0xffe09000] = 0x840000d0;
+	//   [0xffe09004] = 0x00000000;
+	*(volatile unsigned long *)0xffe09000 = 0x840000d0;
+	*(volatile unsigned long *)0xffe09004 = 0x00000000;
+
+	//2. [0xffe09000] = 0x840000cc;
+	//   [0xffe09004] = 0x02011001;
+	*(volatile unsigned long *)0xffe09000 = 0x840000cc;
+	*(volatile unsigned long *)0xffe09004 = 0x02011001;
+
+	//3. [0xffe09000] = 0x840000cc;
+	//   show [0xffe09004];
+	*(volatile unsigned long *)0xffe09000 = 0x840000cc;
+	//printf("0xffe09000 = 0x%08x", *(volatile unsigned long *)0xffe09004);
+}
+#endif
+
+#ifndef CONFIG_SDCARD
+int misc_init_r(void)
+{
+	struct cpld_data *cpld_data = (void *)(CONFIG_SYS_CPLD_BASE);
+	ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+
+	if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "can")) {
+		clrbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_CAN1_TDM |
+				MPC85xx_PMUXCR_CAN1_UART |
+				MPC85xx_PMUXCR_CAN2_TDM |
+				MPC85xx_PMUXCR_CAN2_UART);
+		out_8(&cpld_data->tdm_can_sel, MUX_CPLD_CAN_UART);
+	}
+#ifndef CONFIG_SPIFLASH
+		if (hwconfig_subarg_cmp("fsl_p1010mux", "tdm_can", "tdm")) {
+			printf("TDM");
+		clrbits_be32(&gur->pmuxcr, MPC85xx_PMUXCR_CAN2_UART |
+				MPC85xx_PMUXCR_CAN1_UART);
+		setbits_be32(&gur->pmuxcr,MPC85xx_PMUXCR_CAN2_TDM |
+				MPC85xx_PMUXCR_CAN1_TDM);
+		clrbits_be32(&gur->pmuxcr2, MPC85xx_PMUXCR2_UART_GPIO);
+		setbits_be32(&gur->pmuxcr2, MPC85xx_PMUXCR2_UART_TDM);
+		out_8(&cpld_data->tdm_can_sel, MUX_CPLD_TDM);
+		out_8(&cpld_data->spi_cs0_sel, MUX_CPLD_SPICS0_SLIC);
+		}
+#endif
+	return 0;
+}
+#endif
--- u-boot-2011.03/board/freescale/fbx_T15/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/board/freescale/fbx_T15/ddr.c	2022-05-09 14:05:11.208069004 -0700
@@ -0,0 +1,301 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/fsl_ddr_dimm_params.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_DDR_RAW_TIMING
+/*
+#define CONFIG_SYS_DRAM_SIZE	512
+*/
+/* for T15, by Mega on 20170123*/
+#define CONFIG_SYS_DRAM_SIZE	1024
+
+#if defined(DDR_800)
+fsl_ddr_cfg_regs_t ddr_cfg_regs_800 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_800,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_800,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_800,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_800,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_800,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_800,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_800,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_800,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL_800,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+#if 0
+	.ddr_cdr1=CONFIG_SYS_DDR_CDR_1,
+	.ddr_cdr2=CONFIG_SYS_DDR_CDR_2,
+#endif
+};
+
+#elif defined(DDR_667)
+fsl_ddr_cfg_regs_t ddr_cfg_regs_667 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.cs[0].config_2 = CONFIG_SYS_DDR_CS0_CONFIG_2,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_667,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0_667,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_667,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2_667,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_667,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_667,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CONTROL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_667,
+	.ddr_data_init = CONFIG_MEM_INIT_VALUE,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_667,
+	.ddr_init_addr = CONFIG_SYS_DDR_INIT_ADDR,
+	.ddr_init_ext_addr = CONFIG_SYS_DDR_INIT_EXT_ADDR,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CONTROL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL_667,
+	.ddr_sr_cntr = CONFIG_SYS_DDR_SR_CNTR,
+	.ddr_sdram_rcw_1 = CONFIG_SYS_DDR_RCW_1,
+	.ddr_sdram_rcw_2 = CONFIG_SYS_DDR_RCW_2
+};
+
+#elif defined(DDR_533)
+fsl_ddr_cfg_regs_t ddr_cfg_regs_533 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_533,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3_533,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1_533,
+	.ddr_cdr1=CONFIG_SYS_DDR_CDR_1,
+	.ddr_cdr2=CONFIG_SYS_DDR_CDR_2,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CONTROL_533,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL_533,
+	
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL_533,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2_533,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+};
+#endif
+
+fixed_ddr_parm_t fixed_ddr_parm_0[] = {
+#if defined(DDR_800)
+	{750, 850, &ddr_cfg_regs_800},
+#elif defined(DDR_677)
+	{607, 749, &ddr_cfg_regs_667},
+#elif defined(DDR_533)
+	{500, 606, &ddr_cfg_regs_533},
+#endif
+	{0, 0, NULL}
+};
+
+unsigned long get_sdram_size(void)
+{
+	struct cpu_type *cpu;
+	phys_size_t ddr_size;
+
+	cpu = gd->cpu;
+	/* P1014 and it's derivatives support max 16it DDR width */
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E)
+		ddr_size = (CONFIG_SYS_DRAM_SIZE / 2);
+	else
+		ddr_size = CONFIG_SYS_DRAM_SIZE;
+
+	return ddr_size;
+}
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+phys_size_t fixed_sdram(void)
+{
+	int i;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	phys_size_t ddr_size;
+	ulong ddr_freq, ddr_freq_mhz;
+	//struct cpu_type *cpu;
+	volatile ccsr_ddr_t *ddr = (void *)CONFIG_SYS_MPC85xx_DDR_ADDR;	
+
+/*
+#if defined(CONFIG_SYS_RAMBOOT)
+	return CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+#endif
+*/
+
+	ddr_freq = get_ddr_freq(0);
+	ddr_freq_mhz = ddr_freq / 1000000;
+
+	printf("Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, ddr_freq));
+
+	for (i = 0; fixed_ddr_parm_0[i].max_freq > 0; i++) {
+		if ((ddr_freq_mhz > fixed_ddr_parm_0[i].min_freq) &&
+		   (ddr_freq_mhz <= fixed_ddr_parm_0[i].max_freq)) {
+			memcpy(&ddr_cfg_regs, fixed_ddr_parm_0[i].ddr_settings,
+							sizeof(ddr_cfg_regs));
+			break;
+		}
+	}
+	ddr_size = (phys_size_t) (CONFIG_SYS_DRAM_SIZE * 1024 * 1024);
+	out_be32(&ddr->timing_cfg_3, ddr_cfg_regs.timing_cfg_3);
+	out_be32(&ddr->timing_cfg_1, ddr_cfg_regs.timing_cfg_1);
+	out_be32(&ddr->sdram_mode, ddr_cfg_regs.ddr_sdram_mode);
+	out_be32(&ddr->ddr_cdr1, ddr_cfg_regs.ddr_cdr1);
+	out_be32(&ddr->ddr_cdr2, ddr_cfg_regs.ddr_cdr2);
+	out_be32(&ddr->ddr_wrlvl_cntl, ddr_cfg_regs.ddr_wrlvl_cntl);
+	
+	out_be32(&ddr->sdram_interval, ddr_cfg_regs.ddr_sdram_interval);
+	out_be32(&ddr->sdram_mode_2, ddr_cfg_regs.ddr_sdram_mode_2);
+	out_be32(&ddr->sdram_cfg, ddr_cfg_regs.ddr_sdram_cfg);
+					
+
+	/*
+	if (fixed_ddr_parm_0[i].max_freq == 0)
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+					strmhz(buf, ddr_freq));
+
+	cpu = gd->cpu;
+	// P1014 and it's derivatives support max 16bit DDR width 
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E) {
+		ddr_cfg_regs.ddr_sdram_cfg |= SDRAM_CFG_16_BE;
+		ddr_cfg_regs.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS >> 1;
+		ddr_cfg_regs.ddr_sdram_cfg &= ~0x00180000;
+		ddr_cfg_regs.ddr_sdram_cfg |= 0x001080000;
+	}
+
+	ddr_size = (phys_size_t) (CONFIG_SYS_SDRAM_SIZE * 1024 * 1024);
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+
+	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE, ddr_size,
+					LAW_TRGT_IF_DDR_1) < 0) {
+		printf("ERROR setting Local Access Windows for DDR\n");
+		return 0;
+	}
+	*/
+
+	return ddr_size;
+}
+
+#else /* CONFIG_DDR_RAW_TIMING */
+/*
+ * Samsung K4B2G0846C-HCF8
+ * The following timing are for "downshift"
+ * i.e. to use CL9 part as CL7
+ * otherwise, tAA, tRCD, tRP will be 13500ps
+ * and tRC will be 49500ps
+ */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 268435456u,
+	.capacity = 268435456u,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 14,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tCKmin_X_ps = 1875,
+	.caslat_X = 0x1e << 4,	/* 5,6,7,8 */
+	.tAA_ps = 13125,
+	.tWR_ps = 15000,
+	.tRCD_ps = 13125,
+	.tRRD_ps = 7500,
+	.tRP_ps = 13125,
+	.tRAS_ps = 37500,
+	.tRC_ps = 50625,
+	//.tRFC_ps = 160000,
+	.tRFC_ps = 260000,	//Mega Note/20170214:suggestion from promos vendor
+	.tWTR_ps = 7500,
+	.tRTP_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tFAW_ps = 37500,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR on board";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	struct cpu_type *cpu;
+	int i;
+	popts->clk_adjust = 6;
+	popts->cpo_override = 0x1f;
+	popts->write_data_delay = 2;
+	popts->half_strength_driver_enable = 1;
+	/* Write leveling override */
+	popts->wrlvl_en = 1;
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+	popts->wrlvl_start = 0x8;
+	popts->trwt_override = 1;
+	popts->trwt = 0;
+
+	cpu = gd->cpu;
+	/* P1014 and it's derivatives support max 16it DDR width */
+	if (cpu->soc_ver == SVR_P1014 || cpu->soc_ver == SVR_P1014_E)
+		popts->data_bus_width = DDR_DATA_BUS_WIDTH_16;
+
+	for (i = 0; i < CONFIG_CHIP_SELECTS_PER_CTRL; i++) {
+		popts->cs_local_opts[i].odt_rd_cfg = FSL_DDR_ODT_NEVER;
+		popts->cs_local_opts[i].odt_wr_cfg = FSL_DDR_ODT_CS;
+	}
+}
+
+#endif /* CONFIG_DDR_RAW_TIMING */
--- u-boot-2011.03/common/wgmenu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/common/wgmenu.c	2022-05-09 14:05:11.480057974 -0700
@@ -0,0 +1,183 @@
+#include <common.h>
+#ifndef DO_DEPS_ONLY
+#include "version_autogenerated.h"
+#include "timestamp_autogenerated.h"
+#include "perforce_autogenerated.h"
+#endif
+#include <wgmenu.h>
+
+#define WG_VERSION_STRING ("WatchGuard " U_BOOT_VERSION " - " PERFORCE_CHANGE " - " U_BOOT_DATE " " U_BOOT_TIME)
+#define ANSI_CLEAR		"\e[2J"
+#define ANSI_REVERSE		"\e[7m"
+#define	ANSI_NORMAL		"\e[m"
+#define ANSI_GOTOYX		"\e[%d;%dH"
+
+#define SCREEN_HIGH		24
+#define SCREEN_WIDTH		80
+#define MAX_MENU_ITEMS		10
+
+#define FIRST_LINE_Y		2
+#define FIRST_LINE_X_FUN(len)	((SCREEN_WIDTH - len)/2)
+#define FIRST_LINE_X		FIRST_LINE_X_FUN(58)
+
+#define TABLE_START_Y		4
+#define TABLE_START_X		2 
+#define TABLE_LENGHT		(SCREEN_WIDTH - 6)
+#define TABLE_HIGH		(SCREEN_HIGH/2)
+
+#define	TOP_ROW			(TABLE_START_X + 1)
+#define	MENU_0_ROW		(TABLE_START_Y + 1)
+
+struct __wgmenu_option {
+	const char *label;		// WG:BH - We really only use the label...
+	void (*fn)(void *user);		// but we could add functionality to add dynamically generated menu items.
+	void *user;			// <<< this one is the argument to fn.
+};
+
+static struct __wgmenu_option wg_options[MAX_MENU_ITEMS];
+static int __wgmenu_max_width = TABLE_LENGHT - 4;
+static int __wgmenu_num_options = 0;
+static int __wgmenu_option_pos = 0;
+static int __wgmenu_boot_menu = 1;
+
+static void __wgmenu_print_option(const struct __wgmenu_option *opt, int reverse)
+{
+	int n = (opt - wg_options);
+	char format[10] = {'\0'};
+
+	printf(ANSI_GOTOYX, MENU_0_ROW+n, TABLE_START_X + 1);
+	if (reverse) {
+		printf(ANSI_REVERSE);
+	}
+
+	sprintf(format, "%%-%ds", __wgmenu_max_width);
+	printf(format, opt->label);
+
+	if (reverse) {
+		printf(ANSI_NORMAL);
+	}
+
+	printf(ANSI_GOTOYX ,SCREEN_HIGH + 2 , 1); 
+}
+
+static void __wgmenu_show_bootmenu_table(void)
+{
+	int i = 0,j = 0 ;
+
+	printf(ANSI_CLEAR ANSI_GOTOYX "%s", FIRST_LINE_Y,
+			(int)FIRST_LINE_X_FUN((strlen(WG_VERSION_STRING))), WG_VERSION_STRING);
+
+	for (i = 0 ; i < TABLE_LENGHT ; i++) {	//the above horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y, TABLE_START_X + i);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	//the left line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	// the right line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X + TABLE_LENGHT);
+	}
+	for (i = 1 ; i < TABLE_LENGHT ; i++) {	//the below horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y + TABLE_HIGH, TABLE_START_X + i);
+	}
+
+	printf(ANSI_GOTOYX "+",TABLE_START_Y, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y , TABLE_START_X + TABLE_LENGHT); 
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X + TABLE_LENGHT);
+
+	printf(ANSI_GOTOYX "Use the ^ and v keys to select which entry is highlighted.",
+			TABLE_START_Y + TABLE_HIGH + 2, 7);
+	printf(ANSI_GOTOYX "Press enter to boot the selected OS.",
+			TABLE_START_Y + TABLE_HIGH + 3, 7);
+
+	printf(ANSI_GOTOYX , SCREEN_HIGH + 2, 1);
+}
+
+static void __wgmenu_show_bootmenu(void)
+{
+	const struct __wgmenu_option *opt = {NULL};
+
+	__wgmenu_show_bootmenu_table();
+
+	for (opt = wg_options; opt != (wg_options + __wgmenu_num_options); opt++) {
+		__wgmenu_print_option(opt, opt == wg_options);
+	}
+}
+
+static int __wgmenu_wg_display_menu(int key)
+{
+	static struct __wgmenu_option *opt = wg_options;
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 0);
+
+	switch (key) {
+		case 65: //up
+			if(__wgmenu_option_pos > 0)
+				__wgmenu_option_pos--;
+			break; 
+		case 66: //down
+			if(__wgmenu_option_pos < (__wgmenu_num_options - 1))
+				__wgmenu_option_pos++;
+			break; 
+		case 13:
+		default:
+			break;
+	}
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 1);
+
+	return opt - wg_options ;
+}
+
+int wgmenu_hook(int key)
+{
+	static const struct __wgmenu_option *opt = wg_options;
+	int hooked = 0;
+
+	if ((key == 65 || key == 66) && opt && __wgmenu_num_options) {
+		hooked = 1;
+		__wgmenu_wg_display_menu(key);
+	}
+
+	return hooked;
+}
+
+
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user)
+{
+	int len;
+
+	wg_options[__wgmenu_num_options].label = label;
+	wg_options[__wgmenu_num_options].fn = fn;
+	wg_options[__wgmenu_num_options].user = user;
+	__wgmenu_num_options++;
+
+	len = strlen(label);
+
+	if (len > __wgmenu_max_width)
+		__wgmenu_max_width = len;
+}
+
+
+void wgmenu_show(void)
+{
+	wgmenu_add("WatchGuard (SYSA)", NULL, NULL);
+	wgmenu_add("WatchGuard (SYSB)", NULL, NULL);
+	wgmenu_add("WatchGuard (SAFE MODE)", NULL, NULL);
+	__wgmenu_show_bootmenu();
+}
+
+int wgmenu_selected(void)
+{
+	return __wgmenu_option_pos;
+}
+
+int wgmenu_inmenu(void)
+{
+	return __wgmenu_boot_menu;
+}
+
+void wgmenu_exit(void)
+{
+	__wgmenu_boot_menu = 0;
+}
--- u-boot-2011.03/common/random.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/common/random.c	2022-05-09 14:05:11.472058298 -0700
@@ -0,0 +1,26 @@
+/* concatenation of following two 16-bit multiply with carry generators */
+/* x(n)=a*x(n-1)+carry mod 2^16 and y(n)=b*y(n-1)+carry mod 2^16, */
+/* number and carry packed within the same 32 bit integer.        */
+/******************************************************************/
+
+#include <random.h>
+static unsigned int SEED_X = 521288629;
+static unsigned int SEED_Y = 362436069;
+
+
+unsigned int rand ()
+   {
+   static unsigned int a = 18000, b = 30903;
+
+   SEED_X = a*(SEED_X&65535) + (SEED_X>>16);
+   SEED_Y = b*(SEED_Y&65535) + (SEED_Y>>16);
+
+   return ((SEED_X<<16) + (SEED_Y&65535));
+   }
+
+
+void rand_seed( unsigned int seed1, unsigned int seed2 )
+   {
+   if (seed1) SEED_X = seed1;   /* use default seeds if parameter is 0 */
+   if (seed2) SEED_Y = seed2;
+   }
--- u-boot-2011.03/common/cmd_tpm.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/common/cmd_tpm.c	2022-05-09 14:05:11.404061056 -0700
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <tpm.h>
+#include "../drivers/tpm/generic_lpc_tpm.c"
+
+#define MAX_TRANSACTION_SIZE 30
+
+/*
+ * tpm_write() expects a variable number of parameters: the internal address
+ * followed by data to write, byte by byte.
+ *
+ * Returns 0 on success or -1 on errors (wrong arguments or TPM failure).
+ */
+static int tpm_process(int argc, char * const argv[], cmd_tbl_t *cmdtp)
+{
+	u8 tpm_buffer[MAX_TRANSACTION_SIZE];
+	u32 write_size, read_size;
+	char *p;
+	int rv = -1;
+
+	for (write_size = 0; write_size < argc; write_size++) {
+		u32 datum = simple_strtoul(argv[write_size], &p, 0);
+		if (*p || (datum > 0xff)) {
+			printf("\n%s: bad data value\n\n", argv[write_size]);
+			cmd_usage(cmdtp);
+			return rv;
+		}
+		tpm_buffer[write_size] = (u8)datum;
+	}
+
+	read_size = sizeof(tpm_buffer);
+	if (!tis_sendrecv(tpm_buffer, write_size, tpm_buffer, &read_size)) {
+		int i;
+		puts("Got TPM response:\n");
+		for (i = 0; i < read_size; i++)
+			printf(" %2.2x", tpm_buffer[i]);
+		puts("\n");
+		rv = 0;
+	} else {
+		puts("tpm command failed\n");
+	}
+	return rv;
+}
+
+static int do_tpm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rv = 0;
+
+	/*
+	 * Verify that in case it is present, the first argument, it is
+	 * exactly one character in size.
+	 */
+	if (argc < 7) {
+		puts("command should be at least six bytes in size\n");
+		return -1;
+	}
+
+	if (tis_init()) {
+		puts("tis_init() failed!\n");
+		return -1;
+	}
+
+	if (tis_open()) {
+		puts("tis_open() failed!\n");
+		return -1;
+	}
+
+	rv = tpm_process(argc - 1, argv + 1, cmdtp);
+
+	if (tis_close()) {
+		puts("tis_close() failed!\n");
+		rv = -1;
+	}
+
+	return rv;
+}
+
+U_BOOT_CMD(tpm, MAX_TRANSACTION_SIZE, 1, do_tpm,
+	   "<byte> [<byte> ...]   - write data and read response",
+	   "send arbitrary data (at least 6 bytes) to the TPM "
+	   "device and read the response"
+);
--- u-boot-2011.03/common/cmd_show.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/common/cmd_show.c	2022-05-09 14:05:11.404061056 -0700
@@ -0,0 +1,108 @@
+/*
+ * Lanner switch burn test tool
+ * vlan switch 0x10 
+ * port 1,2 vid=3
+ * port 3,5 vid=4
+ * port 4,6 vid=5
+ * vlan switch 0x11
+ * port 5,6 vid=7
+ * port 0,1 vid=8
+ * port 2,3 vod=9
+ * under OS brige eth0 and eth1
+ */
+
+#include <common.h>
+#include <command.h>
+#include <miiphy.h>
+
+int vid_1[7]={1, 3, 3, 4, 5, 4, 5};
+int fid30_1[3]={0x3113, 0x1333, 0x3333};
+int fid64_1[3]={0x333, 0x313, 0x131};
+
+int vid_2[7]={8, 8, 9, 9, 1, 7, 7};
+int fid30_2[3]={0x3333, 0x3311, 0x1133};
+int fid64_2[3]={0x113, 0x333, 0x333};
+
+int do_vid_set (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int i;
+	int timeout = 0;
+	unsigned short value = 0;
+
+/* Set Seitch 1 address 0x10 */
+	for( i = 0; i< 7 ; i++)
+	{
+		DLAY SMIRW(1, 0x10, 0x7, vid_1[i], 0, 0,0x10 + i, 0);
+		DLAY SMIRW(1, 0x10, 0x8, 0x2c80, 0, 0,0x10 + i, 0);
+	}
+
+	for( i = 0 ; i < 3 ;i++)
+	{
+		/* current VID table 3 ~ 0 */
+		DLAY SMIRW(1, 0x10, 0x7, fid30_1[i], 0, 0,0x1b, 0);
+		/* current VID table 6 ~ 4 */
+		DLAY SMIRW(1, 0x10, 0x8, fid64_1[i], 0, 0,0x1b, 0);
+		/* Set VID ID,Start ID is 3 */
+		DLAY SMIRW(1, 0x10, 0x6, 0x1003 + i , 0, 0,0x1b, 0);
+		/* Set multiple address for vid */
+		DLAY SMIRW(1, 0x10, 0x2, 0x02 + i , 0, 0,0x1b, 0);
+		/* Store current VID */
+		DLAY SMIRW(1, 0x10, 0x5, 0xb000, 0, 0,0x1b, 0);
+
+		DLAY SMIRW(0, 0x10, 0x5, 0x0000, 0, 0,0x1b, &value);
+		timeout = 0;
+		while ( (value & 0x8000 ) != 0 && timeout > 200)
+		{
+			DLAY SMIRW(0, 0x10, 0x5, 0x0000, 0, 0,0x1b, &value);
+			timeout++;
+		}
+		if(timeout >= 200 )
+		{
+			printf("Switch 0x10 VLAN Table %01d Set timeout \n",i+3);
+		}
+	}
+/* Set Switch 0 address 0x11 */
+	for( i = 0; i< 7 ; i++)
+	{
+		DLAY SMIRW(1, 0x11, 0x7, vid_2[i], 0, 0,0x10 + i, 0);
+		DLAY SMIRW(1, 0x11, 0x8, 0x2c80, 0, 0,0x10 + i, 0);
+	}
+
+	for( i = 0 ; i < 3 ;i++)
+	{
+		/* current VID table 3 ~ 0 */
+		DLAY SMIRW(1, 0x11, 0x7, fid30_2[i], 0, 0,0x1b, 0);
+		/* current VID table 6 ~ 4 */
+		DLAY SMIRW(1, 0x11, 0x8, fid64_2[i], 0, 0,0x1b, 0);
+		/* Set VID ID ,Start ID is 7 */
+		DLAY SMIRW(1, 0x11, 0x6, 0x1007 + i , 0, 0,0x1b, 0);
+		/* Set multiple address for vid */
+		DLAY SMIRW(1, 0x11, 0x2, 0x02 + i , 0, 0,0x1b, 0);
+		/* Store current VID */
+		DLAY SMIRW(1, 0x11, 0x5, 0xb000, 0, 0,0x1b, 0);
+
+		DLAY SMIRW(0, 0x11, 0x5, 0x0000, 0, 0,0x1b, &value);
+		timeout = 0;
+		while ( (value & 0x8000 ) != 0 && timeout > 200)
+		{
+			DLAY SMIRW(0, 0x11, 0x5, 0x0000, 0, 0,0x1b, &value);
+			timeout++;
+		}
+		if(timeout >= 200 )
+		{
+			printf("Switch 0x11 VLAN Table %01d Set timeout \n",i+3);
+		}
+	}
+/* Enable internal switch connect  */
+	DLAY SMIRW(1, 0x10, 0x0, 0x9140, 0, 0,0x04,0);
+	DLAY SMIRW(1, 0x10, 0x1, 0x803e, 0, 0,0x16,0);
+	DLAY SMIRW(1, 0x11, 0x1, 0x803e, 0, 0,0x16,0);
+	return 0;
+}
+
+U_BOOT_CMD(
+        vid_set,       2,      1,      do_vid_set,
+        "Set switch 0x10 and 0x11 to vid",
+        "lanner switch test\n"
+);
+
--- u-boot-2011.03/common/cmd_test.new.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/common/cmd_test.new.c	2022-05-09 14:05:11.404061056 -0700
@@ -0,0 +1,1128 @@
+/*
+ * Copyright 2000-2009
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <watchdog.h>
+#include "..//sc_mfg_standalone//sc_mfg.h"
+//#include "..//drivers//rtc//s35390.h"
+
+
+#if defined(CONFIG_FBX_T10) || defined(CONFIG_FBX_T15)
+#define CONFIG_FACTORY_TEST
+#define RESET_BTN_HOLD_TIME_CHECK_INTERVAL	10	//ms
+#define RESET_BTN_HOLD_TIME					3000	//ms
+#define FACTORY_RESET_GPIO					0x00200000
+
+
+#define GPIO_USB_EN		0
+#define GPIO_PHY_RST	11
+#define GPIO_DDR_RST	14
+#define GPIO_PCIE_MODULE_RST	15
+
+
+
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+extern int run_command (const char *cmd, int flag);
+extern void *malloc (size_t len);
+
+extern int sc_rtc_set_time(SC_RTC_TIME * time);
+extern void sc_i2c_init(int speed, int slaveadd);
+
+int RTC_Test(void);
+
+int mem_test(void);
+
+int RTC_Battery_Test_Write(char *cRTCTime);
+int RTC_Battery_Test_Read(void);
+
+
+#endif
+
+int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+
+#if !defined(CONFIG_FACTORY_TEST)
+	char * const *ap;
+	int left, adv, expr, last_expr, neg, last_cmp;
+
+	/* args? */
+	if (argc < 3)
+		return 1;
+
+#if 0
+	{
+		printf("test:");
+		left = 1;
+		while (argv[left])
+			printf(" %s", argv[left++]);
+	}
+#endif
+
+	last_expr = 0;
+	left = argc - 1; ap = argv + 1;
+	if (left > 0 && strcmp(ap[0], "!") == 0) {
+		neg = 1;
+		ap++;
+		left--;
+	} else
+		neg = 0;
+
+	expr = -1;
+	last_cmp = -1;
+	last_expr = -1;
+	while (left > 0) {
+
+		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
+			adv = 1;
+		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
+			adv = 2;
+		else
+			adv = 3;
+
+		if (left < adv) {
+			expr = 1;
+			break;
+		}
+
+		if (adv == 1) {
+			if (strcmp(ap[0], "-o") == 0) {
+				last_expr = expr;
+				last_cmp = 0;
+			} else if (strcmp(ap[0], "-a") == 0) {
+				last_expr = expr;
+				last_cmp = 1;
+			} else {
+				expr = 1;
+				break;
+			}
+		}
+
+		if (adv == 2) {
+			if (strcmp(ap[0], "-z") == 0)
+				expr = strlen(ap[1]) == 0 ? 1 : 0;
+			else if (strcmp(ap[0], "-n") == 0)
+				expr = strlen(ap[1]) == 0 ? 0 : 1;
+			else {
+				expr = 1;
+				break;
+			}
+
+			if (last_cmp == 0)
+				expr = last_expr || expr;
+			else if (last_cmp == 1)
+				expr = last_expr && expr;
+			last_cmp = -1;
+		}
+
+		if (adv == 3) {
+			if (strcmp(ap[1], "=") == 0)
+				expr = strcmp(ap[0], ap[2]) == 0;
+			else if (strcmp(ap[1], "!=") == 0)
+				expr = strcmp(ap[0], ap[2]) != 0;
+			else if (strcmp(ap[1], ">") == 0)
+				expr = strcmp(ap[0], ap[2]) > 0;
+			else if (strcmp(ap[1], "<") == 0)
+				expr = strcmp(ap[0], ap[2]) < 0;
+			else if (strcmp(ap[1], "-eq") == 0)
+				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
+			else if (strcmp(ap[1], "-ne") == 0)
+				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
+			else if (strcmp(ap[1], "-lt") == 0)
+				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
+			else if (strcmp(ap[1], "-le") == 0)
+				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
+			else if (strcmp(ap[1], "-gt") == 0)
+				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
+			else if (strcmp(ap[1], "-ge") == 0)
+				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
+			else {
+				expr = 1;
+				break;
+			}
+
+			if (last_cmp == 0)
+				expr = last_expr || expr;
+			else if (last_cmp == 1)
+				expr = last_expr && expr;
+			last_cmp = -1;
+		}
+
+		ap += adv; left -= adv;
+	}
+
+	if (neg)
+		expr = !expr;
+
+	expr = !expr;
+
+	debug (": returns %d\n", expr);
+
+	return expr;
+#else
+	ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+	int nResetBtnHoldTime=0;
+
+	static char command[CONFIG_SYS_CBSIZE] = { 0, };
+	char cBuf[8]={0}, *cTemp;
+	int nItemIndex = 1, nBufIndex=0, nCur=-1;
+	u32 *uTemp=(u32 *)0x200000;
+	cTemp=malloc(24);
+
+	printf("Factory Test:\n");
+
+/*CRC check of Kernel tests*/
+/*	printf("CRC Test for NAND:\n");
+	printf("\t%d.CRC:\t\t%d-1.CRC test of NAND/Kernel-Image\n", nItemIndex, nItemIndex);
+	printf("\n");
+	nItemIndex++;
+*/
+
+/*LED tests*/
+	printf("\t%d.LED:\t\t%d-1.ATTN LED\n", nItemIndex, nItemIndex);
+	printf("\t\t\t%d-2.Status LED\n", nItemIndex);
+	printf("\t\t\t%d-3.Mode LED\n", nItemIndex);
+	printf("\t\t\t%d-4.FailOver LED\n", nItemIndex);	
+	printf("\t\t\t%d-5.WAP yellow LED\n", nItemIndex);	
+	printf("\t\t\t%d-6.WAP Green LED\n", nItemIndex);
+	printf("\n");
+	nItemIndex++;
+
+/*Flash Test*/
+	printf("\t%d.Flash:\t%d-1.SPI R/W\n", nItemIndex, nItemIndex);
+	printf("\t\t\t%d-2.Nand R/W\n", nItemIndex);
+	printf("\n");
+	nItemIndex++;
+	
+/*GPIO*/
+	printf("\t%d.GPIO:\t\t%d-1.USB Power\t(Disable(0)/Enable(1))\n", nItemIndex, nItemIndex);
+//	printf("\t\t\t%d-2.Simulate Overcurrent(0)/Normal Status(1)\n", nItemIndex);	
+	printf("\t\t\t%d-2.PHY reset:\t(Reset all PHYs(0) / Normal Status(1) )\n", nItemIndex);	
+	printf("\t\t\t%d-3.DDR reset:\t(Reset DDR(0) / Normal Status(1) )\n", nItemIndex);	
+	printf("\t\t\t%d-4.PCIe module reset:(Reset(0) / Normal Status(1) ) \n", nItemIndex);	
+	printf("\n");
+	nItemIndex++;
+
+/*MemTest*/
+	printf("\t%d.MemTest:\t%d-1.Memory test.\n", nItemIndex, nItemIndex);
+	printf("\n");
+	nItemIndex++;
+
+/*RTC Test*/
+	printf("\t%d.I2C Test:\t%d-1.TPM: If the address is 0x29, then PASS. If it is not ,then FAIL.\n", nItemIndex, nItemIndex);
+	printf("\t\t\t%d-2.RTC clock test.\n", nItemIndex);	
+	printf("\t\t\t%d-3.RTC Battery Test: Write command example \"%d3:201402021530\" (YYYYMMDDHHMM)\n", nItemIndex, nItemIndex);	
+	printf("\t\t\t%d-4.RTC Battery Test.\n", nItemIndex);	
+	printf("\n");
+	nItemIndex++;	
+	
+/*USB Test*/
+	printf("\t%d.USB Test:\t%d-1.USB test.\n", nItemIndex, nItemIndex);
+	printf("\t\t\t   (It is PASS if it shows '1 Storage Device(s) found'.).\n");
+	printf("\t\t\t   (It is FAIL if it shows '0 Storage Device(s) found'.).\n");
+	printf("\n");
+	nItemIndex++;	
+
+/*Ethernet*/
+	printf("\t%d.Ethernet:\t%d-1.Ping test.\n", nItemIndex, nItemIndex);
+	printf("\t\t\t    Please insert the RJ45 jack of the port you want to test.\n");
+	printf("\t\t\t%d-2.Throughput: If the result shows \"Total of XXX bytes were the same\" then PASS. If it is not ,then FAIL.\n", nItemIndex);	
+	printf("\n");
+	nItemIndex++;
+
+/*Factory reset btn*/
+	printf("\t%d.Btn:\t\t%d-1.Factory button test.\n", nItemIndex, nItemIndex);
+	printf("\t\t\t    (After entering this mode, please press and hold for 3 secs and the Factory reset button and the system will reset.\n");
+	nItemIndex++;
+	
+/*Others
+	printf("\t%d.Others:\t%d-1.Entering Linux kernel for other test items by downloading images.\n", nItemIndex, nItemIndex);
+	printf("\t\t\t\tPlease make sure server ip is set and the TFTP server is ready.\n");	
+*/
+
+	memset(cTemp, 0, sizeof(cTemp));
+	cTemp=getenv("serverip");
+	if(strlen(cTemp))
+		printf("\t\t\t    (Current server ip is %s)\n", cTemp);	
+	printf("\n");
+	nItemIndex++;
+	
+	printf("Press \'Q\' or \'q\' to quit factory test.\n\n");
+	
+ReTest:	
+	printf("Please insert command:");
+	while (1) {
+		cBuf[++nCur] = getc();
+
+		if ((cBuf[nCur] == 'q') || (cBuf[nCur] == 'Q')) 
+		{
+			printf("\n");
+
+#undef CONFIG_FACTORY_TEST
+			return 0;
+		}
+
+		if ((cBuf[nCur] == '\n') || (cBuf[nCur] == '\r')) 
+		{
+			printf("\n");
+			goto FactoryTest;
+		}
+		else
+		{
+			printf("%c", cBuf[nCur]);
+			continue;
+		}
+	}
+
+
+FactoryTest:
+
+	switch (cBuf[0]) 
+	{
+		/*
+		case '1':
+			//CRC tests
+			switch (cBuf[1]) 
+			{
+				case '1': //
+				memset(command, 0, sizeof(command));
+				strcpy(command, "nand device 0;nand read 300000 0 9000000;crc32 300000 9000000 200000;md 200000 1");
+				run_command (command, 0);
+				
+				break;
+			}
+			break;
+		*/
+		case '1':
+		/*LED tests*/
+		switch (cBuf[1]) 
+			{
+			case '1': //ATTN
+				pgpio->gpdat=0xdc3f0000;
+				break;
+			case '2'://Status
+				pgpio->gpdat=0xec3f0000;
+				break;
+			case '3'://mode
+				pgpio->gpdat=0xf43f0000;
+				break;
+			case '4'://Fail Over
+				pgpio->gpdat=0xf83f0000;
+				break;
+			case '5'://WAN, Yellow
+				pgpio->gpdat=0xfc370000;
+				break;
+			case '6'://WAN, Green
+				pgpio->gpdat=0xfc3B0000;
+				break;
+			
+			}
+		break;
+	case '2':
+		/*Flash tests*/
+
+		memset(command, 0, sizeof(command));
+
+		switch (cBuf[1])
+		{
+			case '1': //SPI
+				strcpy(command, "mw 200000 12345678; mw 200004 99999999;sf probe 0;sf erase 90000 10000;sf write 200000 90000 4;sf read 200004 90000 4;");
+				run_command (command, 0);
+
+				uTemp=(u32 *)0x200000;
+				if( (*uTemp) == (*(uTemp+1)))
+					printf("SPI test PASS!\n\n");
+				else
+					printf("SPI test FAIL!\n\n");
+
+				break;
+			case '2'://NAND
+				strcpy(command, "mw 200010 abcdef12; mw 200014 56565656;nand device 0;nand erase 1f000000 20000;nand write 200010 1f000000 4;nand read 200014 1f000000 4;");
+				run_command (command, 0);
+								
+				uTemp=(u32 *)0x200010;
+				if((*uTemp) == (*(uTemp+1)))
+					printf("NAND test PASS!\n\n");
+				else
+				{
+					printf("NAND test FAIL!\n\n");
+				}
+				break;
+		}
+		break;
+	case '3':
+		/*GPIO tests*/
+		memset(command, 0, sizeof(command));
+		
+		switch (cBuf[1]) 
+			{
+			case '1': /*USB GPIO*/
+				switch (cBuf[2]) 
+				{
+				case '0':
+					pgpio->gpdat &= ~(0x1 << (31-GPIO_USB_EN));
+
+					if(pgpio->gpdat | (0x1 << (31-GPIO_USB_EN)) )
+						printf("GPIO USB Disable PASS!\n\n");
+					else
+						printf("GPIO USB Disable FAIL!\n\n");
+					break;
+				case '1':
+					pgpio->gpdat |= 0x1 << (31-GPIO_USB_EN);
+
+					if(pgpio->gpdat & ~(0x1 << (31-GPIO_USB_EN)))
+						printf("GPIO USB Enable PASS!\n\n");
+					else
+						printf("GPIO USB Enable FAIL!\n\n");
+					break;
+				}
+				break;
+				
+			case '2':/*PHY GPIO reset*/
+				switch (cBuf[2]) 
+				{
+				case '0':
+					pgpio->gpdat &= ~(0x1 << (31-GPIO_PHY_RST));
+
+					if(pgpio->gpdat | (0x1 << (31-GPIO_PHY_RST)) )
+						printf("GPIO PHY Reset Pin Clr PASS!\n\n");
+					else
+						printf("GPIO PHY Reset Pin Clr FAIL!\n\n");
+					break;
+				case '1':
+					pgpio->gpdat |= 0x1 << (31-GPIO_PHY_RST);
+
+					if(pgpio->gpdat & ~(0x1 << (31-GPIO_PHY_RST)))
+						printf("GPIO PHY Reset Pin Set PASS!\n\n");
+					else
+						printf("GPIO PHY Reset Pin Set FAIL!\n\n");
+					break;
+				}
+				break;
+			case '3':/*DDR GPIO reset*/
+				switch (cBuf[2]) 
+				{
+				case '0':
+					strcpy(command, "mw ffe0f000 bc3f0000;mw ffe0f008 fc3d0000");
+					run_command (command, 0);
+
+					break;
+				case '1':
+					strcpy(command, "mw ffe0f000 bc3f0000;mw ffe0f008 fc3f0000");
+					run_command (command, 0);
+					
+					break;
+				}
+				break;
+			case '4':/*PCIe Module GPIO reset*/
+				switch (cBuf[2]) 
+				{
+				case '0':
+					pgpio->gpdat &= ~(0x1 << (31-GPIO_PCIE_MODULE_RST));
+
+					if(pgpio->gpdat | (0x1 << (31-GPIO_PCIE_MODULE_RST)) )
+						printf("GPIO PCIe Reset Pin Clr PASS!\n\n");
+					else
+						printf("GPIO PCIe Reset Pin Clr FAIL!\n\n");
+					break;
+				case '1':
+					pgpio->gpdat |= 0x1 << (31-GPIO_PCIE_MODULE_RST);
+
+					if(pgpio->gpdat & ~(0x1 << (31-GPIO_PCIE_MODULE_RST)))
+						printf("GPIO PCIe Reset Pin Set PASS!\n\n");
+					else
+						printf("GPIO PCIe Reset Pin Set FAIL!\n\n");
+					break;
+				}
+				break;
+				
+			}	
+		break;
+	case '4':
+		/*Memory Test*/
+		switch (cBuf[1]) 
+			{
+			case '1':
+				mem_test();
+				/*
+				memset(command, 0, sizeof(command));
+				strcpy(command, "mtest");
+				run_command (command, 0);
+				*/
+				break;
+			}
+		break;
+	case '5':
+		/*I2C Test*/
+		switch (cBuf[1]) 
+		{
+			case '1': /*TPM*/
+				memset(command, 0, sizeof(command));
+				strcpy(command, "i2c dev 1;i2c probe");
+				run_command (command, 0);
+				break;
+			case '2':/*RTC*/
+				RTC_Test();
+				break;
+			case '3':/*RTC Battery Test:Write*/
+				if(cBuf[3])
+					RTC_Battery_Test_Write(&cBuf[3]);
+				else
+					printf("Error! Please follow the pattern:\"201402021530\" (YYYYMMDDHHMM)\n");
+				break;
+			case '4':/*RTC Battery Test:Read*/
+				RTC_Battery_Test_Read();
+				break;
+		}
+		break;
+	case '6':
+		/*USB Test*/
+		switch (cBuf[1]) 
+		{
+			case '1':/*RTC*/
+				memset(command, 0, sizeof(command));
+				strcpy(command, "usb reset");
+				run_command (command, 0);
+				break;
+		}
+		break;
+	case '7':
+		/*Ethernet tests*/
+		memset(command, 0, sizeof(command));
+
+		printf("If a message showed that \"Your (IP) is alive!\", then the enthernet is PASS.\n");
+		printf("If it is not, then is FAIL.\n");
+		switch (cBuf[1])
+		{
+			case '1': 
+				if(strlen(cTemp))
+				{
+					printf("Now ping the server IP %s\n", cTemp);
+					sprintf(command, "ping %s", cTemp);
+				}
+				else
+				{
+					printf("The serverip is not set, so now pinging default ip---192.168.1.101.\n");
+					strcpy(command, "ping 192.168.1.101");
+				}
+				run_command (command, 0);
+				break;
+			case '2':
+				memset(command, 0, sizeof(command));
+				strcpy(command, "tftp 200000 rootfs.ext2.gz.uboot;tftp 4200000 rootfs.ext2.gz.uboot;cmp.b 200000 4200000 2200000");
+				run_command (command, 0);			
+				break;			
+		}
+		break;
+	case '8':
+			printf("\nPlease press and hold for 3 secs and the Factory reset button and the system will reset.)\n");
+			printf("\n");
+	
+			while(1)
+			{		
+				if(pgpio->gpdat & FACTORY_RESET_GPIO)//normal status, so reset the timer
+					nResetBtnHoldTime=0;
+				else
+					nResetBtnHoldTime+=RESET_BTN_HOLD_TIME_CHECK_INTERVAL;
+				
+				udelay(RESET_BTN_HOLD_TIME_CHECK_INTERVAL*1000);
+
+				if(nResetBtnHoldTime>RESET_BTN_HOLD_TIME)
+				{
+					printf("Factory reset button is hold more than %d ms, now reset...\n", RESET_BTN_HOLD_TIME);
+					do_reset (NULL, 0, 0, NULL);
+				}
+			}
+			break;
+	
+//	case '8':
+		/*Entering kernel*/
+	/*	memset(command, 0, sizeof(command));
+
+		switch (cBuf[1])
+		{
+			case '1': 
+				if(strlen(cTemp))
+				{
+					printf("Please set the IP of your test station as %s\n", cTemp);
+				}
+				else
+				{
+					printf("Your 'serverip' environment variable is not set. Now set it as default 192.168.1.101\n");
+					setenv("serverip", "192.168.1.101");
+				}
+				
+				memset(command, 0, sizeof(command));
+				strcpy(command, "tftp 0x2000000 p1010rdb.dtb;tftp 0x2100000 uImage;tftp 0x2600000 rootfs.ext2.gz.uboot;bootm 0x2100000 0x2600000 0x2000000;");
+				run_command (command, 0);
+
+				break;
+			
+		}
+		break;
+*/
+	}
+
+	for(nBufIndex=0; nBufIndex<nCur; nBufIndex++)
+		cBuf[nBufIndex]='\0';
+	nCur=-1;
+	
+	goto ReTest;
+
+	return 0;
+#endif
+}
+
+U_BOOT_CMD(
+	test,	CONFIG_SYS_MAXARGS,	1,	do_test,
+	"minimal test like /bin/sh",
+	"[args..]"
+);
+
+int mem_test(void)
+{
+	vu_long	*addr, *start, *end;
+	ulong	val;
+	ulong	readback;
+	ulong	errs = 0;
+	int iterations = 1;
+	int iteration_limit;
+
+//#if defined(CONFIG_SYS_ALT_MEMTEST)
+	vu_long	len;
+	vu_long	offset;
+	vu_long	test_offset;
+	vu_long	pattern;
+	vu_long	temp;
+	vu_long	anti_pattern;
+	vu_long	num_words;
+#if defined(CONFIG_SYS_MEMTEST_SCRATCH)
+	vu_long *dummy = (vu_long*)CONFIG_SYS_MEMTEST_SCRATCH;
+#else
+	vu_long *dummy = 0;	/* yes, this is address 0x0, not NULL */
+#endif
+	int	j;
+
+	static const ulong bitpattern[] = {
+		0x00000001,	/* single bit */
+		0x00000003,	/* two adjacent bits */
+		0x00000007,	/* three adjacent bits */
+		0x0000000F,	/* four adjacent bits */
+		0x00000005,	/* two non-adjacent bits */
+		0x00000015,	/* three non-adjacent bits */
+		0x00000055,	/* four non-adjacent bits */
+		0xaaaaaaaa,	/* alternating 1/0 */
+	};
+/*
+#else
+	ulong	incr;
+	ulong	pattern;
+#endif
+*/
+
+	start = (ulong *)(CONFIG_SYS_MEMTEST_START);
+	end = (ulong *)(CONFIG_SYS_MEMTEST_END);
+	iteration_limit = 0;
+
+	printf ("Testing %08x ... %08x:\n", (uint)start, (uint)end);
+	printf("%s:%d: start 0x%p end 0x%p\n",
+		__FUNCTION__, __LINE__, start, end);
+
+	/*for (;;) */{
+		if (ctrlc()) {
+			putc ('\n');
+			return 1;
+		}
+
+
+		if (iteration_limit && iterations > iteration_limit) {
+			printf("Tested %d iteration(s) with %lu errors.\n",
+				iterations-1, errs);
+			return errs != 0;
+		}
+
+		/*
+		printf("Iteration: %6d\r", iterations);
+		PRINTF("\n");
+		*/
+		iterations++;
+
+		/*
+		 * Data line test: write a pattern to the first
+		 * location, write the 1's complement to a 'parking'
+		 * address (changes the state of the data bus so a
+		 * floating bus doen't give a false OK), and then
+		 * read the value back. Note that we read it back
+		 * into a variable because the next time we read it,
+		 * it might be right (been there, tough to explain to
+		 * the quality guys why it prints a failure when the
+		 * "is" and "should be" are obviously the same in the
+		 * error message).
+		 *
+		 * Rather than exhaustively testing, we test some
+		 * patterns by shifting '1' bits through a field of
+		 * '0's and '0' bits through a field of '1's (i.e.
+		 * pattern and ~pattern).
+		 */
+		printf("Data line testing...\n");
+		addr = start;
+		for (j = 0; j < sizeof(bitpattern)/sizeof(bitpattern[0]); j++) {
+			
+		    val = bitpattern[j];
+			for(; val != 0; val <<= 1) {
+			
+			/*
+			printf("testing val=%08x, addr=%x\n", val, addr);
+			*/
+
+			*addr  = val;
+			*dummy  = ~val; /* clear the test data off of the bus */
+			readback = *addr;
+			if(readback != val) {
+			    printf ("FAILURE (data line): "
+				"expected %08lx, actual %08lx\n",
+					  val, readback);
+			    errs++;
+			    if (ctrlc()) {
+				putc ('\n');
+				return 1;
+			    }
+			}
+			*addr  = ~val;
+			*dummy  = val;
+			readback = *addr;
+			if(readback != ~val) {
+			    printf ("FAILURE (data line): "
+				"Is %08lx, should be %08lx\n",
+					readback, ~val);
+			    errs++;
+			    if (ctrlc()) {
+				putc ('\n');
+				return 1;
+			    }
+			}
+		    }
+		}
+
+		/*
+		 * Based on code whose Original Author and Copyright
+		 * information follows: Copyright (c) 1998 by Michael
+		 * Barr. This software is placed into the public
+		 * domain and may be used for any purpose. However,
+		 * this notice must not be changed or removed and no
+		 * warranty is either expressed or implied by its
+		 * publication or distribution.
+		 */
+
+		/*
+		 * Address line test
+		 *
+		 * Description: Test the address bus wiring in a
+		 *              memory region by performing a walking
+		 *              1's test on the relevant bits of the
+		 *              address and checking for aliasing.
+		 *              This test will find single-bit
+		 *              address failures such as stuck -high,
+		 *              stuck-low, and shorted pins. The base
+		 *              address and size of the region are
+		 *              selected by the caller.
+		 *
+		 * Notes:	For best results, the selected base
+		 *              address should have enough LSB 0's to
+		 *              guarantee single address bit changes.
+		 *              For example, to test a 64-Kbyte
+		 *              region, select a base address on a
+		 *              64-Kbyte boundary. Also, select the
+		 *              region size as a power-of-two if at
+		 *              all possible.
+		 *
+		 * Returns:     0 if the test succeeds, 1 if the test fails.
+		 */
+		len = ((ulong)end - (ulong)start)/sizeof(vu_long);
+ 		printf("Address line testing...\n");
+		pattern = (vu_long) 0xaaaaaaaa;
+		anti_pattern = (vu_long) 0x55555555;
+
+		/*
+		printf("%s:%d: length = 0x%.8lx\n",
+			__FUNCTION__, __LINE__,
+			len);
+		*/
+		/*
+		 * Write the default pattern at each of the
+		 * power-of-two offsets.
+		 */
+		for (offset = 1; offset < len; offset <<= 1) {
+			
+			start[offset] = pattern;
+			/*
+			printf("Write the default pattern. start[%08x]--> Addr:%08x, Value = %08x -->%08x \n", offset, &start[offset], start[offset], pattern);
+			*/
+		}
+
+		/*
+		 * Check for address bits stuck high.
+		 */
+		test_offset = 0;
+		start[test_offset] = anti_pattern;
+
+		for (offset = 1; offset < len; offset <<= 1) {
+			/*
+			printf("Check for address bits stuck high. start[%08x]--> Addr:%08x, Value = %08x -->%08x \n", offset, &start[offset], start[offset], anti_pattern);
+			*/
+		    temp = start[offset];
+		    if (temp != pattern) {
+			printf ("\nFAILURE: Address bit stuck high @ 0x%.8lx:"
+				" expected 0x%.8lx, actual 0x%.8lx\n",
+				(ulong)&start[offset], pattern, temp);
+			errs++;
+			if (ctrlc()) {
+			    putc ('\n');
+			    return 1;
+			}
+		    }
+		}
+		start[test_offset] = pattern;
+		WATCHDOG_RESET();
+		/*
+		 * Check for addr bits stuck low or shorted.
+		 */
+		for (test_offset = 1; test_offset < len; test_offset <<= 1) {
+		    start[test_offset] = anti_pattern;
+			/*
+			printf("Check for addr bits stuck low or shorted.. start[%08x]--> Addr:%08x, Value = %08x -->%08x \n", test_offset, &start[test_offset], start[test_offset], anti_pattern);
+			*/
+
+		    for (offset = 1; offset < len; offset <<= 1) {
+			temp = start[offset];
+			if ((temp != pattern) && (offset != test_offset)) {
+			    printf ("\nFAILURE: Address bit stuck low or shorted @"
+				" 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx\n",
+				(ulong)&start[offset], pattern, temp);
+			    errs++;
+			    if (ctrlc()) {
+				putc ('\n');
+				return 1;
+			    }
+			}
+		    }
+		    start[test_offset] = pattern;
+		}
+
+		/*
+		 * Description: Test the integrity of a physical
+		 *		memory device by performing an
+		 *		increment/decrement test over the
+		 *		entire region. In the process every
+		 *		storage bit in the device is tested
+		 *		as a zero and a one. The base address
+		 *		and the size of the region are
+		 *		selected by the caller.
+		 *
+		 * Returns:     0 if the test succeeds, 1 if the test fails.
+		 */
+		printf("Integrity testing...This will take a while. Please wait...\n");
+		num_words = ((ulong)end - (ulong)start)/sizeof(vu_long) + 1;
+
+		/*
+		 * Fill memory with a known pattern.
+		 */
+		printf("Fill memory with a known pattern.");	
+		for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
+			WATCHDOG_RESET();
+			start[offset] = pattern;
+			/*
+			printf("Fill memory with a known pattern. start[%08x]--> Addr:%08x, Value = %08x -->%08x \n", offset, &start[offset], start[offset],pattern);	
+			*/
+			
+			if( !(pattern % 0xd0000))
+				printf(".");
+		}
+	
+		/*
+		 * Check each location and invert it for the second pass.
+		 */
+		printf("\nCheck each location and invert it for the second stage.");	
+		for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
+			/*
+			printf("Check each location and invert it for the second stage. start[%08x]--> Addr:%08x, Value = %08x -->%08x \n", offset, &start[offset], start[offset], pattern);
+			*/
+		    WATCHDOG_RESET();
+		    temp = start[offset];
+		    if (temp != pattern) {
+			printf ("\nFAILURE (read/write) @ 0x%.8lx:"
+				" expected 0x%.8lx, actual 0x%.8lx)\n",
+				(ulong)&start[offset], pattern, temp);
+			errs++;
+			if (ctrlc()) {
+			    putc ('\n');
+			    return 1;
+			}
+		    }
+
+		    anti_pattern = ~pattern;
+		    start[offset] = anti_pattern;
+			if( !(pattern % 0xd0000))
+				printf(".");
+		}
+
+		/*
+		 * Check each location for the inverted pattern and zero it.
+		 */
+		printf("\nCheck each location for the inverted pattern and zero it..");	
+		for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
+		    WATCHDOG_RESET();
+		    anti_pattern = ~pattern;
+		    temp = start[offset];
+		    if (temp != anti_pattern) {
+			printf ("\nFAILURE (read/write): @ 0x%.8lx:"
+				" expected 0x%.8lx, actual 0x%.8lx)\n",
+				(ulong)&start[offset], anti_pattern, temp);
+			errs++;
+			if (ctrlc()) {
+			    putc ('\n');
+			    return 1;
+			}
+		    }
+		    start[offset] = 0;
+			if( !(pattern % 0xd0000))
+				printf(".");
+		}
+	}
+
+	if(errs)
+		printf ("\n%lu errors occurs! Memtest FAIL\n", errs);
+	else
+		printf ("\nMemtest PASS\n");
+		
+	return 0;
+}
+
+int rtc_set_get_test(void)
+{
+	SC_RTC_TIME time;
+	SC_RTC_TIME time_get;
+
+	time.year	= 8; //year 2008
+	time.month	= 8; //month
+	time.day	= 8; //day
+	time.week	= 5; //day of week data,2008 -08 -08 is Fri
+	time.hour	= 8; //hour
+	time.min	= 8; //minute
+	time.sec	= 8; //second
+
+	printf("***Will set time to 2008-08-08 08:08:08***\n");
+
+	if (sc_rtc_set_time(&time) == RTC_OP_FAIL) {
+		printf("***Set time to 2008-08-08 08:08:08 error***\n");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("***Set time to 2008-08-08 08:08:08 success, will delay %d second...***\n", RTC_TEST_DELAY);
+	udelay(1000000 * RTC_TEST_DELAY);
+
+	if (sc_rtc_get_time(&time_get) == RTC_OP_FAIL) {
+		printf("***After set time,read back error***");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("Read back time:%d-%d-%d %d(day of week) %d:%d:%d\n",
+	time_get.year + 2000,
+	time_get.month,
+	time_get.day,
+	time_get.week,
+	time_get.hour,
+	time_get.min,
+	time_get.sec);
+
+	if ((time_get.year != time.year ) || (time_get.month != time.month) ||
+	    (time_get.day != time.day ) || (time_get.week != time.week) ||
+	    (time_get.hour != time.hour) || (time_get.min != time.min )) {
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("Set second:%d, Read second:%d \n", time.sec, time_get.sec);
+	if ( (time_get.sec - time.sec) == RTC_TEST_DELAY ) {
+		return SC_MFG_TEST_OP_PASS;
+	}
+	else {
+		return SC_MFG_TEST_OP_FAIL;
+	}
+}
+
+/*
+* RTC Test main entry
+*/
+int RTC_Test(void)
+{
+	int RTC_result;
+
+	/* I2C bus Init */
+	sc_i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	/* RTC Chip Init */
+	sc_rtc_init();
+
+	RTC_result = rtc_set_get_test();
+
+	if ( RTC_result != SC_MFG_TEST_OP_PASS ) {
+		printf("RTC Test FAIL\n");
+	}
+	else {
+		printf("RTC Test PASS\n");
+	}
+	return 0;
+}
+
+int RTC_Battery_Test_Write(char *cRTCTime)
+{
+	SC_RTC_TIME time;
+	int i=0, nTmp=0;
+	char cTmp[5]={0};
+	
+	if(strlen(cRTCTime)<strlen("201402021530"))
+		goto RTC_BATTERY_TEST_ERROR;
+		
+	for(;i<strlen(cRTCTime);i++)
+	{
+		if(!cRTCTime[i])
+			goto RTC_BATTERY_TEST_ERROR;
+	}
+	
+	i=0;
+	
+	strncpy(cTmp, &cRTCTime[i], 4); 
+	nTmp=simple_strtoul(cTmp, NULL, 10);
+	time.year	= nTmp-2000; 
+	i+=4;
+	
+	memset(cTmp, 0, sizeof(cTmp));
+	strncpy(cTmp, &cRTCTime[i], 2); 
+	nTmp=simple_strtoul(cTmp, NULL, 10);
+	time.month	= nTmp;
+	i+=2;
+	
+	memset(cTmp, 0, sizeof(cTmp));
+	strncpy(cTmp, &cRTCTime[i], 2); 
+	nTmp=simple_strtoul(cTmp, NULL, 10);
+	time.day	= nTmp; 
+	i+=2;
+	
+	memset(cTmp, 0, sizeof(cTmp));
+	strncpy(cTmp, &cRTCTime[i], 2); 
+	nTmp=simple_strtoul(cTmp, NULL, 10);
+	time.hour	= nTmp;
+	i+=2;
+	
+	memset(cTmp, 0, sizeof(cTmp));
+	strncpy(cTmp, &cRTCTime[i], 2); 
+	nTmp=simple_strtoul(cTmp, NULL, 10);
+	time.min	= nTmp; 
+	i+=2;
+	
+	time.sec	= 0; 
+	time.week	= 5; //day of week data,2008 -08 -08 is Fri
+	
+	printf(	"***Will set time to %04d-%02d-%02d %02d:%02d:%02d***\n", 
+			time.year+2000, 
+			time.month, 
+			time.day,
+			time.hour,
+			time.min,
+			time.sec);
+
+	if (sc_rtc_set_time(&time) == RTC_OP_FAIL) {
+		printf("***Set time FAIL***\n");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("***Set time OK***\n");
+	return SC_MFG_TEST_OP_PASS;
+	
+	RTC_BATTERY_TEST_ERROR:
+		printf("Error! Please follow the pattern like this:\"201402021530\" (YYYYMMDDHHMM)\n");
+		return SC_MFG_TEST_OP_FAIL;		
+}
+
+int RTC_Battery_Test_Read(void)
+{
+	SC_RTC_TIME time_get;
+	
+	if (sc_rtc_get_time(&time_get) == RTC_OP_FAIL) {
+		printf("***Get time FAIL***");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	if(time_get.hour >= 40) //the bit represent am/pm
+	{
+		printf("Read back time:%04d-%02d-%02d %02d:%02d:%02d\n",
+		time_get.year + 2000,
+		time_get.month,
+		time_get.day,
+		time_get.hour-40,
+		time_get.min,
+		time_get.sec);
+	}
+	else
+	{
+		printf("Read back time:%04d-%02d-%02d %02d:%02d:%02d\n",
+		time_get.year + 2000,
+		time_get.month,
+		time_get.day,
+		time_get.hour,
+		time_get.min,
+		time_get.sec);
+	}	
+	/*
+	if ((time_get.year != time.year ) || (time_get.month != time.month) ||
+	    (time_get.day != time.day ) || (time_get.week != time.week) ||
+	    (time_get.hour != time.hour) || (time_get.min != time.min )) {
+		return SC_MFG_TEST_OP_FAIL;
+	}
+	*/
+	
+	printf("***Get time OK***\n");
+	return SC_MFG_TEST_OP_PASS;
+
+}
+
+int do_false(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return 1;
+}
+
+U_BOOT_CMD(
+	false,	CONFIG_SYS_MAXARGS,	1,	do_false,
+	"do nothing, unsuccessfully",
+	NULL
+);
+
+int do_true(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return 0;
+}
+
+U_BOOT_CMD(
+	true,	CONFIG_SYS_MAXARGS,	1,	do_true,
+	"do nothing, successfully",
+	NULL
+);
--- u-boot-2011.03/arch/powerpc/include/asm/fsl_ifc.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/arch/powerpc/include/asm/fsl_ifc.h	2022-05-09 14:05:10.932080195 -0700
@@ -0,0 +1,963 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ * Author: Dipen Dudhat <dipen.dudhat@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASM_PPC_FSL_IFC_H
+#define __ASM_PPC_FSL_IFC_H
+
+#include <config.h>
+#include <common.h>
+
+/*
+ * CSPR - Chip Select Property Register
+ */
+#define CSPR_BA				0xFFFF0000
+#define CSPR_BA_SHIFT			16
+#define CSPR_PORT_SIZE			0x00000180
+#define CSPR_PORT_SIZE_SHIFT		7
+/* Port Size 8 bit */
+#define CSPR_PORT_SIZE_8		0x00000080
+/* Port Size 16 bit */
+#define CSPR_PORT_SIZE_16		0x00000100
+/* Port Size 32 bit */
+#define CSPR_PORT_SIZE_32		0x00000180
+/* Write Protect */
+#define CSPR_WP				0x00000040
+#define CSPR_WP_SHIFT			6
+/* Machine Select */
+#define CSPR_MSEL			0x00000006
+#define CSPR_MSEL_SHIFT			1
+/* NOR */
+#define CSPR_MSEL_NOR			0x00000000
+/* NAND */
+#define CSPR_MSEL_NAND			0x00000002
+/* GPCM */
+#define CSPR_MSEL_GPCM			0x00000004
+/* Bank Valid */
+#define CSPR_V				0x00000001
+#define CSPR_V_SHIFT			0
+
+/* Convert an address into the right format for the CSPR Registers */
+#define CSPR_PHYS_ADDR(x)		(((uint64_t)x) & 0xffff0000)
+
+/*
+ * Address Mask Register
+ */
+#define IFC_AMASK_MASK			0xFFFF0000
+#define IFC_AMASK_SHIFT			16
+#define IFC_AMASK(n)			(IFC_AMASK_MASK << \
+					(__ilog2(n) - IFC_AMASK_SHIFT))
+
+/*
+ * Chip Select Option Register IFC_NAND Machine
+ */
+/* Enable ECC Encoder */
+#define CSOR_NAND_ECC_ENC_EN		0x80000000
+#define CSOR_NAND_ECC_MODE_MASK		0x30000000
+/* 4 bit correction per 520 Byte sector */
+#define CSOR_NAND_ECC_MODE_4		0x00000000
+/* 8 bit correction per 528 Byte sector */
+#define CSOR_NAND_ECC_MODE_8		0x10000000
+/* Enable ECC Decoder */
+#define CSOR_NAND_ECC_DEC_EN		0x04000000
+/* Row Address Length */
+#define CSOR_NAND_RAL_MASK		0x01800000
+#define CSOR_NAND_RAL_SHIFT		20
+#define CSOR_NAND_RAL_1			0x00000000
+#define CSOR_NAND_RAL_2			0x00800000
+#define CSOR_NAND_RAL_3			0x01000000
+#define CSOR_NAND_RAL_4			0x01800000
+/* Page Size 512b, 2k, 4k */
+#define CSOR_NAND_PGS_MASK		0x00180000
+#define CSOR_NAND_PGS_SHIFT		16
+#define CSOR_NAND_PGS_512		0x00000000
+#define CSOR_NAND_PGS_2K		0x00080000
+#define CSOR_NAND_PGS_4K		0x00100000
+/* Spare region Size */
+#define CSOR_NAND_SPRZ_MASK		0x0000E000
+#define CSOR_NAND_SPRZ_SHIFT		13
+#define CSOR_NAND_SPRZ_16		0x00000000
+#define CSOR_NAND_SPRZ_64		0x00002000
+#define CSOR_NAND_SPRZ_128		0x00004000
+#define CSOR_NAND_SPRZ_210		0x00006000
+#define CSOR_NAND_SPRZ_218		0x00008000
+#define CSOR_NAND_SPRZ_224		0x0000A000
+/* Pages Per Block */
+#define CSOR_NAND_PB_MASK		0x00000700
+#define CSOR_NAND_PB_SHIFT		8
+#define CSOR_NAND_PB(n)		((__ilog2(n) - 5) << CSOR_NAND_PB_SHIFT)
+/* Time for Read Enable High to Output High Impedance */
+#define CSOR_NAND_TRHZ_MASK		0x0000001C
+#define CSOR_NAND_TRHZ_SHIFT		2
+#define CSOR_NAND_TRHZ_20		0x00000000
+#define CSOR_NAND_TRHZ_40		0x00000004
+#define CSOR_NAND_TRHZ_60		0x00000008
+#define CSOR_NAND_TRHZ_80		0x0000000C
+#define CSOR_NAND_TRHZ_100		0x00000010
+/* Buffer control disable */
+#define CSOR_NAND_BCTLD			0x00000001
+
+/*
+ * Chip Select Option Register - NOR Flash Mode
+ */
+/* Enable Address shift Mode */
+#define CSOR_NOR_ADM_SHFT_MODE_EN	0x80000000
+/* Page Read Enable from NOR device */
+#define CSOR_NOR_PGRD_EN		0x10000000
+/* AVD Toggle Enable during Burst Program */
+#define CSOR_NOR_AVD_TGL_PGM_EN		0x01000000
+/* Address Data Multiplexing Shift */
+#define CSOR_NOR_ADM_MASK		0x0003E000
+#define CSOR_NOR_ADM_SHIFT_SHIFT	13
+#define CSOR_NOR_ADM_SHIFT(n)	((n) << CSOR_NOR_ADM_SHIFT_SHIFT)
+/* Type of the NOR device hooked */
+#define CSOR_NOR_NOR_MODE_AYSNC_NOR	0x00000000
+#define CSOR_NOR_NOR_MODE_AVD_NOR	0x00000020
+/* Time for Read Enable High to Output High Impedance */
+#define CSOR_NOR_TRHZ_MASK		0x0000001C
+#define CSOR_NOR_TRHZ_SHIFT		2
+#define CSOR_NOR_TRHZ_20		0x00000000
+#define CSOR_NOR_TRHZ_40		0x00000004
+#define CSOR_NOR_TRHZ_60		0x00000008
+#define CSOR_NOR_TRHZ_80		0x0000000C
+#define CSOR_NOR_TRHZ_100		0x00000010
+/* Buffer control disable */
+#define CSOR_NOR_BCTLD			0x00000001
+
+/*
+ * Chip Select Option Register - GPCM Mode
+ */
+/* GPCM Mode - Normal */
+#define CSOR_GPCM_GPMODE_NORMAL		0x00000000
+/* GPCM Mode - GenericASIC */
+#define CSOR_GPCM_GPMODE_ASIC		0x80000000
+/* Parity Mode odd/even */
+#define CSOR_GPCM_PARITY_EVEN		0x40000000
+/* Parity Checking enable/disable */
+#define CSOR_GPCM_PAR_EN		0x20000000
+/* GPCM Timeout Count */
+#define CSOR_GPCM_GPTO_MASK		0x0F000000
+#define CSOR_GPCM_GPTO_SHIFT		24
+#define CSOR_GPCM_GPTO(n)	((__ilog2(n) - 8) << CSOR_GPCM_GPTO_SHIFT)
+/* GPCM External Access Termination mode for read access */
+#define CSOR_GPCM_RGETA_EXT		0x00080000
+/* GPCM External Access Termination mode for write access */
+#define CSOR_GPCM_WGETA_EXT		0x00040000
+/* Address Data Multiplexing Shift */
+#define CSOR_GPCM_ADM_MASK		0x0003E000
+#define CSOR_GPCM_ADM_SHIFT_SHIFT	13
+#define CSOR_GPCM_ADM_SHIFT(n)	((n) << CSOR_GPCM_ADM_SHIFT_SHIFT)
+/* Generic ASIC Parity error indication delay */
+#define CSOR_GPCM_GAPERRD_MASK		0x00000180
+#define CSOR_GPCM_GAPERRD_SHIFT		7
+#define CSOR_GPCM_GAPERRD(n)	(((n) - 1) << CSOR_GPCM_GAPERRD_SHIFT)
+/* Time for Read Enable High to Output High Impedance */
+#define CSOR_GPCM_TRHZ_MASK		0x0000001C
+#define CSOR_GPCM_TRHZ_20		0x00000000
+#define CSOR_GPCM_TRHZ_40		0x00000004
+#define CSOR_GPCM_TRHZ_60		0x00000008
+#define CSOR_GPCM_TRHZ_80		0x0000000C
+#define CSOR_GPCM_TRHZ_100		0x00000010
+/* Buffer control disable */
+#define CSOR_GPCM_BCTLD			0x00000001
+
+/*
+ * Flash Timing Registers (FTIM0 - FTIM2_CSn)
+ */
+/*
+ * FTIM0 - NAND Flash Mode
+ */
+#define FTIM0_NAND			0x7EFF3F3F
+#define FTIM0_NAND_TCCST_SHIFT	25
+#define FTIM0_NAND_TCCST(n)	((n) << FTIM0_NAND_TCCST_SHIFT)
+#define FTIM0_NAND_TWP_SHIFT	16
+#define FTIM0_NAND_TWP(n)	((n) << FTIM0_NAND_TWP_SHIFT)
+#define FTIM0_NAND_TWCHT_SHIFT	8
+#define FTIM0_NAND_TWCHT(n)	((n) << FTIM0_NAND_TWCHT_SHIFT)
+#define FTIM0_NAND_TWH_SHIFT	0
+#define FTIM0_NAND_TWH(n)	((n) << FTIM0_NAND_TWH_SHIFT)
+/*
+ * FTIM1 - NAND Flash Mode
+ */
+#define FTIM1_NAND			0xFFFF3FFF
+#define FTIM1_NAND_TADLE_SHIFT	24
+#define FTIM1_NAND_TADLE(n)	((n) << FTIM1_NAND_TADLE_SHIFT)
+#define FTIM1_NAND_TWBE_SHIFT	16
+#define FTIM1_NAND_TWBE(n)	((n) << FTIM1_NAND_TWBE_SHIFT)
+#define FTIM1_NAND_TRR_SHIFT	8
+#define FTIM1_NAND_TRR(n)	((n) << FTIM1_NAND_TRR_SHIFT)
+#define FTIM1_NAND_TRP_SHIFT	0
+#define FTIM1_NAND_TRP(n)	((n) << FTIM1_NAND_TRP_SHIFT)
+/*
+ * FTIM2 - NAND Flash Mode
+ */
+#define FTIM2_NAND			0x1FE1F8FF
+#define FTIM2_NAND_TRAD_SHIFT	21
+#define FTIM2_NAND_TRAD(n)	((n) << FTIM2_NAND_TRAD_SHIFT)
+#define FTIM2_NAND_TREH_SHIFT	11
+#define FTIM2_NAND_TREH(n)	((n) << FTIM2_NAND_TREH_SHIFT)
+#define FTIM2_NAND_TWHRE_SHIFT	0
+#define FTIM2_NAND_TWHRE(n)	((n) << FTIM2_NAND_TWHRE_SHIFT)
+/*
+ * FTIM3 - NAND Flash Mode
+ */
+#define FTIM3_NAND			0xFF000000
+#define FTIM3_NAND_TWW_SHIFT	24
+#define FTIM3_NAND_TWW(n)	((n) << FTIM3_NAND_TWW_SHIFT)
+
+/*
+ * FTIM0 - NOR Flash Mode
+ */
+#define FTIM0_NOR			0xF03F3F3F
+#define FTIM0_NOR_TACSE_SHIFT	28
+#define FTIM0_NOR_TACSE(n)	((n) << FTIM0_NOR_TACSE_SHIFT)
+#define FTIM0_NOR_TEADC_SHIFT	16
+#define FTIM0_NOR_TEADC(n)	((n) << FTIM0_NOR_TEADC_SHIFT)
+#define FTIM0_NOR_TAVDS_SHIFT	8
+#define FTIM0_NOR_TAVDS(n)	((n) << FTIM0_NOR_TAVDS_SHIFT)
+#define FTIM0_NOR_TEAHC_SHIFT	0
+#define FTIM0_NOR_TEAHC(n)	((n) << FTIM0_NOR_TEAHC_SHIFT)
+/*
+ * FTIM1 - NOR Flash Mode
+ */
+#define FTIM1_NOR			0xFF003F3F
+#define FTIM1_NOR_TACO_SHIFT	24
+#define FTIM1_NOR_TACO(n)	((n) << FTIM1_NOR_TACO_SHIFT)
+#define FTIM1_NOR_TRAD_NOR_SHIFT	8
+#define FTIM1_NOR_TRAD_NOR(n)	((n) << FTIM1_NOR_TRAD_NOR_SHIFT)
+#define FTIM1_NOR_TSEQRAD_NOR_SHIFT	0
+#define FTIM1_NOR_TSEQRAD_NOR(n)	((n) << FTIM1_NOR_TSEQRAD_NOR_SHIFT)
+/*
+ * FTIM2 - NOR Flash Mode
+ */
+#define FTIM2_NOR			0x0F3CFCFF
+#define FTIM2_NOR_TCS_SHIFT		24
+#define FTIM2_NOR_TCS(n)	((n) << FTIM2_NOR_TCS_SHIFT)
+#define FTIM2_NOR_TCH_SHIFT		18
+#define FTIM2_NOR_TCH(n)	((n) << FTIM2_NOR_TCH_SHIFT)
+#define FTIM2_NOR_TWPH_SHIFT	10
+#define FTIM2_NOR_TWPH(n)	((n) << FTIM2_NOR_TWPH_SHIFT)
+#define FTIM2_NOR_TWP_SHIFT		0
+#define FTIM2_NOR_TWP(n)	((n) << FTIM2_NOR_TWP_SHIFT)
+
+/*
+ * FTIM0 - Normal GPCM Mode
+ */
+#define FTIM0_GPCM			0xF03F3F3F
+#define FTIM0_GPCM_TACSE_SHIFT	28
+#define FTIM0_GPCM_TACSE(n)	((n) << FTIM0_GPCM_TACSE_SHIFT)
+#define FTIM0_GPCM_TEADC_SHIFT	16
+#define FTIM0_GPCM_TEADC(n)	((n) << FTIM0_GPCM_TEADC_SHIFT)
+#define FTIM0_GPCM_TAVDS_SHIFT	8
+#define FTIM0_GPCM_TAVDS(n)	((n) << FTIM0_GPCM_TAVDS_SHIFT)
+#define FTIM0_GPCM_TEAHC_SHIFT	0
+#define FTIM0_GPCM_TEAHC(n)	((n) << FTIM0_GPCM_TEAHC_SHIFT)
+/*
+ * FTIM1 - Normal GPCM Mode
+ */
+#define FTIM1_GPCM			0xFF003F00
+#define FTIM1_GPCM_TACO_SHIFT	24
+#define FTIM1_GPCM_TACO(n)	((n) << FTIM1_GPCM_TACO_SHIFT)
+#define FTIM1_GPCM_TRAD_SHIFT	8
+#define FTIM1_GPCM_TRAD(n)	((n) << FTIM1_GPCM_TRAD_SHIFT)
+/*
+ * FTIM2 - Normal GPCM Mode
+ */
+#define FTIM2_GPCM			0x0F3C00FF
+#define FTIM2_GPCM_TCS_SHIFT	24
+#define FTIM2_GPCM_TCS(n)	((n) << FTIM2_GPCM_TCS_SHIFT)
+#define FTIM2_GPCM_TCH_SHIFT	18
+#define FTIM2_GPCM_TCH(n)	((n) << FTIM2_GPCM_TCH_SHIFT)
+#define FTIM2_GPCM_TWP_SHIFT	0
+#define FTIM2_GPCM_TWP(n)	((n) << FTIM2_GPCM_TWP_SHIFT)
+
+/*
+ * Ready Busy Status Register (RB_STAT)
+ */
+/* CSn is READY */
+#define IFC_RB_STAT_READY_CS0		0x80000000
+#define IFC_RB_STAT_READY_CS1		0x40000000
+#define IFC_RB_STAT_READY_CS2		0x20000000
+#define IFC_RB_STAT_READY_CS3		0x10000000
+
+/*
+ * General Control Register (GCR)
+ */
+#define IFC_GCR_MASK			0x8000F800
+/* reset all IFC hardware */
+#define IFC_GCR_SOFT_RST_ALL		0x80000000
+/* Turnaroud Time of external buffer */
+#define IFC_GCR_TBCTL_TRN_TIME		0x0000F800
+#define IFC_GCR_TBCTL_TRN_TIME_SHIFT	11
+
+/*
+ * Common Event and Error Status Register (CM_EVTER_STAT)
+ */
+/* Chip select error */
+#define IFC_CM_EVTER_STAT_CSER		0x80000000
+
+/*
+ * Common Event and Error Enable Register (CM_EVTER_EN)
+ */
+/* Chip select error checking enable */
+#define IFC_CM_EVTER_EN_CSEREN		0x80000000
+
+/*
+ * Common Event and Error Interrupt Enable Register (CM_EVTER_INTR_EN)
+ */
+/* Chip select error interrupt enable */
+#define IFC_CM_EVTER_INTR_EN_CSERIREN	0x80000000
+
+/*
+ * Common Transfer Error Attribute Register-0 (CM_ERATTR0)
+ */
+/* transaction type of error Read/Write */
+#define IFC_CM_ERATTR0_ERTYP_READ	0x80000000
+#define IFC_CM_ERATTR0_ERAID		0x0FF00000
+#define IFC_CM_ERATTR0_ESRCID		0x0000FF00
+
+/*
+ * Clock Control Register (CCR)
+ */
+#define IFC_CCR_MASK			0x0F0F8800
+/* Clock division ratio */
+#define IFC_CCR_CLK_DIV_MASK		0x0F000000
+#define IFC_CCR_CLK_DIV_SHIFT		24
+#define IFC_CCR_CLK_DIV(n)		((n-1) << IFC_CCR_CLK_DIV_SHIFT)
+/* IFC Clock Delay */
+#define IFC_CCR_CLK_DLY_MASK		0x000F0000
+#define IFC_CCR_CLK_DLY_SHIFT		16
+#define IFC_CCR_CLK_DLY(n)		((n) << IFC_CCR_CLK_DLY_SHIFT)
+/* Invert IFC clock before sending out */
+#define IFC_CCR_INV_CLK_EN		0x00008000
+/* Fedback IFC Clock */
+#define IFC_CCR_FB_IFC_CLK_SEL		0x00000800
+
+/*
+ * Clock Status Register (CSR)
+ */
+/* Clk is stable */
+#define IFC_CSR_CLK_STAT_STABLE		0x80000000
+
+/*
+ * IFC_NAND Machine Specific Registers
+ */
+/*
+ * NAND Configuration Register (NCFGR)
+ */
+/* Auto Boot Mode */
+#define IFC_NAND_NCFGR_BOOT		0x80000000
+/* Addressing Mode-ROW0+n/COL0 */
+#define IFC_NAND_NCFGR_ADDR_MODE_RC0	0x00000000
+/* Addressing Mode-ROW0+n/COL0+n */
+#define IFC_NAND_NCFGR_ADDR_MODE_RC1	0x00400000
+/* Number of loop iterations of FIR sequences for multi page operations */
+#define IFC_NAND_NCFGR_NUM_LOOP_MASK	0x0000F000
+#define IFC_NAND_NCFGR_NUM_LOOP_SHIFT	12
+#define IFC_NAND_NCFGR_NUM_LOOP(n)	((n) << IFC_NAND_NCFGR_NUM_LOOP_SHIFT)
+/* Number of wait cycles */
+#define IFC_NAND_NCFGR_NUM_WAIT_MASK	0x000000FF
+#define IFC_NAND_NCFGR_NUM_WAIT_SHIFT	0
+
+/*
+ * NAND Flash Command Registers (NAND_FCR0/NAND_FCR1)
+ */
+/* General purpose FCM flash command bytes CMD0-CMD7 */
+#define IFC_NAND_FCR0_CMD0		0xFF000000
+#define IFC_NAND_FCR0_CMD0_SHIFT	24
+#define IFC_NAND_FCR0_CMD1		0x00FF0000
+#define IFC_NAND_FCR0_CMD1_SHIFT	16
+#define IFC_NAND_FCR0_CMD2		0x0000FF00
+#define IFC_NAND_FCR0_CMD2_SHIFT	8
+#define IFC_NAND_FCR0_CMD3		0x000000FF
+#define IFC_NAND_FCR0_CMD3_SHIFT	0
+#define IFC_NAND_FCR1_CMD4		0xFF000000
+#define IFC_NAND_FCR1_CMD4_SHIFT	24
+#define IFC_NAND_FCR1_CMD5		0x00FF0000
+#define IFC_NAND_FCR1_CMD5_SHIFT	16
+#define IFC_NAND_FCR1_CMD6		0x0000FF00
+#define IFC_NAND_FCR1_CMD6_SHIFT	8
+#define IFC_NAND_FCR1_CMD7		0x000000FF
+#define IFC_NAND_FCR1_CMD7_SHIFT	0
+
+#define FCR_CMD0_SHIFT			24
+
+/*
+ * Flash ROW and COL Address Register (ROWn, COLn)
+ */
+/* Main/spare region locator */
+#define IFC_NAND_COL_MS			0x80000000
+/* Column Address */
+#define IFC_NAND_COL_CA_MASK		0x00000FFF
+
+/*
+ * NAND Flash Byte Count Register (NAND_BC)
+ */
+/* Byte Count for read/Write */
+#define IFC_NAND_BC			0x000001FF
+
+/*
+ * NAND Flash Instruction Registers (NAND_FIR0/NAND_FIR1/NAND_FIR2)
+ */
+/* NAND Machine specific opcodes OP0-OP14*/
+#define IFC_NAND_FIR0_OP0		0xFC000000
+#define IFC_NAND_FIR0_OP0_SHIFT		26
+#define IFC_NAND_FIR0_OP1		0x03F00000
+#define IFC_NAND_FIR0_OP1_SHIFT		20
+#define IFC_NAND_FIR0_OP2		0x000FC000
+#define IFC_NAND_FIR0_OP2_SHIFT		14
+#define IFC_NAND_FIR0_OP3		0x00003F00
+#define IFC_NAND_FIR0_OP3_SHIFT		8
+#define IFC_NAND_FIR0_OP4		0x000000FC
+#define IFC_NAND_FIR0_OP4_SHIFT		2
+#define IFC_NAND_FIR1_OP5		0xFC000000
+#define IFC_NAND_FIR1_OP5_SHIFT		26
+#define IFC_NAND_FIR1_OP6		0x03F00000
+#define IFC_NAND_FIR1_OP6_SHIFT		20
+#define IFC_NAND_FIR1_OP7		0x000FC000
+#define IFC_NAND_FIR1_OP7_SHIFT		14
+#define IFC_NAND_FIR1_OP8		0x00003F00
+#define IFC_NAND_FIR1_OP8_SHIFT		8
+#define IFC_NAND_FIR1_OP9		0x000000FC
+#define IFC_NAND_FIR1_OP9_SHIFT		2
+#define IFC_NAND_FIR2_OP10		0xFC000000
+#define IFC_NAND_FIR2_OP10_SHIFT	26
+#define IFC_NAND_FIR2_OP11		0x03F00000
+#define IFC_NAND_FIR2_OP11_SHIFT	20
+#define IFC_NAND_FIR2_OP12		0x000FC000
+#define IFC_NAND_FIR2_OP12_SHIFT	14
+#define IFC_NAND_FIR2_OP13		0x00003F00
+#define IFC_NAND_FIR2_OP13_SHIFT	8
+#define IFC_NAND_FIR2_OP14		0x000000FC
+#define IFC_NAND_FIR2_OP14_SHIFT	2
+
+
+/*
+ * Instruction opcodes to be programmed
+ * in FIR registers- 6bits
+ */
+enum ifc_nand_fir_opcodes {
+	IFC_FIR_OP_NOP,
+	IFC_FIR_OP_CA0,
+	IFC_FIR_OP_CA1,
+	IFC_FIR_OP_CA2,
+	IFC_FIR_OP_CA3,
+	IFC_FIR_OP_RA0,
+	IFC_FIR_OP_RA1,
+	IFC_FIR_OP_RA2,
+	IFC_FIR_OP_RA3,
+	IFC_FIR_OP_CMD0,
+	IFC_FIR_OP_CMD1,
+	IFC_FIR_OP_CMD2,
+	IFC_FIR_OP_CMD3,
+	IFC_FIR_OP_CMD4,
+	IFC_FIR_OP_CMD5,
+	IFC_FIR_OP_CMD6,
+	IFC_FIR_OP_CMD7,
+	IFC_FIR_OP_CW0,
+	IFC_FIR_OP_CW1,
+	IFC_FIR_OP_CW2,
+	IFC_FIR_OP_CW3,
+	IFC_FIR_OP_CW4,
+	IFC_FIR_OP_CW5,
+	IFC_FIR_OP_CW6,
+	IFC_FIR_OP_CW7,
+	IFC_FIR_OP_WBCD,
+	IFC_FIR_OP_RBCD,
+	IFC_FIR_OP_BTRD,
+	IFC_FIR_OP_RDSTAT,
+	IFC_FIR_OP_NWAIT,
+	IFC_FIR_OP_WFR,
+	IFC_FIR_OP_SBRD,
+	IFC_FIR_OP_UA,
+	IFC_FIR_OP_RB,
+};
+
+/*
+ * NAND Chip Select Register (NAND_CSEL)
+ */
+#define IFC_NAND_CSEL			0x0C000000
+#define IFC_NAND_CSEL_SHIFT		26
+#define IFC_NAND_CSEL_CS0		0x00000000
+#define IFC_NAND_CSEL_CS1		0x04000000
+#define IFC_NAND_CSEL_CS2		0x08000000
+#define IFC_NAND_CSEL_CS3		0x0C000000
+
+/*
+ * NAND Operation Sequence Start (NANDSEQ_STRT)
+ */
+/* NAND Flash Operation Start */
+#define IFC_NAND_SEQ_STRT_FIR_STRT	0x80000000
+/* Automatic Erase */
+#define IFC_NAND_SEQ_STRT_AUTO_ERS	0x00800000
+/* Automatic Program */
+#define IFC_NAND_SEQ_STRT_AUTO_PGM	0x00100000
+/* Automatic Copyback */
+#define IFC_NAND_SEQ_STRT_AUTO_CPB	0x00020000
+/* Automatic Read Operation */
+#define IFC_NAND_SEQ_STRT_AUTO_RD	0x00004000
+/* Automatic Status Read */
+#define IFC_NAND_SEQ_STRT_AUTO_STAT_RD	0x00000800
+
+/*
+ * NAND Event and Error Status Register (NAND_EVTER_STAT)
+ */
+/* Operation Complete */
+#define IFC_NAND_EVTER_STAT_OPC		0x80000000
+/* Flash Timeout Error */
+#define IFC_NAND_EVTER_STAT_FTOER	0x08000000
+/* Write Protect Error */
+#define IFC_NAND_EVTER_STAT_WPER	0x04000000
+/* ECC Error */
+#define IFC_NAND_EVTER_STAT_ECCER	0x02000000
+/* RCW Load Done */
+#define IFC_NAND_EVTER_STAT_RCW_DN	0x00008000
+/* Boot Loadr Done */
+#define IFC_NAND_EVTER_STAT_BOOT_DN	0x00004000
+/* Bad Block Indicator search select */
+#define IFC_NAND_EVTER_STAT_BBI_SRCH_SE	0x00000800
+
+/*
+ * NAND Flash Page Read Completion Event Status Register
+ * (PGRDCMPL_EVT_STAT)
+ */
+#define PGRDCMPL_EVT_STAT_MASK		0xFFFF0000
+/* Small Page 0-15 Done */
+#define PGRDCMPL_EVT_STAT_SECTION_SP(n)	(1 << (31 - (n)))
+/* Large Page(2K) 0-3 Done */
+#define PGRDCMPL_EVT_STAT_LP_2K(n)	(0xF << (28 - (n)*4))
+/* Large Page(4K) 0-1 Done */
+#define PGRDCMPL_EVT_STAT_LP_4K(n)	(0xFF << (24 - (n)*8))
+
+/*
+ * NAND Event and Error Enable Register (NAND_EVTER_EN)
+ */
+/* Operation complete event enable */
+#define IFC_NAND_EVTER_EN_OPC_EN	0x80000000
+/* Page read complete event enable */
+#define IFC_NAND_EVTER_EN_PGRDCMPL_EN	0x20000000
+/* Flash Timeout error enable */
+#define IFC_NAND_EVTER_EN_FTOER_EN	0x08000000
+/* Write Protect error enable */
+#define IFC_NAND_EVTER_EN_WPER_EN	0x04000000
+/* ECC error logging enable */
+#define IFC_NAND_EVTER_EN_ECCER_EN	0x02000000
+
+/*
+ * NAND Event and Error Interrupt Enable Register (NAND_EVTER_INTR_EN)
+ */
+/* Enable interrupt for operation complete */
+#define IFC_NAND_EVTER_INTR_OPCIR_EN		0x80000000
+/* Enable interrupt for Page read complete */
+#define IFC_NAND_EVTER_INTR_PGRDCMPLIR_EN	0x20000000
+/* Enable interrupt for Flash timeout error */
+#define IFC_NAND_EVTER_INTR_FTOERIR_EN		0x08000000
+/* Enable interrupt for Write protect error */
+#define IFC_NAND_EVTER_INTR_WPERIR_EN		0x04000000
+/* Enable interrupt for ECC error*/
+#define IFC_NAND_EVTER_INTR_ECCERIR_EN		0x02000000
+
+/*
+ * NAND Transfer Error Attribute Register-0 (NAND_ERATTR0)
+ */
+#define IFC_NAND_ERATTR0_MASK		0x0C080000
+/* Error on CS0-3 for NAND */
+#define IFC_NAND_ERATTR0_ERCS_CS0	0x00000000
+#define IFC_NAND_ERATTR0_ERCS_CS1	0x04000000
+#define IFC_NAND_ERATTR0_ERCS_CS2	0x08000000
+#define IFC_NAND_ERATTR0_ERCS_CS3	0x0C000000
+/* Transaction type of error Read/Write */
+#define IFC_NAND_ERATTR0_ERTTYPE_READ	0x00080000
+
+/*
+ * NAND Flash Status Register (NAND_FSR)
+ */
+/* First byte of data read from read status op */
+#define IFC_NAND_NFSR_RS0		0xFF000000
+/* Second byte of data read from read status op */
+#define IFC_NAND_NFSR_RS1		0x00FF0000
+
+/*
+ * ECC Error Status Registers (ECCSTAT0-ECCSTAT3)
+ */
+/* Number of ECC errors on sector n (n = 0-15) */
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR0_MASK	0x0F000000
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR0_SHIFT	24
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR1_MASK	0x000F0000
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR1_SHIFT	16
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR2_MASK	0x00000F00
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR2_SHIFT	8
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR3_MASK	0x0000000F
+#define IFC_NAND_ECCSTAT0_ERRCNT_SECTOR3_SHIFT	0
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR4_MASK	0x0F000000
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR4_SHIFT	24
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR5_MASK	0x000F0000
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR5_SHIFT	16
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR6_MASK	0x00000F00
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR6_SHIFT	8
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR7_MASK	0x0000000F
+#define IFC_NAND_ECCSTAT1_ERRCNT_SECTOR7_SHIFT	0
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR8_MASK	0x0F000000
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR8_SHIFT	24
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR9_MASK	0x000F0000
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR9_SHIFT	16
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR10_MASK	0x00000F00
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR10_SHIFT	8
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR11_MASK	0x0000000F
+#define IFC_NAND_ECCSTAT2_ERRCNT_SECTOR11_SHIFT	0
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR12_MASK	0x0F000000
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR12_SHIFT	24
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR13_MASK	0x000F0000
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR13_SHIFT	16
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR14_MASK	0x00000F00
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR14_SHIFT	8
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR15_MASK	0x0000000F
+#define IFC_NAND_ECCSTAT3_ERRCNT_SECTOR15_SHIFT	0
+
+/*
+ * NAND Control Register (NANDCR)
+ */
+#define IFC_NAND_NCR_FTOCNT_MASK	0x1E000000
+#define IFC_NAND_NCR_FTOCNT_SHIFT	25
+#define IFC_NAND_NCR_FTOCNT(n)	((_ilog2(n) - 8)  << IFC_NAND_NCR_FTOCNT_SHIFT)
+
+/*
+ * NAND_AUTOBOOT_TRGR
+ */
+/* Trigger RCW load */
+#define IFC_NAND_AUTOBOOT_TRGR_RCW_LD	0x80000000
+/* Trigget Auto Boot */
+#define IFC_NAND_AUTOBOOT_TRGR_BOOT_LD	0x20000000
+
+/*
+ * NAND_MDR
+ */
+/* 1st read data byte when opcode SBRD */
+#define IFC_NAND_MDR_RDATA0		0xFF000000
+/* 2nd read data byte when opcode SBRD */
+#define IFC_NAND_MDR_RDATA1		0x00FF0000
+
+/*
+ * NOR Machine Specific Registers
+ */
+/*
+ * NOR Event and Error Status Register (NOR_EVTER_STAT)
+ */
+/* NOR Command Sequence Operation Complete */
+#define IFC_NOR_EVTER_STAT_OPC_NOR	0x80000000
+/* Write Protect Error */
+#define IFC_NOR_EVTER_STAT_WPER		0x04000000
+/* Command Sequence Timeout Error */
+#define IFC_NOR_EVTER_STAT_STOER	0x01000000
+
+/*
+ * NOR Event and Error Enable Register (NOR_EVTER_EN)
+ */
+/* NOR Command Seq complete event enable */
+#define IFC_NOR_EVTER_EN_OPCEN_NOR	0x80000000
+/* Write Protect Error Checking Enable */
+#define IFC_NOR_EVTER_EN_WPEREN		0x04000000
+/* Timeout Error Enable */
+#define IFC_NOR_EVTER_EN_STOEREN	0x01000000
+
+/*
+ * NOR Event and Error Interrupt Enable Register (NOR_EVTER_INTR_EN)
+ */
+/* Enable interrupt for OPC complete */
+#define IFC_NOR_EVTER_INTR_OPCEN_NOR	0x80000000
+/* Enable interrupt for write protect error */
+#define IFC_NOR_EVTER_INTR_WPEREN	0x04000000
+/* Enable interrupt for timeout error */
+#define IFC_NOR_EVTER_INTR_STOEREN	0x01000000
+
+/*
+ * NOR Transfer Error Attribute Register-0 (NOR_ERATTR0)
+ */
+/* Source ID for error transaction */
+#define IFC_NOR_ERATTR0_ERSRCID		0xFF000000
+/* AXI ID for error transation */
+#define IFC_NOR_ERATTR0_ERAID		0x000FF000
+/* Chip select corresponds to NOR error */
+#define IFC_NOR_ERATTR0_ERCS_CS0	0x00000000
+#define IFC_NOR_ERATTR0_ERCS_CS1	0x00000010
+#define IFC_NOR_ERATTR0_ERCS_CS2	0x00000020
+#define IFC_NOR_ERATTR0_ERCS_CS3	0x00000030
+/* Type of transaction read/write */
+#define IFC_NOR_ERATTR0_ERTYPE_READ	0x00000001
+
+/*
+ * NOR Transfer Error Attribute Register-2 (NOR_ERATTR2)
+ */
+#define IFC_NOR_ERATTR2_ER_NUM_PHASE_EXP	0x000F0000
+#define IFC_NOR_ERATTR2_ER_NUM_PHASE_PER	0x00000F00
+
+/*
+ * NOR Control Register (NORCR)
+ */
+#define IFC_NORCR_MASK			0x0F0F0000
+/* No. of Address/Data Phase */
+#define IFC_NORCR_NUM_PHASE_MASK	0x0F000000
+#define IFC_NORCR_NUM_PHASE_SHIFT	24
+#define IFC_NORCR_NUM_PHASE(n)	((n-1) << IFC_NORCR_NUM_PHASE_SHIFT)
+/* Sequence Timeout Count */
+#define IFC_NORCR_STOCNT_MASK		0x000F0000
+#define IFC_NORCR_STOCNT_SHIFT		16
+#define IFC_NORCR_STOCNT(n)	((__ilog2(n) - 8) << IFC_NORCR_STOCNT_SHIFT)
+
+/*
+ * GPCM Machine specific registers
+ */
+/*
+ * GPCM Event and Error Status Register (GPCM_EVTER_STAT)
+ */
+/* Timeout error */
+#define IFC_GPCM_EVTER_STAT_TOER	0x04000000
+/* Parity error */
+#define IFC_GPCM_EVTER_STAT_PER		0x01000000
+
+/*
+ * GPCM Event and Error Enable Register (GPCM_EVTER_EN)
+ */
+/* Timeout error enable */
+#define IFC_GPCM_EVTER_EN_TOER_EN	0x04000000
+/* Parity error enable */
+#define IFC_GPCM_EVTER_EN_PER_EN	0x01000000
+
+/*
+ * GPCM Event and Error Interrupt Enable Register (GPCM_EVTER_INTR_EN)
+ */
+/* Enable Interrupt for timeout error */
+#define IFC_GPCM_EEIER_TOERIR_EN	0x04000000
+/* Enable Interrupt for Parity error */
+#define IFC_GPCM_EEIER_PERIR_EN		0x01000000
+
+/*
+ * GPCM Transfer Error Attribute Register-0 (GPCM_ERATTR0)
+ */
+/* Source ID for error transaction */
+#define IFC_GPCM_ERATTR0_ERSRCID	0xFF000000
+/* AXI ID for error transaction */
+#define IFC_GPCM_ERATTR0_ERAID		0x000FF000
+/* Chip select corresponds to GPCM error */
+#define IFC_GPCM_ERATTR0_ERCS_CS0	0x00000000
+#define IFC_GPCM_ERATTR0_ERCS_CS1	0x00000040
+#define IFC_GPCM_ERATTR0_ERCS_CS2	0x00000080
+#define IFC_GPCM_ERATTR0_ERCS_CS3	0x000000C0
+/* Type of transaction read/Write */
+#define IFC_GPCM_ERATTR0_ERTYPE_READ	0x00000001
+
+/*
+ * GPCM Transfer Error Attribute Register-2 (GPCM_ERATTR2)
+ */
+/* On which beat of address/data parity error is observed */
+#define IFC_GPCM_ERATTR2_PERR_BEAT		0x00000C00
+/* Parity Error on byte */
+#define IFC_GPCM_ERATTR2_PERR_BYTE		0x000000F0
+/* Parity Error reported in addr or data phase */
+#define IFC_GPCM_ERATTR2_PERR_DATA_PHASE	0x00000001
+
+/*
+ * GPCM Status Register (GPCM_STAT)
+ */
+#define IFC_GPCM_STAT_BSY		0x80000000  /* GPCM is busy */
+
+
+#ifndef __ASSEMBLY__
+#include <asm/io.h>
+
+extern void print_ifc_regs(void);
+extern void init_early_memctl_regs(void);
+
+#define IFC_BASE_ADDR (struct fsl_ifc *)(CONFIG_SYS_IFC_ADDR)
+
+#define get_ifc_cspr(i) (in_be32(&(IFC_BASE_ADDR)->cspr_cs[i].cspr))
+#define get_ifc_csor(i) (in_be32(&(IFC_BASE_ADDR)->csor_cs[i].csor))
+#define get_ifc_amask(i) (in_be32(&(IFC_BASE_ADDR)->amask_cs[i].amask))
+#define get_ifc_ftim(i, j) (in_be32(&(IFC_BASE_ADDR)->ftim_cs[i].ftim[j]))
+
+#define set_ifc_cspr(i, v) (out_be32(&(IFC_BASE_ADDR)->cspr_cs[i].cspr, v))
+#define set_ifc_csor(i, v) (out_be32(&(IFC_BASE_ADDR)->csor_cs[i].csor, v))
+#define set_ifc_amask(i, v) (out_be32(&(IFC_BASE_ADDR)->amask_cs[i].amask, v))
+#define set_ifc_ftim(i, j, v) \
+			(out_be32(&(IFC_BASE_ADDR)->ftim_cs[i].ftim[j], v))
+
+#define FSL_IFC_BANK_COUNT	4
+
+enum ifc_chip_sel {
+	IFC_CS0,
+	IFC_CS1,
+	IFC_CS2,
+	IFC_CS3,
+};
+
+enum ifc_ftims {
+	IFC_FTIM0,
+	IFC_FTIM1,
+	IFC_FTIM2,
+	IFC_FTIM3,
+};
+
+/*
+ * IFC Controller NAND Machine registers
+ */
+struct fsl_ifc_nand {
+	u32 ncfgr;
+	u32 res1[0x4];
+	u32 nand_fcr0;
+	u32 nand_fcr1;
+	u32 res2[0x8];
+	u32 row0;
+	u32 res3;
+	u32 col0;
+	u32 res4;
+	u32 row1;
+	u32 res5;
+	u32 col1;
+	u32 res6;
+	u32 row2;
+	u32 res7;
+	u32 col2;
+	u32 res8;
+	u32 row3;
+	u32 res9;
+	u32 col3;
+	u32 res10[0x24];
+	u32 nand_fbcr;
+	u32 res11;
+	u32 nand_fir0;
+	u32 nand_fir1;
+	u32 nand_fir2;
+	u32 res12[0x10];
+	u32 nand_csel;
+	u32 res13;
+	u32 nandseq_strt;
+	u32 res14;
+	u32 nand_evter_stat;
+	u32 res15;
+	u32 pgrdcmpl_evt_stat;
+	u32 res16[0x2];
+	u32 nand_evter_en;
+	u32 res17[0x2];
+	u32 nand_evter_intr_en;
+	u32 res18[0x2];
+	u32 nand_erattr0;
+	u32 nand_erattr1;
+	u32 res19[0x10];
+	u32 nand_fsr;
+	u32 res20;
+	u32 nand_eccstat[4];
+	u32 res21[0x20];
+	u32 nanndcr;
+	u32 res22[0x2];
+	u32 nand_autoboot_trgr;
+	u32 res23;
+	u32 nand_mdr;
+	u32 res24[0x5C];
+};
+
+/*
+ * IFC controller NOR Machine registers
+ */
+struct fsl_ifc_nor {
+	u32 nor_evter_stat;
+	u32 res1[0x2];
+	u32 nor_evter_en;
+	u32 res2[0x2];
+	u32 nor_evter_intr_en;
+	u32 res3[0x2];
+	u32 nor_erattr0;
+	u32 nor_erattr1;
+	u32 nor_erattr2;
+	u32 res4[0x4];
+	u32 norcr;
+	u32 res5[0xEF];
+};
+
+/*
+ * IFC controller GPCM Machine registers
+ */
+struct fsl_ifc_gpcm {
+	u32 gpcm_evter_stat;
+	u32 res1[0x2];
+	u32 gpcm_evter_en;
+	u32 res2[0x2];
+	u32 gpcm_evter_intr_en;
+	u32 res3[0x2];
+	u32 gpcm_erattr0;
+	u32 gpcm_erattr1;
+	u32 gpcm_erattr2;
+	u32 gpcm_stat;
+	u32 res4[0x1F3];
+};
+
+
+/*
+ * IFC Controller Registers
+ */
+struct fsl_ifc {
+	u32 ifc_rev;
+	u32 res1[0x3];
+	struct {
+		u32 cspr;
+		u32 res2[0x2];
+	} cspr_cs[FSL_IFC_BANK_COUNT];
+	u32 res3[0x18];
+	struct {
+		u32 amask;
+		u32 res4[0x2];
+	} amask_cs[FSL_IFC_BANK_COUNT];
+	u32 res5[0x18];
+	struct {
+		u32 csor;
+		u32 res6[0x2];
+	} csor_cs[FSL_IFC_BANK_COUNT];
+	u32 res7[0x18];
+	struct {
+		u32 ftim[4];
+		u32 res8[0x8];
+	} ftim_cs[FSL_IFC_BANK_COUNT];
+	u32 res9[0x60];
+	u32 rb_stat;
+	u32 res10[0x2];
+	u32 ifc_gcr;
+	u32 res11[0x2];
+	u32 cm_evter_stat;
+	u32 res12[0x2];
+	u32 cm_evter_en;
+	u32 res13[0x2];
+	u32 cm_evter_intr_en;
+	u32 res14[0x2];
+	u32 cm_erattr0;
+	u32 cm_erattr1;
+	u32 res15[0x2];
+	u32 ifc_ccr;
+	u32 ifc_csr;
+	u32 res16[0x2EB];
+	struct fsl_ifc_nand ifc_nand;
+	struct fsl_ifc_nor ifc_nor;
+	struct fsl_ifc_gpcm ifc_gpcm;
+};
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_IFC_A002769
+#undef CSPR_MSEL_NOR
+#define CSPR_MSEL_NOR	CSPR_MSEL_GPCM
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __ASM_PPC_FSL_IFC_H */
--- u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/fsl_ifc.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/arch/powerpc/cpu/mpc8xxx/fsl_ifc.c	2022-05-09 14:05:10.916080844 -0700
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ * Author: Dipen Dudhat <dipen.dudhat@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_ifc.h>
+
+void print_ifc_regs(void)
+{
+	int i, j;
+
+	printf("IFC Controller Registers\n");
+	for (i = 0; i < FSL_IFC_BANK_COUNT; i++) {
+		printf("CSPR%d:0x%08X\tAMASK%d:0x%08X\tCSOR%d:0x%08X\n",
+			i, get_ifc_cspr(i), i, get_ifc_amask(i),
+			i, get_ifc_csor(i));
+		for (j = 0; j < 4; j++)
+			printf("IFC_FTIM%d:0x%08X\n", j, get_ifc_ftim(i, j));
+	}
+}
+
+void init_early_memctl_regs(void)
+{
+#if defined(CONFIG_SYS_CSPR0) && defined(CONFIG_SYS_CSOR0)
+	set_ifc_ftim(IFC_CS0, IFC_FTIM0, CONFIG_SYS_CS0_FTIM0);
+	set_ifc_ftim(IFC_CS0, IFC_FTIM1, CONFIG_SYS_CS0_FTIM1);
+	set_ifc_ftim(IFC_CS0, IFC_FTIM2, CONFIG_SYS_CS0_FTIM2);
+	set_ifc_ftim(IFC_CS0, IFC_FTIM3, CONFIG_SYS_CS0_FTIM3);
+
+#if !defined(CONFIG_SYS_FSL_ERRATUM_IFC_A003399) || defined(CONFIG_SYS_RAMBOOT)
+	set_ifc_cspr(IFC_CS0, CONFIG_SYS_CSPR0);
+	set_ifc_amask(IFC_CS0, CONFIG_SYS_AMASK0);
+	set_ifc_csor(IFC_CS0, CONFIG_SYS_CSOR0);
+#endif
+#endif
+
+#if defined(CONFIG_SYS_CSPR1) && defined(CONFIG_SYS_CSOR1)
+	set_ifc_ftim(IFC_CS1, IFC_FTIM0, CONFIG_SYS_CS1_FTIM0);
+	set_ifc_ftim(IFC_CS1, IFC_FTIM1, CONFIG_SYS_CS1_FTIM1);
+	set_ifc_ftim(IFC_CS1, IFC_FTIM2, CONFIG_SYS_CS1_FTIM2);
+	set_ifc_ftim(IFC_CS1, IFC_FTIM3, CONFIG_SYS_CS1_FTIM3);
+
+	set_ifc_csor(IFC_CS1, CONFIG_SYS_CSOR1);
+	set_ifc_amask(IFC_CS1, CONFIG_SYS_AMASK1);
+	set_ifc_cspr(IFC_CS1, CONFIG_SYS_CSPR1);
+#endif
+
+#if defined(CONFIG_SYS_CSPR2) && defined(CONFIG_SYS_CSOR2)
+	set_ifc_ftim(IFC_CS2, IFC_FTIM0, CONFIG_SYS_CS2_FTIM0);
+	set_ifc_ftim(IFC_CS2, IFC_FTIM1, CONFIG_SYS_CS2_FTIM1);
+	set_ifc_ftim(IFC_CS2, IFC_FTIM2, CONFIG_SYS_CS2_FTIM2);
+	set_ifc_ftim(IFC_CS2, IFC_FTIM3, CONFIG_SYS_CS2_FTIM3);
+
+	set_ifc_csor(IFC_CS2, CONFIG_SYS_CSOR2);
+	set_ifc_amask(IFC_CS2, CONFIG_SYS_AMASK2);
+	set_ifc_cspr(IFC_CS2, CONFIG_SYS_CSPR2);
+#endif
+
+#if defined(CONFIG_SYS_CSPR3) && defined(CONFIG_SYS_CSOR3)
+	set_ifc_ftim(IFC_CS3, IFC_FTIM0, CONFIG_SYS_CS3_FTIM0);
+	set_ifc_ftim(IFC_CS3, IFC_FTIM1, CONFIG_SYS_CS3_FTIM1);
+	set_ifc_ftim(IFC_CS3, IFC_FTIM2, CONFIG_SYS_CS3_FTIM2);
+	set_ifc_ftim(IFC_CS3, IFC_FTIM3, CONFIG_SYS_CS3_FTIM3);
+
+	set_ifc_cspr(IFC_CS3, CONFIG_SYS_CSPR3);
+	set_ifc_amask(IFC_CS3, CONFIG_SYS_AMASK3);
+	set_ifc_csor(IFC_CS3, CONFIG_SYS_CSOR3);
+#endif
+}
--- u-boot-2011.03/arch/powerpc/cpu/mpc85xx/p1010_serdes.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/arch/powerpc/cpu/mpc85xx/p1010_serdes.c	2022-05-09 14:05:10.904081331 -0700
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ * Author: Prabhakar Kushwaha <prabhakar@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <config.h>
+#include <common.h>
+#include <asm/io.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_serdes.h>
+
+#define SRDS1_MAX_LANES		4
+#define SRDS2_MAX_LANES		2
+
+static u32 serdes1_prtcl_map, serdes2_prtcl_map;
+
+static const u8 serdes1_cfg_tbl[][SRDS1_MAX_LANES] = {
+	[0x00] = {NONE, NONE, NONE, NONE},
+	[0x01] = {PCIE1, PCIE2, SGMII_TSEC2, SGMII_TSEC3},
+	[0x02] = {PCIE1, SGMII_TSEC1, SGMII_TSEC2, SGMII_TSEC3},
+	[0x03] = {NONE, SGMII_TSEC1, SGMII_TSEC2, SGMII_TSEC3},
+};
+
+static const u8 serdes2_cfg_tbl[][SRDS2_MAX_LANES] = {
+	[0x00] = {NONE, NONE},
+	[0x01] = {SATA1, SATA2},
+	[0x02] = {SATA1, SATA2},
+	[0x03] = {PCIE1, PCIE2},
+};
+
+
+int is_serdes_configured(enum srds_prtcl device)
+{
+	int ret = (1 << device) & serdes1_prtcl_map;
+
+
+	if (ret)
+		return ret;
+
+	return (1 << device) & serdes2_prtcl_map;
+}
+
+void fsl_serdes_init(void)
+{
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+	u32 pordevsr = in_be32(&gur->pordevsr);
+	u32 srds_cfg = (pordevsr & MPC85xx_PORDEVSR_IO_SEL) >>
+				MPC85xx_PORDEVSR_IO_SEL_SHIFT;
+	int lane;
+
+	debug("PORDEVSR[IO_SEL_SRDS] = %x\n", srds_cfg);
+
+	/*
+	printf("PORDEVSR[IO_SEL_SRDS] = %x, srds_cfg=%x\n", pordevsr, srds_cfg);
+	*/
+
+	if (srds_cfg > ARRAY_SIZE(serdes1_cfg_tbl)) {
+		printf("Invalid PORDEVSR[IO_SEL_SRDS] = %d\n", srds_cfg);
+		return;
+	}
+	for (lane = 0; lane < SRDS1_MAX_LANES; lane++) {
+		enum srds_prtcl lane_prtcl = serdes1_cfg_tbl[srds_cfg][lane];
+		serdes1_prtcl_map |= (1 << lane_prtcl);
+	}
+
+	if (srds_cfg > ARRAY_SIZE(serdes2_cfg_tbl)) {
+		printf("Invalid PORDEVSR[IO_SEL_SRDS] = %d\n", srds_cfg);
+		return;
+	}
+
+	for (lane = 0; lane < SRDS2_MAX_LANES; lane++) {
+		enum srds_prtcl lane_prtcl = serdes2_cfg_tbl[srds_cfg][lane];
+		serdes2_prtcl_map |= (1 << lane_prtcl);
+	}
+}
--- u-boot-2011.03/sc_mfg_standalone/ram_test_random.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/ram_test_random.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,31 @@
+/* concatenation of following two 16-bit multiply with carry generators */
+/* x(n)=a*x(n-1)+carry mod 2^16 and y(n)=b*y(n-1)+carry mod 2^16,	*/
+/* number and carry packed within the same 32 bit integer.		*/
+/************************************************************************/
+
+unsigned int rand(void);	/* returns a random 32-bit integer */
+void rand_seed(unsigned int, unsigned int);	/* seed the generator */
+
+/* return a random float >= 0 and < 1 */
+#define rand_float	((double)rand() / 4294967296.0)
+
+static unsigned int SEED_X = 521288629;
+static unsigned int SEED_Y = 362436069;
+
+
+unsigned int rand (void)
+{
+	static unsigned int a = 18000, b = 30903;
+
+	SEED_X = a*(SEED_X&65535) + (SEED_X>>16);
+	SEED_Y = b*(SEED_Y&65535) + (SEED_Y>>16);
+
+	return ((SEED_X<<16) + (SEED_Y&65535));
+}
+
+
+void rand_seed (unsigned int seed1, unsigned int seed2)
+{
+	if (seed1) SEED_X = seed1; /* use default seeds if parameter is 0 */
+	if (seed2) SEED_Y = seed2;
+}
--- u-boot-2011.03/sc_mfg_standalone/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/Makefile	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,84 @@
+include $(TOPDIR)/config.mk
+
+ELF-$(ARCH)  :=
+ELF-$(BOARD) :=
+ELF-$(CPU)   :=
+ELF-y        := sc_do_mfg
+
+
+ELF := $(strip $(ELF-y) $(ELF-$(ARCH)) $(ELF-$(BOARD)) $(ELF-$(CPU)))
+
+SREC = $(addsuffix .srec,$(ELF))
+BIN  = $(addsuffix .bin,$(ELF))
+
+COBJS	:= $(ELF:=.o)
+
+LIB	= $(obj)libstubs.a
+
+LIBAOBJS-$(ARCH)     :=
+LIBAOBJS-$(CPU)      :=
+LIBAOBJS-powerpc     += $(ARCH)_longjmp.o $(ARCH)_setjmp.o
+#LIBAOBJS-mpc8xx      += test_burst_lib.o
+LIBAOBJS := $(LIBAOBJS-$(ARCH)) $(LIBAOBJS-$(CPU))
+
+LIBCOBJS = stubs.o
+###############################
+# Sercomm C OBJs
+###############################
+# LED
+LIBCOBJS += led_test.o
+# NAND
+LIBCOBJS += nand_test.o
+# NOR
+LIBCOBJS += nor_test.o
+# DRAM
+LIBCOBJS += ram_test_port.o ram_test_error.o ram_test_main.o ram_test_random.o ram_test_algo.o
+# RTC
+LIBCOBJS += rtc_test.o
+# MAIN
+LIBCOBJS += sc_mfg_results.o
+
+
+
+LIBOBJS	= $(addprefix $(obj),$(LIBAOBJS) $(LIBCOBJS))
+
+SRCS	:= $(COBJS:.o=.c) $(LIBCOBJS:.o=.c) $(LIBAOBJS:.o=.S)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+ELF	:= $(addprefix $(obj),$(ELF))
+BIN	:= $(addprefix $(obj),$(BIN))
+SREC	:= $(addprefix $(obj),$(SREC))
+
+gcclibdir := $(shell dirname `$(CC) -print-libgcc-file-name`)
+
+CPPFLAGS += -I..
+
+CFLAGS += -I.
+
+all:	$(obj).depend $(OBJS) $(LIB) $(obj)sc_do_mfg.srec $(obj)sc_do_mfg.bin $(obj)sc_do_mfg
+
+#########################################################################
+$(LIB):	$(obj).depend $(LIBOBJS)
+		$(AR) $(ARFLAGS) $@ $(LIBOBJS)
+
+$(ELF):
+$(obj)%:	$(obj)%.o $(LIB)
+		$(LD) -g -Ttext $(STANDALONE_LOAD_ADDR) \
+			-o $@ -e $(SYM_PREFIX)$(notdir $(<:.o=)) $< $(LIB) \
+			-L$(gcclibdir) -lgcc
+
+$(SREC):
+$(obj)%.srec:	$(obj)%
+		$(OBJCOPY) -O srec $< $@ 2>/dev/null
+
+$(BIN):
+$(obj)%.bin:	$(obj)%
+		$(OBJCOPY) -O binary $< $@ 2>/dev/null
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- u-boot-2011.03/sc_mfg_standalone/nand_test.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/nand_test.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,200 @@
+/***********************************************************************
+ * 			NewCastle Uboot Test Software Version 1.0      *
+ ***********************************************************************
+ * Module	: Nand Test					       *
+ ***********************************************************************/
+
+/*
+ * Header File
+ */
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <linux/mtd/mtd.h>
+#include <command.h>
+#include <watchdog.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+#include <jffs2/jffs2.h>
+#include <nand.h>
+
+#include "sc_mfg.h"
+
+int BadBlockNumStore[TEST_RESULT_BUF_LEN];
+unsigned char BLK_BUF[NAND_BLK_SIZE];
+
+int Nand_Flash_Check(unsigned short blk_num, int test_mode)
+{
+	unsigned int offset;
+	unsigned int length;
+	int ret = 0;
+	int result = 0;
+	unsigned char tmp_buf[NAND_BLK_SIZE];
+	//int ok_block_count = 0;
+
+	/* nand info */
+	nand_info_t *nand = sc_get_nand_info_ptr();
+	/* erase opt */
+	nand_erase_options_t erase_opt;
+
+	memset(&erase_opt, 0, sizeof(erase_opt));    
+
+	/* fill erase info */
+	erase_opt.length = NAND_BLK_SIZE;
+	erase_opt.offset = blk_num * NAND_BLK_SIZE;
+	erase_opt.quiet  = test_mode;
+	erase_opt.jffs2  = 0;
+	erase_opt.scrub  = 0;
+
+	offset = blk_num * NAND_BLK_SIZE;
+	length = NAND_BLK_SIZE;
+
+	if (nand_erase_opts(nand, &erase_opt)) {
+		printf("Erase is Failed  \n");
+		return SC_MFG_TEST_OP_FAIL;    
+	}
+
+	/* fill buffer with certain pattern */
+	memset(BLK_BUF, NAND_FLASH_TEST_DATA, NAND_BLK_SIZE);
+
+	// using jffs2, not yaffs
+	if(nand_write_skip_bad(nand, offset, &length, BLK_BUF, 0)) {
+		result = -1;
+		goto check_result;
+	}
+
+	if(nand_read_skip_bad(nand, offset, &length, tmp_buf)) {
+		result = -1;
+		goto check_result;
+	}
+
+	if(memcmp(tmp_buf, BLK_BUF, NAND_BLK_SIZE)) {
+		result = -1;
+		goto check_result;
+	}
+
+check_result:	
+	if (!result) {
+		printf("(blcok:%d)...is ok \n", blk_num);
+	}
+	else {
+		printf("(blcok:%d) is Bad \n", blk_num);
+		ret = SC_MFG_TEST_OP_FAIL;
+		goto check_final;
+	}
+
+	if (nand_erase_opts(nand, &erase_opt)) {
+		printf("Erase is Failed  \n");
+		ret = SC_MFG_TEST_OP_FAIL;    
+		goto check_final;
+	}
+	else {
+		ret = SC_MFG_TEST_OP_PASS;
+		goto check_final;
+	}
+check_final:
+	return ret;
+}
+
+int Nand_Flash_Test(int test_mode)
+{
+	int __attribute__((unused)) i = 0;
+
+	/* nand info */
+	nand_info_t *nand = sc_get_nand_info_ptr();;
+
+	int BadBlockNum = 0;
+	int Block_Test_Num;
+
+	unsigned int offset = 0;
+
+	int ret = 0;
+
+	int Nand_Flash_Check_state;
+    
+	for (i=0; i<NAND_TOTAL_BLK; i++)
+	{
+		offset = i*NAND_BLK_SIZE;
+
+		if (nand_block_isbad(nand, offset)) {
+			printf("********Bad Block Found at %d*******\n", i);
+			BadBlockNumStore[BadBlockNum] = i;
+			BadBlockNum++;
+		}
+	}
+
+	printf("Bad Blocks Num is: %d\n", BadBlockNum);
+
+	if (BadBlockNum > MAX_BADBLK_ALLOW) {
+		printf("There are too many bad blocks to allow the test to pass \n");
+		printf(" NAND Flash Test \n");
+		printf(" FAIL \n");
+		memcpy(test_result, TEST_NAND_FAIL_STR, sizeof(TEST_NAND_FAIL_STR));
+		test_result[TEST_RESULT_OFF] = NAND_FLASH_FAIL;
+
+		set_result_state = Set_Test_Result( test_result, NAND_FLASH_TEST_ITEM );
+		if (set_result_state) {
+			printf("write the NAND_FLASH_TEST (fail) is fail \n");
+			ret = SC_MFG_TEST_OP_FAIL;
+			goto test_final;
+		}
+		else {
+			printf("write the NAND_FLASH_TEST (fail) is OK \n");
+			ret = SC_MFG_TEST_OP_FAIL;
+			goto test_final;
+		}
+	} /* bad block check is over */
+	for (Block_Test_Num = NAND_TEST_START_BLK; Block_Test_Num <= NAND_TEST_END_BLK; Block_Test_Num++)
+	{
+		/* skip bad block */
+		for (i=0; i<BadBlockNum; i++)
+		{
+			if (BadBlockNumStore[i] == Block_Test_Num) {
+				Block_Test_Num = Block_Test_Num+1;
+				if(Block_Test_Num == NAND_TEST_END_BLK) {
+					Nand_Flash_Check_state = SC_MFG_TEST_OP_PASS;
+					goto done;
+				}
+			}
+		}
+		Nand_Flash_Check_state = Nand_Flash_Check( Block_Test_Num , test_mode);
+done:
+		if (Nand_Flash_Check_state == SC_MFG_TEST_OP_FAIL) {
+			printf(" NAND Flash Test \n");
+			printf(" FAIL \n");
+			memcpy(test_result, TEST_NAND_FAIL_STR, sizeof(TEST_NAND_FAIL_STR));
+			test_result[TEST_RESULT_OFF] = NAND_FLASH_FAIL;
+			set_result_state=Set_Test_Result( test_result, NAND_FLASH_TEST_ITEM );
+			if (set_result_state) {
+				printf("write the NAND_FLASH_TEST (fail) is fail \n");
+				ret = SC_MFG_TEST_OP_FAIL;
+				goto test_final;
+			} 
+			else {
+				printf("write the NAND_FLASH_TEST (fail) is OK \n");
+				ret = SC_MFG_TEST_OP_FAIL;
+				goto test_final;
+			}
+		}
+		if ((Block_Test_Num==NAND_TEST_END_BLK-1)||(Block_Test_Num==NAND_TEST_END_BLK)) {
+			printf(" NAND Flash Test \n");
+			printf(" PASS \n");
+			memcpy(test_result, TEST_NAND_PASS_STR, sizeof(TEST_NAND_PASS_STR));
+			test_result[TEST_RESULT_OFF] = NAND_FLASH_PASS;
+			set_result_state=Set_Test_Result( test_result, NAND_FLASH_TEST_ITEM );
+			if (set_result_state) {
+				printf("write the NAND_FLASH_TEST (OK) is fail \n");
+				ret = SC_MFG_TEST_OP_FAIL;
+				goto test_final;
+			}
+			else {
+				printf("write the NAND_FLASH_TEST (OK) is OK \n");
+				ret = SC_MFG_TEST_OP_PASS;
+				goto test_final;
+			}
+		}
+	}
+test_final:
+	return ret;
+}
--- u-boot-2011.03/sc_mfg_standalone/sc_mfg_results.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/sc_mfg_results.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,275 @@
+/*
+ * Header Files
+ */
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <exports.h>
+
+#include "sc_mfg.h"
+/*
+ * Global Variables For Test Results
+ */
+char test_result[TEST_RESULT_BUF_LEN];		/* test result, as string */
+int set_result_state;
+
+/*--------------------------------------------------------------------*/
+/*
+ * U_BOOT_CMD definition list for sc_mfg_test
+ */
+
+int do_sc_mfg_led (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int ret = Led_Test();
+	return ret;
+}
+
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_dram (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int ret = Ram_Test();
+	return ret;
+}
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_nor_fill (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int ret = Fill_NOR_Flash(NOR_FLASH_TEST_DATA);
+
+	return ret;
+}
+
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_nor (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int ret = Check_NOR_Flash(NOR_FLASH_TEST_DATA);
+
+	return ret;
+}
+
+
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_nand (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int ret = Nand_Flash_Test(TEST_QUIET);
+	return ret;
+}
+
+
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_rtc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int ret = RTC_Test();
+	return ret;
+}
+
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_pci (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	/* BUS 1 */
+	pciinfo(1, 1);
+	/* BUS 2 */
+	pciinfo(2, 1);
+
+	return 0;
+}
+
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_read_results (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	Read_Test_Result();
+	return 0;
+}
+
+/*--------------------------------------------------------------------*/
+int Set_Test_Result( char *test_result, int test_item )
+{
+	unsigned char block_buffer_result[BLOCK_SIZE];
+	unsigned char *buf_pos = NULL;
+	unsigned int sector_base;
+	
+	sector_base = TEST_RESULT_OFFSET & (~(BLOCK_SIZE-1));
+
+	/* Copy Test Result resident block content out */
+	memcpy(block_buffer_result, (unsigned char *) (FLASH_ADDR_BASE + sector_base), BLOCK_SIZE);
+	
+	switch(test_item){
+	case NAND_FLASH_TEST_ITEM:
+		buf_pos = block_buffer_result + TEST_ITEM_NAND_OFFSET + (TEST_RESULT_OFFSET - sector_base);
+		break;
+	case NOR_FLASH_TEST_ITEM:
+		buf_pos = block_buffer_result + TEST_ITEM_NOR_OFFSET + (TEST_RESULT_OFFSET - sector_base);
+		break;
+	case RTC_TEST_ITEM:
+		buf_pos = block_buffer_result + TEST_ITEM_RTC_OFFSET + (TEST_RESULT_OFFSET - sector_base);
+		break;
+	case LED_TEST_ITEM:
+		buf_pos = block_buffer_result + TEST_ITEM_LED_OFFSET + (TEST_RESULT_OFFSET - sector_base);
+		break;
+	case DRAM_TEST_ITEM:
+		buf_pos = block_buffer_result + TEST_ITEM_RAM_OFFSET + (TEST_RESULT_OFFSET - sector_base);
+		break;
+	case PCI_TEST_ITEM:
+		buf_pos = block_buffer_result + TEST_ITEM_PCI_OFFSET + (TEST_RESULT_OFFSET - sector_base);
+		break;
+	default:
+		printf("Error: Wrong Test Item...\n");
+		return SC_MFG_TEST_OP_FAIL; 
+	}
+	/* Overwrite test result to corresponding position in buffer */
+	memcpy(buf_pos, test_result, TEST_RESULT_BUF_LEN);
+	
+	printf("Erasing eeprom...\n");
+
+	if(sc_flash_erase(FLASH_ADDR_BASE + sector_base, BLOCK_SIZE) != FLASH_OP_OK)
+	{
+		printf("Error erasing at %x\n", (FLASH_ADDR_BASE + sector_base));
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("done\nPrograming ...");
+
+	if(sc_flash_program(FLASH_ADDR_BASE + sector_base, (void *) block_buffer_result, BLOCK_SIZE) != FLASH_OP_OK) {
+		printf("Can't program region at %x\n", FLASH_ADDR_BASE + sector_base);
+		return SC_MFG_TEST_OP_FAIL;
+	}
+	udelay(1000000);
+	printf("done\n");
+	return SC_MFG_TEST_OP_PASS;
+}
+
+void Read_Test_Result(void)
+{
+	unsigned char * p_test_result_flag;
+	unsigned char test_result_flag;
+
+	int idx = -1;	
+	unsigned int dram_err_address = 0;
+	int dram_err_type = -1;
+	char dram_err_chipmsk = 0;
+	int i=0;
+
+	/*
+ 	 * NAND Flash Test Flag
+ 	 */
+	p_test_result_flag = (unsigned char *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_NAND_OFFSET + TEST_RESULT_OFF);
+	test_result_flag = *p_test_result_flag;
+	
+	printf("NAND Flash Test Flag: %d\n", test_result_flag);
+
+	printf(" NAND Flash Test \n");
+
+	if (test_result_flag == NAND_FLASH_PASS)
+		printf(" PASS \n");
+	else if (test_result_flag == NAND_FLASH_FAIL)
+		printf(" FAIL \n");
+	else
+		printf(" UNKNOWN \n");
+		
+	/*
+	 * NOR Flash Test Flag
+	 */
+	p_test_result_flag = (unsigned char *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_NOR_OFFSET + TEST_RESULT_OFF);
+	test_result_flag = *p_test_result_flag;
+
+	printf("NOR Flash Test Flag: %d\n", test_result_flag);
+
+	printf(" NOR Flash Test \n");
+
+	if (test_result_flag == NOR_FLASH_PASS)
+		printf(" PASS \n");
+	else if (test_result_flag == NOR_FLASH_FAIL)
+		printf(" FAIL \n");
+	else
+		printf(" UNKNOWN \n");
+
+	/*
+	* LED Test Flag
+	*/
+	p_test_result_flag = (unsigned char *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_LED_OFFSET + TEST_RESULT_OFF);
+	test_result_flag   = *p_test_result_flag;
+
+	printf("LED Test Flag: %d\n", test_result_flag);
+
+	printf(" LED Test \n");
+
+	if (test_result_flag == LED_TEST_PASS)
+		printf(" PASS \n");
+	else if (test_result_flag == LED_TEST_FAIL)
+		printf(" FAIL \n");
+	else
+		printf(" UNKNOWN \n");
+
+	/*
+	* RTC Test Flag
+	*/
+	p_test_result_flag = (unsigned char *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_RTC_OFFSET + TEST_RESULT_OFF);
+	test_result_flag   = *p_test_result_flag;
+
+	printf("RTC Test Flag: %d\n", test_result_flag);
+
+	printf(" RTC Test \n");
+
+	if (test_result_flag == RTC_TEST_PASS)
+		printf(" PASS \n");
+	else if (test_result_flag == RTC_TEST_FAIL)
+		printf(" FAIL \n");
+	else
+		printf(" UNKNOWN \n");
+
+	/*
+	* PCI Test Flag
+	*/
+	p_test_result_flag = (unsigned char *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_PCI_OFFSET + TEST_RESULT_OFF);
+	test_result_flag   = *p_test_result_flag;
+
+	printf("PCI Test Flag: %d\n", test_result_flag);
+
+	printf(" PCI Test \n");
+
+	if (test_result_flag == PCI_TEST_PASS)
+		printf(" PASS \n");
+	else if (test_result_flag == PCI_TEST_FAIL)
+		printf(" FAIL \n");
+	else
+		printf(" UNKNOWN \n");
+
+	/*
+	* DRAM Test Flag
+	*/
+	p_test_result_flag = (unsigned char *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_RAM_OFFSET + TEST_RESULT_OFF);
+	test_result_flag   = *p_test_result_flag;
+	dram_err_address = *(unsigned int *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_RAM_OFFSET + DRAM_TEST_ERR_ADDR);
+	dram_err_type = *(int *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_RAM_OFFSET + DRAM_TEST_ERR_TYPE);
+	dram_err_chipmsk = *(char *)(FLASH_ADDR_BASE + TEST_RESULT_OFFSET + TEST_ITEM_RAM_OFFSET + DRAM_TEST_ERR_CHIP);
+ 
+	printf("DRAM Test Flag: %d\n", test_result_flag);
+
+	if(test_result_flag == DRAM_TEST_OK) {
+		printf(" DRAM Test Pass \n");
+	} else {
+		printf(" DRAM Test Fail \n");
+		idx = find_ram_test_item(test_result_flag);
+		if (idx != -1)
+			printf("%s", tseq[idx].msg);
+		else
+			printf(" UNKNOWN \n");
+
+		printf(" : Address: %x, Type %x, Bad Chip Mask %x \n",\
+				dram_err_address, dram_err_type, dram_err_chipmsk);	
+
+		for(; i<4; i++) {
+			if((dram_err_chipmsk >> i) & 0x1)
+				printf(" Please Replace DRAM Chip U%d\n", (i+4));
+		}
+ 	}
+}
+
+/* eof */
--- u-boot-2011.03/sc_mfg_standalone/led_test.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/led_test.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,193 @@
+/***********************************************************************
+ * 			NewCastle Uboot Test Software Version 1.0      *
+ ***********************************************************************
+ * Module	: LED Test					       *
+ ***********************************************************************/
+
+/*
+ * Header File
+ */
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include "sc_mfg.h"
+
+/*
+ * Init gpio for led & button
+ */
+void sc_led_init(void)
+{
+	unsigned int reg_val;
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	reg_val = pgpio->gpdir;
+	/* set gpio dir out for led */
+	reg_val |= 1 << (31 - LED_ATTENTION);
+	reg_val |= 1 << (31 - LED_SW_STATUS);
+	reg_val |= 1 << (31 - LED_SW_MODE);
+	reg_val |= 1 << (31 - LED_WAP_BG);
+	reg_val |= 1 << (31 - LED_WAP_N);
+	reg_val |= 1 << (31 - LED_FAILOVER);
+	/* set gpio dir in for button */
+	reg_val &= ~(1 << (31 - BTN_RESET));
+
+	pgpio->gpdir = reg_val;
+	/* set default state: all off */
+	reg_val = pgpio->gpdat;
+
+	reg_val |= 1 << (31 - LED_ATTENTION);
+	reg_val |= 1 << (31 - LED_SW_STATUS);
+	reg_val |= 1 << (31 - LED_SW_MODE);
+	reg_val &= ~(1 << (31 - LED_WAP_BG));
+	reg_val &= ~(1 << (31 - LED_WAP_N));
+	reg_val |= 1 << (31 - LED_FAILOVER);
+
+	pgpio->gpdat = reg_val;
+}
+
+/*
+* Turn led on by given gpio number
+*/
+void sc_led_on(unsigned int led)
+{
+	unsigned int reg_val;
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	reg_val = pgpio->gpdat;
+
+	reg_val &= ~(1 << (31 - led));
+
+	pgpio->gpdat = reg_val;
+}
+
+/*
+* Turn led off by given gpio number
+*/
+void sc_led_off(unsigned int led)
+{
+	unsigned int reg_val;
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	reg_val = pgpio->gpdat;
+
+	reg_val |= 1 << (31 - led);
+
+	pgpio->gpdat = reg_val;
+}
+
+/*
+* Read button status by given gpio number
+*/
+int sc_read_btn_status(unsigned int btn)
+{
+	unsigned int reg_val;
+	volatile ccsr_gpio_t *pgpio = (void *)(CONFIG_SYS_MPC85xx_GPIO_ADDR);
+
+	reg_val = pgpio->gpdat;
+	/* Low active */
+	if (reg_val & (1 << (31 - btn)) )
+	return 0;
+	else
+	return 1;
+}
+
+
+/*
+* LED Test main entry
+*/
+int Led_Test()
+{		
+	unsigned long long Led_start_time, Led_timer;
+	int i = 0;
+
+	/* init gpio for led & btn first */
+	sc_led_init();
+
+	for (i=0; i<LED_TEST_CYCLE; i++)
+	{
+		sc_led_on(LED_FAILOVER);
+		udelay(1000000);
+		sc_led_off(LED_FAILOVER);
+
+		udelay(1000000);
+
+		sc_led_on(LED_WAP_N);
+		sc_led_off(LED_WAP_BG);
+		udelay(1000000);
+		sc_led_off(LED_WAP_N);
+		sc_led_on(LED_WAP_BG);
+
+		udelay(1000000);
+
+		sc_led_on(LED_WAP_BG);
+		sc_led_off(LED_WAP_N);
+		udelay(1000000);
+		sc_led_off(LED_WAP_BG);
+		sc_led_on(LED_WAP_N); 	
+
+		udelay(1000000);
+
+		sc_led_on(LED_SW_MODE);
+		udelay(1000000);
+		sc_led_off(LED_SW_MODE);
+
+		udelay(1000000);
+
+		sc_led_on(LED_SW_STATUS);
+		udelay(1000000);
+		sc_led_off(LED_SW_STATUS);
+
+		udelay(1000000);
+
+		sc_led_on(LED_ATTENTION);
+		udelay(1000000);
+		sc_led_off(LED_ATTENTION);
+
+		udelay(1000000);
+	}
+
+	printf("Monitor Button Status..\n");
+
+	/* wait for button press */
+	Led_start_time = 0;
+	Led_timer = (LED_TEST_TIMEOUT)*1000;
+
+	while ( Led_start_time <= Led_timer)
+		{
+		if (sc_read_btn_status(BTN_RESET)) {
+			memcpy(test_result, TEST_LED_PASS_STR, sizeof(TEST_LED_PASS_STR));
+			test_result[TEST_RESULT_OFF] = LED_TEST_PASS;
+			set_result_state=Set_Test_Result( test_result, LED_TEST_ITEM );
+			if (set_result_state) {
+				printf("write the LED_TEST (OK) is fail \n");
+			}
+			else {
+				printf("write the LED_TEST (OK) is OK \n");
+			}
+			printf("LED Test\n");
+			printf("LED and Reset Button Test Pass\n");
+			return SC_MFG_TEST_OP_PASS;
+		}
+		udelay(1000);
+		Led_start_time += 1;
+	}
+
+	printf("LED Test\n");
+	printf("LED or Reset Button Test Fail\n");
+	memcpy(test_result, TEST_LED_FAIL_SRT, sizeof(TEST_LED_FAIL_SRT));
+	printf("memcpy done.\n");
+	test_result[TEST_RESULT_OFF] = LED_TEST_FAIL;
+	set_result_state=Set_Test_Result( test_result, LED_TEST_ITEM );
+	if (set_result_state) {
+		printf("write the LED_TEST (fail) is fail \n");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+	else {
+		printf("write the LED_TEST (fail) is OK \n");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+}
+
+
--- u-boot-2011.03/sc_mfg_standalone/powerpc_longjmp.S.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/powerpc_longjmp.S	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,79 @@
+/* longjmp for PowerPC.
+   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ppc_asm.tmpl>
+
+# define JB_GPR1   0  /* Also known as the stack pointer */
+# define JB_GPR2   1
+# define JB_LR     2  /* The address we will return to */
+# define JB_GPRS   3  /* GPRs 14 through 31 are saved, 18 in total */
+# define JB_CR     21 /* Condition code registers. */
+# define JB_FPRS   22 /* FPRs 14 through 31 are saved, 18*2 words total */
+# define JB_SIZE   (58*4)
+
+#define FP(x...) x
+#define FP(x...) x
+
+.globl      ppc_longjmp;
+
+ppc_longjmp:
+	lwz r1,(JB_GPR1*4)(r3)
+	lwz r2,(JB_GPR2*4)(r3)
+	lwz r0,(JB_LR*4)(r3)
+	lwz r14,((JB_GPRS+0)*4)(r3)
+FP(	lfd 14,((JB_FPRS+0*2)*4)(r3))
+	lwz r15,((JB_GPRS+1)*4)(r3)
+FP(	lfd 15,((JB_FPRS+1*2)*4)(r3))
+	lwz r16,((JB_GPRS+2)*4)(r3)
+FP(	lfd 16,((JB_FPRS+2*2)*4)(r3))
+	lwz r17,((JB_GPRS+3)*4)(r3)
+FP(	lfd 17,((JB_FPRS+3*2)*4)(r3))
+	lwz r18,((JB_GPRS+4)*4)(r3)
+FP(	lfd 18,((JB_FPRS+4*2)*4)(r3))
+	lwz r19,((JB_GPRS+5)*4)(r3)
+FP(	lfd 19,((JB_FPRS+5*2)*4)(r3))
+	lwz r20,((JB_GPRS+6)*4)(r3)
+FP(	lfd 20,((JB_FPRS+6*2)*4)(r3))
+	mtlr r0
+	lwz r21,((JB_GPRS+7)*4)(r3)
+FP(	lfd 21,((JB_FPRS+7*2)*4)(r3))
+	lwz r22,((JB_GPRS+8)*4)(r3)
+FP(	lfd 22,((JB_FPRS+8*2)*4)(r3))
+	lwz r0,(JB_CR*4)(r3)
+	lwz r23,((JB_GPRS+9)*4)(r3)
+FP(	lfd 23,((JB_FPRS+9*2)*4)(r3))
+	lwz r24,((JB_GPRS+10)*4)(r3)
+FP(	lfd 24,((JB_FPRS+10*2)*4)(r3))
+	lwz r25,((JB_GPRS+11)*4)(r3)
+FP(	lfd 25,((JB_FPRS+11*2)*4)(r3))
+	mtcrf 0xFF,r0
+	lwz r26,((JB_GPRS+12)*4)(r3)
+FP(	lfd 26,((JB_FPRS+12*2)*4)(r3))
+	lwz r27,((JB_GPRS+13)*4)(r3)
+FP(	lfd 27,((JB_FPRS+13*2)*4)(r3))
+	lwz r28,((JB_GPRS+14)*4)(r3)
+FP(	lfd 28,((JB_FPRS+14*2)*4)(r3))
+	lwz r29,((JB_GPRS+15)*4)(r3)
+FP(	lfd 29,((JB_FPRS+15*2)*4)(r3))
+	lwz r30,((JB_GPRS+16)*4)(r3)
+FP(	lfd 30,((JB_FPRS+16*2)*4)(r3))
+	lwz r31,((JB_GPRS+17)*4)(r3)
+FP(	lfd 31,((JB_FPRS+17*2)*4)(r3))
+	mr r3,r4
+	blr
--- u-boot-2011.03/sc_mfg_standalone/ram_test.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/ram_test.h	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,92 @@
+#ifndef _RAM_TEST_H_
+#define _RAM_TEST_H_
+/* ram_test.h
+ * Athour	: Tony Tang
+ * Date 	: 2008-04-15
+ * Usage	: Common Ram Test Code header file, which includes data structures.
+ */
+
+/*
+ * Platform Definitions - here for u-boot.
+ */
+#include <common.h>
+#include <command.h>
+#include <linux/types.h>
+#define diag_printf printf
+
+/*------------------------------------------*/
+extern struct vars * v;
+extern struct mem_info_t mem_info;
+
+#define BAILOUT		if (bail) goto skip_test;
+#define BAILR		if (bail) return;
+#define MOD_SZ		20
+#define TEST_OK		(99)
+#define SPINSZ		0x100000 /* 1MB */
+
+struct err_info
+{
+	unsigned long ebits;
+	long tbits;
+	short min_bits;
+	short max_bits;
+	unsigned long maxl;
+	unsigned long eadr;
+	unsigned long exor;
+	unsigned long cor_err;
+};
+
+struct mem_info_t {
+	ulong start;
+	ulong end;
+};
+
+struct tseq_t {
+	short cache;
+	short pat;
+	short iter;
+	short ticks;
+	short errors;
+	char *msg;
+};
+
+struct vars
+{
+	int test;		/* test number of test sequence */
+	int pass;		/* what this for ??? - if set 1, equals to the test is passed and memory test is OK */
+	int msg_line;		/* ??? */
+	int ecount;		/* Error Counter ? */
+	int ecc_ecount;		/* ECC Error Counter ? */
+	int testsel;		/* test number in progress */
+	struct err_info erri;
+	struct mem_info_t map;	/* The memory map for test, including start & end address */
+	//struct mem_info_t *test_region;
+	//ulong clks_msec;	/* CPU clock in khz */
+};
+
+void disableECC(void);
+void sleep(int n);
+void set_cache(int val) ;
+void test_complete_enable_caches(void);
+void get_test_region(ulong start, ulong end);
+void get_mem_map(void);
+void get_cpu_freq(void);
+void poll_errors(void);
+
+void addr_tst2(void);
+void addr_tst1(void);
+void bit_fade(void);
+void block_move(int iter);
+void modtst(int offset, int iter, ulong p1, ulong p2);
+void movinv1(int iter, ulong p1, ulong p2);
+void movinv32(int iter, ulong p1, ulong lb, ulong hb, int sval, int off);
+void movinvr(void);
+unsigned int rand(void);
+void rand_seed( unsigned int seed1, unsigned int seed2 );
+
+void ad_err1(ulong *adr1, ulong *mask, ulong bad, ulong good);
+void ad_err2(ulong *adr, ulong bad);
+void ram_error(ulong *adr, ulong good, ulong bad);
+
+#endif /* _RAM_TEST_H_ */
+
--- u-boot-2011.03/sc_mfg_standalone/sc_mfg.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/sc_mfg.h	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,246 @@
+#ifndef _SC_MFG_CMD_H_
+#define _SC_MFG_CMD_H_
+#include <asm/immap_85xx.h>
+#include <common.h>
+#include <nand.h>
+#include <exports.h>
+#include "ram_test.h"
+
+/*************************************************************/
+/* FLASH MAP for current design */
+/* ------------------------------------
+ * Size  : 0x00200000 | 0x00100000
+ * Base  : 0xEFE00000 | 0xEFF00000
+ * -----------------------------------------------------------------------------
+ * UBOOT : 0xEFF80000 - 0xEFFFFFFF : 0x80000 # Uboot Image
+ * ENV   : 0xEFF70000 - 0xEFF7FFFF : 0x10000 # Uboot ENV
+ * TEST  : 0xEFF60000 - 0xEFF6FFFF : 0x10000 # WG UBOOT SW TEST Result
+ * EMPTY : 0xEFF50000 - 0xEFF5FFFF : 0x10000 # WG MFG DATA
+ * STAND : 0xEFF20000 - 0xEFF4FFFF : 0x30000 # WG CFG1
+ * DTB   : 0xEFF00000 - 0xEFF1FFFF : 0x20000 # WG CFG0 (NEW bootopt partition)
+ * -----------------------------------------------------------------------------
+ */
+#define FL_SIZE_UBOOT 		0x80000
+#define FL_SIZE_ENV		0x10000
+#define FL_SIZE_TEST_RESULT	0x10000
+#define FL_SIZE_MFG_DATA	0x10000
+#define FL_SIZE_CFG1		0x30000
+#define FL_SIZE_CFG0		0x20000
+
+/*
+ * Global definition for SC MFG TEST
+ */
+#define NAND_FLASH_TEST_ITEM	0x22
+#define NOR_FLASH_TEST_ITEM	0x23
+#define PCI_TEST_ITEM		0x24
+#define RTC_TEST_ITEM		0x25
+#define LED_TEST_ITEM		0x26
+#define DRAM_TEST_ITEM		0x27
+
+/*
+ * TEST RESULT Definition
+ */
+/*#define TEST_RESULT_OFFSET	(CONFIG_SYS_FLASH_SIZE - FL_SIZE_UBOOT - FL_SIZE_ENV - FL_SIZE_TEST_RESULT)*/	/* before ENV sector */
+#define TEST_RESULT_BUF_LEN	(0x100)
+
+#define DRAM_TEST_ERR_CHIP  	(0x70)
+#define DRAM_TEST_ERR_ADDR	(0x80)
+#define DRAM_TEST_ERR_TYPE	(0x90)
+
+#define TEST_ITEM_NAND_OFFSET	(0x0000)
+#define TEST_ITEM_NOR_OFFSET	(0x0100)
+#define TEST_ITEM_RTC_OFFSET	(0x0200)
+#define TEST_ITEM_LED_OFFSET	(0x0300)
+#define TEST_ITEM_RAM_OFFSET	(0x0400)
+#define TEST_ITEM_PCI_OFFSET	(0x0500)
+
+/*
+ * TEST PASS/FAIL NUMBER
+ */
+#define NOR_FLASH_PASS		(88)
+#define NOR_FLASH_FAIL		(77)
+
+#define NAND_FLASH_PASS		(88)
+#define NAND_FLASH_FAIL		(77)
+
+#define LED_TEST_PASS		(88)
+#define LED_TEST_FAIL		(77)
+
+#define RTC_TEST_PASS		(88)
+#define RTC_TEST_FAIL		(77)
+
+#define PCI_TEST_PASS		(88)
+#define PCI_TEST_FAIL		(77)
+
+#define DRAM_TEST_OK 		(99)
+#define DRAM_TEST_FAIL_UNKNOWN 	(13)
+
+/*
+ * PASS/FAIL NUMBER OFFSET in test_result string
+ */
+#define TEST_RESULT_OFF		(99)
+
+/*
+ * STRINGs for PASS/FAIL
+ */
+#define TEST_DRAM_PASS_STR	" DRAM Test\n PASS \n "
+#define TEST_DRAM_FAIL_STR	" DRAM Test\n FAIL \n "
+
+#define TEST_NOR_FAIL_STR	" NOR Flash Test \n FAIL \n"
+#define TEST_NOR_PASS_STR	" NOR Flash Test \n PASS \n"
+
+#define TEST_LED_PASS_STR	" LED Test\n LED and Reset Button Test Pass\n"
+#define TEST_LED_FAIL_SRT	" LED Test\n LED or Reset Button Test Fail\n"
+
+#define TEST_RTC_PASS_STR	" RTC Test\nRTC Test Pass\nPass\n"
+#define TEST_RTC_FAIL_STR	" RTC Test\nRTC Test Fail\nFail\n"
+
+#define TEST_NAND_FAIL_STR	" NAND Flash Test \n FAIL \n"
+#define TEST_NAND_PASS_STR	" NAND Flash Test \n PASS \n"
+/*
+ * TEST OPEARTION RETURN
+ */
+#define SC_MFG_TEST_OP_PASS	(0)
+#define SC_MFG_TEST_OP_FAIL	(1)
+/*
+ * Save/Read Test Result to/from Flash
+ */
+int Set_Test_Result(char test_result[100], int test_item);
+void Read_Test_Result(void);
+/*
+ * test result
+ */
+extern char test_result[];
+extern int set_result_state;
+
+/*--------------------------------------------------------------------
+ * For DRAM Test
+ *-------------------------------------------------------------------*/
+
+/* Test items and pattern structure */
+extern struct tseq_t tseq[];
+/* help tp find test type */
+extern int find_ram_test_item(int pat);
+/* Main function for DRAM test */
+int Ram_Test(void);
+
+/*--------------------------------------------------------------------
+ * For PCI Info List
+ *-------------------------------------------------------------------*/
+extern void pciinfo(int BusNum, int ShortPCIListing);
+
+/*--------------------------------------------------------------------
+ * For Nor Flash Check
+ *-------------------------------------------------------------------*/
+/*
+ * Pattern used for test NOR flash
+ */
+#define NOR_FLASH_TEST_DATA	0x5A
+/*
+ * Nor Flash Block Size
+ */
+#define BLOCK_SIZE		(0x10000)	/* MX29LV800CT */
+/*
+ * Flash Base Address
+ */
+#define FLASH_ADDR_BASE (CONFIG_SYS_FLASH_BASE)
+/*
+ * Start Offset to be tested
+ */
+#define NOR_TEST_START_OFFSET \
+	(CONFIG_SYS_FLASH_SIZE - FL_SIZE_UBOOT - FL_SIZE_ENV - FL_SIZE_TEST_RESULT - FL_SIZE_MFG_DATA)
+/*
+ * Number of blocks to be test
+ */
+#define BUFFER_NUM		3
+
+int Fill_NOR_Flash(int write_data);
+int Check_NOR_Flash(int read_data);
+
+/*--------------------------------------------------------------------
+ * For Nand Flash Check
+ *-------------------------------------------------------------------*/
+/*
+ * Pattern used for test NAND flash
+ */
+#define NAND_FLASH_TEST_DATA	0x55
+
+/* CONFIG_XTM3 && ! CONFIG_XTM3_1M means cut1 or cut2 newport */
+#if defined(CONFIG_XTM2_1M) || (defined(CONFIG_XTM3) && !defined(CONFIG_XTM3_1M)) || defined(CONFIG_XTM2)
+/* Samsung K9F2G08U0B */
+# define NAND_TOTAL_BLK		(2048)
+# define NAND_BLK_SIZE		(0x20000)
+#elif defined(CONFIG_XTM3_1M)
+/* Samsung K9F4G08U0D */
+# define NAND_TOTAL_BLK		(4096)
+# define NAND_BLK_SIZE		(0x20000)
+#endif
+/* allow 1% of bad block or reject the unit */
+#define MAX_BADBLK_ALLOW	(NAND_TOTAL_BLK/100)
+
+#define NAND_TEST_START_BLK	0
+#define NAND_TEST_END_BLK	(NAND_TOTAL_BLK - 1)
+
+#define TEST_QUIET		1
+#define TEST_DEBUG		0
+
+int Nand_Flash_Test(int test_mode);
+int Nand_Flash_Check(unsigned short blk_num, int test_mode);
+/*--------------------------------------------------------------------
+ * For LED/BUTTON TEST definition
+ *-------------------------------------------------------------------*/
+/*
+ * Headr Files for GPIO registers
+ */
+
+/*
+ * LED/BTN definition
+ */
+#define LED_ATTENTION		(0x02)
+#define LED_SW_STATUS		(0x03)
+#define LED_SW_MODE		(0x04)
+#define LED_WAP_BG		(0x05)
+#define LED_WAP_N		(0x06)
+#define LED_FAILOVER		(0x07)
+
+#define BTN_RESET		(0x01)
+
+/* LED is Low_Active */
+#define LED_OFF			(1)
+#define LED_ON			(0)
+
+#define LED_TEST_CYCLE		(5)
+#define LED_TEST_TIMEOUT	(20)
+
+int Led_Test(void);
+void sc_led_init(void);
+void sc_led_off(unsigned int led);
+void sc_led_on(unsigned int led);
+int sc_read_btn_status(unsigned int btn);
+
+
+/*--------------------------------------------------------------------
+ * For RTC TEST definition
+ *-------------------------------------------------------------------*/
+/*
+ * Delay Time
+ */
+#define RTC_TEST_DELAY		5
+
+
+int RTC_Test(void);
+
+/*-------------------------------------------------------------------
+ * Flash ERASE/PROGRAM Opeations
+ *-------------------------------------------------------------------*/
+#define FLASH_OP_FAIL		(0)
+#define FLASH_OP_OK		(1)
+int sc_flash_erase(ulong address, int size);
+int sc_flash_program(ulong address, char * buffer, int size);
+void disable_DDR_ECC(void);
+nand_info_t *sc_get_nand_info_ptr(void);
+
+
+#endif /* _SC_MFG_CMD_H_ */
+
+// vim: noet ai
--- u-boot-2011.03/sc_mfg_standalone/ram_test_port.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/ram_test_port.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,116 @@
+/* This file inclues all functions which are changed on different platforms. */
+/* This means : these APIs should be supported by externel of this test tool */
+#include <asm/cache.h>
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <exports.h>
+
+/*===============================*/
+
+#include "ram_test.h"
+/*
+ * Sleep fucntion used by bit fade test
+ */
+void sleep(int n)
+{
+	int i = 0,j;
+	for(;i<n;i++)
+	{
+		for(j=0;j<1000;j++)		
+		{	//1 s
+			udelay(1000); //1 ms
+		}
+		if(i==60)
+			diag_printf("Elapsed time : about 1 minute \n");
+	}
+}
+
+/*
+ * Control to enable caches if need be ...
+ */
+int test_complete_en_caches = 0;
+void test_complete_enable_caches(void)
+{
+	test_complete_en_caches = 1;
+}
+
+/*
+ * Cache Operation
+ */
+void set_cache(int val) /* 1 - on , 0 - off */
+{
+#ifdef TEST_CODE
+	ulong enable_caches = 0; /* release code */
+	char *s;
+
+	 /* release code */
+	if ((s = getenv ("enable_caches")) != NULL) {
+		enable_caches = simple_strtoul (s, NULL, 16);
+	}
+
+	if(val && enable_caches && test_complete_en_caches)
+	{
+#else
+	if(val && test_complete_en_caches)
+	{
+#endif
+		diag_printf("MJ:new cache code executing\n");
+
+		flush_dcache();
+		invalidate_icache();	
+		
+		icache_enable();
+		dcache_enable();
+	}
+	else
+	{		
+		flush_dcache();
+		invalidate_icache();	
+		
+		icache_disable();
+		dcache_disable();	
+	}	
+}
+/*
+ * Find out how much memory there is.
+ */
+/*
+void get_test_region(ulong start, ulong end)
+{
+	v->map.start = start;
+	v->map.end = end;
+}
+*/
+void get_mem_map(void)
+{
+#if defined(CONFIG_XTM2_1M)
+	mem_info.start = 0x01300000;	//star: start of address space for DDR
+	mem_info.end   = 0x1F900000;	//end : leave 7 Mbytes space for uboot itself and other.
+#else
+	mem_info.start = 0x01300000;	//star: start of address space for DDR
+	mem_info.end   = 0x3F900000;	//end : leave 7 Mbytes space for uboot itself and other.
+#endif
+
+	diag_printf("Test Range : %lx - %lx.\n", mem_info.start, mem_info.end);
+}
+/*
+extern ulong cpu_freq;
+void get_cpu_freq(void)
+{
+	v->clks_msec = cpu_freq;
+}
+*/
+void disable_DDR_ECC(void)
+{
+	/* set dummy now, we won't used ECC for NewCastle */
+}
+void enable_DDR_ECC(void)
+{
+	/* set dummy now, we won't used ECC for NewCastle */
+}
+void poll_errors(void)
+{
+}
+
--- u-boot-2011.03/sc_mfg_standalone/ram_test_algo.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/ram_test_algo.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,1037 @@
+/* test_algo.c - change from MemTest-86
+ * tony tang
+ */
+#include "ram_test.h"
+
+extern int bail;
+extern volatile ulong *p;
+extern ulong p1, p2;
+extern struct tseq_t tseq[];
+extern void poll_errors(void);
+
+int ecount = 0;
+
+static inline ulong roundup_x(ulong value, ulong mask)
+{
+	return (value + mask) & ~mask;
+}
+/*
+ * Memory address test, walking ones
+ */
+void addr_tst1()
+{
+	int i, j, k;
+	volatile ulong *pt;
+	volatile ulong *end;
+	ulong bad, mask, bank;
+
+	//diag_printf("v->map.start %08x\n", (ulong)(v->map.start));
+	/* Test the global address bits */
+	for (p1=0, j=0; j<2; j++)
+	{
+		/* Set pattern in our lowest multiple of 0x20000 */
+		p = (ulong *)roundup_x((ulong)(v->map.start), 0x1ffff);
+		*p = p1;
+	
+		/* Now write pattern compliment */
+		p1 = ~p1;
+		end = (ulong *)v->map.end;
+		for (i=0; i<1000; i++)
+		{
+			mask = 4;
+			do
+			{
+				pt = (ulong *)((ulong)p | mask);
+				if (pt == p)
+				{
+					mask = mask << 1;
+					continue;
+				}
+				if (pt >= end)
+				{
+					break;
+				}
+				*pt = p1;
+				if ((bad = *p) != ~p1)
+				{
+					diag_printf("excepted data : %08lx.\n", ~p1);
+					ad_err1((ulong *)p, (ulong *)mask, bad, ~p1);
+					i = 1000;
+				}
+				mask = mask << 1;
+			} while(mask);
+		}
+		//do_tick();
+		BAILR
+	}
+#if 0 /* TONY debug for init pattern */
+		{
+			int iiiii = 0;
+			volatile ulong *ptr = (ulong *)v->map.start;
+			for(;iiiii<256; iiiii++)
+			{
+				diag_printf("%08x\t", ptr[iiiii]);
+
+				if(!((iiiii+1)%7))
+					diag_printf("\n");
+			}
+		}
+#endif
+	/* Now check the address bits in each bank */
+	/* If we have more than 8mb of memory then the bank size must be */
+	/* bigger than 256k. If so use 1mb for the bank size. */
+#if 1
+	if ((v->map.end - v->map.start) > (0x800000))
+	{
+		bank = 0x100000;
+	}
+	else
+	{
+		bank = 0x40000;
+	}
+#else /* set default bank size now */
+	bank = 0x40000;
+#endif
+	for (p1 = 0, k = 0; k<2; k++)
+	{
+		{
+			p = (ulong *)v->map.start;
+			/* Force start address to be a multiple of 256k */
+			p = (ulong *)roundup_x((ulong)p, bank - 1);
+			end = (ulong *)v->map.end;
+			while (p < end)
+			{
+
+				*p = p1;
+
+				p1 = ~p1;
+				for (i=0; i<200; i++)
+				{
+					mask = 4;
+					do{
+						pt = (ulong *)((ulong)p | mask);
+						if (pt == p)
+						{
+							mask = mask << 1;
+							continue;
+						}
+						if (pt >= end)
+						{
+							break;
+						}
+						*pt = p1;
+						if ((bad = *p) != ~p1)
+						{
+							ad_err1((ulong *)p,(ulong *)mask,bad,~p1);
+							i = 200;
+						}
+						mask = mask << 1;
+					} while(mask);
+				}
+				if (p + bank > p)
+				{
+					p += bank;
+				}
+				else
+				{
+					p = end;
+				}
+				p1 = ~p1;
+			}
+		}		
+		//do_tick();
+		BAILR
+		p1 = ~p1;
+	}
+}
+
+/*
+ * Memory address test, own address
+ */
+void addr_tst2()
+{
+	int done;
+	volatile ulong *pe;
+	volatile ulong *end, *start;
+	ulong bad;
+
+	/* Write each address with it's own address */
+	{
+		start = (ulong *)v->map.start;
+		end = (ulong *)v->map.end;
+		pe = (ulong *)start;
+		p = start;
+		done = 0;
+		do
+		{
+			/* Check for overflow */
+			if (pe + SPINSZ > pe)
+			{
+				pe += SPINSZ;
+			}
+			else
+			{
+				pe = end;
+			}
+			if (pe >= end)
+			{
+				pe = end;
+				done++;
+			} 	
+			if (p == pe )
+			{
+				break;
+			}
+			for (; p < pe; p++)
+ 			{
+ 				*p = (ulong)p;
+ 			}
+			//do_tick();
+			BAILR
+		} while (!done);
+	}
+
+	/* Each address should have its own address */
+	{
+		start = (ulong *)v->map.start;
+		end = (ulong *)v->map.end;
+		pe = (ulong *)start;
+		p = start;
+		done = 0;
+		do {
+			/* Check for overflow */
+			if (pe + SPINSZ > pe) {
+				pe += SPINSZ;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			if (p == pe ) {
+				break;
+			}
+ 			for (; p < pe; p++)
+ 			{
+ 				if((bad = *p) != (ulong)p)
+ 				{
+					diag_printf("excepted data : %08lx.\n", *p);
+ 					ad_err2((ulong *)p, bad);
+ 				}
+ 			}
+			//do_tick();
+			BAILR
+		} while (!done);
+	}
+}
+
+/*
+ * Test all of memory using a "half moving inversions" algorithm using random
+ * numbers and their complment as the data pattern. Since we are not able to
+ * produce random numbers in reverse order testing is only done in the forward
+ * direction.
+ */
+static int random_run = 0;
+void movinvr()
+{
+	int i, done, seed1, seed2;
+	volatile ulong *pe;
+	volatile ulong *start,*end;
+	ulong num;
+	ulong bad;
+
+	random_run ++;
+	/* Initialize memory with initial sequence of random numbers. */
+	{
+#if 0
+		seed1 = 521288629 + v->pass;
+		seed2 = 362436069 - v->pass;
+#else
+		seed1 = 521288629 + random_run;
+		seed2 = 362436069 - random_run;
+#endif
+	}
+
+	/* Display the current seed */
+	diag_printf("Current Seed :%08x .\n", seed1);
+
+	rand_seed(seed1, seed2);
+	
+	{
+		start = (ulong *)v->map.start;
+		end = (ulong *)v->map.end;
+		pe = start;
+		p = start;
+		done = 0;
+		do
+		{
+			/* Check for overflow */
+			if (pe + SPINSZ > pe) {
+				pe += SPINSZ;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			if (p == pe ) {
+				break;
+			}
+			for (; p < pe; p++)
+			{
+				*p = rand();
+			}
+			//do_tick();
+			BAILR
+		} while (!done);
+	}
+
+	/* Do moving inversions test. Check for initial pattern and then
+	 * write the complement for each memory location. Test from bottom
+	 * up and then from the top down. */
+	for (i=0; i<2; i++)
+	{
+		rand_seed(seed1, seed2);
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			pe = start;
+			p = start;
+			done = 0;
+			do
+			{
+				/* Check for overflow */
+				if (pe + SPINSZ > pe) {
+					pe += SPINSZ;
+				} else {
+					pe = end;
+				}
+				if (pe >= end) {
+					pe = end;
+					done++;
+				}
+				if (p == pe ) {
+					break;
+				}
+				for (; p < pe; p++)
+				{
+					num = rand();
+					if (i)
+					{
+						num = ~num;
+					}
+					if ((bad=*p) != num)
+					{
+						diag_printf("excepted data : %08lx.\n", num);
+						ram_error((ulong*)p, num, bad);
+					}
+					*p = ~num;
+				}
+				//do_tick();
+				BAILR
+			} while (!done);
+		}
+	}
+}
+
+/*
+ * Test all of memory using a "moving inversions" algorithm using the
+ * pattern in p1 and it's complement in p2. parameter iter is times to be executed
+ */
+void movinv1(int iter, ulong p1, ulong p2)
+{
+	int i, done;
+	volatile ulong *pe;
+	//volatile ulong len;
+	volatile ulong *start,*end;
+	ulong bad;
+
+	/* Display the current pattern */
+	diag_printf("Current Pattern %08lx .\n", p1);
+
+	/* Initialize memory with the initial pattern. */
+	{
+		start = (ulong *)v->map.start;
+		end = (ulong *)v->map.end;
+		pe = start;
+		p = start;
+		done = 0;
+		do
+		{
+#if 0 /* tony */
+			printf("pe %x, p %x \n", pe, p);
+#endif			
+			/* Check for overflow */
+			if (pe + SPINSZ > pe) {
+				pe += SPINSZ;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			//len = pe - p;
+			if (p == pe ) {
+				break;
+			}
+ 			for (; p < pe; p++)
+ 			{
+#if 0 /* tony */
+				printf("p %x\t", p);
+#endif 				
+ 				*p = p1;
+ 			}
+ 			//do_tick();
+			BAILR
+		} while (!done);
+	}
+#if 0 /* tony */
+			printf("pe %x, p %x \t", pe, p);
+#endif	
+	/* Do moving inversions test. Check for initial pattern and then
+	 * write the complement for each memory location. Test from bottom
+	 * up and then from the top down. */
+	for (i=0; i<iter; i++)
+	{
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			pe = start;
+			p = start;
+			done = 0;
+			do
+			{
+				/* Check for overflow */
+				if (pe + SPINSZ > pe) {
+					pe += SPINSZ;
+				} else {
+					pe = end;
+				}
+				if (pe >= end) {
+					pe = end;
+					done++;
+				}
+				if (p == pe ) {
+					break;
+				}
+ 				for (; p < pe; p++)
+ 				{
+ 					if ((bad=*p) != p1)
+ 					{
+						diag_printf("excepted data p1: %08lx.\n", p1);
+ 						ram_error((ulong*)p, p1, bad);
+ 					}
+ 					*p = p2;
+ 				}
+				//do_tick();
+				BAILR
+			} while (!done);
+		}
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			pe = end -1;
+			p = end - 1;
+				
+			done = 0;
+			do
+			{
+#if 0 /* tony */
+			printf("pe %x, p %x \t", pe, p);
+#endif				
+			/* Check for underflow */
+				if (pe - SPINSZ < pe) {
+					pe -= SPINSZ;
+				} else {
+					pe = start;
+				}
+				if (pe <= start) {
+					pe = start;
+					done++;
+				}
+				if (p == pe ) {
+					break;
+				}
+ 				do
+ 				{
+ 					if ((bad=*p) != p2)
+ 					{
+						diag_printf("excepted data p2: %08lx.\n", p2);
+ 						ram_error((ulong*)p, p2, bad);
+ 					}
+ 					*p = p1;
+ 				} while (p-- > pe);
+				//do_tick();
+				BAILR
+			} while (!done);
+		}
+	}
+}
+
+void movinv32(int iter, ulong p1, ulong lb, ulong hb, int sval, int off)
+{
+	int i, k=0, done;
+	volatile ulong *pe;
+	volatile ulong *start, *end;
+	ulong pat = 0;
+	ulong bad;
+
+	/* Display the current pattern */
+	diag_printf("Current Pattern %08lx .\n", p1);
+
+	/* Initialize memory with the initial pattern. */
+	{
+		start = (ulong *)v->map.start;
+		end = (ulong *)v->map.end;
+		pe = start;
+		p = start;
+		done = 0;
+		k = off;
+		pat = p1;
+		do
+		{
+			/* Check for overflow */
+			if (pe + SPINSZ > pe) {
+				pe += SPINSZ;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			if (p == pe ) {
+				break;
+			}
+ 			while (p < pe)
+ 			{
+ 				*p = pat;
+ 				if (++k >= 32)
+ 				{
+ 					pat = lb;
+ 					k = 0;
+ 				}
+ 				else
+ 				{
+ 					pat = pat << 1;
+ 					pat |= sval;
+ 				}
+ 				p++;
+ 			}
+			/* Do a SPINSZ section of memory */
+			//do_tick();
+			BAILR
+		} while (!done);
+	}
+
+	/* Do moving inversions test. Check for initial pattern and then
+	 * write the complement for each memory location. Test from bottom
+	 * up and then from the top down. */
+	for (i=0; i<iter; i++)
+	{
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			pe = start;
+			p = start;
+			done = 0;
+			k = off;
+			pat = p1;
+			do
+			{
+				/* Check for overflow */
+				if (pe + SPINSZ > pe) {
+					pe += SPINSZ;
+				} else {
+					pe = end;
+				}
+				if (pe >= end) {
+					pe = end;
+					done++;
+				}
+				if (p == pe ) {
+					break;
+				}
+				while (p < pe)
+				{
+ 					if ((bad=*p) != pat)
+ 					{
+						diag_printf("excepted data : %08lx.\n", pat);
+						ram_error((ulong*)p, pat, bad);
+					}
+ 					*p = ~pat;
+ 					if (++k >= 32)
+ 					{
+ 						pat = lb;
+ 						k = 0;
+ 					}
+ 					else
+ 					{
+ 						pat = pat << 1;
+ 						pat |= sval;
+ 					}
+ 					p++;
+ 				}
+				//do_tick();
+				BAILR
+			} while (!done);
+		}
+
+		/* Since we already adjusted k and the pattern this
+		 * code backs both up one step
+		 */
+		pat = lb;
+ 		if ( 0 != (k = (k-1) & 31) )
+ 		{
+ 			pat = (pat << k);
+ 			if ( sval )
+ 				pat |= ((sval << k) - 1);
+ 		}
+ 		k++;
+#if 0 /* for tony debug use */
+ 		diag_printf("pat now %08x, k now %08x\n", pat, k);
+/* CDH start */
+		{
+			int iiiii = 0;
+			volatile ulong *ptr = ((ulong *)v->map.end) - 20);
+			for(;iiiii<20; iiiii++)
+			{
+				diag_printf("%08x\n", ptr[iiiii]);
+			}
+		}
+#endif
+/* CDH end */
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			p = end -1;
+			pe = end -1;
+			done = 0;
+			do
+			{
+				/* Check for underflow */
+				if (pe - SPINSZ < pe) {
+					pe -= SPINSZ;
+				} else {
+					pe = start;
+				}
+				if (pe <= start) {
+					pe = start;
+					done++;
+				}
+				if (p == pe ) {
+					break;
+				}
+ 				do
+ 				{
+ 					if ((bad=*p) != ~pat)
+ 					{
+						diag_printf("excepted data : %08lx.\n", ~pat);
+ 						ram_error((ulong*)p, ~pat, bad);
+ 					}
+ 					*p = pat;
+ 					if (--k <= 0)
+ 					{
+ 						pat = hb;
+ 						k = 32;
+ 					}
+ 					else
+ 					{
+ 						pat = pat >> 1;
+ 						pat |= (sval<<31);	// org : p3 -- ??????????? -- this is decided by TONY TANG
+ 					}
+ 				} while (p-- > pe);
+				//do_tick();
+				BAILR
+			} while (!done);
+		}
+	}
+}
+
+/*
+ * Test all of memory using modulo X access pattern.
+ */
+void modtst(int offset, int iter, ulong p1, ulong p2)
+{
+	int k, l, done;
+	volatile ulong *pe;
+	volatile ulong *start, *end;
+	ulong bad;
+
+	/* Display the current pattern */
+	diag_printf("Modelo X test using pattern %08lx with offset %08x.\n", p1, offset);
+
+	/* Write every nth location with pattern */
+	{
+		start = (ulong *)v->map.start;
+		end = (ulong *)v->map.end;
+		pe = (ulong *)start;
+		p = start + offset;
+		done = 0;
+		do
+		{
+			/* Check for overflow */
+			if (pe + SPINSZ > pe) {
+				pe += SPINSZ;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			if (p == pe ) {
+				break;
+			}
+ 			for (; p < pe; p += MOD_SZ)
+ 			{
+ 				*p = p1;
+ 			}
+			//do_tick();
+			BAILR
+		} while (!done);
+	}
+
+	/* Write the rest of memory "iter" times with the pattern complement */
+	for (l=0; l<iter; l++)
+	{
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			pe = (ulong *)start;
+			p = start;
+			done = 0;
+			k = 0;
+			do
+			{
+				/* Check for overflow */
+				if (pe + SPINSZ > pe) {
+					pe += SPINSZ;
+				} else {
+					pe = end;
+				}
+				if (pe >= end) {
+					pe = end;
+					done++;
+				}
+				if (p == pe ) {
+					break;
+				}
+ 				for (; p < pe; p++)
+ 				{
+ 					if (k != offset)
+ 					{
+ 						*p = p2;
+ 					}
+ 					if (++k > MOD_SZ-1)
+ 					{
+ 						k = 0;
+ 					}
+ 				}
+				//do_tick();
+				BAILR
+			} while (!done);
+		}
+	}
+
+	/* Now check every nth location */
+	{
+		start = (ulong *)v->map.start;
+		end = (ulong *)v->map.end;
+		pe = (ulong *)start;
+		p = start+offset;
+		done = 0;
+		do
+		{
+			/* Check for overflow */
+			if (pe + SPINSZ > pe) {
+				pe += SPINSZ;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			if (p == pe ) {
+				break;
+			}
+ 			for (; p < pe; p += MOD_SZ)
+ 			{
+ 				if ((bad=*p) != p1)
+ 				{
+					diag_printf("excepted data : %08lx.\n", p1);
+ 					ram_error((ulong*)p, p1, bad);
+ 				}
+ 			}
+			//do_tick();
+			BAILR
+		} while (!done);
+	}
+	diag_printf("\n");
+}
+
+/*
+ * Test memory using block moves
+ * Adapted from Robert Redelmeier's burnBX test
+ */
+void block_move(int iter)
+{
+#if 1
+	int i, done;
+	ulong len;
+	volatile ulong p, pe, pp;
+	volatile ulong start, end;
+
+	ulong p1 = 1;
+
+	/* Initialize memory with the initial pattern. */
+	{
+		start = (ulong)v->map.start;
+		end = (ulong)v->map.end;
+		pe = start;
+		p = start;
+		done = 0;
+		do
+		{
+			/* Check for overflow */
+			if (pe + SPINSZ*4 > pe)
+			{
+				pe += SPINSZ*4;
+			}
+			else
+			{
+				pe = end;
+			}
+			if (pe >= end)
+			{
+				pe = end;
+				done++;
+			}
+			if (p == pe )
+			{
+				break;
+			}
+			len = ((ulong)pe - (ulong)p) / 64;
+			
+			do
+			{
+				int off = 0;
+				ulong p2 = ~p1;
+				volatile ulong *ptr = (ulong *)p;
+								
+				for(;off<16;off++)
+				{
+					if((off==4) || (off==5) ||(off==10)||(off==11))
+						*(ptr+off) = p2;
+					else
+						*(ptr+off) = p1;
+				}
+				p += 64;
+				/****/// 
+				p1 = p1 >> 1;
+				if(!p1)
+				{
+					p1 |= 0x80000000;
+				}
+				/****/			
+			}while(--len);
+#if 0 /* TONY debug for init pattern */
+		{
+			int iiiii = 0;
+			volatile ulong *ptr = (v->map.start);
+			for(;iiiii<128; iiiii++)
+			{
+				if(!((iiiii+1)%7))
+					diag_printf("\n");
+				diag_printf("%08x\t", ptr[iiiii]);
+			}
+		}
+#endif
+			//do_tick();
+			BAILR
+		} while (!done);
+	}
+	//diag_printf("pattern filled in\n");
+	/* Now move the data around
+	 * First move the data up half of the segment size we are testing
+	 * Then move the data to the original location + 32 bytes
+	 */
+	{
+		start = (ulong)v->map.start;
+		end = (ulong)v->map.end;
+		pe = start;
+		p = start;
+		done = 0;
+		do {
+			/* Check for overflow */
+			if (pe + SPINSZ*4 > pe) {
+				pe += SPINSZ*4;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			if (p == pe ) {
+				break;
+			}
+			pp = p + ((pe - p) / 2);
+			len = ((ulong)pe - (ulong)p) / 8;
+			for(i=0; i<iter; i++)
+			{
+				ulong *src = (ulong *)p;
+				ulong *dst = (ulong *)pp;
+				ulong tmp = p;
+				ulong len_tmp = len;
+				do
+				{					
+					*dst = *src;
+					src += 1;
+					dst += 1;										
+				}while(--len_tmp);
+				
+				tmp = tmp + 32;
+				dst = (ulong *)tmp;
+				src = (ulong *)pp;
+				len_tmp = len - 8;
+				
+				do
+				{
+					*dst = *src;
+					src += 1;
+					dst += 1;
+				}while(--len_tmp);
+				
+				dst = (ulong *)p;
+				len_tmp = 8;
+				do
+				{
+					*dst = *src;
+					src += 1;
+					dst += 1;
+				}while(--len_tmp);
+				//do_tick();
+				BAILR
+			}
+			p = pe;
+		} while (!done);
+	}
+	//diag_printf("moves finished\n");
+	/* Now check the data
+	 * The error checking is rather crude. We just check that the
+	 * adjacent words are the same.
+	 */
+	{
+		start = (ulong)v->map.start;
+
+		end = (ulong)v->map.end;
+		pe = start;
+		p = start;
+		done = 0;
+		do {
+			/* Check for overflow */
+			if (pe + SPINSZ*4 > pe) {
+				pe += SPINSZ*4;
+			} else {
+				pe = end;
+			}
+			if (pe >= end) {
+				pe = end;
+				done++;
+			}
+			if (p == pe ) {
+				break;
+			}
+			
+			do
+			{
+				ulong tmp;
+				ulong *tmp1, *tmp2;
+				tmp = p;
+				tmp1 = (ulong *)tmp;
+				tmp = tmp + 4;
+				tmp2 = (ulong *)tmp;			
+				
+				if(*tmp1 != *tmp2)
+				{
+					diag_printf("Block Move has error!!!\n");
+					ram_error((ulong *)tmp, *tmp1, *tmp2);
+				}
+				
+				p = p + 8;				
+			}while(p < pe);
+			
+			BAILR
+		} while (!done);
+	}
+#else
+	diag_printf("block_move - dummy now.\n");
+#endif
+}
+
+/*
+ * Test memory for bit fade.
+ */
+#define STIME 5400
+void bit_fade()
+{
+	volatile ulong *pe;
+	volatile ulong bad;
+	volatile ulong *start,*end;
+
+
+	/* Do -1 and 0 patterns */
+	p1 = 0;
+	while (1)
+	{
+		/* Display the current pattern */
+
+		/* Initialize memory with the initial pattern. */
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			pe = start;
+			p = start;
+			for (p=start; p<end; p++)
+			{
+				*p = p1;
+			}
+			//do_tick();
+			BAILR
+		}
+		/* Snooze for 90 minutes */
+		sleep (STIME); ///?????
+
+		/* Make sure that nothing changed while sleeping */
+		{
+			start = (ulong *)v->map.start;
+			end = (ulong *)v->map.end;
+			pe = start;
+			p = start;
+			for (p=start; p<end; p++)
+			{
+ 				if ((bad=*p) != p1)
+ 				{
+					diag_printf("excepted data : %08lx.\n", p1);
+					ram_error((ulong*)p, p1, bad);
+				}
+			}
+			//do_tick();
+			BAILR
+		}
+		if (p1 == 0)
+		{
+			p1=-1;
+		}
+		else
+		{
+			break;
+		}
+	}
+}
+
--- u-boot-2011.03/sc_mfg_standalone/rtc_test.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/rtc_test.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,129 @@
+/****************************************************************
+ *	NewCastle Uboot Test Software Version 1.0		*
+ ****************************************************************
+ *	Module 	: RTC Test					*
+ *	Chip	: Seiko 35390					*
+ ****************************************************************/
+
+/*
+ * Header File
+ */
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include "sc_mfg.h"
+#include "../drivers/rtc/s35390.h"
+
+/*
+ * RTC Test example function:
+ * Set time to 2008-08-08 08:08:08 and delay 5 second
+ * and then check the time
+ */
+int rtc_set_get_test(void)
+{
+	SC_RTC_TIME time;
+	SC_RTC_TIME time_get;
+
+	time.year	= 8; //year 2008
+	time.month	= 8; //month
+	time.day	= 8; //day
+	time.week	= 5; //day of week data,2008 -08 -08 is Fri
+	time.hour	= 8; //hour
+	time.min	= 8; //minute
+	time.sec	= 8; //second
+
+	printf("***Will set time to 2008-08-08 08:08:08***\n");
+
+	if (sc_rtc_set_time(&time) == RTC_OP_FAIL) {
+		printf("***Set time to 2008-08-08 08:08:08 error***\n");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("***Set time to 2008-08-08 08:08:08 success, will delay %d second...***\n", RTC_TEST_DELAY);
+	udelay(1000000 * RTC_TEST_DELAY);
+
+	if (sc_rtc_get_time(&time_get) == RTC_OP_FAIL) {
+		printf("***After set time,read back error***");
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("Read back time:%d-%d-%d %d(day of week) %d:%d:%d\n",
+	time_get.year + 2000,
+	time_get.month,
+	time_get.day,
+	time_get.week,
+	time_get.hour,
+	time_get.min,
+	time_get.sec);
+
+	if ((time_get.year != time.year ) || (time_get.month != time.month) ||
+	    (time_get.day != time.day ) || (time_get.week != time.week) ||
+	    (time_get.hour != time.hour) || (time_get.min != time.min )) {
+		return SC_MFG_TEST_OP_FAIL;
+	}
+
+	printf("Set second:%d, Read second:%d \n", time.sec, time_get.sec);
+	if ( (time_get.sec - time.sec) == RTC_TEST_DELAY ) {
+		return SC_MFG_TEST_OP_PASS;
+	}
+	else {
+		return SC_MFG_TEST_OP_FAIL;
+	}
+}
+
+/*
+* RTC Test main entry
+*/
+int RTC_Test(void)
+{
+	int RTC_result;
+
+	/* I2C bus Init */
+	sc_i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	/* RTC Chip Init */
+	sc_rtc_init();
+
+	RTC_result = rtc_set_get_test();
+
+	if ( RTC_result != SC_MFG_TEST_OP_PASS ) {
+		memcpy(test_result, TEST_RTC_FAIL_STR, sizeof(TEST_RTC_FAIL_STR));
+		test_result[TEST_RESULT_OFF] = RTC_TEST_FAIL;
+		set_result_state = Set_Test_Result( test_result, RTC_TEST_ITEM );
+
+		if (set_result_state) {
+			printf("RTC Test\n");
+			printf("RTC Test Fail\n");
+			printf("Fail\n");
+			printf("write the RTC Test (Fail) is fail \n");
+			return SC_MFG_TEST_OP_FAIL;
+		}
+		else {
+			printf("RTC Test\n");
+			printf("RTC Test Fail\n");
+			printf("Fail\n");
+			printf("write the RTC Test (Fail) is ok \n");
+			return SC_MFG_TEST_OP_FAIL;
+		}
+	}
+	else {
+		memcpy(test_result, TEST_RTC_PASS_STR, sizeof(TEST_RTC_PASS_STR));
+		test_result[TEST_RESULT_OFF] = RTC_TEST_PASS;
+		set_result_state = Set_Test_Result( test_result, RTC_TEST_ITEM );
+		if (set_result_state) {
+			printf("RTC Test\n");
+			printf("RTC Test Pass\n");
+			printf("Pass\n");
+			printf("write the RTC Test (OK) is fail \n");
+			return SC_MFG_TEST_OP_FAIL;
+		}
+		else {
+			printf("RTC Test\n");
+			printf("RTC Test Pass\n");
+			printf("Pass\n");
+			printf("write the RTC Test (OK) is OK \n");
+			return SC_MFG_TEST_OP_PASS;
+		}
+	}
+}
+
--- u-boot-2011.03/sc_mfg_standalone/nor_test.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/nor_test.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,181 @@
+/***********************************************************************
+ * 			NewCastle Uboot Test Software Version 1.0      *
+ ***********************************************************************
+ * Module	: Nor Test					       *
+ ***********************************************************************/
+
+/*
+ * Header File
+ */
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <flash.h>
+#include "sc_mfg.h"
+
+/* Static Variables - be careful about stack size */
+static char block_buffer[BLOCK_SIZE];
+
+/* Check Function */
+int Check_NOR_Flash(int read_data)
+{
+	int i, j;
+	int compare = SC_MFG_TEST_OP_PASS;
+	unsigned int test_addr = 0;
+
+	for (i=0; i<BUFFER_NUM; i++)
+	{
+		test_addr = FLASH_ADDR_BASE + NOR_TEST_START_OFFSET + i*BLOCK_SIZE;
+
+		memcpy(block_buffer, (unsigned char *)test_addr, BLOCK_SIZE);
+
+		for(j=0; j<BLOCK_SIZE; j++)
+		{
+			if(block_buffer[j] != read_data) {
+				compare = SC_MFG_TEST_OP_FAIL;
+				goto TEST_OVER;
+			}
+		}
+	}
+
+	if (i==BUFFER_NUM)
+		compare = SC_MFG_TEST_OP_PASS;
+
+TEST_OVER:
+	if (compare == SC_MFG_TEST_OP_FAIL) {
+		memcpy(test_result, TEST_NOR_FAIL_STR, sizeof(TEST_NOR_FAIL_STR));
+
+		test_result[TEST_RESULT_OFF]=NOR_FLASH_FAIL;
+
+		set_result_state = Set_Test_Result(test_result, NOR_FLASH_TEST_ITEM);
+		printf(" NOR Flash Test \n");
+		printf(" FAIL \n");
+		if (set_result_state) {
+			printf("write the NOR_FLASH_TEST (fail) is fail \n");
+			return SC_MFG_TEST_OP_FAIL;
+		}
+		else {
+			printf("write the NOR_FLASH_TEST (fail) is OK \n");
+			return SC_MFG_TEST_OP_FAIL;
+		}
+	}
+	else {
+		memcpy(test_result, TEST_NOR_PASS_STR, sizeof(TEST_NOR_PASS_STR));
+		test_result[TEST_RESULT_OFF]=NOR_FLASH_PASS;
+		set_result_state = Set_Test_Result( test_result, NOR_FLASH_TEST_ITEM );
+		printf(" NOR Flash Test \n");
+		printf(" PASS \n");
+		if (set_result_state) {
+			printf("write the NOR_FLASH_TEST (OK) is fail \n");
+			return SC_MFG_TEST_OP_FAIL;
+		}
+		else {
+			printf("write the NOR_FLASH_TEST (OK) is OK \n");
+			return SC_MFG_TEST_OP_PASS;
+		}
+	}
+}
+
+/* Fill Pattern */
+int Fill_NOR_Flash(int write_data)
+{
+	int i;
+
+	memcpy(block_buffer, (char *) (FLASH_ADDR_BASE + NOR_TEST_START_OFFSET), BLOCK_SIZE);
+
+	for (i=0; i<BLOCK_SIZE; i++)
+	{
+		block_buffer[i] = write_data;
+
+		if (i%500==0)
+			udelay(2*10000); // delay
+
+		if (i%5000==0)
+			udelay(2*10000); // delay
+	}
+
+	printf("Erasing eeprom...\n");
+
+	for (i=0; i<BUFFER_NUM; i++)
+	{
+		if (sc_flash_erase(FLASH_ADDR_BASE + NOR_TEST_START_OFFSET + i*BLOCK_SIZE, BLOCK_SIZE) != FLASH_OP_OK) {
+			printf("Error erasing at %x\n", FLASH_ADDR_BASE + NOR_TEST_START_OFFSET + i*BLOCK_SIZE);
+			return SC_MFG_TEST_OP_FAIL;
+		}
+	}
+
+	printf("done\nPrograming ...\n");
+
+	for (i=0; i<BUFFER_NUM; i++)
+	{
+		if (sc_flash_program(FLASH_ADDR_BASE + NOR_TEST_START_OFFSET + i*BLOCK_SIZE, block_buffer, BLOCK_SIZE) != FLASH_OP_OK) {
+			printf("Can't program region at %x\n", FLASH_ADDR_BASE + NOR_TEST_START_OFFSET + i*BLOCK_SIZE);
+			return SC_MFG_TEST_OP_FAIL;
+		}
+	}
+
+	udelay(1000);
+
+	printf("write datas into Nor Flash is OK...\n");
+	return SC_MFG_TEST_OP_PASS;
+}
+
+
+/* Flash Erase/Program Operation */
+int sc_flash_erase(ulong address, int size)
+{
+	unsigned long addr_first;
+	unsigned long addr_last;
+
+	addr_first = (unsigned long)(address);	
+	addr_last  = (unsigned long)(address + size - 1);
+
+	printf("address %lx, size %x\n", address, size);
+
+	/* un-protect before real erase */
+	if(flash_sect_protect(0, addr_first, addr_last)) {
+		printf("up-protect flash fail!\n");
+		return FLASH_OP_FAIL;
+	}
+
+	if(flash_sect_erase(addr_first, addr_last)) {
+		printf("erase flash fail!\n");
+		return FLASH_OP_FAIL;
+	}
+
+	/* protect again */
+	if(flash_sect_protect(1, addr_first, addr_last)) {
+		printf("protect flash fail!\n");
+		return FLASH_OP_FAIL;
+	}
+	return FLASH_OP_OK;
+}
+
+int sc_flash_program(ulong address, char * buffer, int size)
+{
+	unsigned long addr_first;
+	unsigned long addr_last;
+
+	addr_first = (unsigned long)(address);	
+	addr_last  = (unsigned long)(address + size - 1);
+
+	/* un-protect before real program */
+	if(flash_sect_protect(0, addr_first, addr_last)) {
+		printf("up-protect flash fail!\n");
+		return FLASH_OP_FAIL;
+	}
+
+	if(flash_write(buffer, address, size)) {
+		printf("program flash fail!\n");
+		return FLASH_OP_FAIL;
+	}
+
+	/* protect again */
+	if(flash_sect_protect(1, addr_first, addr_last)) {
+		printf("protect flash fail!\n");
+		return FLASH_OP_FAIL;
+	}
+	return FLASH_OP_OK;
+}
+
--- u-boot-2011.03/sc_mfg_standalone/stubs.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/stubs.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,225 @@
+#include <exports.h>
+
+#ifndef GCC_VERSION
+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
+#endif /* GCC_VERSION */
+
+#if defined(CONFIG_I386)
+/*
+ * x86 does not have a dedicated register to store the pointer to
+ * the global_data. Thus the jump table address is stored in a
+ * global variable, but such approach does not allow for execution
+ * from flash memory. The global_data address is passed as argv[-1]
+ * to the application program.
+ */
+static void **jt;
+gd_t *global_data;
+
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+"	.globl " #x "\n"		\
+#x ":\n"				\
+"	movl	%0, %%eax\n"		\
+"	movl	jt, %%ecx\n"		\
+"	jmp	*(%%ecx, %%eax)\n"	\
+	: : "i"(XF_ ## x * sizeof(void *)) : "eax", "ecx");
+#elif defined(CONFIG_PPC)
+/*
+ * r2 holds the pointer to the global_data, r11 is a call-clobbered
+ * register
+ */
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+"	.globl " #x "\n"		\
+#x ":\n"				\
+"	lwz	%%r11, %0(%%r2)\n"	\
+"	lwz	%%r11, %1(%%r11)\n"	\
+"	mtctr	%%r11\n"		\
+"	bctr\n"				\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "r11");
+#elif defined(CONFIG_ARM)
+/*
+ * r8 holds the pointer to the global_data, ip is a call-clobbered
+ * register
+ */
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+"	.globl " #x "\n"		\
+#x ":\n"				\
+"	ldr	ip, [r8, %0]\n"		\
+"	ldr	pc, [ip, %1]\n"		\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "ip");
+#elif defined(CONFIG_MIPS)
+/*
+ * k0 ($26) holds the pointer to the global_data; t9 ($25) is a call-
+ * clobbered register that is also used to set gp ($26). Note that the
+ * jr instruction also executes the instruction immediately following
+ * it; however, GCC/mips generates an additional `nop' after each asm
+ * statement
+ */
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+"	.globl " #x "\n"		\
+#x ":\n"				\
+"	lw	$25, %0($26)\n"		\
+"	lw	$25, %1($25)\n"		\
+"	jr	$25\n"			\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "t9");
+#elif defined(CONFIG_NIOS)
+/*
+ * %g7 holds the pointer to the global_data. %g0 is call clobbered.
+ */
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+"	.globl " #x "\n"		\
+#x ":\n"				\
+"	pfx	%%hi(%0)\n"		\
+"	movi	%%g0, %%lo(%0)\n"	\
+"	add	%%g0, %%g7\n"		\
+"	ld	%%g0, [%%g0]\n"		\
+"	pfx	%1\n"			\
+"	ld	%%g0, [%%g0]\n"		\
+"	jmp	%%g0\n"			\
+"	nop	\n"			\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x) : "r0");
+#elif defined(CONFIG_NIOS2)
+/*
+ * r15 holds the pointer to the global_data, r8 is call-clobbered
+ */
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+"	.globl " #x "\n"		\
+#x ":\n"				\
+"	movhi	r8, %%hi(%0)\n"		\
+"	ori	r8, r0, %%lo(%0)\n"	\
+"	add	r8, r8, r15\n"		\
+"	ldw	r8, 0(r8)\n"		\
+"	ldw	r8, %1(r8)\n"		\
+"	jmp	r8\n"			\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "r15");
+#elif defined(CONFIG_M68K)
+/*
+ * d7 holds the pointer to the global_data, a0 is a call-clobbered
+ * register
+ */
+#define EXPORT_FUNC(x) \
+	asm volatile (			\
+"	.globl " #x "\n"		\
+#x ":\n"				\
+"	move.l	%%d7, %%a0\n"		\
+"	adda.l	%0, %%a0\n"		\
+"	move.l	(%%a0), %%a0\n"		\
+"	adda.l	%1, %%a0\n"		\
+"	move.l	(%%a0), %%a0\n"		\
+"	jmp	(%%a0)\n"			\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "a0");
+#elif defined(CONFIG_MICROBLAZE)
+/*
+ * r31 holds the pointer to the global_data. r5 is a call-clobbered.
+ */
+#define EXPORT_FUNC(x)				\
+	asm volatile (				\
+"	.globl " #x "\n"			\
+#x ":\n"					\
+"	lwi	r5, r31, %0\n"			\
+"	lwi	r5, r5, %1\n"			\
+"	bra	r5\n"				\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "r5");
+#elif defined(CONFIG_BLACKFIN)
+/*
+ * P3 holds the pointer to the global_data, P0 is a call-clobbered
+ * register
+ */
+#define EXPORT_FUNC(x)			\
+	asm volatile (			\
+"	.globl _" #x "\n_"		\
+#x ":\n"				\
+"	P0 = [P3 + %0]\n"		\
+"	P0 = [P0 + %1]\n"		\
+"	JUMP (P0)\n"			\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "P0");
+#elif defined(CONFIG_AVR32)
+/*
+ * r6 holds the pointer to the global_data. r8 is call clobbered.
+ */
+#define EXPORT_FUNC(x)					\
+	asm volatile(					\
+		"	.globl\t" #x "\n"		\
+		#x ":\n"				\
+		"	ld.w	r8, r6[%0]\n"		\
+		"	ld.w	pc, r8[%1]\n"		\
+		:					\
+		: "i"(offsetof(gd_t, jt)), "i"(XF_ ##x)	\
+		: "r8");
+#elif defined(CONFIG_SH)
+/*
+ * r13 holds the pointer to the global_data. r1 is a call clobbered.
+ */
+#define EXPORT_FUNC(x)					\
+	asm volatile (					\
+		"	.align	2\n"			\
+		"	.globl " #x "\n"		\
+		#x ":\n"				\
+		"	mov	r13, r1\n"		\
+		"	add	%0, r1\n"		\
+		"	mov.l @r1, r2\n"	\
+		"	add	%1, r2\n"		\
+		"	mov.l @r2, r1\n"	\
+		"	jmp	@r1\n"			\
+		"	nop\n"				\
+		"	nop\n"				\
+		: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "r1", "r2");
+#elif defined(CONFIG_SPARC)
+/*
+ * g7 holds the pointer to the global_data. g1 is call clobbered.
+ */
+#define EXPORT_FUNC(x)					\
+	asm volatile(					\
+"	.globl\t" #x "\n"				\
+#x ":\n"						\
+"	set %0, %%g1\n"					\
+"	or %%g1, %%g7, %%g1\n"				\
+"	ld [%%g1], %%g1\n"				\
+"	ld [%%g1 + %1], %%g1\n"				\
+"	jmp %%g1\n"					\
+"	nop\n"						\
+	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "g1" );
+
+#else
+#error stubs definition missing for this architecture
+#endif
+
+/* This function is necessary to prevent the compiler from
+ * generating prologue/epilogue, preparing stack frame etc.
+ * The stub functions are special, they do not use the stack
+ * frame passed to them, but pass it intact to the actual
+ * implementation. On the other hand, asm() statements with
+ * arguments can be used only inside the functions (gcc limitation)
+ */
+#if GCC_VERSION < 3004
+static
+#endif /* GCC_VERSION */
+void __attribute__((unused)) dummy(void)
+{
+#include <_exports.h>
+}
+
+extern unsigned long __bss_start, _end;
+
+void app_startup(char * const *argv)
+{
+	unsigned char * cp = (unsigned char *) &__bss_start;
+
+	/* Zero out BSS */
+	while (cp < (unsigned char *)&_end) {
+		*cp++ = 0;
+	}
+
+#if defined(CONFIG_I386)
+	/* x86 does not have a dedicated register for passing global_data */
+	global_data = (gd_t *)argv[-1];
+	jt = global_data->jt;
+#endif
+}
+
+#undef EXPORT_FUNC
--- u-boot-2011.03/sc_mfg_standalone/powerpc_setjmp.S.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/powerpc_setjmp.S	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,83 @@
+/* setjmp for PowerPC.
+   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ppc_asm.tmpl>
+
+# define JB_GPR1   0  /* Also known as the stack pointer */
+# define JB_GPR2   1
+# define JB_LR     2  /* The address we will return to */
+# define JB_GPRS   3  /* GPRs 14 through 31 are saved, 18 in total */
+# define JB_CR     21 /* Condition code registers. */
+# define JB_FPRS   22 /* FPRs 14 through 31 are saved, 18*2 words total */
+# define JB_SIZE   (58*4)
+
+#define FP(x...) x
+
+.globl      setctxsp;
+setctxsp:
+	mr  r1, r3
+	blr
+
+.globl      ppc_setjmp;
+ppc_setjmp:
+	stw  r1,(JB_GPR1*4)(3)
+	mflr r0
+	stw  r2,(JB_GPR2*4)(3)
+	stw  r14,((JB_GPRS+0)*4)(3)
+FP(	stfd 14,((JB_FPRS+0*2)*4)(3))
+	stw  r0,(JB_LR*4)(3)
+	stw  r15,((JB_GPRS+1)*4)(3)
+FP(	stfd 15,((JB_FPRS+1*2)*4)(3))
+	mfcr r0
+	stw  r16,((JB_GPRS+2)*4)(3)
+FP(	stfd 16,((JB_FPRS+2*2)*4)(3))
+	stw  r0,(JB_CR*4)(3)
+	stw  r17,((JB_GPRS+3)*4)(3)
+FP(	stfd 17,((JB_FPRS+3*2)*4)(3))
+	stw  r18,((JB_GPRS+4)*4)(3)
+FP(	stfd 18,((JB_FPRS+4*2)*4)(3))
+	stw  r19,((JB_GPRS+5)*4)(3)
+FP(	stfd 19,((JB_FPRS+5*2)*4)(3))
+	stw  r20,((JB_GPRS+6)*4)(3)
+FP(	stfd 20,((JB_FPRS+6*2)*4)(3))
+	stw  r21,((JB_GPRS+7)*4)(3)
+FP(	stfd 21,((JB_FPRS+7*2)*4)(3))
+	stw  r22,((JB_GPRS+8)*4)(3)
+FP(	stfd 22,((JB_FPRS+8*2)*4)(3))
+	stw  r23,((JB_GPRS+9)*4)(3)
+FP(	stfd 23,((JB_FPRS+9*2)*4)(3))
+	stw  r24,((JB_GPRS+10)*4)(3)
+FP(	stfd 24,((JB_FPRS+10*2)*4)(3))
+	stw  r25,((JB_GPRS+11)*4)(3)
+FP(	stfd 25,((JB_FPRS+11*2)*4)(3))
+	stw  r26,((JB_GPRS+12)*4)(3)
+FP(	stfd 26,((JB_FPRS+12*2)*4)(3))
+	stw  r27,((JB_GPRS+13)*4)(3)
+FP(	stfd 27,((JB_FPRS+13*2)*4)(3))
+	stw  r28,((JB_GPRS+14)*4)(3)
+FP(	stfd 28,((JB_FPRS+14*2)*4)(3))
+	stw  r29,((JB_GPRS+15)*4)(3)
+FP(	stfd 29,((JB_FPRS+15*2)*4)(3))
+	stw  r30,((JB_GPRS+16)*4)(3)
+FP(	stfd 30,((JB_FPRS+16*2)*4)(3))
+	stw  r31,((JB_GPRS+17)*4)(3)
+FP(	stfd 31,((JB_FPRS+17*2)*4)(3))
+
+	li 3, 0
+	blr
--- u-boot-2011.03/sc_mfg_standalone/sc_do_mfg.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/sc_do_mfg.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,68 @@
+#include <common.h>
+#include <exports.h>
+#include "sc_mfg.h"
+
+enum {
+	SC_MFG_LED_TEST = 0,
+	SC_MFG_NOR_TEST,
+	SC_MFG_NAND_TEST,
+	SC_MFG_DRAM_TEST,
+	SC_MFG_RTC_TEST,
+	SC_MFG_PCI_TEST,
+	SC_MFG_TEST_RESULTS,
+} SC_MFG_TYPE;
+
+
+void sc_do_mfg (int argc, char *argv[])
+{
+	int test_item;
+
+	/* Print the ABI version */
+	app_startup(argv);
+	printf ("Actual U-Boot ABI version %d\n", (int)get_version());
+
+	printf ("SC MFG STANDALONE:\n");
+
+	if(argc != 2)
+	{
+		printf("arg number is not correct!\n");
+		return;
+	}
+	else
+	{
+		test_item = simple_strtoul(argv[1], NULL, 16);
+		printf("test_item is %d\n", test_item);
+	}
+
+	switch(test_item)
+	{
+		case SC_MFG_LED_TEST:
+			Led_Test();
+			break;
+		case SC_MFG_NOR_TEST:
+			Fill_NOR_Flash(NOR_FLASH_TEST_DATA);
+			Check_NOR_Flash(NOR_FLASH_TEST_DATA);
+			break;
+		case SC_MFG_NAND_TEST:
+			Nand_Flash_Test(TEST_QUIET);
+			break;
+		case SC_MFG_DRAM_TEST:
+			Ram_Test();
+			break;
+		case SC_MFG_RTC_TEST:
+			RTC_Test();
+			break;
+		case SC_MFG_PCI_TEST:
+			/* BUS 1 */
+			pciinfo(1, 1);
+			/* BUS 2 */
+			pciinfo(2, 1);
+			break;
+		case SC_MFG_TEST_RESULTS:
+			Read_Test_Result();
+			break;
+		default:
+			printf("Wrong MFG TEST type!\n");
+			break;
+	}
+}
--- u-boot-2011.03/sc_mfg_standalone/ram_test_error.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/ram_test_error.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,251 @@
+/* error.c - change from MemTest-86 Version 3.4
+ *
+ * Released under version 2 of the Gnu Public License.
+ * By Tony Tang
+ */
+
+/*===============================*/
+
+#include "ram_test.h"
+
+extern int bail;
+extern struct tseq_t tseq[];
+extern void poll_errors(void);
+
+static void update_err_counts(void);
+static void print_err_counts(void);
+static void common_err(ulong *adr, ulong good, ulong bad, ulong xor, int type);
+static int syn, chan, len=1;
+
+/*
+ * Display data error message. Don't display duplicate errors.
+ */
+void ram_error(ulong *adr, ulong good, ulong bad)
+{
+	ulong xor;
+ 	diag_printf("%s %d called: address %08lx, good %08lx, bad %08lx \n",
+			__func__, __LINE__, (ulong)adr, good, bad);
+
+	xor = good ^ bad;
+
+	common_err(adr, good, bad, xor, 0);
+}
+
+/*
+ * Display address error message.
+ * Since this is strictly an address test, trying to create BadRAM
+ * patterns does not make sense. Just report the error.
+ */
+void ad_err1(ulong *adr1, ulong *mask, ulong bad, ulong good)
+{
+	common_err(adr1, good, bad, (ulong)mask, 1);
+}
+
+/*
+ * Display address error message.
+ * Since this type of address error can also report data errors go
+ * ahead and generate BadRAM patterns.
+ */
+void ad_err2(ulong *adr, ulong bad)
+{
+	common_err(adr, (ulong)adr, bad, ((ulong)adr) ^ bad, 0);
+}
+
+static void update_err_counts(void)
+{
+	if (v->pass && v->ecount == 0)
+	{
+		diag_printf("TEST PASS and ERROR COUNT = 0\n");
+	}
+	++(v->ecount);
+	tseq[v->test].errors++;
+		
+}
+
+static void print_err_counts(void)
+{
+}
+
+unsigned int err_address = 0;
+int err_test_type = -1;
+char errbitmask = 0;
+
+void ramtest_find_err_pos(ulong good, ulong bad)
+{
+	ulong xor;
+	ulong i= 0;
+	diag_printf("%s %d called: good %08lx, bad %08lx \n",
+			__func__, __LINE__, good, bad);
+	xor = good ^ bad;
+	while(i<4)
+	{
+		if( (xor>>(i*8)) && 0xFF)
+ 			errbitmask |= (1<<i);
+		i++;
+ 	}
+	diag_printf("%s %d called: errbitmask %x \n",
+			__func__, __LINE__, errbitmask);
+}
+
+/*
+ * Print an individual error
+ */
+void common_err(ulong *adr, ulong good, ulong bad, ulong xor, int type)
+{
+	unsigned int i, n, flag=0;
+
+	update_err_counts();
+
+	diag_printf("%s %d called: address %08lx, good %08lx, bad %08lx \n",
+			__func__, __LINE__, (ulong)adr, good, bad);
+	err_test_type = type;
+	err_address = (ulong)adr;
+	ramtest_find_err_pos(good, bad);
+
+	{	/* Don't do anything for a parity error. */
+		if (type == 3)
+		{
+			diag_printf("Parity Error - do nothing then return!\n");
+			return;
+		}
+		/* Address error */
+		if (type == 1)
+		{
+			diag_printf("Address ERROR.\n");
+			xor = good ^ bad;
+		}
+		/* Ecc correctable errors */
+		if (type == 2)
+		{
+			/* the bad value is the corrected flag */
+			if (bad)
+			{
+				v->erri.cor_err++;
+			}
+		}
+		else /* 0 */
+		{
+			/* nothing */
+		}
+		bail ++;
+			
+		/* Calc upper and lower error addresses */
+			/* removed now */
+
+		/* Calc bits in error */
+		for (i=0, n=0; i<32; i++)
+		{
+			if (xor>>i & 1)
+			{
+				n++;
+			}
+		}
+		v->erri.tbits += n;
+		if (n > v->erri.max_bits)
+		{
+			v->erri.max_bits = n;
+			flag++;
+		}
+		if (n < v->erri.min_bits)
+		{
+			v->erri.min_bits = n;
+			flag++;
+		}
+		if (v->erri.ebits ^ xor)
+		{
+			flag++;
+		}
+		v->erri.ebits |= xor;
+
+	 	/* Calc max contig errors */
+		len = 1;
+		if ((ulong)adr == (ulong)v->erri.eadr+4 || (ulong)adr == (ulong)v->erri.eadr-4 )
+		{
+			len++;
+		}
+		if (len > v->erri.maxl)
+		{
+			v->erri.maxl = len;
+			flag++;
+		}
+		v->erri.eadr = (ulong)adr;
+		
+		{
+			diag_printf("ERROR Information: \n");
+			diag_printf("Current Detect Error On Address: %08lx. bad data %08lx\n", v->erri.eadr, bad);	
+		}
+
+		if (flag)
+		{
+			/* Calc bits in error */
+			for (i=0, n=0; i<32; i++)
+		 	{
+				if (v->erri.ebits>>i & 1)
+				{
+					n++;
+				}
+			}
+			
+			for (i=0; tseq[i].msg != NULL; i++)
+			{
+				diag_printf("Each kind of test errors : %d - %08x.\n", i, tseq[i].errors);
+				diag_printf("Current test num %d : %s\n", v->test, tseq[v->test].msg);
+			}
+		}
+		if (v->erri.cor_err)
+		{
+			/* ECC enable - this dose make sense */
+		}
+	}
+}
+
+/*
+ * Print an ecc error
+ */
+void print_ecc_err(unsigned long page, unsigned long offset,
+	int corrected, unsigned short syndrome, int channel)
+{
+	++(v->ecc_ecount);
+	syn = syndrome;
+	chan = channel;
+	common_err((ulong *)page, offset, corrected, 0, 2);
+}
+
+#ifdef PARITY_MEM
+/*
+ * Print a parity error message
+ */
+void parity_err( unsigned long edi, unsigned long esi)
+{
+	unsigned long addr;
+
+	if (v->test == 5) {
+		addr = esi;
+	} else {
+		addr = edi;
+	}
+	common_err((ulong *)addr, addr & 0xFFF, 0, 0, 3);
+}
+#endif
+
+	
+/*
+ * Show progress by displaying elapsed time and update bar graphs
+ */
+void do_tick(void)
+{
+	/*
+	int i, n, pct;
+	ulong h, l, t;
+	*/
+
+	/* FIXME only print serial error messages from the tick handler */
+	if (v->ecount)
+	{
+		print_err_counts();
+	}
+
+	/* Poll for ECC errors */
+	poll_errors();
+}
+
--- u-boot-2011.03/sc_mfg_standalone/ram_test_main.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_standalone/ram_test_main.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,423 @@
+/***********************************************************************
+ * 			NewCastle Uboot Test Software Version 1.0      *
+ ***********************************************************************
+ * Module	: RAM Test					       *
+ ***********************************************************************/
+/*
+ * Header File
+ */
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include "sc_mfg.h"
+#include "ram_test.h"
+
+#define DEFTESTS 9
+
+/* TODO tests in designed sequence */
+struct tseq_t tseq[] = {
+/*	cache	pat	iter	ticks	errors	msg					*/
+	{0, 	5,	1,	0,	0,	"[Address test, walking ones, no cache]"},
+	{1, 	6,	1,	2,	0,	"[Address test, own address]"		},
+	{1, 	12, 	1,	14,	0,	"[Moving inversions, ones & zeros]"	},
+	{1, 	1,	1,	80,	0,	"[Moving inversions, 8 bit pattern]"	},
+	{1,	10,	1,	300,	0,	"[Moving inversions, random pattern]"	},
+	{1,	7,	1,	66,	0,	"[Block move, 64 moves]"		},
+	{1,	2,	1,	320,	0,	"[Moving inversions, 32 bit pattern]"	},
+	{1,	9,	1,	120,	0,	"[Random number sequence]"		},
+	{1,	11,	1,	1920,	0,	"[Modulo 20, Random pattern]"		},
+	{1,	3,	1,	1920,	0,	"[Module 20, ones & zeros]"		},
+	{1,	4,	1,	1920,	0,	"[Module 20, 8bit pattern]"		},
+	/*{1,	8,	1,	2,	0,	"[Bit fade test, 90 min, 2 patterns]"	},*/
+	{0,	0,	0,	0,	0,	NULL					}
+};
+
+
+struct mem_info_t mem_info;
+
+char firsttime = 0;
+struct vars variables = {};
+struct vars * v ;
+
+volatile ulong *p = 0;
+ulong p1 = 0, p2 = 0, p0 = 0;
+int bail = 0;
+/***********************************************************************/
+/*
+ * Initialize test, setup screen and find out how much memory there is.
+ */
+void init(void)
+{
+	int i;
+	
+	v = &variables;
+	/* Turn on cache */
+	/* default cache is open */
+	//set_cache(1);
+
+	/* Setup the display */
+	//display_init();
+	/****************************************************/
+	/* Determine the memory map			    */
+	/* TONY :					    */
+	/* (a) the X86 original code detects which BIOS is. */
+	/* 	remove it, for its useless on our platform  */
+	/* (b) the memory size reads from BIOS(pc/linux) Or */
+	/*	probe the memory size, I think this could be*/	
+	/*	omitted on our paltform			    */
+	/* (c) because there maybe several segments in x86  */
+	/*	system, so use 'v' data structure to store  */
+	/*	segments information such as every segments'*/
+	/*	start, end, and records total page bumber   */
+	/*     On our platform, there is no need to do such */
+	/* 	   action				    */
+	/****************************************************/
+	get_mem_map();
+	/****************************************************/
+	/* TONY : the original code do PCI_INIT here, REMOVE*/
+	/****************************************************/
+	v->test		= 0;
+	v->pass		= 0;
+	v->msg_line	= 0;
+	v->ecount	= 0;
+	v->ecc_ecount	= 0;
+	v->testsel	= -1;
+	
+	/* test range set !!! */
+	v->map.start = mem_info.start;
+	v->map.end = mem_info.end;
+
+
+	//get_cpu_freq();	
+	
+	for (i=0; tseq[i].msg != NULL; i++)
+	{
+		tseq[i].errors = 0;
+	}
+	/*************************************************************/
+	/* TONY :						     */
+	/* What is DMI ?					     */
+	/* Desktop Management Interface - hardcored on motherboard   */
+	/* on X86 PC system, which is used to gather system hardware */
+	/* information. --- REMOVE it on our platform		     */
+	/*************************************************************/
+	/* TONY CLOSE*/
+	/*
+	 * Need to find out CPU type before seting up pci. This is
+	 * because AMD Opterons dont have a host bridge on dev 0.
+	 */
+	/************************************************/
+	/* TONY :					*/
+	/* This function would find out CPU type of x86 */
+	/* system, and would get Cache L1 & L2 size, 	*/
+	/* Then CPU speed, L1 & L2 speed, Memory speed 	*/
+	/* All of the speed detection is based in RDTSC */
+	/* !!! PAY ATTECTION - this paltform related!   */
+	/************************************************/
+#if 0 /* tony : close for temp */
+	cpu_type();
+#endif
+	/* setup pci */
+	/************************************************/
+	/* TONY : I dont think PCI init is useful for us*/
+	/************************************************/
+	#if 0 /* tony */
+	pci_init();
+	#endif
+	/* Find the memory controller */
+	/************************************************/
+	/* TONY : Original code using this to what is   */
+	/* controlling memory , such as ECC (?), disable*/
+	/* ECC by now. Maybe we should follow this ???	*/
+	/************************************************/
+	/* I think disable ECC is good for us */
+#if 0
+	find_controller(); /* to disable ECC ? */
+#else
+	disable_DDR_ECC();
+#endif
+	/* print VAR init info */
+#if 0
+	/* ticks deal */
+	find_ticks();
+#endif
+}
+
+/* main thread part */
+int do_ram_test(void)
+{
+	int i = 0, j = 0;
+	int seq = 0;
+	
+	int err_no;
+
+
+	diag_printf("Going to do RAM test now ...\n");
+	/* If first time, initialize test */
+	if (firsttime == 0)
+	{
+		init();
+		firsttime = 1;
+	}
+	/* tony : useful for counter */
+	bail = 0;
+
+	/* Update display of memory segments being tested */
+
+	/* Now setup the test parameters based on the current test number */
+	/* Figure out the next test to run */
+	for(; tseq[seq].msg != NULL; seq++)
+	{
+
+		v->testsel = seq;
+		if (v->testsel >= 0)
+		{
+			v->test = v->testsel;
+		}
+		diag_printf("**************************************************************\n");
+		diag_printf("*  Test To be done : %s  *\n", tseq[v->test].msg);
+		diag_printf("**************************************************************\n");
+
+		set_cache(tseq[v->test].cache);
+		/* Have a way to cancel memory tests ... */
+		if (tstc () && getc () == 0x3) {
+			printf ("CTRL + C detected, Aborting memtests ...\n");
+			goto skip_test;
+		}
+		switch(tseq[v->test].pat)
+		{
+	
+		/* Now do the testing according to the selected pattern */
+		case 0:	/* Moving inversions, all ones and zeros */
+			p1 = 0;
+			p2 = ~p1;
+			movinv1(tseq[v->test].iter,p1,p2);
+			BAILOUT;
+		
+			/* Switch patterns */
+			p2 = p1;
+			p1 = ~p2;
+			movinv1(tseq[v->test].iter,p1,p2);
+			BAILOUT;
+			break;
+			
+		case 1: /* Moving inversions, 8 bit wide walking ones and zeros. */
+			p0 = 0x80;
+			for (i=0; i<8; i++, p0=p0>>1) {
+				p1 = p0 | (p0<<8) | (p0<<16) | (p0<<24);
+				p2 = ~p1;
+				movinv1(tseq[v->test].iter,p1,p2);
+				BAILOUT;
+		
+				/* Switch patterns */
+				p2 = p1;
+				p1 = ~p2;
+				movinv1(tseq[v->test].iter,p1,p2);
+				BAILOUT
+			}
+			break;
+	
+		case 2: /* Moving inversions, 32 bit shifting pattern, very long */
+			for (i=0, p1=1; p1; p1=p1<<1, i++) {
+				movinv32(tseq[v->test].iter,p1, 1, 0x80000000, 0, i);
+				BAILOUT
+				movinv32(tseq[v->test].iter,~p1, 0xfffffffe,0x7fffffff, 1, i);
+				BAILOUT
+			}
+			break;
+	
+		case 3: /* Modulo 20 check, all ones and zeros */
+			p1=0;
+			for (i=0; i<MOD_SZ; i++) {
+				p2 = ~p1;
+				modtst(i, tseq[v->test].iter, p1, p2);
+				BAILOUT
+	
+				/* Switch patterns */
+				p2 = p1;
+				p1 = ~p2;
+				modtst(i, tseq[v->test].iter, p1,p2);
+				BAILOUT
+			}
+			break;
+	
+		case 4: /* Modulo 20 check, 8 bit pattern */
+			p0 = 0x80;
+			for (j=0; j<8; j++, p0=p0>>1) {
+				p1 = p0 | (p0<<8) | (p0<<16) | (p0<<24);
+				for (i=0; i<MOD_SZ; i++) {
+					p2 = ~p1;
+					modtst(i, tseq[v->test].iter, p1, p2);
+					BAILOUT
+	
+					/* Switch patterns */
+					p2 = p1;
+					p1 = ~p2;
+					modtst(i, tseq[v->test].iter, p1, p2);
+					BAILOUT
+				}
+			}
+			break;
+		case 5: /* Address test, walking ones */
+			addr_tst1();
+			BAILOUT;
+			break;
+	
+		case 6: /* Address test, own address */
+			addr_tst2();
+			BAILOUT;
+			break;
+	
+		case 7: /* Block move test */
+			block_move(tseq[v->test].iter);
+			BAILOUT;
+			break;
+		case 8: /* Bit fade test */
+			bit_fade();
+
+			BAILOUT;
+			break;
+		case 9: /* Random Data Sequence */
+			for (i=0; i < tseq[v->test].iter; i++) {
+				movinvr();
+				BAILOUT;
+			}
+			break;
+		case 10: /* Random Data */
+			for (i=0; i < tseq[v->test].iter; i++) {
+				p1 = rand();
+				p2 = ~p1;
+				movinv1(2,p1,p2);
+				BAILOUT;
+			}
+			break;
+	
+		case 11: /* Modulo 20 check, Random pattern */
+			for (j=0; j<tseq[v->test].iter; j++) {
+				p1 = rand();
+				for (i=0; i<MOD_SZ; i++) {
+					p2 = ~p1;
+					modtst(i, tseq[v->test].iter, p1, p2);
+					BAILOUT
+	
+					/* Switch patterns */
+					p2 = p1;
+					p1 = ~p2;
+					modtst(i, tseq[v->test].iter, p1, p2);
+					BAILOUT
+				}
+			}
+			break;
+		}
+		diag_printf("*********************************************\n");
+		diag_printf("*	   Test item %d OVER                 *\n", seq);
+		diag_printf("*********************************************\n");
+		diag_printf("\n");
+		diag_printf("\n");
+	}
+skip_test:
+	if (v->ecount == 0)
+	{
+		diag_printf("Pass %d complete, no errors\n", v->pass);
+		v->pass++;
+		test_complete_enable_caches();
+		set_cache(1);
+
+		return TEST_OK;
+	}
+	else
+	{
+		
+		diag_printf("Test Have Errors.\n");
+		test_complete_enable_caches();
+		set_cache(1);
+		
+		err_no = tseq[v->test].pat;
+
+		return err_no;
+	}	
+	/* Rever to the default mapping and enable the cache */
+#if 0
+	/* TONY : we won't use ECC feature */
+	enable_DDR_ECC();
+#endif
+}
+
+int find_ram_test_item(int pat)
+{
+	int i = 0;
+	
+	for(;i < sizeof(tseq)/sizeof(struct tseq_t); i++)
+	{
+		/* success to find index */
+		if(pat == tseq[i].pat)
+			return i;
+	}
+	
+	/* fail to find */
+	return -1;
+}
+
+extern unsigned int err_address;
+extern int err_test_type;
+extern char errbitmask;
+
+/*
+ * Main Test Entry for RAM Test
+ */
+int Ram_Test(void)
+{
+	int ret = -1;
+	int idx = -1;
+
+	ret = do_ram_test();
+
+	if (ret == TEST_OK) {
+		memcpy(test_result, TEST_DRAM_PASS_STR, sizeof(TEST_DRAM_PASS_STR));
+
+		test_result[TEST_RESULT_OFF] = DRAM_TEST_OK;
+		set_result_state = Set_Test_Result( test_result, DRAM_TEST_ITEM );
+
+		printf("DRAM Test Pass \n");
+
+		if (set_result_state) {
+			printf("write the DRAM Test (OK) is fail \n");
+			return SC_MFG_TEST_OP_FAIL;
+		}
+		else {
+			printf("write the DRAM Test (OK) is OK \n");
+			return SC_MFG_TEST_OP_PASS;
+		}
+	}
+	else {
+		printf("DRAM Test Fail \n");
+		memcpy(test_result, TEST_DRAM_FAIL_STR, sizeof(TEST_DRAM_FAIL_STR));
+
+		idx = find_ram_test_item(ret);
+
+		if (idx != -1) {
+			printf("%s", tseq[idx].msg);
+			test_result[TEST_RESULT_OFF] = ret;
+
+			/* record the reasons for DRAM test Failure */
+			*(unsigned int *)&test_result[DRAM_TEST_ERR_ADDR] = err_address;
+			*(int *)&test_result[DRAM_TEST_ERR_TYPE] = err_test_type;
+			*(char *)&test_result[DRAM_TEST_ERR_CHIP] = errbitmask;
+		}
+		else { /* unknown fail return value */
+			test_result[TEST_RESULT_OFF] = DRAM_TEST_FAIL_UNKNOWN;
+		}
+
+		set_result_state = Set_Test_Result( test_result, DRAM_TEST_ITEM );
+		if (set_result_state) {
+			printf("write the DRAM Test (fail) is fail \n");
+		}
+		else {
+			printf("write the DRAM Test (fail) is OK \n");
+		}
+		return SC_MFG_TEST_OP_FAIL;
+	}
+}
+
+
--- "u-boot-2011.03/sc_mfg_standalone/Sercomm License.txt.orig"	1969-12-31 16:00:00.000000000 -0800
+++ "u-boot-2011.03/sc_mfg_standalone/Sercomm License.txt"	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1 @@
+Copyright ? 2005 SerComm Corporation. All Rights Reserved. SerComm Corporation reserves the right to make changes to this document without notice. SerComm Corporation makes no warranty, representation or guarantee regarding the suitability of its products for any particular purpose. SerComm Corporation assumes no liability arising out of the application or use of any product or circuit. SerComm Corporation specifically disclaims any and all liability, including without limitation consequential or incidental damages; neither does it convey any license under its patent rights, nor the rights of others.
\ No newline at end of file
--- u-boot-2011.03/sc_mfg_cmd/sc_mfg_cmd.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_cmd/sc_mfg_cmd.h	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,21 @@
+#ifndef _SC_MFG_CMD_H_
+#define _SC_MFG_CMD_H_
+
+#define SC_MFG_LED_TEST		"0"
+#define SC_MFG_NOR_TEST		"1"
+#define SC_MFG_NAND_TEST	"2"
+#define SC_MFG_DRAM_TEST	"3"
+#define SC_MFG_RTC_TEST		"4"
+#define SC_MFG_PCI_TEST		"5"
+#define SC_MFG_TEST_RESULTS	"6"
+
+#ifndef STANDALONE_LOAD_ADDR
+#define STANDALONE_LOAD_ADDR 0x1000000
+#endif
+
+#define STR_GO_ADDR		      "1000004"
+
+int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+
+#endif /* _SC_MFG_CMD_H_ */
+
--- u-boot-2011.03/sc_mfg_cmd/sc_mfg_cmd.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_cmd/sc_mfg_cmd.c	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,211 @@
+/*
+ * Header Files
+ */
+#include <asm/cache.h>
+#include <common.h>
+#include <command.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <exports.h>
+
+#include "sc_mfg_cmd.h"
+
+/*--------------------------------------------------------------------*/
+/*
+ * U_BOOT_CMD definition list for sc_mfg_test
+ */
+
+int do_sc_mfg_led_e (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int arg_c;
+	char *arg_v[10];
+
+	memcpy((char *)STANDALONE_LOAD_ADDR, (char *)(SC_STANDALONE_BIN_ADDR + 0xEFF00000), SC_STANDALONE_BIN_SIZE);
+	
+	flush_dcache();
+	invalidate_icache();	
+	
+	arg_c = 3;
+	
+	arg_v[0] = "go";
+	arg_v[1] = STR_GO_ADDR;
+	arg_v[2] = SC_MFG_LED_TEST;
+		
+	do_go(NULL, 0, arg_c, arg_v);
+	
+	return 0;	
+}
+
+U_BOOT_CMD(
+    led_test_e,		1,	1,	do_sc_mfg_led_e,
+    "sc mfg LED test",
+    ""
+);
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_dram_e (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int arg_c;
+	char *arg_v[10];
+
+	memcpy((char *)STANDALONE_LOAD_ADDR, (char *)(SC_STANDALONE_BIN_ADDR + 0xEFF00000), SC_STANDALONE_BIN_SIZE);
+	
+	flush_dcache();
+	invalidate_icache();	
+	
+	arg_c = 3;
+	
+	arg_v[0] = "go";
+	arg_v[1] = STR_GO_ADDR;
+	arg_v[2] = SC_MFG_DRAM_TEST;
+		
+	do_go(NULL, 0, arg_c, arg_v);
+	
+	return 0;	
+}
+
+U_BOOT_CMD(
+    ram_test_e,	1,		1,	do_sc_mfg_dram_e,
+    "sc mfg DRAM test",
+    ""
+);
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_nor_e (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int arg_c;
+	char *arg_v[10];
+
+	memcpy((char *)STANDALONE_LOAD_ADDR, (char *)(SC_STANDALONE_BIN_ADDR + 0xEFF00000), SC_STANDALONE_BIN_SIZE);
+	
+	flush_dcache();
+	invalidate_icache();	
+	
+	arg_c = 3;
+	
+	arg_v[0] = "go";
+	arg_v[1] = STR_GO_ADDR;
+	arg_v[2] = SC_MFG_NOR_TEST;
+		
+	do_go(NULL, 0, arg_c, arg_v);
+	
+	return 0;	
+}
+
+U_BOOT_CMD(
+    nor_flash_check_e,	1,		1,	do_sc_mfg_nor_e,
+    "sc mfg NOR flash test",
+    ""
+);
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_nand_e (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int arg_c;
+	char *arg_v[10];
+
+	memcpy((char *)STANDALONE_LOAD_ADDR, (char *)(SC_STANDALONE_BIN_ADDR + 0xEFF00000), SC_STANDALONE_BIN_SIZE);
+	
+	flush_dcache();
+	invalidate_icache();	
+	
+	arg_c = 3;
+	
+	arg_v[0] = "go";
+	arg_v[1] = STR_GO_ADDR;
+	arg_v[2] = SC_MFG_NAND_TEST;
+		
+	do_go(NULL, 0, arg_c, arg_v);
+	
+	return 0;	
+}
+
+U_BOOT_CMD(
+    nand_test_e,	1,		1,	do_sc_mfg_nand_e,
+    "sc mfg NAND flash test",
+    ""
+);
+
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_rtc_e (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int arg_c;
+	char *arg_v[10];
+
+	memcpy((char *)STANDALONE_LOAD_ADDR, (char *)(SC_STANDALONE_BIN_ADDR + 0xEFF00000), SC_STANDALONE_BIN_SIZE);
+	
+	flush_dcache();
+	invalidate_icache();	
+	
+	arg_c = 3;
+	
+	arg_v[0] = "go";
+	arg_v[1] = STR_GO_ADDR;
+	arg_v[2] = SC_MFG_RTC_TEST;
+		
+	do_go(NULL, 0, arg_c, arg_v);
+	
+	return 0;	
+}
+
+U_BOOT_CMD(
+    rtc_test_e,	1,		1,	do_sc_mfg_rtc_e,
+    "sc mfg RTC test",
+    ""
+);
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_pci_e (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int arg_c;
+	char *arg_v[10];
+
+	memcpy((char *)STANDALONE_LOAD_ADDR, (char *)(SC_STANDALONE_BIN_ADDR + 0xEFF00000), SC_STANDALONE_BIN_SIZE);
+	
+	flush_dcache();
+	invalidate_icache();	
+	
+	arg_c = 3;
+	
+	arg_v[0] = "go";
+	arg_v[1] = STR_GO_ADDR;
+	arg_v[2] = SC_MFG_PCI_TEST;
+		
+	do_go(NULL, 0, arg_c, arg_v);
+	
+	return 0;		
+}
+
+U_BOOT_CMD(
+    pci_test_e,	1,		1,	do_sc_mfg_pci_e,
+    "sc mfg PCI test",
+    ""
+);
+/*--------------------------------------------------------------------*/
+int do_sc_mfg_read_results_e (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int arg_c;
+	char *arg_v[10];
+
+	memcpy((char *)STANDALONE_LOAD_ADDR, (char *)(SC_STANDALONE_BIN_ADDR + 0xEFF00000), SC_STANDALONE_BIN_SIZE);
+	
+	flush_dcache();
+	invalidate_icache();	
+	
+	arg_c = 3;
+	
+	arg_v[0] = "go";
+	arg_v[1] = STR_GO_ADDR;
+	arg_v[2] = SC_MFG_TEST_RESULTS;
+		
+	do_go(NULL, 0, arg_c, arg_v);
+	
+	return 0;	
+}
+
+U_BOOT_CMD(
+    read_test_result_e,	1,		1,	do_sc_mfg_read_results_e,
+    "sc mfg read test results",
+    ""
+);
+
+/* eof */
--- u-boot-2011.03/sc_mfg_cmd/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/sc_mfg_cmd/Makefile	2022-05-09 14:05:11.836043538 -0700
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2004-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)libscmfg_external.a
+
+AOBJS	=
+
+# command 
+COBJS-y += sc_mfg_cmd.o
+
+COBJS	:= $(sort $(COBJS-y))
+SRCS	:= $(AOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(AOBJS) $(COBJS))
+
+CPPFLAGS += -I..
+CFLAGS   += -D_SC_MFG_STANDALONE_ -DSC_STANDALONE_BIN_ADDR=0x20000 -DSC_STANDALONE_BIN_SIZE=0x20000
+
+all:	$(LIB) $(AOBJS)
+
+$(LIB): $(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- u-boot-2011.03/include/tpm.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/tpm.h	2022-05-09 14:05:11.804044836 -0700
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+//#ifndef _INCLUDE_TPM_H_
+//#define _INCLUDE_TPM_H_
+
+#include <common.h>
+
+/*
+ * tis_init()
+ *
+ * Initialize the TPM device. Returns 0 on success or -1 on
+ * failure (in case device probing did not succeed).
+ */
+int tis_init(void);
+
+/*
+ * tis_open()
+ *
+ * Requests access to locality 0 for the caller. After all commands have been
+ * completed the caller is supposed to call tis_close().
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+int tis_open(void);
+
+/*
+ * tis_close()
+ *
+ * terminate the currect session with the TPM by releasing the locked
+ * locality. Returns 0 on success of -1 on failure (in case lock
+ * removal did not succeed).
+ */
+int tis_close(void);
+
+/*
+ * tis_sendrecv()
+ *
+ * Send the requested data to the TPM and then try to get its response
+ *
+ * @sendbuf - buffer of the data to send
+ * @send_size size of the data to send
+ * @recvbuf - memory to save the response to
+ * @recv_len - pointer to the size of the response buffer
+ *
+ * Returns 0 on success (and places the number of response bytes at recv_len)
+ * or -1 on failure.
+ */
+int tis_sendrecv(const uint8_t *sendbuf, size_t send_size, uint8_t *recvbuf,
+			size_t *recv_len);
+
+//#endif /* _INCLUDE_TPM_H_ */
--- u-boot-2011.03/include/linux/compiler-gcc6.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/linux/compiler-gcc6.h	2022-05-09 14:05:11.784045647 -0700
@@ -0,0 +1,61 @@
+#ifdef CONFIG_WG_PLATFORM_BACKPORT /* FBX-9469 */
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc6.h> directly, include <linux/compiler.h> instead."
+#endif
+
+#define __used				__attribute__((__used__))
+#define __must_check			__attribute__((warn_unused_result))
+#define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+
+/* Mark functions as cold. gcc will assume any path leading to a call
+   to them will be unlikely.  This means a lot of manual unlikely()s
+   are unnecessary now for any paths leading to the usual suspects
+   like BUG(), printk(), panic() etc. [but let's keep them for now for
+   older compilers]
+
+   gcc also has a __attribute__((__hot__)) to move hot functions into
+   a special section, but I don't see any sense in this right now in
+   the kernel context */
+#define __cold			__attribute__((__cold__))
+
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+
+/*
+ * Mark a position in code as unreachable.  This can be used to
+ * suppress control flow warnings after asm blocks that transfer
+ * control elsewhere.
+ */
+#define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__))
+
+/*
+ * Tell the optimizer that something else uses this function or variable.
+ */
+#define __visible __attribute__((externally_visible))
+
+/*
+ * GCC 'asm goto' miscompiles certain code sequences:
+ *
+ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+ *
+ * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+ *
+ * (asm goto is automatically volatile - the naming reflects this.)
+ */
+#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+
+#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+#define __HAVE_BUILTIN_BSWAP32__
+#define __HAVE_BUILTIN_BSWAP64__
+#define __HAVE_BUILTIN_BSWAP16__
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
+
+#define KASAN_ABI_VERSION 4
+#endif /* CONFIG_WG_PLATFORM_BACKPORT */
--- u-boot-2011.03/include/random.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/random.h	2022-05-09 14:05:11.800044998 -0700
@@ -0,0 +1,7 @@
+/* concatenation of following two 16-bit multiply with carry generators */
+/* x(n)=a*x(n-1)+carry mod 2^16 and y(n)=b*y(n-1)+carry mod 2^16, */
+/* number and carry packed within the same 32 bit integer.        */
+/******************************************************************/
+
+unsigned int rand( void );           /* returns a random 32-bit integer */
+void  rand_seed( unsigned int, unsigned int );      /* seed the generator */
--- u-boot-2011.03/include/wgmenu.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/wgmenu.h	2022-05-09 14:05:11.812044511 -0700
@@ -0,0 +1,11 @@
+#ifndef _WGMENU_H
+#define _WGMENU_H
+
+int wgmenu_hook(int key);
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user);
+void wgmenu_show(void);
+int wgmenu_selected(void);
+int wgmenu_inmenu(void);
+void wgmenu_exit(void);
+
+#endif /* _WGMENU_H */
--- u-boot-2011.03/include/configs/XTM2_3.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/configs/XTM2_3.h	2022-05-09 14:05:11.720048242 -0700
@@ -0,0 +1,746 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * P1 P2 RDB board configuration file
+ * This file is intended to address a set of Low End and Ultra Low End
+ * Freescale SOCs of QorIQ series(RDB platforms).
+ * Currently only P2020RDB
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef CONFIG_NAND
+#define CONFIG_NAND_U_BOOT		1
+#define CONFIG_RAMBOOT_NAND		1
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_SYS_TEXT_BASE_SPL 0xfff00000
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE_SPL /* start of monitor */
+#else
+#define CONFIG_SYS_TEXT_BASE		0xf8f82000
+#endif /* CONFIG_NAND_SPL */
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RAMBOOT_SDCARD		1
+#define CONFIG_SYS_TEXT_BASE		0xf8f80000
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define CONFIG_RAMBOOT_SPIFLASH		1
+#define CONFIG_SYS_TEXT_BASE		0xf8f80000
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#if defined(CONFIG_XTM2_1M) || defined(CONFIG_XTM3_1M)
+# ifndef CONFIG_SYS_TEXT_BASE
+#  define CONFIG_SYS_TEXT_BASE		0xeff80000
+# endif /* ifndef CONFIG_SYS_TEXT_BASE */
+#else /* !defined(CONFIG_XTM2_1M) || !defined(CONFIG_XTM3_1M) */
+# ifndef CONFIG_SYS_TEXT_BASE
+#  ifndef CONFIG_FAILSAFE
+#   define CONFIG_SYS_TEXT_BASE		0xeff80000
+#  else /* defined CONFIG_FAILSAFE */
+#   define CONFIG_SYS_TEXT_BASE		0xefe80000
+#  endif
+# endif
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41/48/P1020/P2020,etc*/
+#define CONFIG_FSL_ELBC		1	/* Enable eLBC Support */
+
+#define CONFIG_PCI		1	/* Enable PCI/PCIE */
+#if defined(CONFIG_PCI)
+#define CONFIG_PCIE1		1	/* PCIE controler 1 (slot 1) */
+#define CONFIG_PCIE2		1	/* PCIE controler 2 (slot 2) */
+#define CONFIG_FSL_PCI_INIT	1	/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET	1	/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT	1	/* enable 64-bit PCI resources */
+#endif /* #if defined(CONFIG_PCI) */
+#define CONFIG_FSL_LAW		1	/* Use common FSL init code */
+#define CONFIG_TSEC_ENET		/* tsec ethernet support */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_SERCOMM_MFG		/* WG:BH - Enable Sercomm manufacturing code */
+#define CONFIG_WG_COMMON_MFG		/* WG:BH - Enable WatchGuard common manufacturing code */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_board_sys_clk(unsigned long dummy);
+#endif
+#define CONFIG_DDR_CLK_FREQ	66666666 
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk(0)
+
+#if defined(CONFIG_XTM3)
+#define CONFIG_MP
+#endif
+
+#define CONFIG_HWCONFIG
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ADDR_STREAMING		/* toggle addr streaming */
+
+#define CONFIG_ENABLE_36BIT_PHYS	1
+
+#define CONFIG_SYS_MEMTEST_START	0x00000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x1fffffff
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+ /*
+  * Config the L2 Cache as L2 SRAM
+  */
+#define CONFIG_SYS_INIT_L2_ADDR		0xf8f80000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_L2_ADDR_PHYS	0xff8f80000ull
+#else
+#define CONFIG_SYS_INIT_L2_ADDR_PHYS	CONFIG_SYS_INIT_L2_ADDR
+#endif
+#define CONFIG_SYS_L2_SIZE		(512 << 10)
+#define CONFIG_SYS_INIT_L2_END		(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_L2_SIZE)
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CONFIG_SYS_CCSRBAR		0xffe00000	/* relocated CCSRBAR */
+#define CONFIG_SYS_CCSRBAR_PHYS	CONFIG_SYS_CCSRBAR	/* physical addr of */
+							/* CCSRBAR */
+#define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses */
+							/* CONFIG_SYS_IMMR */
+
+#if defined(CONFIG_RAMBOOT_NAND) && !defined(CONFIG_NAND_SPL)
+#define CONFIG_SYS_CCSRBAR_DEFAULT	CONFIG_SYS_CCSRBAR
+#else
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000      /* CCSRBAR Default */
+#endif
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR3
+#undef CONFIG_FSL_DDR_INTERACTIVE
+#undef CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup */
+
+#define CONFIG_MEM_INIT_VALUE	0xDeadBeef
+
+#if defined(CONFIG_XTM2_1M)
+#define CONFIG_SYS_SDRAM_SIZE	512
+#else
+#define CONFIG_SYS_SDRAM_SIZE	1024
+#endif
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+#define CONFIG_SYS_DDR_ERR_INT_EN	0x0000000d
+#define CONFIG_SYS_DDR_ERR_DIS		0x00000000
+#define CONFIG_SYS_DDR_SBE		0x00FF0000
+
+/*
+ * Memory map
+ *
+ * 0x0000_0000	0x3fff_ffff	DDR			1G cacheablen
+ * 0x8000_0000	0xbfff_ffff	PCI Express Mem		1G non-cacheable
+ * 0xffc0_0000	0xffc3_ffff	PCI IO range		256K non-cacheable
+ *
+ * Localbus cacheable (TBD)
+ * 0xXXXX_XXXX	0xXXXX_XXXX	SRAM			YZ M Cacheable
+ *
+ * Localbus non-cacheable
+ * 0xefe0_0000	0xefff_ffff	FLASH			2M non-cacheable
+ * 0xffa0_0000	0xffaf_ffff	NAND			1M non-cacheable
+ * 0xffb0_0000	0xffbf_ffff	VSC7385 switch		1M non-cacheable
+ * 0xffd0_0000	0xffd0_3fff	L1 for stack		16K Cacheable TLB0
+ * 0xffe0_0000	0xffef_ffff	CCSR			1M non-cacheable
+ */
+
+/*
+ * Local Bus Definitions
+ */
+#if defined(CONFIG_XTM2_1M) || defined(CONFIG_XTM3_1M)
+
+/* I2C SYSMON */
+#define CONFIG_CMD_DTT
+#define CONFIG_DTT_LM63         1       /* National LM63        */
+#define CONFIG_DTT_SENSORS      { 0x4C }   /* Sensor addresses     */
+#define CONFIG_DTT_PWM_LOOKUPTABLE      \
+	{ { 60, 7 }, { 65, 8 }, { 70, 9 }, { 75, 10 }, { 80, 11 }, { 85, 12 }, { 90, 13  }, { 95, 14 } } /* temp/PWM value pairs */
+	/* { { 60, 50.00 }, { 65, 57.14 }, { 70, 64.29 }, { 75, 71.43 }, { 80, 78.57 }, { 85, 85.71 }, { 90, 92.86  }, { 95, 100 } } */ /* relative temp/Duty cycle value pairs */
+
+#define CONFIG_DTT_TACH_LIMIT   0xa10
+
+# define CONFIG_SYS_FLASH_BASE		0xeff00000	/* start of FLASH 1M */
+# define CONFIG_SYS_FLASH_SIZE		0x100000
+# define CONFIG_SYS_FLASH_SECT_SIZE	CONFIG_ENV_SECT_SIZE    /* 64K (one sector) */
+#else
+# define CONFIG_SYS_FLASH_BASE		0xefe00000	/* start of FLASH 2M */
+# define CONFIG_SYS_FLASH_SIZE		0x200000
+# define CONFIG_SYS_FLASH_SECT_SIZE	CONFIG_ENV_SECT_SIZE    /* 64K (one sector) */
+#endif
+
+#define FL_SIZE_UBOOT 		0x80000
+#define FL_SIZE_TEST_RESULT	0x10000
+
+/* TEST_RESULT_OFFSET is location where the test results are stored */
+#define TEST_RESULT_OFFSET	(CONFIG_SYS_FLASH_SIZE - FL_SIZE_UBOOT - CONFIG_ENV_SIZE - FL_SIZE_TEST_RESULT)	/* before ENV sector */
+
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_FLASH_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+					BR_PS_16 | BR_V)
+
+#if defined(CONFIG_XTM2_1M) || defined(CONFIG_XTM3_1M)
+# define CONFIG_FLASH_OR_PRELIM		0xfff00831	/* flash 1MB*/
+#else
+# define CONFIG_FLASH_OR_PRELIM		0xffe00831	/* flash 2MB*/
+#endif
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE}
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS 45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 128
+
+#undef	CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#if defined(CONFIG_RAMBOOT_NAND) || defined(CONFIG_RAMBOOT_SDCARD) || \
+    defined(CONFIG_RAMBOOT_SPIFLASH)
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#else
+#undef CONFIG_SYS_RAMBOOT
+#endif
+
+/*
+#ifndef CONFIG_FAILSAFE
+// protect failsafe region 0xeff80000 ~ 0xefffffff 
+#define CONFIG_SYS_FLASH_AUTOPROTECT_LIST {{0xeff80000, 0x80000}}
+#endif
+*/
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_AMD_CHECK_DQ7
+
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+#define CONFIG_HWCONFIG
+
+#define CONFIG_SYS_INIT_RAM_LOCK	1
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* stack in RAM */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000	/* Size of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE \
+						- GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon*/
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc*/
+
+#ifndef CONFIG_NAND_SPL
+#define CONFIG_SYS_NAND_BASE		0xffa00000
+#else
+#define CONFIG_SYS_NAND_BASE		0xfff00000
+#endif
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#define CONFIG_SYS_NAND_BASE_LIST	{CONFIG_SYS_NAND_BASE}
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS			1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND			1
+#define CONFIG_NAND_FSL_ELBC		1
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+/* NAND boot: 4K NAND loader config */
+#define CONFIG_SYS_NAND_SPL_SIZE	0x1000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	((512 << 10) - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(CONFIG_SYS_INIT_L2_ADDR)
+#define CONFIG_SYS_NAND_U_BOOT_START	(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_NAND_SPL_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(0)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC	(CONFIG_SYS_INIT_L2_END - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC_SP		((CONFIG_SYS_INIT_L2_END - 1) & ~0xF)
+
+/* NAND flash config */
+#define CONFIG_NAND_BR_PRELIM	(CONFIG_SYS_NAND_BASE_PHYS \
+				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+				| BR_PS_8	/* Port Size = 8 bit */ \
+				| BR_MS_FCM		/* MSEL = FCM */ \
+				| BR_V)			/* valid */
+
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
+				| OR_FCM_PGS \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+
+#ifdef CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#endif
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_NS16550_MIN_FUNCTIONS
+#endif
+
+#define CONFIG_SERIAL_MULTI	1 /* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT		1
+#define CONFIG_OF_BOARD_SETUP		1
+#define CONFIG_OF_STDOUT_VIA_ALIAS	1
+
+/* new uImage format support */
+#define CONFIG_FIT		1
+#define CONFIG_FIT_VERBOSE	1 /* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support */
+#undef	CONFIG_SOFT_I2C		/* I2C bit-banged */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed and slave address*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x54
+#define CONFIG_SYS_I2C_SLAVE            0x7F
+#define CONFIG_SYS_I2C_NOPROBES	{{0,0x29}}	/* Don't probe these addrs */
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/*
+ * I2C2 EEPROM
+ */
+#define CONFIG_ID_EEPROM
+#ifdef CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#endif
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x54
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+
+#define CONFIG_RTC_S35390
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+#if defined(CONFIG_PCI)
+/* controller 2, Slot 2, tgtid 2, Base address 9000 */
+#define CONFIG_SYS_PCIE2_NAME		"Slot 1"
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 1, Slot 1, tgtid 1, Base address a000 */
+#define CONFIG_SYS_PCIE1_NAME		"Slot 2"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#undef CONFIG_EEPRO100
+#undef CONFIG_TULIP
+#undef CONFIG_RTL8139
+
+#ifdef CONFIG_RTL8139
+/* This macro is used by RTL8139 but not defined in PPC architecture */
+#define KSEG1ADDR(x)		(x)
+#define _IO_BASE	0x00000000
+#endif
+
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+
+#endif	/* CONFIG_PCI */
+
+#define CONFIG_NET_MULTI	1
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_MII		1	/* MII PHY management */
+#define CONFIG_MII_DEFAULT_TSEC	1	/* Allow unregistered phys */
+#define CONFIG_TSEC1	1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#define CONFIG_TSEC3	1
+#define CONFIG_TSEC3_NAME	"eTSEC3"
+
+#define TSEC1_PHY_ADDR          0x10
+#define TSEC3_PHY_ADDR          1
+
+#define TSEC1_FLAGS             (TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS             (TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC1_PHYIDX            0
+#define TSEC3_PHYIDX            0
+
+#define CONFIG_ETHPRIME		"eTSEC1"
+
+#define CONFIG_PHY_GIGE		1	/* Include GbE speed/duplex detection */
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_RAMBOOT_NAND)
+	#define CONFIG_ENV_IS_IN_NAND	1
+	#define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+	#define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_RAMBOOT_SDCARD) || defined(CONFIG_RAMBOOT_SPIFLASH)
+	#define CONFIG_ENV_IS_NOWHERE	1	/* Store ENV in memory only */
+	#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - 0x1000)
+	#define CONFIG_ENV_SIZE		0x2000
+#endif
+#else
+	#define CONFIG_ENV_IS_IN_FLASH	1
+                #define CONFIG_ENV_ADDR         (CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+                #define CONFIG_ENV_SIZE         0x10000
+                #define CONFIG_ENV_SECT_SIZE    0x10000 /* 64K (one sector) (check comments near def of CONFIG_SYS_MAX_FLASH_SECT) */
+#endif
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#include <version.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#if defined(CONFIG_PCI)
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PCI
+#endif
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+
+#define CONFIG_BOARD_EARLY_INIT_F      1       /* Call board_pre_init */
+#define CONFIG_DOS_PARTITION
+
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#endif
+
+#if defined(CONFIG_USB_EHCI)
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+
+#ifdef CONFIG_FAILSAFE
+# if defined (CONFIG_XTM3)
+#   define CONFIG_SYS_PROMPT      "XTM3(FAILSAFE) => " /* Monitor Command Prompt */
+# elif defined (CONFIG_XTM2)
+#   define CONFIG_SYS_PROMPT      "XTM2(FAILSAFE) => " /* Monitor Command Prompt */
+# else
+#   define CONFIG_SYS_PROMPT      "(FAILSAFE) => " /* Monitor Command Prompt */
+# endif
+#else
+# if defined (CONFIG_XTM3)
+#   define CONFIG_SYS_PROMPT      "XTM3 => "           /* Monitor Command Prompt */
+# elif defined (CONFIG_XTM2)
+#   define CONFIG_SYS_PROMPT      "XTM2 => "           /* Monitor Command Prompt */
+# else
+#   define CONFIG_SYS_PROMPT      "=> " /* Monitor Command Prompt */
+# endif
+#endif
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+						/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 16 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(16 << 20)/* Initial Memory map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(16 << 20)	/* Increase max gunzip size */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#endif
+
+#if defined (CONFIG_XTM2)
+#define CONFIG_HOSTNAME		XTM2
+#define CONFIG_FDTFILE		wg_newcastle.dtb
+#elif defined (CONFIG_XTM3)
+#define CONFIG_HOSTNAME		XTM3
+#define CONFIG_FDTFILE		wg_newport.dtb
+#endif
+#define CONFIG_ROOTPATH		/opt/nfsroot
+#define CONFIG_BOOTFILE		uImage
+#define CONFIG_UBOOTPATH	u-boot.bin /* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY 5	/* -1 disables auto-boot */
+
+/* WatchGuard BootMenu */
+#define CONFIG_WG_BOOTMENU
+
+#undef  CONFIG_BOOTARGS		/* the boot command will set bootargs */
+
+#define CONFIG_BAUDRATE	115200
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"netdev=eth0\0"						\
+	"uboot=" MK_STR(CONFIG_UBOOTPATH) "\0"				\
+	"loadaddr=1000000\0"			\
+	"tftpflash=tftpboot $loadaddr $uboot; "			\
+		"protect off " MK_STR(CONFIG_SYS_TEXT_BASE) " +$filesize; "	\
+		"erase " MK_STR(CONFIG_SYS_TEXT_BASE) " +$filesize; "		\
+		"cp.b $loadaddr " MK_STR(CONFIG_SYS_TEXT_BASE) " $filesize; "	\
+		"protect on " MK_STR(CONFIG_SYS_TEXT_BASE) " +$filesize; "		\
+		"cmp.b $loadaddr " MK_STR(CONFIG_SYS_TEXT_BASE) " $filesize\0"	\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=" MK_STR(CONFIG_FDTFILE) "\0"		\
+	"bdev=sda1\0"	\
+	"jffs2nor=mtdblock3\0"	\
+	"norbootaddr=ef080000\0"	\
+	"norfdtaddr=ef040000\0"	\
+	"SysARoot=mtdblock8\0"	\
+	"SysBRoot=mtdblock10\0"	\
+	"SysARootAddr=520000\0"	\
+	"SysBRootAddr=8400000\0"	\
+	"SysAKernAddr=20000\0"	\
+	"SysAKernSize=500000\0"	\
+	"SysBKernAddr=7f00000\0"	\
+	"SysBKernSize=500000\0"		\
+	"DTBAddr=0\0"		\
+	"DTBSize=20000\0"		\
+	"SysAMfgRootSize=2000000\0"	\
+	"SysBMfgRootSize=800000\0"	\
+	"usb_phy_type=ulpi\0"		\
+	"othbootargs=ramdisk_size=600000\0" \
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"lannerboot=setenv bootargs root=/dev/ram rw " \
+	"rootdelay=10 console=ttyS0,115200;" \
+	"usb start;" \
+	"fatload usb 0 $loadaddr $bootfile;" \
+	"fatload usb 0 $ramdiskaddr $ramdiskfile;" \
+	"fatload usb 0 $fdtaddr xtm505_p2020.dtb;" \
+	"bootm $loadaddr $ramdiskaddr $fdtaddr;\0" \
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"norboot=setenv bootargs root=/dev/$jffs2nor rw "	\
+	"console=$consoledev,$baudrate rootfstype=jffs2 $othbootargs;"	\
+	"bootm $norbootaddr - $norfdtaddr\0"		\
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysBKernAddr $SysBKernSize;"	\
+	"bootm;\0"			\
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootMfgsys=setenv bootargs rdinit=/sbin/init " \
+	"console=$consoledev,$baudrate;"			\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"nand read $ramdiskaddr $SysARootAddr $SysAMfgRootSize;"	\
+	"bootm $loadaddr:kernel@1 $ramdiskaddr $loadaddr:fdt@1; \0"	\
+	"wgBootSercomm=setenv bootargs root=/dev/ram rw " \
+	"console=$consoledev,$baudrate $othbootargs;"			\
+	"nand read $loadaddr $SysBKernAddr $SysAKernSize;"	\
+	"nand read $fdtaddr $DTBAddr $DTBSize;"	\
+	"nand read $ramdiskaddr $SysBRootAddr $SysBMfgRootSize;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr;\0"			\
+	"bootloader_normal_update=protect off 0xeff80000 0xefffffff;" \
+	"erase 0xeff80000 0xefffffff;" \
+	"cp.b $loadaddr 0xeff80000 0x80000;" \
+	"cmp.b $loadaddr 0xeff80000 0x80000;\0"\
+	"nuke_env=protect off 0xeff70000 0xeff7ffff;" \
+	"erase 0xeff70000 0xeff7ffff; \0" \
+	"ethaddr=00:c0:02:12:35:88\0"  \
+	"eth1addr=00:c0:02:12:35:89\0"  \
+	"eth2addr=00:c0:02:12:35:90\0"  \
+	"uboot_built_info=" U_BOOT_VERSION " - " PERFORCE_CHANGE "B (" U_BOOT_DATE " - " U_BOOT_TIME ")" "\0"
+
+#define CONFIG_NFSBOOTCOMMAND		\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_HDBOOT			\
+	"setenv bootargs root=/dev/$bdev rw rootdelay=30 "	\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"usb start;"			\
+	"ext2load usb 0:1 $loadaddr /boot/$bootfile;"		\
+	"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_RTC_TEST \
+	"rtc_test_e 20"
+
+#define CONFIG_NOR_TEST \
+	"nor_flash_check_e 0xeff04000 0xeff4ffff"
+
+#define CONFIG_NAND_TEST \
+	"nor_flash_check_e 0 0x500000"
+
+#define CONFIG_DRAM_TEST \
+	"ram_test_e"
+
+
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#endif	/* __CONFIG_H */
--- u-boot-2011.03/include/configs/FBX_T15.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/configs/FBX_T15.h	2022-05-09 14:05:11.684049702 -0700
@@ -0,0 +1,1121 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * P010 RDB board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef CONFIG_36BIT
+#define CONFIG_PHYS_64BIT
+#endif
+
+#define DDR_533
+#if 1
+/*
+#define DDR_667
+#define DDR_800
+*/
+#endif
+
+#ifdef CONFIG_SPIFLASH
+ #define CONFIG_RAMBOOT_SPIFLASH
+ #define CONFIG_SYS_TEXT_BASE		0x11000000
+ #define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+ #define CONFIG_SYS_NO_FLASH
+#endif
+
+#define CONFIG_WG_COMMON_MFG		/* WG:BH - Enable WatchGuard common manufacturing code */
+
+#define CONFIG_WG_BOOTMENU
+
+#define CONFIG_CMD_WGTOOLS
+#if defined(CONFIG_RAMBOOT_SPIFLASH)
+   #define CONFIG_MFG_OFFSET		0xc0000
+   #define CONFIG_MFG_SECT_SIZE		0x10000
+#endif
+
+#ifdef CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#endif
+
+#define CONFIG_SYS_FLASH_SIZE		0x100000
+
+#if defined(CONFIG_FBX_T15)
+ #define FL_PART_UBOOT_FSAFE_SIZE	0x80000
+ #define FL_PART_UBOOT_SIZE		0x80000
+ #define FL_SIZE_TEST_RESULT		0x10000
+#endif
+
+/* TEST_RESULT_OFFSET is location where the test results are stored */
+#define TEST_RESULT_OFFSET		(CONFIG_SYS_FLASH_SIZE - FL_PART_UBOOT_SIZE - CONFIG_ENV_SIZE - FL_SIZE_TEST_RESULT)
+
+#define CONFIG_RTC_TEST \
+	"rtc_test_e 20"
+	
+#define CONFIG_NOR_TEST \
+	"nor_flash_check_e 0xeff04000 0xeff4ffff"
+
+#define CONFIG_NAND_TEST \
+	"nor_flash_check_e 0 0x500000"
+
+#define CONFIG_DRAM_TEST \
+	"ram_test_e"
+	
+#if defined(CONFIG_RAMBOOT_NAND) && !defined(CONFIG_NAND_SPL)
+#define CONFIG_SYS_CCSRBAR_DEFAULT	CONFIG_SYS_CCSRBAR
+#else
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000      /* CCSRBAR Default */
+#endif
+
+#if defined(CONFIG_XTM2_1M) || defined(CONFIG_XTM3_1M) || defined(CONFIG_FBX_T15)
+# define CONFIG_FLASH_OR_PRELIM		0xfff00831	/* flash 1MB*/
+#else
+# define CONFIG_FLASH_OR_PRELIM		0xffe00831	/* flash 2MB*/
+#endif
+
+/* NAND flash config */
+#define CONFIG_NAND_BR_PRELIM	(CONFIG_SYS_NAND_BASE_PHYS \
+				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+				| BR_PS_8	/* Port Size = 8 bit */ \
+				| BR_MS_FCM		/* MSEL = FCM */ \
+				| BR_V)			/* valid */
+
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
+				| OR_FCM_PGS \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_FLASH_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+					BR_PS_16 | BR_V)
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+/* End of "for WG only" */
+
+
+/*
+#ifdef CONFIG_P1010RDB 
+#define CONFIG_P1010
+*/
+
+#if defined(CONFIG_P1010) || defined(CONFIG_FBX_T15)
+#define CONFIG_NAND_FSL_IFC
+/*
+#define CONFIG_FLASH_CFI_LEGACY
+*/
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RAMBOOT_SDCARD
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+
+#ifdef CONFIG_NAND	/* NAND Boot */
+#define CONFIG_RAMBOOT_NAND
+#define CONFIG_NAND_U_BOOT
+#define CONFIG_SYS_TEXT_BASE_SPL	0xff800000
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE_SPL
+#else
+#define CONFIG_SYS_TEXT_BASE		0x11001000
+#endif  /* CONFIG_NAND_SPL */
+#endif
+
+
+#ifdef CONFIG_NAND_SECBOOT	/* NAND Boot */
+#define CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE			/* BOOKE */
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_MPC85xx			/* MPC8540/60/55/41/48/P1020/P2020/P1010,etc*/
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+#define CONFIG_SYS_HAS_SERDES		/* common SERDES init code */
+
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#if defined(CONFIG_PCI)
+#define CONFIG_PCIE1			/* PCIE controler 1 (slot 1) */
+/*#define CONFIG_PCIE2	 	*/	/* PCIE controler 2 (slot 2) */
+
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET		/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PCI
+
+#define CONFIG_E1000			/*  E1000 pci Ethernet card*/
+
+/*
+ * PCI Windows
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+/* controller 1, Slot 1, tgtid 1, Base address a000 */
+
+#define CONFIG_SYS_PCIE1_NAME		"mini PCIe Slot"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc00000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
+#endif
+
+/*
+#define CONFIG_SYS_PCIE1_NAME		"PCIe Slot"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc10000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc10000
+#endif
+*/
+
+/* controller 2, Slot 2, tgtid 2, Base address 9000 */
+#define CONFIG_SYS_PCIE2_NAME		"PCIe Slot"
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xfffc10000ull
+#else
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#endif
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_TSEC_ENET
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_DDR_CLK_FREQ	66666666 /* DDRCLK on P1010 RDB */
+#define CONFIG_SYS_CLK_FREQ	66666666 /* SYSCLK for P1010 RDB */
+
+#ifndef CONFIG_SDCARD
+#define CONFIG_MISC_INIT_R
+#endif
+
+#define CONFIG_HWCONFIG
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ADDR_STREAMING		/* toggle addr streaming */
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP			1
+#define CONFIG_SYS_NUM_ADDR_MAP		16	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_MEMTEST_SKIP_UBOOT_SIZE 0x100000	/*the uboot size should be smaller than 1 MB*/
+#define CONFIG_SYS_MEMTEST_START	0x11000000+CONFIG_MEMTEST_SKIP_UBOOT_SIZE	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x1f7fffff	/*reserver 8 MB not to test, in case the system has put data in.*/
+#define CONFIG_PANIC_HANG		/* do not reset board on panic */
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR3
+/*
+#define CONFIG_DDR_RAW_TIMING
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_SPD_BUS_NUM		1
+#define SPD_EEPROM_ADDRESS		0x52
+*/
+#define CONFIG_MEM_INIT_VALUE		0xDeadBeef
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_sdram_size(void);
+#endif
+
+
+#define CONFIG_SYS_SDRAM_SIZE		get_sdram_size() /* DDR size */
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+/* DDR3 Controller Settings */
+#ifdef DDR_667
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000001f
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014202
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_DATA_INIT	0xdeadbeef
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0x470C0000
+
+
+/* Type = DDR3  */
+/* for the value of DDR_SDRAM_CFG_2: mem [CCSR 0x2114] = 0x04401000
+#define CONFIG_SYS_DDR_CONTROL_2	0x04401010
+*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x04401000
+
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x03402400
+/* settings for DDR3 at 667MT/s */
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00010000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x00110004
+#define CONFIG_SYS_DDR_TIMING_1_667	0x5d59e544
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0FA890CD
+
+
+/*this is for 201504 Soc ver2*/
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_667 0x8675F606
+/* #define CONFIG_SYS_DDR_WRLVL_CONTROL_667 0x8675F605 */
+
+#elif defined(DDR_800)
+/* DDR3 Controller Settings */
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000001f
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014502
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_DATA_INIT	0xdeadbeef
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0x470C0008	/* Type = DDR3  */
+/* for the value of DDR_SDRAM_CFG_2: mem [CCSR 0x2114] = 0x04401000
+#define CONFIG_SYS_DDR_CONTROL_2	0x04401010
+*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401000
+
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x02401400
+
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00110104
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6B8644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA888CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_800	0x00441420
+#define CONFIG_SYS_DDR_MODE_2_800	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0C300100
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_800	0x8675F607
+
+#elif  defined(DDR_533)
+/* for T15, by Mega on 20170213, for jimmy's promos in 20170210, update at 20170628
+CONFIG_SYS_DDR_CONTROL value is for ddr3
+*/
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000003f
+
+/*
+fine-tuend timing
+*/
+#define CONFIG_SYS_DDR_TIMING_3_533	0x00050000
+#define CONFIG_SYS_DDR_TIMING_1_533	0x6f6BA644
+
+#define CONFIG_SYS_DDR_MODE_1_533	0x00461420 
+#define CONFIG_SYS_DDR_CLK_CTRL_533	0x02800000
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_533 	0x8655A605 
+#define CONFIG_SYS_DDR_CDR_1	0x00040000   
+#define CONFIG_SYS_DDR_CDR_2	0x00000000  
+#define CONFIG_SYS_DDR_CONTROL	0xc70c0008
+
+#define CONFIG_SYS_DDR_MODE_2_533	0x8080c000
+#define CONFIG_SYS_DDR_INTERVAL_533	0x08201B4A
+#endif 
+
+#if 0
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6B4644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA888CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_800	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_800	0x8000c000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0C300100
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_800	0x8655A608
+#endif
+
+
+
+
+/*this is for 201504 Soc ver2*/
+/* #define CONFIG_SYS_DDR_CLK_CTRL_667		0x02000000 */
+/*
+#define CONFIG_SYS_DDR_CLK_CTRL_667		0x01800000
+#define CONFIG_SYS_DDR_MODE_1_667		0x00441210
+#define CONFIG_SYS_DDR_MODE_2_667		0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667		0x0a280000
+*/
+
+/*
+//org settings in tar.gz
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_667	0x8675F608
+
+//this is for Soc Ver1
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_667 0x8675F605
+*/
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CONFIG_SYS_CCSRBAR		0xffe00000	/* relocated CCSRBAR */
+
+/* "Don't relocate CCSRBAR while in NAND_SPL." */
+#if defined(CONFIG_NAND_SPL)
+#define CONFIG_SYS_CCSRBAR_PHYS	CONFIG_SYS_CCSRBAR_DEFAULT
+#else
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_CCSRBAR_PHYS	0xfffe00000ull
+#else
+#define CONFIG_SYS_CCSRBAR_PHYS	CONFIG_SYS_CCSRBAR
+#endif
+							/* CCSRBAR */
+#endif /* CONFIG_NAND_SPL */
+
+#define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses */
+							/* CONFIG_SYS_IMMR */
+
+/*
+ * Memory map
+ *
+ * 0x0000_0000	0x3fff_ffff	DDR			1G cacheable
+ * 0x8000_0000  0xbfff_ffff	PCI Express Mem		1.5G non-cacheable
+ * 0xffc0_0000  0xffc3_ffff	PCI IO range		256k non-cacheable
+ *
+ * Localbus non-cacheable
+ * 0xff80_0000	0xff8f_ffff	NAND Flash		1M non-cacheable
+ * 0xffb0_0000	0xffbf_ffff	Board CPLD		1M non-cacheable
+ * 0xffd0_0000	0xffd0_3fff	L1 for stack		16K Cacheable TLB0
+ * 0xffe0_0000	0xffef_ffff	CCSR			1M non-cacheable
+ */
+
+/* In case of SD card boot, IFC interface is not available because of muxing */
+#ifdef CONFIG_SDCARD
+#define CONFIG_SYS_NO_FLASH
+#else
+/*
+ * IFC Definitions
+ */
+/* NOR Flash on IFC */
+#define CONFIG_SYS_FLASH_BASE		0xee000000
+#define CONFIG_SYS_MAX_FLASH_SECT	256	/* 32M */
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_SYS_NOR_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(32*1024*1024)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(7)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_FTIM0	FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5)
+#define CONFIG_SYS_NOR_FTIM1	FTIM1_NOR_TACO(0x1e) | \
+				FTIM1_NOR_TRAD_NOR(0x0f)
+#define CONFIG_SYS_NOR_FTIM2	FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWP(0x1c)
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+
+/*
+#define CONFIG_SYS_FLASH_QUIET_TEST
+*/
+#define CONFIG_FLASH_SHOW_PROGRESS	45	/* count down from 45/5: 9..1 */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+
+#undef CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+/* CFI for NOR Flash */
+/*
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE         1
+#define CONFIG_SYS_FLASH_BUFFER_WRITE_EXTERN_DELAY  1
+*/
+
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfff800000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_NAND_BASE}
+
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8	/* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4	/* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2048Byte */ \
+				| CSOR_NAND_SPRZ_64	/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/* Pages Per Block = 64 */
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+/* NAND Flash Timing Params */
+#define CONFIG_SYS_NAND_FTIM0 		FTIM0_NAND_TCCST(0x01) | \
+					FTIM0_NAND_TWP(0x0C)   | \
+					FTIM0_NAND_TWCHT(0x04) | \
+					FTIM0_NAND_TWH(0x05)
+#define CONFIG_SYS_NAND_FTIM1 		FTIM1_NAND_TADLE(0x1d) | \
+					FTIM1_NAND_TWBE(0x1d)  | \
+					FTIM1_NAND_TRR(0x07)   | \
+					FTIM1_NAND_TRP(0x0c)
+#define CONFIG_SYS_NAND_FTIM2 		FTIM2_NAND_TRAD(0x0c) | \
+					FTIM2_NAND_TREH(0x05) | \
+					FTIM2_NAND_TWHRE(0x0f)
+#define CONFIG_SYS_NAND_FTIM3 		FTIM3_NAND_TWW(0x04)
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+
+/* Set up IFC registers from boot location NOR/NAND */
+/*
+#if defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SECBOOT)
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+*/
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+
+/* NAND boot: 8K NAND loader config */
+#define CONFIG_SYS_NAND_SPL_SIZE	0x2000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(0x11000000 - CONFIG_SYS_NAND_SPL_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_START	0x11000000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(0)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC	0x10000
+#define CONFIG_SYS_NAND_U_BOOT_RELOC_SP	(CONFIG_SYS_NAND_U_BOOT_RELOC + 0x10000)
+
+#define CONFIG_SYS_CPLD_BASE		0xffb00000
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_CPLD_BASE_PHYS	0xfffb00000ull
+#else
+#define CONFIG_SYS_CPLD_BASE_PHYS	CONFIG_SYS_CPLD_BASE
+#endif
+
+#define CONFIG_SYS_CSPR3		(CSPR_PHYS_ADDR(CONFIG_SYS_CPLD_BASE_PHYS) | \
+					CSPR_PORT_SIZE_8 | CSPR_MSEL_GPCM | CSPR_V)
+#define CONFIG_SYS_AMASK3		IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR3		0x0
+/* CPLD Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0x0e) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x0) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+#endif
+
+#if defined(CONFIG_RAMBOOT_SDCARD) || defined(CONFIG_RAMBOOT_SPIFLASH) || \
+    defined(CONFIG_RAMBOOT_NAND)
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#else
+#undef CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_F	/* Call board_pre_init */
+#define CONFIG_BOARD_EARLY_INIT_R
+
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* stack in RAM */
+#define CONFIG_SYS_INIT_RAM_END		0x00004000	/* End of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END \
+						- GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon*/
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc*/
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX	1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SERIAL_MULTI		/* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE		/* enable fit_format_{error,warning}() */
+
+#define CONFIG_FSL_I2C			/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C			/* I2C with hardware support */
+#undef CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000 /* I2C speed and slave address*/
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/* I2C EEPROM */
+#undef CONFIG_ID_EEPROM
+/* enable read and write access to EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/* RTC */
+/*
+#define CONFIG_RTC_PT7C4338
+#define CONFIG_SYS_I2C_RTC_ADDR	0x68
+*/
+#define CONFIG_RTC_S35390
+#define CONFIG_SYS_I2C_RTC_ADDR	0x30
+
+#define CONFIG_CMD_I2C
+
+/*
+ * SPI interface will not be available in case of NAND boot SPI CS0 will be
+ * used for SLIC
+ */
+
+#if !defined(CONFIG_NAND_U_BOOT) || !defined(CONFIG_NAND_SECBOOT)
+/* eSPI - Enhanced SPI */
+#define CONFIG_FSL_ESPI
+#define CONFIG_WG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_WG_SPI_FLASH
+
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_WG_SPI_FLASH_MACRONIX
+
+#define CONFIG_CF_DSPI
+/*
+#define CONFIG_SPI_FLASH_SPANSION
+*/
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		10000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+
+#if defined(CONFIG_TSEC_ENET)
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI
+#endif
+
+#define CONFIG_MII			/* MII PHY management */
+#define CONFIG_MII_DEFAULT_TSEC	2	/* Allow unregistered phys */
+#define CONFIG_TSEC1	1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#define CONFIG_TSEC2	1
+#define CONFIG_TSEC2_NAME	"eTSEC2"
+#define CONFIG_TSEC3	1
+#define CONFIG_TSEC3_NAME	"eTSEC3"
+
+#define TSEC1_PHY_ADDR		1
+#define TSEC2_PHY_ADDR		2
+#define TSEC3_PHY_ADDR		3
+
+
+
+#define TSEC1_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+#define TSEC3_PHYIDX		0
+
+#define CONFIG_ETHPRIME		"eTSEC1"
+
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+
+/* TBI PHY configuration for SGMII mode */
+#define CONFIG_TSEC_TBICR_SETTINGS ( \
+		TBICR_PHY_RESET \
+		| TBICR_ANEG_ENABLE \
+		| TBICR_FULL_DUPLEX \
+		| TBICR_SPEED1_SET \
+		)
+
+#endif	/* CONFIG_TSEC_ENET */
+
+
+/* SATA */
+/*
+#define CONFIG_FSL_SATA
+#define CONFIG_LIBATA
+
+#ifdef CONFIG_FSL_SATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	2
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_SATA2
+#define CONFIG_SYS_SATA2		CONFIG_SYS_MPC85xx_SATA2_ADDR
+#define CONFIG_SYS_SATA2_FLAGS		FLAGS_DMA
+
+#define CONFIG_CMD_SATA
+#define CONFIG_LBA48
+#endif
+*/
+ /* #ifdef CONFIG_FSL_SATA  */
+
+/*  SD interface will only be available in case of SD boot */
+#ifdef CONFIG_SDCARD
+#define CONFIG_MMC
+#define CONFIG_DEF_HWCONFIG		esdhc
+#endif
+
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_FSL_ESDHC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#endif
+
+#define CONFIG_USB_EHCI
+#define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#define CONFIG_HAS_FSL_DR_USB
+#endif
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_SYS_RAMBOOT)
+  #if defined(CONFIG_RAMBOOT_SDCARD)
+   #define CONFIG_ENV_IS_IN_MMC
+   #define CONFIG_SYS_MMC_ENV_DEV		0
+   #define CONFIG_ENV_SIZE			0x2000
+  #elif defined(CONFIG_RAMBOOT_SPIFLASH)
+   #define CONFIG_ENV_IS_IN_SPI_FLASH
+   #define CONFIG_ENV_SPI_BUS	0
+   #define CONFIG_ENV_SPI_CS	0
+   #define CONFIG_ENV_SPI_MAX_HZ	10000000
+   #define CONFIG_ENV_SPI_MODE	0
+   #define CONFIG_ENV_OFFSET		0x90000
+   /*since for macronix M25FL8006E the sector size is 64K*/
+   #define CONFIG_ENV_SECT_SIZE		0x10000
+   #define CONFIG_ENV_SIZE		 0x2000
+  #elif defined(CONFIG_NAND_U_BOOT)
+   #define CONFIG_ENV_IS_IN_NAND
+   #define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+   #define CONFIG_ENV_OFFSET	CONFIG_SYS_NAND_U_BOOT_SIZE
+   #define CONFIG_ENV_RANGE	(3 * CONFIG_ENV_SIZE)
+  #else
+   #define CONFIG_ENV_IS_NOWHERE		/* Store ENV in memory only */
+   #define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE - 0x1000)
+   #define CONFIG_ENV_SIZE			0x2000
+  #endif
+#else
+  #define CONFIG_ENV_IS_IN_FLASH
+  #if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+   #define CONFIG_ENV_ADDR	0xfff80000
+  #else
+   #define CONFIG_ENV_ADDR	(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+  #endif
+  #define CONFIG_ENV_SIZE		0x2000
+  #define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_LOADS_ECHO			/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE		/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#include <version.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+
+#if defined(CONFIG_MMC) || defined(CONFIG_USB_EHCI) \
+		 || defined(CONFIG_FSL_SATA)
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x600000	/* default load address */
+
+# if defined (CONFIG_FBX_T15)
+#   define CONFIG_SYS_PROMPT      "T15 => "           /* Monitor Command Prompt */
+# else
+#   define CONFIG_SYS_PROMPT      "=> " /* Monitor Command Prompt */
+#endif
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+						/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+#define CONFIG_CMD_TPM
+*/
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 16 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(16 << 20) /* Initial Memory map for Linux */
+#define CONFIG_SYS_BOOTM_LEN	(16 << 20) /* Increase max gunzip size */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#endif
+
+#define CONFIG_HOSTNAME		P1010RDB
+#define CONFIG_ROOTPATH		/opt/nfsroot
+#define CONFIG_BOOTFILE		uImage
+#define CONFIG_UBOOTPATH	u-boot.bin/* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY	3	/* -1 disables auto-boot */
+#undef  CONFIG_BOOTARGS		/* the boot command will set bootargs */
+
+#define CONFIG_BAUDRATE		115200
+
+
+#if defined(CONFIG_P1010) || defined(CONFIG_FBX_T15)
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=" MK_STR(CONFIG_DEF_HWCONFIG)  "\0"	\
+	"netdev=eth0\0"						\
+	"uboot=" MK_STR(CONFIG_UBOOTPATH) "\0"				\
+	"loadaddr=1000000\0"			\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=p1010rdb.dtb\0"		\
+	"bdev=sda1\0"	\
+	"SysARoot=mtdblock2\0"		\
+	"SysBRoot=mtdblock4\0"		\
+	"SysA2Root=mtdblock6\0"		\
+	"SysARootAddr=520000\0"		\
+	"SysBRootAddr=fc20000\0"	\
+	"SysA2RootAddr=11920000\0"	\
+	"SysAKernAddr=20000\0"		\
+	"SysAKernSize=500000\0"		\
+	"SysBKernAddr=f720000\0"	\
+	"SysBKernSize=500000\0"		\
+	"SysA2KernAddr=11420000\0"	\
+	"SysA2KernSize=500000\0"	\
+	"DTBAddr=0\0"			\
+	"DTBSize=20000\0"		\
+	"SysAMfgRootSize=2000000\0"	\
+	"SysBMfgRootSize=800000\0"	\
+	"hwconfig=usb1:dr_mode=host,phy_type=utmi\0"	\
+	"othbootargs=ramdisk_size=600000\0" \
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"	\
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysBKernAddr $SysBKernSize;"	\
+	"bootm;\0"			\
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootMfgsys=setenv bootargs rdinit=/sbin/init " \
+	"console=$consoledev,$baudrate;"			\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"nand read $ramdiskaddr $SysARootAddr $SysAMfgRootSize;"	\
+	"bootm $loadaddr:kernel@1 $ramdiskaddr $loadaddr:fdt@1; \0"	\
+	"nuke_env=sf probe 0;sf erase 90000 10000 \0"	\
+	"spitest=sf probe 0;sf erase 100000 10000; sf read 100000 100; md.b 100000 100;echo \"spitest all \"; \0"	\
+	"upgrade_uboot=tftp 2000000 doris/uboot/u-boot-spi.bin;sf probe 0;sf erase 0 90000;sf write 2000000 0 80400; \0" \
+	"serverip=10.0.1.13\0 "	\
+	"ipaddr=10.0.1.1\0 "	\
+	"netmask=255.255.255.0\0 "	\
+	"ethaddr=192.168.1.1\0 "	\
+	"eth1addr=192.168.1.2\0 "	\
+	"eth2addr=192.168.1.3\0 "	\
+	"uboot_built_info=" U_BOOT_VERSION " - " PERFORCE_CHANGE "B (" U_BOOT_DATE " - " U_BOOT_TIME ")" "\0"
+	
+#else
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=" MK_STR(CONFIG_DEF_HWCONFIG)  "\0"	\
+	"netdev=eth0\0"						\
+	"uboot=" MK_STR(CONFIG_UBOOTPATH) "\0"				\
+	"loadaddr=1000000\0"			\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=p1010rdb.dtb\0"		\
+	"bdev=sda1\0"	\
+	"hwconfig=usb1:dr_mode=host,phy_type=utmi\0"	\
+	"othbootargs=ramdisk_size=600000\0" \
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"serverip=192.168.1.101\0 "	\
+	"ipaddr=192.168.1.1\0 "	 \
+	"ethaddr=192.168.1.1\0 " \
+	"uboot_built_info=" U_BOOT_VERSION " - " PERFORCE_CHANGE "B (" U_BOOT_DATE " - " U_BOOT_TIME ")" "\0"
+#endif
+
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr;"
+		
+
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __CONFIG_H */
--- u-boot-2011.03/include/configs/XTM330.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/configs/XTM330.h	2022-05-09 14:05:11.720048242 -0700
@@ -0,0 +1,694 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * P1 P2 RDB board configuration file
+ * This file is intended to address a set of Low End and Ultra Low End
+ * Freescale SOCs of QorIQ series(RDB platforms).
+ * Currently only P2020RDB
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef CONFIG_NAND
+#define CONFIG_NAND_U_BOOT		1
+#define CONFIG_RAMBOOT_NAND		1
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_SYS_TEXT_BASE_SPL 0xfff00000
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE_SPL /* start of monitor */
+#else
+#define CONFIG_SYS_TEXT_BASE		0xf8f82000
+#endif /* CONFIG_NAND_SPL */
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RAMBOOT_SDCARD		1
+#define CONFIG_SYS_TEXT_BASE		0xf8f80000
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifdef CONFIG_SPIFLASH
+#define CONFIG_RAMBOOT_SPIFLASH		1
+#define CONFIG_SYS_TEXT_BASE		0xf8f80000
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#ifdef CONFIG_FAILSAFE
+#define CONFIG_SYS_TEXT_BASE		0xeff80000
+#else
+#define CONFIG_SYS_TEXT_BASE		0xeff00000
+#endif
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE	CONFIG_SYS_TEXT_BASE	/* start of monitor */
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41/48/P1020/P2020,etc*/
+#define CONFIG_FSL_ELBC		1	/* Enable eLBC Support */
+
+#define CONFIG_PCI		1	/* Enable PCI/PCIE */
+#if defined(CONFIG_PCI)
+#define CONFIG_PCIE1		1	/* PCIE controler 1 (slot 1) */
+#define CONFIG_PCIE2		1	/* PCIE controler 2 (slot 2) */
+#define CONFIG_FSL_PCI_INIT	1	/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET	1	/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT	1	/* enable 64-bit PCI resources */
+#endif /* #if defined(CONFIG_PCI) */
+#define CONFIG_FSL_LAW		1	/* Use common FSL init code */
+#define CONFIG_TSEC_ENET		/* tsec ethernet support */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_LANNER_MFG		/* WG:BH - Enable Lanner manufacturing code */
+#define CONFIG_WG_COMMON_MFG		/* WG:BH - Enable WatchGuard common manufacturing code */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_board_sys_clk(unsigned long dummy);
+#endif
+#define CONFIG_DDR_CLK_FREQ	66666666 
+#define CONFIG_SYS_CLK_FREQ	get_board_sys_clk(0)
+
+#define CONFIG_MP
+#define CONFIG_HWCONFIG
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ADDR_STREAMING		/* toggle addr streaming */
+
+#define CONFIG_ENABLE_36BIT_PHYS	1
+
+#define CONFIG_SYS_MEMTEST_START	0x00000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x1fffffff
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+ /*
+  * Config the L2 Cache as L2 SRAM
+  */
+#define CONFIG_SYS_INIT_L2_ADDR		0xf8f80000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_INIT_L2_ADDR_PHYS	0xff8f80000ull
+#else
+#define CONFIG_SYS_INIT_L2_ADDR_PHYS	CONFIG_SYS_INIT_L2_ADDR
+#endif
+#define CONFIG_SYS_L2_SIZE		(512 << 10)
+#define CONFIG_SYS_INIT_L2_END		(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_L2_SIZE)
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CONFIG_SYS_CCSRBAR		0xffe00000	/* relocated CCSRBAR */
+#define CONFIG_SYS_CCSRBAR_PHYS	CONFIG_SYS_CCSRBAR	/* physical addr of */
+							/* CCSRBAR */
+#define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses */
+							/* CONFIG_SYS_IMMR */
+
+#if defined(CONFIG_RAMBOOT_NAND) && !defined(CONFIG_NAND_SPL)
+#define CONFIG_SYS_CCSRBAR_DEFAULT	CONFIG_SYS_CCSRBAR
+#else
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000      /* CCSRBAR Default */
+#endif
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR3
+#undef CONFIG_FSL_DDR_INTERACTIVE
+#undef CONFIG_SPD_EEPROM		/* Use SPD EEPROM for DDR setup */
+
+#define CONFIG_MEM_INIT_VALUE	0xDeadBeef
+
+#define CONFIG_SYS_SDRAM_SIZE	1024
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+#define CONFIG_SYS_DDR_ERR_INT_EN	0x0000000d
+#define CONFIG_SYS_DDR_ERR_DIS		0x00000000
+#define CONFIG_SYS_DDR_SBE		0x00FF0000
+
+/*
+ * Memory map
+ *
+ * 0x0000_0000	0x3fff_ffff	DDR			1G cacheablen
+ * 0x8000_0000	0xbfff_ffff	PCI Express Mem		1G non-cacheable
+ * 0xffc0_0000	0xffc3_ffff	PCI IO range		256K non-cacheable
+ *
+ * Localbus cacheable (TBD)
+ * 0xXXXX_XXXX	0xXXXX_XXXX	SRAM			YZ M Cacheable
+ *
+ * Localbus non-cacheable
+ * 0xefe0_0000	0xefff_ffff	FLASH			2M non-cacheable
+ * 0xffa0_0000	0xffaf_ffff	NAND			1M non-cacheable
+ * 0xffb0_0000	0xffbf_ffff	VSC7385 switch		1M non-cacheable
+ * 0xffd0_0000	0xffd0_3fff	L1 for stack		16K Cacheable TLB0
+ * 0xffe0_0000	0xffef_ffff	CCSR			1M non-cacheable
+ */
+
+/*
+ * Local Bus Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE		0xefe00000	/* start of FLASH 1M */
+#define SYS_FLASH_SIZE_BUFFER		(3 * 0x10000)	/* 3 blocks of Extra buffer */
+#define CONFIG_SYS_FLASH_SIZE		((CONFIG_SYS_FLASH_SECT_SIZE * CONFIG_SYS_MAX_FLASH_SECT) - SYS_FLASH_SIZE_BUFFER)
+
+#define FL_PART_UBOOT_FSAFE_SIZE	0x80000
+#define FL_PART_UBOOT_SIZE		0x80000
+#define FL_SIZE_TEST_RESULT		0xB0000
+
+/* TEST_RESULT_OFFSET is location where the test results are stored */
+#define TEST_RESULT_OFFSET		(CONFIG_SYS_FLASH_SIZE - FL_PART_UBOOT_FSAFE_SIZE - FL_PART_UBOOT_SIZE - CONFIG_ENV_SIZE - FL_SIZE_TEST_RESULT)
+
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_FLASH_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+					BR_PS_16 | BR_V)
+#define CONFIG_FLASH_OR_PRELIM		0xFFE00FF7	/* flash 2MB*/
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE}
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS 45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+
+/* We will set below value to 35 to leave latest sector as non-deletable */
+/* We will set below value to 35 and those are
+ *  max number of sectors on this CHIP */
+#define CONFIG_SYS_FLASH_SECT_SIZE	0x10000	/* sectors size of this device */
+#define CONFIG_SYS_MAX_FLASH_SECT	35	/* Max sectrors is only 35, (0x10000 * 0x20) = 0x200000  + (3 * 0x10000)  3 blocks of Extra buffer  */
+#undef	CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#if defined(CONFIG_RAMBOOT_NAND) || defined(CONFIG_RAMBOOT_SDCARD) || \
+    defined(CONFIG_RAMBOOT_SPIFLASH)
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#else
+#undef CONFIG_SYS_RAMBOOT
+#endif
+
+#ifndef CONFIG_FAILSAFE
+/* protect failsafe region 0xeff80000 ~ 0xefffffff */
+#define CONFIG_SYS_FLASH_AUTOPROTECT_LIST {{0xeff80000, 0x80000}}
+#endif
+
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_AMD_CHECK_DQ7
+
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+#define CONFIG_HWCONFIG
+
+#define CONFIG_SYS_INIT_RAM_LOCK	1
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* stack in RAM */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000	/* Size of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE \
+						- GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon*/
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc*/
+
+#ifndef CONFIG_NAND_SPL
+#define CONFIG_SYS_NAND_BASE		0xffa00000
+#else
+#define CONFIG_SYS_NAND_BASE		0xfff00000
+#endif
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#define CONFIG_SYS_NAND_BASE_LIST	{CONFIG_SYS_NAND_BASE}
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define NAND_MAX_CHIPS			1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND			1
+#define CONFIG_NAND_FSL_ELBC		1
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(16 * 1024)
+
+/* NAND boot: 4K NAND loader config */
+#define CONFIG_SYS_NAND_SPL_SIZE	0x1000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	((512 << 10) - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(CONFIG_SYS_INIT_L2_ADDR)
+#define CONFIG_SYS_NAND_U_BOOT_START	(CONFIG_SYS_INIT_L2_ADDR + CONFIG_SYS_NAND_SPL_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(0)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC	(CONFIG_SYS_INIT_L2_END - 0x2000)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC_SP		((CONFIG_SYS_INIT_L2_END - 1) & ~0xF)
+
+/* NAND flash config */
+#define CONFIG_NAND_BR_PRELIM	(CONFIG_SYS_NAND_BASE_PHYS \
+				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+				| BR_PS_8	/* Port Size = 8 bit */ \
+				| BR_MS_FCM		/* MSEL = FCM */ \
+				| BR_V)			/* valid */
+
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
+				| OR_FCM_PGS \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+
+#ifdef CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#endif
+
+/* Serial Port - controlled on board with jumper J8
+ * open - index 2
+ * shorted - index 1
+ */
+#define CONFIG_CONS_INDEX	1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_NS16550_MIN_FUNCTIONS
+#endif
+
+#define CONFIG_SERIAL_MULTI	1 /* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400,115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* LCM Enable for chelan/chelan2 */
+#define CONFIG_XTM330_LCM
+#ifdef  CONFIG_XTM330_LCM
+ #define CONFIG_LAST_STAGE_INIT /* last stage int for LCM over serial */
+ #define DEBUG_XTM330_LCM	/* LCM debug Enable */
+#endif
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT		1
+#define CONFIG_OF_BOARD_SETUP		1
+#define CONFIG_OF_STDOUT_VIA_ALIAS	1
+
+/* new uImage format support */
+#define CONFIG_FIT		1
+#define CONFIG_FIT_VERBOSE	1 /* enable fit_format_{error,warning}() */
+
+/* I2C */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support */
+#undef	CONFIG_SOFT_I2C		/* I2C bit-banged */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000	/* I2C speed and slave address*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x54
+#define CONFIG_SYS_I2C_NOPROBES	{{0,0x29}}	/* Don't probe these addrs */
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/*
+ * I2C2 EEPROM
+ */
+#define CONFIG_ID_EEPROM
+#ifdef CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#endif
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x54
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+
+#define CONFIG_RTC_RS5C372A
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+#if defined(CONFIG_PCI)
+/* controller 2, Slot 2, tgtid 2, Base address 9000 */
+#define CONFIG_SYS_PCIE2_NAME		"Slot 1"
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 1, Slot 1, tgtid 1, Base address a000 */
+#define CONFIG_SYS_PCIE1_NAME		"Slot 2"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#undef CONFIG_EEPRO100
+#undef CONFIG_TULIP
+#undef CONFIG_RTL8139
+
+#ifdef CONFIG_RTL8139
+/* This macro is used by RTL8139 but not defined in PPC architecture */
+#define KSEG1ADDR(x)		(x)
+#define _IO_BASE	0x00000000
+#endif
+
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+
+#endif	/* CONFIG_PCI */
+
+#define CONFIG_NET_MULTI	1
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_MII		1	/* MII PHY management */
+#define CONFIG_MII_DEFAULT_TSEC	1	/* Allow unregistered phys */
+#define CONFIG_TSEC1	1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#define CONFIG_TSEC3	1
+#define CONFIG_TSEC3_NAME	"eTSEC3"
+
+#define TSEC1_PHY_ADDR          0
+#define TSEC3_PHY_ADDR          0
+
+#define TSEC1_FLAGS             (TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS             (TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC1_PHYIDX            0
+#define TSEC3_PHYIDX            0
+
+#define CONFIG_ETHPRIME		"eTSEC1"
+
+#define CONFIG_PHY_GIGE		1	/* Include GbE speed/duplex detection */
+
+#endif	/* CONFIG_TSEC_ENET */
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_SYS_RAMBOOT)
+#if defined(CONFIG_RAMBOOT_NAND)
+	#define CONFIG_ENV_IS_IN_NAND	1
+	#define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+	#define CONFIG_ENV_OFFSET	((512 * 1024) + CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_RAMBOOT_SDCARD) || defined(CONFIG_RAMBOOT_SPIFLASH)
+	#define CONFIG_ENV_IS_NOWHERE	1	/* Store ENV in memory only */
+	#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - 0x1000)
+	#define CONFIG_ENV_SIZE		0x2000
+#endif
+#else
+	#define CONFIG_ENV_IS_IN_FLASH	1
+ 						/* NOTE: uboot ENV ADDR: ENV is written TOP -> BOTTOM. so needs the lower addr */
+                #define CONFIG_ENV_ADDR         (CONFIG_SYS_FLASH_BASE + FL_PART_UBOOT_FSAFE_SIZE + FL_PART_UBOOT_SIZE - CONFIG_ENV_SIZE)
+                #define CONFIG_ENV_SIZE         0x10000
+                #define CONFIG_ENV_SECT_SIZE    0x10000 /* 64K (one sector) */
+#endif
+
+#define CONFIG_LOADS_ECHO	1	/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#include <version.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#if defined(CONFIG_PCI)
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PCI
+#endif
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+
+#define CONFIG_BOARD_EARLY_INIT_F      1       /* Call board_pre_init */
+#define CONFIG_DOS_PARTITION
+
+#define CONFIG_USB_EHCI
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#endif
+
+#if defined(CONFIG_USB_EHCI)
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#ifdef CONFIG_FAILSAFE
+#define CONFIG_SYS_PROMPT      "XTM330(FAILSAFE) => " /* Monitor Command Prompt */
+#else
+#define CONFIG_SYS_PROMPT      "XTM330 => "           /* Monitor Command Prompt */
+#endif
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+						/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 16 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(16 << 20)/* Initial Memory map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(16 << 20)	/* Increase max gunzip size */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#endif
+
+#define CONFIG_HOSTNAME		P2020RDB
+#define CONFIG_ROOTPATH		/opt/nfsroot
+#define CONFIG_BOOTFILE		uImage
+#define CONFIG_UBOOTPATH	u-boot.bin/* U-Boot image on TFTP server */
+#define CONFIG_FDTFILE		wg_chelan2.dtb
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY 5	/* -1 disables auto-boot */
+
+/* WatchGuard BootMenu */
+#define CONFIG_WG_BOOTMENU
+
+#undef  CONFIG_BOOTARGS		/* the boot command will set bootargs */
+
+#define CONFIG_BAUDRATE	115200
+
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"netdev=eth0\0"						\
+	"uboot=" MK_STR(CONFIG_UBOOTPATH) "\0"				\
+	"loadaddr=1000000\0"			\
+	"tftpflash=tftpboot $loadaddr $uboot; "			\
+		"protect off " MK_STR(CONFIG_SYS_TEXT_BASE) " +$filesize; "	\
+		"erase " MK_STR(CONFIG_SYS_TEXT_BASE) " +$filesize; "		\
+		"cp.b $loadaddr " MK_STR(CONFIG_SYS_TEXT_BASE) " $filesize; "	\
+		"protect on " MK_STR(CONFIG_SYS_TEXT_BASE) " +$filesize; "		\
+		"cmp.b $loadaddr " MK_STR(CONFIG_SYS_TEXT_BASE) " $filesize\0"	\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=" MK_STR(CONFIG_FDTFILE) "\0"		\
+	"bdev=sda1\0"	\
+	"jffs2nor=mtdblock3\0"	\
+	"norbootaddr=ef080000\0"	\
+	"norfdtaddr=ef040000\0"	\
+	"SysARoot=mtdblock9\0"	\
+	"SysBRoot=mtdblock12\0"	\
+	"SysAKernAddr=20000\0"	\
+	"SysAKernSize=500000\0"		\
+	"SysBKernAddr=1df00000\0"	\
+	"SysBKernSize=500000\0"		\
+	"DTBAddr=0\0"		\
+	"DTBSize=20000\0"		\
+	"SysARootAddr=520000\0"		\
+	"SysAMfgRootSize=2000000\0"	\
+	"usb_phy_type=ulpi\0"		\
+	"othbootargs=ramdisk_size=600000\0" \
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"lannerboot=setenv bootargs root=/dev/ram rw " \
+	"rootdelay=10 console=ttyS0,115200;" \
+	"usb start;" \
+	"fatload usb 0 $loadaddr $bootfile;" \
+	"fatload usb 0 $ramdiskaddr $ramdiskfile;" \
+	"fatload usb 0 $fdtaddr xtm505_p2020.dtb;" \
+	"bootm $loadaddr $ramdiskaddr $fdtaddr;\0" \
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"norboot=setenv bootargs root=/dev/$jffs2nor rw "	\
+	"console=$consoledev,$baudrate rootfstype=jffs2 $othbootargs;"	\
+	"bootm $norbootaddr - $norfdtaddr\0"		\
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysBKernAddr $SysBKernSize;"	\
+	"bootm;\0"			\
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootMfgsys=setenv bootargs rdinit=/sbin/init " \
+	"console=$consoledev,$baudrate;"			\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"nand read $ramdiskaddr $SysARootAddr $SyaAMfgRootSize;"	\
+	"bootm $loadaddr:kernel@1 $ramdiskaddr $loadaddr:fdt@1; \0"	\
+	"bootloader_normal_update=protect off 0xeff00000 0xeff7ffff;" \
+	"erase 0xeff00000 0xeff7ffff;" \
+	"cp.b $loadaddr 0xeff00000 0x80000;" \
+	"cmp.b $loadaddr 0xeff00000 0x80000;\0"\
+	"bootloader_failsafe_update=protect off 0xeff80000 0xefffffff;" \
+	"erase 0xeff80000 0xefffffff;" \
+	"cp.b $loadaddr 0xeff80000 0x80000;" \
+	"cmp.b $loadaddr 0xeff80000 0x80000;\0"\
+	"nuke_env=protect off 0xefef0000 0xefefffff;" \
+	"erase 0xefef0000 0xefefffff; \0"\
+	"uboot_built_info=" U_BOOT_VERSION " - " PERFORCE_CHANGE "B (" U_BOOT_DATE " - " U_BOOT_TIME ")" "\0"
+
+#define CONFIG_NFSBOOTCOMMAND		\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_HDBOOT			\
+	"setenv bootargs root=/dev/$bdev rw rootdelay=30 "	\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"usb start;"			\
+	"ext2load usb 0:1 $loadaddr /boot/$bootfile;"		\
+	"ext2load usb 0:1 $fdtaddr /boot/$fdtfile;"	\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_RTC_TEST \
+	"rtc_test 20"
+
+#define CONFIG_NOR_TEST \
+	"flash_test 0xefe04000 0xefe4ffff"
+
+#define CONFIG_NAND_TEST \
+	"nand_test 0 0x500000"
+
+#define CONFIG_DRAM_TEST \
+	"ram_test"
+
+
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#endif	/* __CONFIG_H */
--- u-boot-2011.03/include/configs/FBX_T10.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/include/configs/FBX_T10.h	2022-05-09 14:05:11.680049864 -0700
@@ -0,0 +1,1043 @@
+/*
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * P010 RDB board configuration file
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#ifdef CONFIG_36BIT
+#define CONFIG_PHYS_64BIT
+#endif
+
+
+
+#ifdef CONFIG_SPIFLASH
+ #define CONFIG_RAMBOOT_SPIFLASH
+ #define CONFIG_SYS_TEXT_BASE		0x11000000
+ #define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+ #define CONFIG_SYS_NO_FLASH
+#endif
+
+#define CONFIG_WG_COMMON_MFG		/* WG:BH - Enable WatchGuard common manufacturing code */
+
+#define CONFIG_WG_BOOTMENU
+
+#define CONFIG_CMD_WGTOOLS
+#if defined(CONFIG_RAMBOOT_SPIFLASH)
+   #define CONFIG_MFG_OFFSET		0xc0000
+   #define CONFIG_MFG_SECT_SIZE		0x10000
+#endif
+
+#ifdef CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#else
+#define CONFIG_SYS_BR0_PRELIM  CONFIG_FLASH_BR_PRELIM  /* NOR Base Address */
+#define CONFIG_SYS_OR0_PRELIM  CONFIG_FLASH_OR_PRELIM  /* NOR Options */
+#define CONFIG_SYS_BR1_PRELIM  CONFIG_NAND_BR_PRELIM  /* NAND Base Address */
+#define CONFIG_SYS_OR1_PRELIM  CONFIG_NAND_OR_PRELIM  /* NAND Options */
+#endif
+
+#define CONFIG_SYS_FLASH_SIZE		0x100000
+
+#if defined(CONFIG_FBX_T10)
+ #define FL_PART_UBOOT_FSAFE_SIZE	0x80000
+ #define FL_PART_UBOOT_SIZE		0x80000
+ #define FL_SIZE_TEST_RESULT		0x10000
+#endif
+
+/* TEST_RESULT_OFFSET is location where the test results are stored */
+#define TEST_RESULT_OFFSET		(CONFIG_SYS_FLASH_SIZE - FL_PART_UBOOT_SIZE - CONFIG_ENV_SIZE - FL_SIZE_TEST_RESULT)
+
+#define CONFIG_RTC_TEST \
+	"rtc_test_e 20"
+	
+#define CONFIG_NOR_TEST \
+	"nor_flash_check_e 0xeff04000 0xeff4ffff"
+
+#define CONFIG_NAND_TEST \
+	"nor_flash_check_e 0 0x500000"
+
+#define CONFIG_DRAM_TEST \
+	"ram_test_e"
+	
+#if defined(CONFIG_RAMBOOT_NAND) && !defined(CONFIG_NAND_SPL)
+#define CONFIG_SYS_CCSRBAR_DEFAULT	CONFIG_SYS_CCSRBAR
+#else
+#define CONFIG_SYS_CCSRBAR_DEFAULT	0xff700000      /* CCSRBAR Default */
+#endif
+
+#if defined(CONFIG_XTM2_1M) || defined(CONFIG_XTM3_1M) || defined(CONFIG_FBX_T10)
+# define CONFIG_FLASH_OR_PRELIM		0xfff00831	/* flash 1MB*/
+#else
+# define CONFIG_FLASH_OR_PRELIM		0xffe00831	/* flash 2MB*/
+#endif
+
+/* NAND flash config */
+#define CONFIG_NAND_BR_PRELIM	(CONFIG_SYS_NAND_BASE_PHYS \
+				| (2<<BR_DECC_SHIFT)	/* Use HW ECC */ \
+				| BR_PS_8	/* Port Size = 8 bit */ \
+				| BR_MS_FCM		/* MSEL = FCM */ \
+				| BR_V)			/* valid */
+
+#define CONFIG_NAND_OR_PRELIM	(0xFFF80000		/* length 32K */ \
+				| OR_FCM_PGS \
+				| OR_FCM_CSCT \
+				| OR_FCM_CST \
+				| OR_FCM_CHT \
+				| OR_FCM_SCY_1 \
+				| OR_FCM_TRLX \
+				| OR_FCM_EHTR)
+
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+
+#define CONFIG_FLASH_BR_PRELIM	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+					BR_PS_16 | BR_V)
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+/* End of "for WG only" */
+
+
+/*
+#ifdef CONFIG_P1010RDB 
+#define CONFIG_P1010
+*/
+
+#if defined(CONFIG_P1010) || defined(CONFIG_FBX_T10)
+#define CONFIG_NAND_FSL_IFC
+/*
+#define CONFIG_FLASH_CFI_LEGACY
+*/
+#endif
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RAMBOOT_SDCARD
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+
+#ifdef CONFIG_NAND	/* NAND Boot */
+#define CONFIG_RAMBOOT_NAND
+#define CONFIG_NAND_U_BOOT
+#define CONFIG_SYS_TEXT_BASE_SPL	0xff800000
+#ifdef CONFIG_NAND_SPL
+#define CONFIG_SYS_MONITOR_BASE		CONFIG_SYS_TEXT_BASE_SPL
+#else
+#define CONFIG_SYS_TEXT_BASE		0x11001000
+#endif  /* CONFIG_NAND_SPL */
+#endif
+
+
+#ifdef CONFIG_NAND_SECBOOT	/* NAND Boot */
+#define CONFIG_RAMBOOT_NAND
+#define CONFIG_SYS_TEXT_BASE		0x11000000
+#define CONFIG_RESET_VECTOR_ADDRESS	0x1107fffc
+#endif
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE		0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE			/* BOOKE */
+#define CONFIG_E500			/* BOOKE e500 family */
+#define CONFIG_MPC85xx			/* MPC8540/60/55/41/48/P1020/P2020/P1010,etc*/
+#define CONFIG_FSL_IFC			/* Enable IFC Support */
+#define CONFIG_SYS_HAS_SERDES		/* common SERDES init code */
+
+#define CONFIG_PCI			/* Enable PCI/PCIE */
+#if defined(CONFIG_PCI)
+#define CONFIG_PCIE1			/* PCIE controler 1 (slot 1) */
+/*#define CONFIG_PCIE2	 	*/	/* PCIE controler 2 (slot 2) */
+
+#define CONFIG_FSL_PCI_INIT		/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET		/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT		/* enable 64-bit PCI resources */
+
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PCI
+
+#define CONFIG_E1000			/*  E1000 pci Ethernet card*/
+
+/*
+ * PCI Windows
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+/* controller 1, Slot 1, tgtid 1, Base address a000 */
+
+#define CONFIG_SYS_PCIE1_NAME		"mini PCIe Slot"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0x80000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc00000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc00000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc00000
+#endif
+
+/*
+#define CONFIG_SYS_PCIE1_NAME		"PCIe Slot"
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xfffc10000ull
+#else
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc10000
+#endif
+*/
+
+/* controller 2, Slot 2, tgtid 2, Base address 9000 */
+#define CONFIG_SYS_PCIE2_NAME		"PCIe Slot"
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xc0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#else
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xa0000000
+#endif
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x20000000	/* 512M */
+
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xffc10000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xfffc10000ull
+#else
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xffc10000
+#endif
+
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif
+
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_TSEC_ENET
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_DDR_CLK_FREQ	66666666 /* DDRCLK on P1010 RDB */
+#define CONFIG_SYS_CLK_FREQ	66666666 /* SYSCLK for P1010 RDB */
+
+#ifndef CONFIG_SDCARD
+#define CONFIG_MISC_INIT_R
+#endif
+
+#define CONFIG_HWCONFIG
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+#define CONFIG_ADDR_STREAMING		/* toggle addr streaming */
+
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP			1
+#define CONFIG_SYS_NUM_ADDR_MAP		16	/* number of TLB1 entries */
+#endif
+
+#define CONFIG_MEMTEST_SKIP_UBOOT_SIZE 0x100000	/*the uboot size should be smaller than 1 MB*/
+#define CONFIG_SYS_MEMTEST_START	0x11000000+CONFIG_MEMTEST_SKIP_UBOOT_SIZE	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x1f7fffff	/*reserver 8 MB not to test, in case the system has put data in.*/
+#define CONFIG_PANIC_HANG		/* do not reset board on panic */
+
+/* DDR Setup */
+#define CONFIG_FSL_DDR3
+/*#define CONFIG_DDR_RAW_TIMING
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_SPD_BUS_NUM		1
+#define SPD_EEPROM_ADDRESS		0x52
+*/
+#define CONFIG_MEM_INIT_VALUE		0xDeadBeef
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_sdram_size(void);
+#endif
+#define CONFIG_SYS_SDRAM_SIZE		get_sdram_size() /* DDR size */
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	1
+
+/* DDR3 Controller Settings */
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000001f
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80014202
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+#define CONFIG_SYS_DDR_DATA_INIT	0xdeadbeef
+#define CONFIG_SYS_DDR_INIT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000
+
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x89080600
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1		0x00000000
+#define CONFIG_SYS_DDR_RCW_2		0x00000000
+#define CONFIG_SYS_DDR_CONTROL		0x470C0000	/* Type = DDR3  */
+/* for the value of DDR_SDRAM_CFG_2: mem [CCSR 0x2114] = 0x04401000
+#define CONFIG_SYS_DDR_CONTROL_2	0x04401010
+*/
+#define CONFIG_SYS_DDR_CONTROL_2	0x04401000
+
+#define CONFIG_SYS_DDR_TIMING_4		0x00000001
+#define CONFIG_SYS_DDR_TIMING_5		0x03402400
+
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x00330004
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6B4644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA888CF
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_800	0x40461520
+#define CONFIG_SYS_DDR_MODE_2_800	0x8000c000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0C300100
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_800	0x8655A608
+
+
+
+/* settings for DDR3 at 667MT/s */
+#define CONFIG_SYS_DDR_TIMING_3_667		0x00010000
+#define CONFIG_SYS_DDR_TIMING_0_667		0x00110004
+#define CONFIG_SYS_DDR_TIMING_1_667		0x5d59e544
+#define CONFIG_SYS_DDR_TIMING_2_667		0x0FA890CD
+
+/*  Revise this for the defination of DDR_SDRAM_CLK_CNTL
+#define CONFIG_SYS_DDR_CLK_CTRL_667		0x03000000
+*/
+#define CONFIG_SYS_DDR_CLK_CTRL_667		0x02000000
+
+#define CONFIG_SYS_DDR_MODE_1_667		0x00441210
+#define CONFIG_SYS_DDR_MODE_2_667		0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667		0x0a280000
+
+/*
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_667	0x8675F608
+//for new boundary test
+*/
+#define CONFIG_SYS_DDR_WRLVL_CONTROL_667 0x8675F605
+
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CONFIG_SYS_CCSRBAR		0xffe00000	/* relocated CCSRBAR */
+
+/* "Don't relocate CCSRBAR while in NAND_SPL." */
+#if defined(CONFIG_NAND_SPL)
+#define CONFIG_SYS_CCSRBAR_PHYS	CONFIG_SYS_CCSRBAR_DEFAULT
+#else
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_CCSRBAR_PHYS	0xfffe00000ull
+#else
+#define CONFIG_SYS_CCSRBAR_PHYS	CONFIG_SYS_CCSRBAR
+#endif
+							/* CCSRBAR */
+#endif /* CONFIG_NAND_SPL */
+
+#define CONFIG_SYS_IMMR		CONFIG_SYS_CCSRBAR	/* PQII uses */
+							/* CONFIG_SYS_IMMR */
+
+/*
+ * Memory map
+ *
+ * 0x0000_0000	0x3fff_ffff	DDR			1G cacheable
+ * 0x8000_0000  0xbfff_ffff	PCI Express Mem		1.5G non-cacheable
+ * 0xffc0_0000  0xffc3_ffff	PCI IO range		256k non-cacheable
+ *
+ * Localbus non-cacheable
+ * 0xff80_0000	0xff8f_ffff	NAND Flash		1M non-cacheable
+ * 0xffb0_0000	0xffbf_ffff	Board CPLD		1M non-cacheable
+ * 0xffd0_0000	0xffd0_3fff	L1 for stack		16K Cacheable TLB0
+ * 0xffe0_0000	0xffef_ffff	CCSR			1M non-cacheable
+ */
+
+/* In case of SD card boot, IFC interface is not available because of muxing */
+#ifdef CONFIG_SDCARD
+#define CONFIG_SYS_NO_FLASH
+#else
+/*
+ * IFC Definitions
+ */
+/* NOR Flash on IFC */
+#define CONFIG_SYS_FLASH_BASE		0xee000000
+#define CONFIG_SYS_MAX_FLASH_SECT	256	/* 32M */
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#else
+#define CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#endif
+
+#define CONFIG_SYS_NOR_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(32*1024*1024)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(7)
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_FTIM0	FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5)
+#define CONFIG_SYS_NOR_FTIM1	FTIM1_NOR_TACO(0x1e) | \
+				FTIM1_NOR_TRAD_NOR(0x0f)
+#define CONFIG_SYS_NOR_FTIM2	FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWP(0x1c)
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+
+/*
+#define CONFIG_SYS_FLASH_QUIET_TEST
+*/
+#define CONFIG_FLASH_SHOW_PROGRESS	45	/* count down from 45/5: 9..1 */
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+
+#undef CONFIG_SYS_FLASH_CHECKSUM
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+/* CFI for NOR Flash */
+/*
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE         1
+#define CONFIG_SYS_FLASH_BUFFER_WRITE_EXTERN_DELAY  1
+*/
+#define CONFIG_SYS_NAND_BASE		0xff800000
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_NAND_BASE_PHYS	0xfff800000ull
+#else
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#endif
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_NAND_BASE}
+
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8	/* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4	/* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2048Byte */ \
+				| CSOR_NAND_SPRZ_64	/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/* Pages Per Block = 64 */
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+/* NAND Flash Timing Params */
+#define CONFIG_SYS_NAND_FTIM0 		FTIM0_NAND_TCCST(0x01) | \
+					FTIM0_NAND_TWP(0x0C)   | \
+					FTIM0_NAND_TWCHT(0x04) | \
+					FTIM0_NAND_TWH(0x05)
+#define CONFIG_SYS_NAND_FTIM1 		FTIM1_NAND_TADLE(0x1d) | \
+					FTIM1_NAND_TWBE(0x1d)  | \
+					FTIM1_NAND_TRR(0x07)   | \
+					FTIM1_NAND_TRP(0x0c)
+#define CONFIG_SYS_NAND_FTIM2 		FTIM2_NAND_TRAD(0x0c) | \
+					FTIM2_NAND_TREH(0x05) | \
+					FTIM2_NAND_TWHRE(0x0f)
+#define CONFIG_SYS_NAND_FTIM3 		FTIM3_NAND_TWW(0x04)
+
+#define CONFIG_SYS_NAND_DDR_LAW		11
+
+/* Set up IFC registers from boot location NOR/NAND */
+/*
+#if defined(CONFIG_NAND_U_BOOT) || defined(CONFIG_NAND_SECBOOT)
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#else
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+#endif
+*/
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+
+/* NAND boot: 8K NAND loader config */
+#define CONFIG_SYS_NAND_SPL_SIZE	0x2000
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 << 10)
+#define CONFIG_SYS_NAND_U_BOOT_DST	(0x11000000 - CONFIG_SYS_NAND_SPL_SIZE)
+#define CONFIG_SYS_NAND_U_BOOT_START	0x11000000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(0)
+#define CONFIG_SYS_NAND_U_BOOT_RELOC	0x10000
+#define CONFIG_SYS_NAND_U_BOOT_RELOC_SP	(CONFIG_SYS_NAND_U_BOOT_RELOC + 0x10000)
+
+#define CONFIG_SYS_CPLD_BASE		0xffb00000
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_SYS_CPLD_BASE_PHYS	0xfffb00000ull
+#else
+#define CONFIG_SYS_CPLD_BASE_PHYS	CONFIG_SYS_CPLD_BASE
+#endif
+
+#define CONFIG_SYS_CSPR3		(CSPR_PHYS_ADDR(CONFIG_SYS_CPLD_BASE_PHYS) | \
+					CSPR_PORT_SIZE_8 | CSPR_MSEL_GPCM | CSPR_V)
+#define CONFIG_SYS_AMASK3		IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR3		0x0
+/* CPLD Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0x0e) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0x0e) | \
+					FTIM2_GPCM_TCH(0x0) | \
+					FTIM2_GPCM_TWP(0x1f))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+#endif
+
+#if defined(CONFIG_RAMBOOT_SDCARD) || defined(CONFIG_RAMBOOT_SPIFLASH) || \
+    defined(CONFIG_RAMBOOT_NAND)
+#define CONFIG_SYS_RAMBOOT
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#else
+#undef CONFIG_SYS_RAMBOOT
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_F	/* Call board_pre_init */
+#define CONFIG_BOARD_EARLY_INIT_R
+
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* stack in RAM */
+#define CONFIG_SYS_INIT_RAM_END		0x00004000	/* End of used area in RAM */
+
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_END \
+						- GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+#define CONFIG_SYS_MONITOR_LEN		(256 * 1024) /* Reserve 256 kB for Mon*/
+#define CONFIG_SYS_MALLOC_LEN		(1024 * 1024)	/* Reserved for malloc*/
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX	1
+#undef	CONFIG_SERIAL_SOFTWARE_FIFO
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SERIAL_MULTI		/* Enable both serial ports */
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV	/* determine from environment */
+
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef	CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+/*
+ * Pass open firmware flat tree
+ */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE		/* enable fit_format_{error,warning}() */
+
+#define CONFIG_FSL_I2C			/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C			/* I2C with hardware support */
+#undef CONFIG_SOFT_I2C			/* I2C bit-banged */
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_CMD_TREE
+#define CONFIG_SYS_I2C_SPEED		400000 /* I2C speed and slave address*/
+#define CONFIG_SYS_I2C_SLAVE		0x7F
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+/* I2C EEPROM */
+#undef CONFIG_ID_EEPROM
+/* enable read and write access to EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_MULTI_EEPROMS
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+/* RTC */
+/*
+#define CONFIG_RTC_PT7C4338
+#define CONFIG_SYS_I2C_RTC_ADDR	0x68
+*/
+#define CONFIG_RTC_S35390
+#define CONFIG_SYS_I2C_RTC_ADDR	0x30
+
+#define CONFIG_CMD_I2C
+
+/*
+ * SPI interface will not be available in case of NAND boot SPI CS0 will be
+ * used for SLIC
+ */
+
+#if !defined(CONFIG_NAND_U_BOOT) || !defined(CONFIG_NAND_SECBOOT)
+/* eSPI - Enhanced SPI */
+#define CONFIG_FSL_ESPI
+#define CONFIG_WG_FSL_ESPI
+#define CONFIG_SPI_FLASH
+#define CONFIG_WG_SPI_FLASH
+
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_WG_SPI_FLASH_MACRONIX
+
+#define CONFIG_CF_DSPI
+/*
+#define CONFIG_SPI_FLASH_SPANSION
+*/
+#define CONFIG_CMD_SF
+#define CONFIG_SF_DEFAULT_SPEED		10000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+
+#if defined(CONFIG_TSEC_ENET)
+#ifndef CONFIG_NET_MULTI
+#define CONFIG_NET_MULTI
+#endif
+
+#define CONFIG_MII			/* MII PHY management */
+#define CONFIG_MII_DEFAULT_TSEC	2	/* Allow unregistered phys */
+#define CONFIG_TSEC1	1
+#define CONFIG_TSEC1_NAME	"eTSEC1"
+#define CONFIG_TSEC2	1
+#define CONFIG_TSEC2_NAME	"eTSEC2"
+#define CONFIG_TSEC3	1
+#define CONFIG_TSEC3_NAME	"eTSEC3"
+
+#define TSEC1_PHY_ADDR		1
+#define TSEC2_PHY_ADDR		2
+#define TSEC3_PHY_ADDR		3
+
+
+
+#define TSEC1_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC2_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+#define TSEC3_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define TSEC1_PHYIDX		0
+#define TSEC2_PHYIDX		0
+#define TSEC3_PHYIDX		0
+
+#define CONFIG_ETHPRIME		"eTSEC1"
+
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+
+/* TBI PHY configuration for SGMII mode */
+#define CONFIG_TSEC_TBICR_SETTINGS ( \
+		TBICR_PHY_RESET \
+		| TBICR_ANEG_ENABLE \
+		| TBICR_FULL_DUPLEX \
+		| TBICR_SPEED1_SET \
+		)
+
+#endif	/* CONFIG_TSEC_ENET */
+
+
+/* SATA */
+/*
+#define CONFIG_FSL_SATA
+#define CONFIG_LIBATA
+
+#ifdef CONFIG_FSL_SATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	2
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_SATA2
+#define CONFIG_SYS_SATA2		CONFIG_SYS_MPC85xx_SATA2_ADDR
+#define CONFIG_SYS_SATA2_FLAGS		FLAGS_DMA
+
+#define CONFIG_CMD_SATA
+#define CONFIG_LBA48
+#endif
+*/
+ /* #ifdef CONFIG_FSL_SATA  */
+
+/*  SD interface will only be available in case of SD boot */
+#ifdef CONFIG_SDCARD
+#define CONFIG_MMC
+#define CONFIG_DEF_HWCONFIG		esdhc
+#endif
+
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_FSL_ESDHC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#endif
+
+#define CONFIG_USB_EHCI
+#define CONFIG_SYS_FSL_USB_INTERNAL_UTMI_PHY
+
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_USB_STORAGE
+#define CONFIG_HAS_FSL_DR_USB
+#endif
+
+/*
+ * Environment
+ */
+#if defined(CONFIG_SYS_RAMBOOT)
+  #if defined(CONFIG_RAMBOOT_SDCARD)
+   #define CONFIG_ENV_IS_IN_MMC
+   #define CONFIG_SYS_MMC_ENV_DEV		0
+   #define CONFIG_ENV_SIZE			0x2000
+  #elif defined(CONFIG_RAMBOOT_SPIFLASH)
+   #define CONFIG_ENV_IS_IN_SPI_FLASH
+   #define CONFIG_ENV_SPI_BUS	0
+   #define CONFIG_ENV_SPI_CS	0
+   #define CONFIG_ENV_SPI_MAX_HZ	10000000
+   #define CONFIG_ENV_SPI_MODE	0
+   #define CONFIG_ENV_OFFSET		0x90000
+   /*since for macronix M25FL8006E the sector size is 64K*/
+   #define CONFIG_ENV_SECT_SIZE		0x10000
+   #define CONFIG_ENV_SIZE		 0x2000
+  #elif defined(CONFIG_NAND_U_BOOT)
+   #define CONFIG_ENV_IS_IN_NAND
+   #define CONFIG_ENV_SIZE		CONFIG_SYS_NAND_BLOCK_SIZE
+   #define CONFIG_ENV_OFFSET	CONFIG_SYS_NAND_U_BOOT_SIZE
+   #define CONFIG_ENV_RANGE	(3 * CONFIG_ENV_SIZE)
+  #else
+   #define CONFIG_ENV_IS_NOWHERE		/* Store ENV in memory only */
+   #define CONFIG_ENV_ADDR			(CONFIG_SYS_MONITOR_BASE - 0x1000)
+   #define CONFIG_ENV_SIZE			0x2000
+  #endif
+#else
+  #define CONFIG_ENV_IS_IN_FLASH
+  #if CONFIG_SYS_MONITOR_BASE > 0xfff80000
+   #define CONFIG_ENV_ADDR	0xfff80000
+  #else
+   #define CONFIG_ENV_ADDR	(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+  #endif
+  #define CONFIG_ENV_SIZE		0x2000
+  #define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#define CONFIG_LOADS_ECHO			/* echo on for serial download */
+#define CONFIG_SYS_LOADS_BAUD_CHANGE		/* allow baudrate change */
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#include <version.h>
+
+#define CONFIG_CMD_DATE
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_REGINFO
+
+#undef CONFIG_WATCHDOG			/* watchdog disabled */
+
+#if defined(CONFIG_MMC) || defined(CONFIG_USB_EHCI) \
+		 || defined(CONFIG_FSL_SATA)
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP			/* undef to save memory	*/
+#define CONFIG_CMDLINE_EDITING			/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE			/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x600000	/* default load address */
+
+# if defined (CONFIG_T10)
+#   define CONFIG_SYS_PROMPT      "T10 => "           /* Monitor Command Prompt */
+# else
+#   define CONFIG_SYS_PROMPT      "=> " /* Monitor Command Prompt */
+#endif
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_SYS_CBSIZE	1024		/* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	256		/* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+						/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+#define CONFIG_SYS_HZ		1000		/* decrementer freq: 1ms ticks */
+
+/*
+#define CONFIG_CMD_TPM
+*/
+
+/*
+ * Internal Definitions
+ *
+ * Boot Flags
+ */
+#define BOOTFLAG_COLD	0x01		/* Normal Power-On: Boot from FLASH */
+#define BOOTFLAG_WARM	0x02		/* Software reboot */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 16 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(16 << 20) /* Initial Memory map for Linux */
+#define CONFIG_SYS_BOOTM_LEN	(16 << 20) /* Increase max gunzip size */
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#endif
+
+#define CONFIG_HOSTNAME		P1010RDB
+#define CONFIG_ROOTPATH		/opt/nfsroot
+#define CONFIG_BOOTFILE		uImage
+#define CONFIG_UBOOTPATH	u-boot.bin/* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+
+#define CONFIG_BOOTDELAY	3	/* -1 disables auto-boot */
+#undef  CONFIG_BOOTARGS		/* the boot command will set bootargs */
+
+#define CONFIG_BAUDRATE		115200
+
+
+#if defined(CONFIG_P1010) || defined(CONFIG_FBX_T10)
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=" MK_STR(CONFIG_DEF_HWCONFIG)  "\0"	\
+	"netdev=eth0\0"						\
+	"uboot=" MK_STR(CONFIG_UBOOTPATH) "\0"				\
+	"loadaddr=1000000\0"			\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=p1010rdb.dtb\0"		\
+	"bdev=sda1\0"	\
+	"SysARoot=mtdblock2\0"		\
+	"SysBRoot=mtdblock4\0"		\
+	"SysA2Root=mtdblock6\0"		\
+	"SysARootAddr=520000\0"		\
+	"SysBRootAddr=8400000\0"	\
+	"SysA2RootAddr=a100000\0"	\
+	"SysAKernAddr=20000\0"		\
+	"SysAKernSize=500000\0"		\
+	"SysBKernAddr=7f00000\0"	\
+	"SysBKernSize=500000\0"		\
+	"SysA2KernAddr=9c00000\0"	\
+	"SysA2KernSize=500000\0"	\
+	"DTBAddr=0\0"			\
+	"DTBSize=20000\0"		\
+	"SysAMfgRootSize=2000000\0"	\
+	"SysBMfgRootSize=800000\0"	\
+	"hwconfig=usb1:dr_mode=host,phy_type=utmi\0"	\
+	"othbootargs=ramdisk_size=600000\0" \
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"	\
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysBKernAddr $SysBKernSize;"	\
+	"bootm;\0"			\
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw rootfstype=jffs2 " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"bootm;\0"			\
+	"wgBootMfgsys=setenv bootargs rdinit=/sbin/init " \
+	"console=$consoledev,$baudrate;"			\
+	"nand read $loadaddr $SysAKernAddr $SysAKernSize;"	\
+	"nand read $ramdiskaddr $SysARootAddr $SysAMfgRootSize;"	\
+	"bootm $loadaddr:kernel@1 $ramdiskaddr $loadaddr:fdt@1; \0"	\
+	"nuke_env=sf probe 0;sf erase 90000 10000 \0"	\
+	"spitest=sf probe 0;sf erase 100000 10000; sf read 100000 100; md.b 100000 100;echo \"spitest all \"; \0"	\
+	"upgrade_uboot=tftp 2000000 dixie/uboot/u-boot-spi.bin;sf probe 0;sf erase 0 90000;sf write 2000000 0 80400; \0" \
+	"serverip=10.0.1.13\0 "	\
+	"ipaddr=10.0.1.1\0 "	\
+	"netmask=255.255.255.0\0 "	\
+	"ethaddr=192.168.1.1\0 "	\
+	"eth1addr=192.168.1.2\0 "	\
+	"eth2addr=192.168.1.3\0 "	\
+	"uboot_built_info=" U_BOOT_VERSION " - " PERFORCE_CHANGE "B (" U_BOOT_DATE " - " U_BOOT_TIME ")" "\0"
+	
+#else
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=" MK_STR(CONFIG_DEF_HWCONFIG)  "\0"	\
+	"netdev=eth0\0"						\
+	"uboot=" MK_STR(CONFIG_UBOOTPATH) "\0"				\
+	"loadaddr=1000000\0"			\
+	"consoledev=ttyS0\0"				\
+	"ramdiskaddr=2000000\0"			\
+	"ramdiskfile=rootfs.ext2.gz.uboot\0"		\
+	"fdtaddr=c00000\0"				\
+	"fdtfile=p1010rdb.dtb\0"		\
+	"bdev=sda1\0"	\
+	"hwconfig=usb1:dr_mode=host,phy_type=utmi\0"	\
+	"othbootargs=ramdisk_size=600000\0" \
+	"usbfatboot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"fatload usb 0:2 $loadaddr $bootfile;"		\
+	"fatload usb 0:2 $fdtaddr $fdtfile;"	\
+	"fatload usb 0:2 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"usbext2boot=setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"usb start;"			\
+	"ext2load usb 0:4 $loadaddr $bootfile;"		\
+	"ext2load usb 0:4 $fdtaddr $fdtfile;"	\
+	"ext2load usb 0:4 $ramdiskaddr $ramdiskfile;"	\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr\0"		\
+	"serverip=192.168.1.101\0 "	\
+	"ipaddr=192.168.1.1\0 "	 \
+	"ethaddr=192.168.1.1\0 " \
+	"uboot_built_info=" U_BOOT_VERSION " - " PERFORCE_CHANGE "B (" U_BOOT_DATE " - " U_BOOT_TIME ")" "\0"
+#endif
+
+
+#define CONFIG_RAMBOOTCOMMAND		\
+	"setenv bootargs root=/dev/ram rw "	\
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"tftp $ramdiskaddr $ramdiskfile;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr;"
+		
+
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#endif
+
+#endif	/* __CONFIG_H */
--- u-boot-2011.03/drivers/spi/fsl_espi.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/spi/fsl_espi.c	2022-05-09 14:05:11.592053432 -0700
@@ -0,0 +1,332 @@
+/*
+ * eSPI controller driver.
+ *
+ * Copyright 2010-2011 Freescale Semiconductor, Inc.
+ * Author: Mingkai Hu (Mingkai.hu@freescale.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <malloc.h>
+#include <spi.h>
+#include <asm/immap_85xx.h>
+
+struct fsl_spi_slave {
+	struct spi_slave slave;
+	unsigned int	div16;
+	unsigned int	pm;
+	unsigned int	mode;
+	size_t		cmd_len;
+	u8		cmd_buf[16];
+	size_t		data_len;
+	unsigned int    max_transfer_length;
+};
+
+#define to_fsl_spi_slave(s) container_of(s, struct fsl_spi_slave, slave)
+
+#define ESPI_MAX_CS_NUM		4
+
+#define ESPI_EV_RNE		(1 << 9)
+#define ESPI_EV_TNF		(1 << 8)
+
+#define ESPI_MODE_EN		(1 << 31)	/* Enable interface */
+#define ESPI_MODE_TXTHR(x)	((x) << 8)	/* Tx FIFO threshold */
+#define ESPI_MODE_RXTHR(x)	((x) << 0)	/* Rx FIFO threshold */
+
+#define ESPI_COM_CS(x)		((x) << 30)
+#define ESPI_COM_TRANLEN(x)	((x) << 0)
+
+#define ESPI_CSMODE_CI_INACTIVEHIGH	(1 << 31)
+#define ESPI_CSMODE_CP_BEGIN_EDGCLK	(1 << 30)
+#define ESPI_CSMODE_REV_MSB_FIRST	(1 << 29)
+#define ESPI_CSMODE_DIV16		(1 << 28)
+#define ESPI_CSMODE_PM(x)		((x) << 24)
+#define ESPI_CSMODE_POL_ASSERTED_LOW	(1 << 20)
+#define ESPI_CSMODE_LEN(x)		((x) << 16)
+#define ESPI_CSMODE_CSBEF(x)		((x) << 12)
+#define ESPI_CSMODE_CSAFT(x)		((x) << 8)
+#define ESPI_CSMODE_CSCG(x)		((x) << 3)
+
+#define ESPI_CSMODE_INIT_VAL (ESPI_CSMODE_POL_ASSERTED_LOW | \
+		ESPI_CSMODE_CSBEF(0) | ESPI_CSMODE_CSAFT(0) | \
+		ESPI_CSMODE_CSCG(1))
+
+#define ESPI_MAX_DATA_TRANSFER_LEN 0xFFF0
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct fsl_spi_slave *fsl;
+	sys_info_t sysinfo;
+	unsigned long spibrg = 0;
+	unsigned char pm = 0;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	fsl = malloc(sizeof(struct fsl_spi_slave));
+	if (!fsl)
+		return NULL;
+
+	fsl->slave.bus = bus;
+	fsl->slave.cs = cs;
+	fsl->mode = mode;
+	fsl->max_transfer_length = ESPI_MAX_DATA_TRANSFER_LEN;
+
+	/* Set eSPI BRG clock source */
+	get_sys_info(&sysinfo);
+	spibrg = sysinfo.freqSystemBus / 2;
+	fsl->div16 = 0;
+	if ((spibrg / max_hz) > 32) {
+		fsl->div16 = ESPI_CSMODE_DIV16;
+		pm = spibrg / (max_hz * 16 * 2);
+		if (pm > 16) {
+			pm = 16;
+			debug("Requested speed is too low: %d Hz, %ld Hz "
+				"is used.\n", max_hz, spibrg / (32 * 16));
+		}
+	} else
+		pm = spibrg / (max_hz * 2);
+	if (pm)
+		pm--;
+	fsl->pm = pm;
+
+	return &fsl->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
+	free(fsl);
+}
+
+void spi_init(void)
+{
+
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
+	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
+	unsigned char pm = fsl->pm;
+	unsigned int cs = slave->cs;
+	unsigned int mode =  fsl->mode;
+	unsigned int div16 = fsl->div16;
+	int i;
+
+	debug("%s: bus:%i cs:%i\n", __func__, slave->bus, cs);
+
+	/* Enable eSPI interface */
+	out_be32(&espi->mode, ESPI_MODE_RXTHR(3)
+			| ESPI_MODE_TXTHR(4) | ESPI_MODE_EN);
+
+	out_be32(&espi->event, 0xffffffff); /* Clear all eSPI events */
+	out_be32(&espi->mask, 0x00000000); /* Mask  all eSPI interrupts */
+
+	/* Init CS mode interface */
+	for (i = 0; i < ESPI_MAX_CS_NUM; i++)
+		out_be32(&espi->csmode[i], ESPI_CSMODE_INIT_VAL);
+
+	out_be32(&espi->csmode[cs], in_be32(&espi->csmode[cs]) &
+		~(ESPI_CSMODE_PM(0xF) | ESPI_CSMODE_DIV16
+		| ESPI_CSMODE_CI_INACTIVEHIGH | ESPI_CSMODE_CP_BEGIN_EDGCLK
+		| ESPI_CSMODE_REV_MSB_FIRST | ESPI_CSMODE_LEN(0xF)));
+
+	/* Set eSPI BRG clock source */
+	out_be32(&espi->csmode[cs], in_be32(&espi->csmode[cs])
+		| ESPI_CSMODE_PM(pm) | div16);
+
+	/* Set eSPI mode */
+	if (mode & SPI_CPHA)
+		out_be32(&espi->csmode[cs], in_be32(&espi->csmode[cs])
+			| ESPI_CSMODE_CP_BEGIN_EDGCLK);
+	if (mode & SPI_CPOL)
+		out_be32(&espi->csmode[cs], in_be32(&espi->csmode[cs])
+			| ESPI_CSMODE_CI_INACTIVEHIGH);
+
+	/* Character bit order: msb first */
+	out_be32(&espi->csmode[cs], in_be32(&espi->csmode[cs])
+		| ESPI_CSMODE_REV_MSB_FIRST);
+
+	/* Character length in bits, between 0x3~0xf, i.e. 4bits~16bits */
+	out_be32(&espi->csmode[cs], in_be32(&espi->csmode[cs])
+		| ESPI_CSMODE_LEN(7));
+
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+
+}
+
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *data_out,
+		void *data_in, unsigned long flags)
+{
+	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
+	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
+	unsigned int tmpdout, tmpdin, event;
+	const void *dout = NULL;
+	void *din = NULL;
+	int len = 0;
+	int num_blks, num_chunks, max_tran_len, tran_len;
+	int num_bytes;
+	unsigned char *ch;
+	unsigned char *buffer = NULL;
+	size_t buf_len;
+	u8 *cmd_buf = fsl->cmd_buf;
+	size_t cmd_len = fsl->cmd_len;
+	size_t data_len = bitlen / 8;
+	size_t rx_offset = 0;
+
+	max_tran_len = fsl->max_transfer_length;
+	switch (flags) {
+	case SPI_XFER_BEGIN:
+		cmd_len = fsl->cmd_len = data_len;
+		memcpy(cmd_buf, data_out, cmd_len);
+		return 0;
+	case 0:
+	case SPI_XFER_END:
+		if (bitlen == 0) {
+			spi_cs_deactivate(slave);
+			return 0;
+		}
+		buf_len = 2 * cmd_len + min(data_len, max_tran_len);
+		len = cmd_len + data_len;
+		rx_offset = cmd_len;
+		buffer = (unsigned char *)malloc(buf_len);
+		if (!buffer) {
+			debug("SF: Failed to malloc memory.\n");
+			return 1;
+		}
+		memcpy(buffer, cmd_buf, cmd_len);
+		if (data_in == NULL)
+			memcpy(buffer + cmd_len, data_out, data_len);
+		break;
+	case SPI_XFER_BEGIN | SPI_XFER_END:
+		len = data_len;
+		buffer = (unsigned char *)malloc(len * 2);
+		if (!buffer) {
+			debug("SF: Failed to malloc memory.\n");
+			return 1;
+		}
+		memcpy(buffer, data_out, len);
+		rx_offset = len;
+		cmd_len = 0;
+		break;
+	}
+
+	debug("spi_xfer: slave %u:%u dout %08X(%p) din %08X(%p) len %u\n",
+	      slave->bus, slave->cs, *(uint *) dout,
+	      dout, *(uint *) din, din, len);
+
+	num_chunks = data_len / max_tran_len +
+		(data_len % max_tran_len ? 1 : 0);
+	while (num_chunks--) {
+		if (data_in)
+			din = buffer + rx_offset;
+		dout = buffer;
+		tran_len = min(data_len , max_tran_len);
+		num_blks = (tran_len + cmd_len) / 4 +
+			((tran_len + cmd_len) % 4 ? 1 : 0);
+		num_bytes = (tran_len + cmd_len) % 4;
+		fsl->data_len = tran_len + cmd_len;
+		spi_cs_activate(slave);
+
+		/* Clear all eSPI events */
+		out_be32(&espi->event , 0xffffffff);
+		/* handle data in 32-bit chunks */
+		while (num_blks--) {
+
+			event = in_be32(&espi->event);
+			if (event & ESPI_EV_TNF) {
+				tmpdout = *(u32 *)dout;
+
+				/* Set up the next iteration */
+				if (len > 4) {
+					len -= 4;
+					dout += 4;
+				}
+
+				out_be32(&espi->tx, tmpdout);
+				out_be32(&espi->event, ESPI_EV_TNF);
+				debug("***spi_xfer:...%08x written\n", tmpdout);
+			}
+
+			/* Wait for eSPI transmit to get out */
+			udelay(80);
+
+			event = in_be32(&espi->event);
+			if (event & ESPI_EV_RNE) {
+				tmpdin = in_be32(&espi->rx);
+				if (num_blks == 0 && num_bytes != 0) {
+					ch = (unsigned char *)&tmpdin;
+					while (num_bytes--)
+						*(unsigned char *)din++ = *ch++;
+				} else {
+					*(u32 *) din = tmpdin;
+					din += 4;
+				}
+
+				out_be32(&espi->event, in_be32(&espi->event)
+						| ESPI_EV_RNE);
+				debug("***spi_xfer:...%08x readed\n", tmpdin);
+			}
+		}
+		if (data_in) {
+			memcpy(data_in, buffer + 2 * cmd_len, tran_len);
+			if (*buffer == 0x0b) {
+				data_in += tran_len;
+				data_len -= tran_len;
+				*(int *)buffer += tran_len;
+			}
+		}
+		spi_cs_deactivate(slave);
+	}
+
+	free(buffer);
+	return 0;
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return bus == 0 && cs < ESPI_MAX_CS_NUM;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct fsl_spi_slave *fsl = to_fsl_spi_slave(slave);
+	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
+	unsigned int com = 0;
+	size_t data_len = fsl->data_len;
+
+	com &= ~(ESPI_COM_CS(0x3) | ESPI_COM_TRANLEN(0xFFFF));
+	com |= ESPI_COM_CS(slave->cs);
+	com |= ESPI_COM_TRANLEN(data_len - 1);
+	out_be32(&espi->com, com);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	ccsr_espi_t *espi = (void *)(CONFIG_SYS_MPC85xx_ESPI_ADDR);
+
+	/* clear the RXCNT and TXCNT */
+	out_be32(&espi->mode, in_be32(&espi->mode) & (~ESPI_MODE_EN));
+	out_be32(&espi->mode, in_be32(&espi->mode) | ESPI_MODE_EN);
+}
--- u-boot-2011.03/drivers/usb/host/ehci-fsl_org.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/usb/host/ehci-fsl_org.c	2022-05-09 14:05:11.600053108 -0700
@@ -0,0 +1,79 @@
+/*
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2008, Excito Elektronik i Sk=E5ne AB
+ *
+ * Author: Tor Krill tor@excito.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <usb.h>
+#include <asm/io.h>
+#include <usb/ehci-fsl.h>
+
+#include "ehci.h"
+#include "ehci-core.h"
+
+/*
+ * Create the appropriate control structures to manage
+ * a new EHCI host controller.
+ *
+ * Excerpts from linux ehci fsl driver.
+ */
+int ehci_hcd_init(void)
+{
+	struct usb_ehci *ehci;
+
+	ehci = (struct usb_ehci *)CONFIG_SYS_FSL_USB_ADDR;
+	hccr = (struct ehci_hccr *)((uint32_t)&ehci->caplength);
+	hcor = (struct ehci_hcor *)((uint32_t) hccr +
+			HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	/* Set to Host mode */
+	setbits_le32(&ehci->usbmode, CM_HOST);
+
+	out_be32(&ehci->snoop1, SNOOP_SIZE_2GB);
+	out_be32(&ehci->snoop2, 0x80000000 | SNOOP_SIZE_2GB);
+
+	/* Init phy */
+	if (!strcmp(getenv("usb_phy_type"), "utmi"))
+		out_le32(&(hcor->or_portsc[0]), PORT_PTS_UTMI);
+	else
+		out_le32(&(hcor->or_portsc[0]), PORT_PTS_ULPI);
+
+	/* Enable interface. */
+	setbits_be32(&ehci->control, USB_EN);
+
+	out_be32(&ehci->prictrl, 0x0000000c);
+	out_be32(&ehci->age_cnt_limit, 0x00000040);
+	out_be32(&ehci->sictrl, 0x00000001);
+
+	in_le32(&ehci->usbmode);
+
+	return 0;
+}
+
+/*
+ * Destroy the appropriate control structures corresponding
+ * the the EHCI host controller.
+ */
+int ehci_hcd_stop(void)
+{
+	return 0;
+}
--- u-boot-2011.03/drivers/usb/host/ehci-pci_org.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/usb/host/ehci-pci_org.c	2022-05-09 14:05:11.600053108 -0700
@@ -0,0 +1,70 @@
+/*-
+ * Copyright (c) 2007-2008, Juniper Networks, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2 of
+ * the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <pci.h>
+#include <usb.h>
+
+#include "ehci.h"
+#include "ehci-core.h"
+
+#ifdef CONFIG_PCI_EHCI_DEVICE
+static struct pci_device_id ehci_pci_ids[] = {
+	/* Please add supported PCI EHCI controller ids here */
+	{0x1033, 0x00E0},
+	{0, 0}
+};
+#endif
+
+/*
+ * Create the appropriate control structures to manage
+ * a new EHCI host controller.
+ */
+int ehci_hcd_init(void)
+{
+	pci_dev_t pdev;
+	uint32_t addr;
+
+	pdev = pci_find_devices(ehci_pci_ids, CONFIG_PCI_EHCI_DEVICE);
+	if (pdev == -1) {
+		printf("EHCI host controller not found\n");
+		return -1;
+	}
+
+	pci_read_config_dword(pdev, PCI_BASE_ADDRESS_0, &addr);
+	hccr = (struct ehci_hccr *)addr;
+	hcor = (struct ehci_hcor *)((uint32_t) hccr +
+			HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	debug("EHCI-PCI init hccr 0x%x and hcor 0x%x hc_length %d\n",
+			(uint32_t)hccr, (uint32_t)hcor,
+			(uint32_t)HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
+
+	return 0;
+}
+
+/*
+ * Destroy the appropriate control structures corresponding
+ * the the EHCI host controller.
+ */
+int ehci_hcd_stop(void)
+{
+	return 0;
+}
--- u-boot-2011.03/drivers/mtd/nand/fsl_ifc_nand.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/mtd/nand/fsl_ifc_nand.c	2022-05-09 14:05:11.532055865 -0700
@@ -0,0 +1,857 @@
+/* Integrated Flash Controller NAND Machine Driver
+ *
+ * Copyright (c) 2011 Freescale Semiconductor, Inc
+ *
+ * Authors: Dipen Dudhat <Dipen.Dudhat@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <malloc.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/fsl_ifc.h>
+
+#define MAX_BANKS	4
+#define ERR_BYTE	0xFF /* Value returned for read bytes
+				when read failed */
+#define IFC_TIMEOUT_MSECS 10 /* Maximum number of mSecs to wait for IFC
+				NAND Machine */
+
+#define MAX_BBT_BLOCKS 8
+struct fsl_ifc_ctrl;
+
+/* mtd information per set */
+struct fsl_ifc_mtd {
+	struct mtd_info mtd;
+	struct nand_chip chip;
+	struct fsl_ifc_ctrl *ctrl;
+
+	struct device *dev;
+	int bank;               /* Chip select bank number                */
+	unsigned int bufnum_mask; /* bufnum = page & bufnum_mask */
+	u8 __iomem *vbase;      /* Chip select base virtual address       */
+};
+
+/* overview of the fsl ifc controller */
+struct fsl_ifc_ctrl {
+	struct nand_hw_control controller;
+	struct fsl_ifc_mtd *chips[MAX_BANKS];
+
+	/* device info */
+	struct fsl_ifc *regs;
+	uint8_t __iomem *addr;   /* Address of assigned IFC buffer        */
+	unsigned int cs_nand;    /* On which chipsel NAND is connected	  */
+	unsigned int page;       /* Last page written to / read from      */
+	unsigned int read_bytes; /* Number of bytes read during command   */
+	unsigned int column;     /* Saved column from SEQIN               */
+	unsigned int index;      /* Pointer to next byte to 'read'        */
+	unsigned int status;     /* status read from NEESR after last op  */
+	unsigned int oob;        /* Non zero if operating on OOB data     */
+	unsigned int eccread;    /* Non zero for a full-page ECC read     */
+};
+
+static struct fsl_ifc_ctrl *ifc_ctrl;
+
+/* 512-byte page with 4-bit ECC, 8-bit */
+static struct nand_ecclayout oob_512_8bit_ecc4 = {
+	.eccbytes = 8,
+	.eccpos = {8, 9, 10, 11, 12, 13, 14, 15},
+	.oobfree = { {0, 5}, {6, 2} },
+};
+
+/* 512-byte page with 4-bit ECC, 16-bit */
+static struct nand_ecclayout oob_512_16bit_ecc4 = {
+	.eccbytes = 8,
+	.eccpos = {8, 9, 10, 11, 12, 13, 14, 15},
+	.oobfree = { {2, 6}, },
+};
+
+/* 2048-byte page size with 4-bit ECC */
+static struct nand_ecclayout oob_2048_ecc4 = {
+	.eccbytes = 32,
+	.eccpos = {
+		8, 9, 10, 11, 12, 13, 14, 15,
+		16, 17, 18, 19, 20, 21, 22, 23,
+		24, 25, 26, 27, 28, 29, 30, 31,
+		32, 33, 34, 35, 36, 37, 38, 39,
+	},
+	.oobfree = { {2, 6}, {40, 24} },
+};
+
+/* 4096-byte page size with 4-bit ECC */
+static struct nand_ecclayout oob_4096_ecc4 = {
+	.eccbytes = 64,
+	.eccpos = {
+		8, 9, 10, 11, 12, 13, 14, 15,
+		16, 17, 18, 19, 20, 21, 22, 23,
+		24, 25, 26, 27, 28, 29, 30, 31,
+		32, 33, 34, 35, 36, 37, 38, 39,
+		40, 41, 42, 43, 44, 45, 46, 47,
+		48, 49, 50, 51, 52, 53, 54, 55,
+		56, 57, 58, 59, 60, 61, 62, 63,
+		64, 65, 66, 67, 68, 69, 70, 71,
+	},
+	.oobfree = { {2, 6}, {72, 56} },
+};
+
+/* 4096-byte page size with 8-bit ECC -- requires 218-byte OOB */
+static struct nand_ecclayout oob_4096_ecc8 = {
+	.eccbytes = 128,
+	.eccpos = {
+		8, 9, 10, 11, 12, 13, 14, 15,
+		16, 17, 18, 19, 20, 21, 22, 23,
+		24, 25, 26, 27, 28, 29, 30, 31,
+		32, 33, 34, 35, 36, 37, 38, 39,
+		40, 41, 42, 43, 44, 45, 46, 47,
+		48, 49, 50, 51, 52, 53, 54, 55,
+		56, 57, 58, 59, 60, 61, 62, 63,
+		64, 65, 66, 67, 68, 69, 70, 71,
+		72, 73, 74, 75, 76, 77, 78, 79,
+		80, 81, 82, 83, 84, 85, 86, 87,
+		88, 89, 90, 91, 92, 93, 94, 95,
+		96, 97, 98, 99, 100, 101, 102, 103,
+		104, 105, 106, 107, 108, 109, 110, 111,
+		112, 113, 114, 115, 116, 117, 118, 119,
+		120, 121, 122, 123, 124, 125, 126, 127,
+		128, 129, 130, 131, 132, 133, 134, 135,
+	},
+	.oobfree = { {2, 6}, {136, 82} },
+};
+
+
+/*
+ * Generic flash bbt descriptors
+ */
+static u8 bbt_pattern[] = {'B', 'b', 't', '0' };
+static u8 mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
+		   NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs =	2, /* 0 on 8-bit small page */
+	.len = 4,
+	.veroffs = 6,
+	.maxblocks = MAX_BBT_BLOCKS,
+	.pattern = bbt_pattern,
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |
+		   NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs =	2, /* 0 on 8-bit small page */
+	.len = 4,
+	.veroffs = 6,
+	.maxblocks = MAX_BBT_BLOCKS,
+	.pattern = mirror_pattern,
+};
+
+/*
+ * Set up the IFC hardware block and page address fields, and the ifc nand
+ * structure addr field to point to the correct IFC buffer in memory
+ */
+static void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	struct fsl_ifc *ifc = ctrl->regs;
+	int buf_num;
+
+	ctrl->page = page_addr;
+
+	/* Program ROW0/COL0 */
+	out_be32(&ifc->ifc_nand.row0, page_addr);
+	out_be32(&ifc->ifc_nand.col0, (oob ? IFC_NAND_COL_MS : 0) | column);
+
+	buf_num = page_addr & priv->bufnum_mask;
+
+	ctrl->addr = priv->vbase + buf_num * (mtd->writesize * 2);
+	ctrl->index = column;
+
+	/* for OOB data point to the second half of the buffer */
+	if (oob)
+		ctrl->index += mtd->writesize;
+}
+
+static int is_blank(struct mtd_info *mtd, struct fsl_ifc_ctrl *ctrl,
+		    unsigned int bufnum)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	u8 __iomem *addr = priv->vbase + bufnum * (mtd->writesize * 2);
+	u32 __iomem *main = (u32 *)addr;
+	u8 __iomem *oob = addr + mtd->writesize;
+	int i;
+
+	for (i = 0; i < mtd->writesize / 4; i++) {
+		if (__raw_readl(&main[i]) != 0xffffffff)
+			return 0;
+	}
+
+	for (i = 0; i < chip->ecc.layout->eccbytes; i++) {
+		int pos = chip->ecc.layout->eccpos[i];
+
+		if (__raw_readb(&oob[pos]) != 0xff)
+			return 0;
+	}
+
+	return 1;
+}
+
+/* returns nonzero if entire page is blank */
+static int check_read_ecc(struct mtd_info *mtd, struct fsl_ifc_ctrl *ctrl,
+			  u32 *eccstat, unsigned int bufnum)
+{
+	u32 reg = eccstat[bufnum / 4];
+	int errors = (reg >> ((3 - bufnum % 4) * 8)) & 15;
+
+	if (errors == 15) { /* uncorrectable */
+		/* Blank pages fail hw ECC checks */
+		if (is_blank(mtd, ctrl, bufnum))
+			return 1;
+
+		/*
+		 * We disable ECCER reporting in hardware due to
+		 * erratum IFC-A002770 -- so report it now if we
+		 * see an uncorrectable error in ECCSTAT.
+		 */
+		ctrl->status |= IFC_NAND_EVTER_STAT_ECCER;
+	} else if (errors > 0) {
+		mtd->ecc_stats.corrected += errors;
+	}
+
+	return 0;
+}
+
+/*
+ * execute IFC NAND command and wait for it to complete
+ */
+static int fsl_ifc_run_command(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	struct fsl_ifc *ifc = ctrl->regs;
+	long long end_tick;
+	u32 eccstat[4];
+	int i;
+
+	/* set the chip select for NAND Transaction */
+	out_be32(&ifc->ifc_nand.nand_csel, ifc_ctrl->cs_nand);
+
+	/* start read/write seq */
+	out_be32(&ifc->ifc_nand.nandseq_strt,
+		 IFC_NAND_SEQ_STRT_FIR_STRT);
+
+	/* wait for NAND Machine complete flag or timeout */
+	end_tick = usec2ticks(IFC_TIMEOUT_MSECS * 1000) + get_ticks();
+
+	while (end_tick > get_ticks()) {
+		ctrl->status = in_be32(&ifc->ifc_nand.nand_evter_stat);
+
+		if (ctrl->status & IFC_NAND_EVTER_STAT_OPC)
+			break;
+	}
+
+	out_be32(&ifc->ifc_nand.nand_evter_stat, ctrl->status);
+
+	if (ctrl->status & IFC_NAND_EVTER_STAT_FTOER)
+		printf("%s: Flash Time Out Error\n", __func__);
+	if (ctrl->status & IFC_NAND_EVTER_STAT_WPER)
+		printf("%s: Write Protect Error\n", __func__);
+
+	if (ctrl->eccread) {
+		int bufperpage = mtd->writesize / 512;
+		int bufnum = (ctrl->page & priv->bufnum_mask) * bufperpage;
+		int bufnum_end = bufnum + bufperpage - 1;
+
+		for (i = bufnum / 4; i <= bufnum_end / 4; i++)
+			eccstat[i] = in_be32(&ifc->ifc_nand.nand_eccstat[i]);
+
+		for (i = bufnum; i <= bufnum_end; i++) {
+			if (check_read_ecc(mtd, ctrl, eccstat, i))
+				break;
+		}
+
+		ctrl->eccread = 0;
+	}
+
+	/* returns 0 on success otherwise non-zero) */
+	return ctrl->status == IFC_NAND_EVTER_STAT_OPC ? 0 : -EIO;
+}
+
+static void fsl_ifc_do_read(struct nand_chip *chip,
+			    int oob,
+			    struct mtd_info *mtd)
+{
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	struct fsl_ifc *ifc = ctrl->regs;
+
+	/* Program FIR/IFC_NAND_FCR0 for Small/Large page */
+	if (mtd->writesize > 512) {
+		out_be32(&ifc->ifc_nand.nand_fir0,
+			 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+			 (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |
+			 (IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |
+			 (IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP3_SHIFT) |
+			 (IFC_FIR_OP_RBCD << IFC_NAND_FIR0_OP4_SHIFT));
+		out_be32(&ifc->ifc_nand.nand_fir1, 0x0);
+
+		out_be32(&ifc->ifc_nand.nand_fcr0,
+			(NAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT) |
+			(NAND_CMD_READSTART << IFC_NAND_FCR0_CMD1_SHIFT));
+	} else {
+		out_be32(&ifc->ifc_nand.nand_fir0,
+			 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+			 (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |
+			 (IFC_FIR_OP_RA0  << IFC_NAND_FIR0_OP2_SHIFT) |
+			 (IFC_FIR_OP_RBCD << IFC_NAND_FIR0_OP3_SHIFT));
+
+		if (oob)
+			out_be32(&ifc->ifc_nand.nand_fcr0,
+				 NAND_CMD_READOOB << IFC_NAND_FCR0_CMD0_SHIFT);
+		else
+			out_be32(&ifc->ifc_nand.nand_fcr0,
+				NAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT);
+	}
+}
+
+/* cmdfunc send commands to the IFC NAND Machine */
+static void fsl_ifc_cmdfunc(struct mtd_info *mtd, unsigned int command,
+			     int column, int page_addr)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	struct fsl_ifc *ifc = ctrl->regs;
+
+	/* clear the read buffer */
+	ctrl->read_bytes = 0;
+	if (command != NAND_CMD_PAGEPROG)
+		ctrl->index = 0;
+
+	switch (command) {
+	/* READ0 read the entire buffer to use hardware ECC. */
+	case NAND_CMD_READ0: {
+		out_be32(&ifc->ifc_nand.nand_fbcr, 0);
+		set_addr(mtd, 0, page_addr, 0);
+
+		ctrl->read_bytes = mtd->writesize + mtd->oobsize;
+		ctrl->index += column;
+
+		if (chip->ecc.mode == NAND_ECC_HW)
+			ctrl->eccread = 1;
+
+		fsl_ifc_do_read(chip, 0, mtd);
+		fsl_ifc_run_command(mtd);
+		return;
+	}
+
+	/* READOOB reads only the OOB because no ECC is performed. */
+	case NAND_CMD_READOOB:
+		out_be32(&ifc->ifc_nand.nand_fbcr, mtd->oobsize - column);
+		set_addr(mtd, column, page_addr, 1);
+
+		ctrl->read_bytes = mtd->writesize + mtd->oobsize;
+
+		fsl_ifc_do_read(chip, 1, mtd);
+		fsl_ifc_run_command(mtd);
+
+		return;
+
+	/* READID must read all possible bytes while CEB is active */
+	case NAND_CMD_READID:
+		out_be32(&ifc->ifc_nand.nand_fir0,
+				(IFC_FIR_OP_CMD0 << IFC_NAND_FIR0_OP0_SHIFT) |
+				(IFC_FIR_OP_UA  << IFC_NAND_FIR0_OP1_SHIFT) |
+				(IFC_FIR_OP_RB << IFC_NAND_FIR0_OP2_SHIFT));
+		out_be32(&ifc->ifc_nand.nand_fcr0,
+				NAND_CMD_READID << IFC_NAND_FCR0_CMD0_SHIFT);
+		/* 4 bytes for manuf, device and exts */
+		out_be32(&ifc->ifc_nand.nand_fbcr, 4);
+		ctrl->read_bytes = 4;
+
+		set_addr(mtd, 0, 0, 0);
+		fsl_ifc_run_command(mtd);
+		return;
+
+	/* ERASE1 stores the block and page address */
+	case NAND_CMD_ERASE1:
+		set_addr(mtd, 0, page_addr, 0);
+		return;
+
+	/* ERASE2 uses the block and page address from ERASE1 */
+	case NAND_CMD_ERASE2:
+		out_be32(&ifc->ifc_nand.nand_fir0,
+			 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+			 (IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP1_SHIFT) |
+			 (IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP2_SHIFT));
+
+		out_be32(&ifc->ifc_nand.nand_fcr0,
+			 (NAND_CMD_ERASE1 << IFC_NAND_FCR0_CMD0_SHIFT) |
+			 (NAND_CMD_ERASE2 << IFC_NAND_FCR0_CMD1_SHIFT));
+
+		out_be32(&ifc->ifc_nand.nand_fbcr, 0);
+		ctrl->read_bytes = 0;
+		fsl_ifc_run_command(mtd);
+		return;
+
+	/* SEQIN sets up the addr buffer and all registers except the length */
+	case NAND_CMD_SEQIN: {
+		u32 nand_fcr0;
+		ctrl->column = column;
+		ctrl->oob = 0;
+
+		if (mtd->writesize > 512) {
+			nand_fcr0 =
+				(NAND_CMD_SEQIN << IFC_NAND_FCR0_CMD0_SHIFT) |
+				(NAND_CMD_PAGEPROG << IFC_NAND_FCR0_CMD1_SHIFT);
+
+			out_be32(&ifc->ifc_nand.nand_fir0,
+				 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+				 (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |
+				 (IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |
+				 (IFC_FIR_OP_WBCD  << IFC_NAND_FIR0_OP3_SHIFT) |
+				 (IFC_FIR_OP_CW1 << IFC_NAND_FIR0_OP4_SHIFT));
+			out_be32(&ifc->ifc_nand.nand_fir1, 0);
+		} else {
+			nand_fcr0 = ((NAND_CMD_PAGEPROG <<
+					IFC_NAND_FCR0_CMD1_SHIFT) |
+				    (NAND_CMD_SEQIN <<
+					IFC_NAND_FCR0_CMD2_SHIFT));
+
+			out_be32(&ifc->ifc_nand.nand_fir0,
+				 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+				 (IFC_FIR_OP_CMD2 << IFC_NAND_FIR0_OP1_SHIFT) |
+				 (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP2_SHIFT) |
+				 (IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP3_SHIFT) |
+				 (IFC_FIR_OP_WBCD << IFC_NAND_FIR0_OP4_SHIFT));
+			out_be32(&ifc->ifc_nand.nand_fir1,
+				 (IFC_FIR_OP_CW1 << IFC_NAND_FIR1_OP5_SHIFT));
+
+			if (column >= mtd->writesize) {
+				/* OOB area --> READOOB */
+				column -= mtd->writesize;
+				nand_fcr0 |= NAND_CMD_READOOB <<
+						IFC_NAND_FCR0_CMD0_SHIFT;
+				ctrl->oob = 1;
+			} else if (column < 256) {
+				/* First 256 bytes --> READ0 */
+				nand_fcr0 |= NAND_CMD_READ0 << FCR_CMD0_SHIFT;
+			} else {
+				/* Second 256 bytes --> READ1 */
+				nand_fcr0 |= NAND_CMD_READ1 << FCR_CMD0_SHIFT;
+			}
+		}
+
+		out_be32(&ifc->ifc_nand.nand_fcr0, nand_fcr0);
+		set_addr(mtd, column, page_addr, ctrl->oob);
+		return;
+	}
+
+	/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+	case NAND_CMD_PAGEPROG:
+		if (ctrl->oob)
+			out_be32(&ifc->ifc_nand.nand_fbcr, ctrl->index);
+		else
+			out_be32(&ifc->ifc_nand.nand_fbcr, 0);
+
+		fsl_ifc_run_command(mtd);
+		return;
+
+	case NAND_CMD_STATUS:
+		out_be32(&ifc->ifc_nand.nand_fir0,
+				(IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+				(IFC_FIR_OP_RB << IFC_NAND_FIR0_OP1_SHIFT));
+		out_be32(&ifc->ifc_nand.nand_fcr0,
+				NAND_CMD_STATUS << IFC_NAND_FCR0_CMD0_SHIFT);
+		out_be32(&ifc->ifc_nand.nand_fbcr, 1);
+		set_addr(mtd, 0, 0, 0);
+		ctrl->read_bytes = 1;
+
+		fsl_ifc_run_command(mtd);
+
+		/* Chip sometimes reporting write protect even when it's not */
+		out_8(ctrl->addr, in_8(ctrl->addr) | NAND_STATUS_WP);
+		return;
+
+	case NAND_CMD_RESET:
+		out_be32(&ifc->ifc_nand.nand_fir0,
+				IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT);
+		out_be32(&ifc->ifc_nand.nand_fcr0,
+				NAND_CMD_RESET << IFC_NAND_FCR0_CMD0_SHIFT);
+		fsl_ifc_run_command(mtd);
+		return;
+
+	default:
+		printf("%s: error, unsupported command 0x%x.\n",
+			__func__, command);
+	}
+}
+
+/*
+ * Write buf to the IFC NAND Controller Data Buffer
+ */
+static void fsl_ifc_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	unsigned int bufsize = mtd->writesize + mtd->oobsize;
+
+	if (len <= 0) {
+		printf("%s of %d bytes", __func__, len);
+		ctrl->status = 0;
+		return;
+	}
+
+	if ((unsigned int)len > bufsize - ctrl->index) {
+		printf("%s beyond end of buffer "
+		       "(%d requested, %u available)\n",
+			__func__, len, bufsize - ctrl->index);
+		len = bufsize - ctrl->index;
+	}
+
+	memcpy_toio(&ctrl->addr[ctrl->index], buf, len);
+	ctrl->index += len;
+}
+
+/*
+ * read a byte from either the IFC hardware buffer if it has any data left
+ * otherwise issue a command to read a single byte.
+ */
+static u8 fsl_ifc_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+
+	/* If there are still bytes in the IFC buffer, then use the
+	 * next byte. */
+	if (ctrl->index < ctrl->read_bytes)
+		return in_8(&ctrl->addr[ctrl->index++]);
+
+	printf("%s beyond end of buffer\n", __func__);
+	return ERR_BYTE;
+}
+
+/*
+ * Read two bytes from the IFC hardware buffer
+ * read function for 16-bit buswith
+ */
+static uint8_t fsl_ifc_read_byte16(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	uint16_t data;
+
+	/*
+	 * If there are still bytes in the IFC buffer, then use the
+	 * next byte.
+	 */
+	if (ctrl->index < ctrl->read_bytes) {
+		data = in_be16((uint16_t *)&ctrl->
+					addr[ctrl->index]);
+		ctrl->index += 2;
+		return (uint8_t)data;
+	}
+
+	printf("%s beyond end of buffer\n", __func__);
+	return ERR_BYTE;
+}
+
+/*
+ * Read from the IFC Controller Data Buffer
+ */
+static void fsl_ifc_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	int avail;
+
+	if (len < 0)
+		return;
+
+	avail = min((unsigned int)len, ctrl->read_bytes - ctrl->index);
+	memcpy_fromio(buf, &ctrl->addr[ctrl->index], avail);
+	ctrl->index += avail;
+
+	if (len > avail)
+		printf("%s beyond end of buffer "
+		       "(%d requested, %d available)\n",
+		       __func__, len, avail);
+}
+
+/*
+ * Verify buffer against the IFC Controller Data Buffer
+ */
+static int fsl_ifc_verify_buf(struct mtd_info *mtd,
+			       const u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	int i;
+
+	if (len < 0) {
+		printf("%s of %d bytes", __func__, len);
+		return -EINVAL;
+	}
+
+	if ((unsigned int)len > ctrl->read_bytes - ctrl->index) {
+		printf("%s beyond end of buffer "
+		       "(%d requested, %u available)\n",
+		       __func__, len, ctrl->read_bytes - ctrl->index);
+
+		ctrl->index = ctrl->read_bytes;
+		return -EINVAL;
+	}
+
+	for (i = 0; i < len; i++)
+		if (in_8(&ctrl->addr[ctrl->index + i]) != buf[i])
+			break;
+
+	ctrl->index += len;
+	return i == len && ctrl->status == IFC_NAND_EVTER_STAT_OPC ? 0 : -EIO;
+}
+
+/* This function is called after Program and Erase Operations to
+ * check for success or failure.
+ */
+static int fsl_ifc_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+	struct fsl_ifc *ifc = ctrl->regs;
+	u32 nand_fsr;
+
+	if (ctrl->status != IFC_NAND_EVTER_STAT_OPC)
+		return NAND_STATUS_FAIL;
+
+	/* Use READ_STATUS command, but wait for the device to be ready */
+	out_be32(&ifc->ifc_nand.nand_fir0,
+		 (IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+		 (IFC_FIR_OP_RDSTAT << IFC_NAND_FIR0_OP1_SHIFT));
+	out_be32(&ifc->ifc_nand.nand_fcr0, NAND_CMD_STATUS <<
+			IFC_NAND_FCR0_CMD0_SHIFT);
+	out_be32(&ifc->ifc_nand.nand_fbcr, 1);
+	set_addr(mtd, 0, 0, 0);
+	ctrl->read_bytes = 1;
+
+	fsl_ifc_run_command(mtd);
+
+	if (ctrl->status != IFC_NAND_EVTER_STAT_OPC)
+		return NAND_STATUS_FAIL;
+
+	nand_fsr = in_be32(&ifc->ifc_nand.nand_fsr);
+
+	/* Chip sometimes reporting write protect even when it's not */
+	nand_fsr = nand_fsr | NAND_STATUS_WP;
+	return nand_fsr;
+}
+
+static int fsl_ifc_read_page(struct mtd_info *mtd,
+			      struct nand_chip *chip,
+			      uint8_t *buf, int page)
+{
+	struct fsl_ifc_mtd *priv = chip->priv;
+	struct fsl_ifc_ctrl *ctrl = priv->ctrl;
+
+	fsl_ifc_read_buf(mtd, buf, mtd->writesize);
+	fsl_ifc_read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	if (ctrl->status != IFC_NAND_EVTER_STAT_OPC)
+		mtd->ecc_stats.failed++;
+
+	return 0;
+}
+
+/* ECC will be calculated automatically, and errors will be detected in
+ * waitfunc.
+ */
+static void fsl_ifc_write_page(struct mtd_info *mtd,
+				struct nand_chip *chip,
+				const uint8_t *buf)
+{
+	fsl_ifc_write_buf(mtd, buf, mtd->writesize);
+	fsl_ifc_write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+
+static void fsl_ifc_ctrl_init(void)
+{
+	ifc_ctrl = kzalloc(sizeof(*ifc_ctrl), GFP_KERNEL);
+	if (!ifc_ctrl)
+		return;
+
+	ifc_ctrl->regs = IFC_BASE_ADDR;
+
+	/* clear event registers */
+	out_be32(&ifc_ctrl->regs->ifc_nand.nand_evter_stat, ~0U);
+	out_be32(&ifc_ctrl->regs->ifc_nand.pgrdcmpl_evt_stat, ~0U);
+
+	/* Enable error and event for any detected errors */
+	out_be32(&ifc_ctrl->regs->ifc_nand.nand_evter_en,
+			IFC_NAND_EVTER_EN_OPC_EN |
+			IFC_NAND_EVTER_EN_PGRDCMPL_EN |
+			IFC_NAND_EVTER_EN_FTOER_EN |
+			IFC_NAND_EVTER_EN_WPER_EN);
+
+	out_be32(&ifc_ctrl->regs->ifc_nand.ncfgr, 0x0);
+}
+
+static void fsl_ifc_select_chip(struct mtd_info *mtd, int chip)
+{
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	struct fsl_ifc_mtd *priv;
+	struct nand_ecclayout *layout;
+	uint32_t cspr = 0, csor = 0;
+
+	
+	if (!ifc_ctrl) {
+		fsl_ifc_ctrl_init();
+		if (!ifc_ctrl)
+			return -1;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->ctrl = ifc_ctrl;
+	priv->vbase = nand->IO_ADDR_R;
+
+	/* Find which chip select it is connected to.
+	 */
+	for (priv->bank = 0; priv->bank < MAX_BANKS; priv->bank++) {
+		phys_addr_t base_addr = virt_to_phys(nand->IO_ADDR_R);
+
+		cspr = in_be32(&ifc_ctrl->regs->cspr_cs[priv->bank].cspr);
+		csor = in_be32(&ifc_ctrl->regs->csor_cs[priv->bank].csor);
+
+		if ((cspr & CSPR_V) && (cspr & CSPR_MSEL) == CSPR_MSEL_NAND &&
+		    (cspr & CSPR_BA) == CSPR_PHYS_ADDR(base_addr)) {
+			ifc_ctrl->cs_nand = priv->bank << IFC_NAND_CSEL_SHIFT;
+			break;
+		}
+	}
+
+	if (priv->bank >= MAX_BANKS) {
+		printf("%s: address did not match any "
+		       "chip selects\n", __func__);
+		return -ENODEV;
+	}
+
+	ifc_ctrl->chips[priv->bank] = priv;
+
+	/* fill in nand_chip structure */
+	/* set up function call table */
+
+	nand->write_buf = fsl_ifc_write_buf;
+	nand->read_buf = fsl_ifc_read_buf;
+	nand->verify_buf = fsl_ifc_verify_buf;
+	nand->select_chip = fsl_ifc_select_chip;
+	nand->cmdfunc = fsl_ifc_cmdfunc;
+	nand->waitfunc = fsl_ifc_wait;
+
+	/* set up nand options */
+	nand->bbt_td = &bbt_main_descr;
+	nand->bbt_md = &bbt_mirror_descr;
+
+	/* set up nand options */
+	nand->options = NAND_NO_READRDY | NAND_NO_AUTOINCR |
+			NAND_USE_FLASH_BBT;
+
+	if (cspr & CSPR_PORT_SIZE_16) {
+		nand->read_byte = fsl_ifc_read_byte16;
+		nand->options |= NAND_BUSWIDTH_16;
+	} else {
+		nand->read_byte = fsl_ifc_read_byte;
+	}
+
+	nand->controller = &ifc_ctrl->controller;
+	nand->priv = priv;
+
+	nand->ecc.read_page = fsl_ifc_read_page;
+	nand->ecc.write_page = fsl_ifc_write_page;
+
+	/* Hardware generates ECC per 512 Bytes */
+	nand->ecc.size = 512;
+	nand->ecc.bytes = 8;
+	
+	
+	switch (csor & CSOR_NAND_PGS_MASK) {
+	case CSOR_NAND_PGS_512:
+		if (nand->options & NAND_BUSWIDTH_16) {
+			layout = &oob_512_16bit_ecc4;
+		} else {
+			layout = &oob_512_8bit_ecc4;
+
+			/* Avoid conflict with bad block marker */
+			bbt_main_descr.offs = 0;
+			bbt_mirror_descr.offs = 0;
+		}
+
+		priv->bufnum_mask = 15;
+		break;
+
+	case CSOR_NAND_PGS_2K:
+		layout = &oob_2048_ecc4;
+		priv->bufnum_mask = 3;
+		break;
+
+	case CSOR_NAND_PGS_4K:
+		if ((csor & CSOR_NAND_ECC_MODE_MASK) ==
+		    CSOR_NAND_ECC_MODE_4) {
+			layout = &oob_4096_ecc4;
+		} else {
+			layout = &oob_4096_ecc8;
+			nand->ecc.bytes = 16;
+		}
+
+		priv->bufnum_mask = 1;
+		break;
+
+	default:
+		printf("ifc nand: bad csor %#x: bad page size\n", csor);
+		return -ENODEV;
+	}
+
+	/*
+	printf("board_nand_init csor & CSOR_NAND_PGS_MASK=%x\n", csor & CSOR_NAND_PGS_MASK);	
+	*/
+
+	/* Must also set CSOR_NAND_ECC_ENC_EN if DEC_EN set */
+	if (csor & CSOR_NAND_ECC_DEC_EN) {
+		nand->ecc.mode = NAND_ECC_HW;
+		nand->ecc.layout = layout;
+	} else {
+		nand->ecc.mode = NAND_ECC_SOFT;
+	}
+
+	return 0;
+}
--- u-boot-2011.03/drivers/tpm/generic_lpc_tpm.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/tpm/generic_lpc_tpm.c	2022-05-09 14:05:11.592053432 -0700
@@ -0,0 +1,843 @@
+/*
+ * Copyright (c) 2011 The Chromium OS Authors.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * The code in this file is based on the article "Writing a TPM Device Driver"
+ * published on http://ptgmedia.pearsoncmg.com.
+ *
+ * One principal difference is that in the simplest config the other than 0
+ * TPM localities do not get mapped by some devices (for instance, by Infineon
+ * slb9635), so this driver provides access to locality 0 only.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <tpm.h>
+
+#define PREFIX "lpc_tpm: "
+
+struct tpm_locality {
+	u32 access;
+	u8 padding0[4];
+	u32 int_enable;
+	u8 vector;
+	u8 padding1[3];
+	u32 int_status;
+	u32 int_capability;
+	u32 tpm_status;
+	u8 padding2[8];
+	u8 data;
+	u8 padding3[3803];
+	u32 did_vid;
+	u8 rid;
+	u8 padding4[251];
+};
+
+/*
+ * This pointer refers to the TPM chip, 5 of its localities are mapped as an
+ * array.
+ */
+#define TPM_TOTAL_LOCALITIES	5
+/*
+static struct tpm_locality *lpc_tpm_dev =
+	(struct tpm_locality *)CONFIG_TPM_TIS_BASE_ADDRESS;
+*/
+static struct fsl_i2c *sc_i2c_dev = (struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C1_OFFSET);
+
+/* Some registers' bit field definitions */
+#define TIS_STS_VALID                  (1 << 7) /* 0x80 */
+#define TIS_STS_COMMAND_READY          (1 << 6) /* 0x40 */
+#define TIS_STS_TPM_GO                 (1 << 5) /* 0x20 */
+#define TIS_STS_DATA_AVAILABLE         (1 << 4) /* 0x10 */
+#define TIS_STS_EXPECT                 (1 << 3) /* 0x08 */
+#define TIS_STS_RESPONSE_RETRY         (1 << 1) /* 0x02 */
+
+#define TIS_ACCESS_TPM_REG_VALID_STS   (1 << 7) /* 0x80 */
+#define TIS_ACCESS_ACTIVE_LOCALITY     (1 << 5) /* 0x20 */
+#define TIS_ACCESS_BEEN_SEIZED         (1 << 4) /* 0x10 */
+#define TIS_ACCESS_SEIZE               (1 << 3) /* 0x08 */
+#define TIS_ACCESS_PENDING_REQUEST     (1 << 2) /* 0x04 */
+#define TIS_ACCESS_REQUEST_USE         (1 << 1) /* 0x02 */
+#define TIS_ACCESS_TPM_ESTABLISHMENT   (1 << 0) /* 0x01 */
+
+#define TIS_STS_BURST_COUNT_MASK       (0xffff)
+#define TIS_STS_BURST_COUNT_SHIFT      (8)
+
+/*
+ * Error value returned if a tpm register does not enter the expected state
+ * after continuous polling. No actual TPM register reading ever returns -1,
+ * so this value is a safe error indication to be mixed with possible status
+ * register values.
+ */
+#define TPM_TIMEOUT_ERR			(-1)
+
+/* Error value returned on various TPM driver errors. */
+#define TPM_DRIVER_ERR		(1)
+
+ /* 1 second is plenty for anything TPM does. */
+#define MAX_DELAY_US	(1000 * 1000)
+
+/* Retrieve burst count value out of the status register contents. */
+static u16 burst_count(u32 status)
+{
+	return (status >> TIS_STS_BURST_COUNT_SHIFT) & TIS_STS_BURST_COUNT_MASK;
+}
+
+/*
+ * Structures defined below allow creating descriptions of TPM vendor/device
+ * ID information for run time discovery. The only device the system knows
+ * about at this time is Infineon slb9635.
+ */
+struct device_name {
+	u16 dev_id;
+	const char * const dev_name;
+};
+
+struct vendor_name {
+	u16 vendor_id;
+	const char *vendor_name;
+	const struct device_name *dev_names;
+};
+
+static const struct device_name infineon_devices[] = {
+	{0xb, "SLB9635 TT 1.2"},
+	{0}
+};
+
+static const struct vendor_name vendor_names[] = {
+	{0x15d1, "Infineon", infineon_devices},
+};
+
+/*
+ * Cached vendor/device ID pair to indicate that the device has been already
+ * discovered.
+ */
+static u32 vendor_dev_id;
+
+/* TPM access wrappers to support tracing */
+static u8 tpm_read_byte(const u8 *ptr)
+{
+	u8  ret = readb(ptr);
+	debug(PREFIX "Read reg 0x%4.4x returns 0x%2.2x\n",
+	      (u32)ptr - (u32)lpc_tpm_dev, ret);
+	return ret;
+}
+
+static u32 tpm_read_word(const u32 *ptr)
+{
+	u32  ret = readl(ptr);
+	debug(PREFIX "Read reg 0x%4.4x returns 0x%8.8x\n",
+	      (u32)ptr - (u32)lpc_tpm_dev, ret);
+	return ret;
+}
+
+static void tpm_write_byte(u8 value, u8 *ptr)
+{
+	debug(PREFIX "Write reg 0x%4.4x with 0x%2.2x\n",
+	      (u32)ptr - (u32)lpc_tpm_dev, value);
+	writeb(value, ptr);
+}
+
+static void tpm_write_word(u32 value, u32 *ptr)
+{
+	debug(PREFIX "Write reg 0x%4.4x with 0x%8.8x\n",
+	      (u32)ptr - (u32)lpc_tpm_dev, value);
+	writel(value, ptr);
+}
+
+/*
+ * tis_wait_reg()
+ *
+ * Wait for at least a second for a register to change its state to match the
+ * expected state. Normally the transition happens within microseconds.
+ *
+ * @reg - pointer to the TPM register
+ * @mask - bitmask for the bitfield(s) to watch
+ * @expected - value the field(s) are supposed to be set to
+ *
+ * Returns the register contents in case the expected value was found in the
+ * appropriate register bits, or TPM_TIMEOUT_ERR on timeout.
+ */
+static u32 tis_wait_reg(u32 *reg, u8 mask, u8 expected)
+{
+	u32 time_us = MAX_DELAY_US;
+
+	while (time_us > 0) {
+		u32 value = tpm_read_word(reg);
+		if ((value & mask) == expected)
+			return value;
+		udelay(1); /* 1 us */
+		time_us--;
+	}
+	return TPM_TIMEOUT_ERR;
+}
+
+/*
+ * Probe the TPM device and try determining its manufacturer/device name.
+ *
+ * Returns 0 on success (the device is found or was found during an earlier
+ * invocation) or TPM_DRIVER_ERR if the device is not found.
+ */
+int tis_init(void)
+{
+	u32 didvid = tpm_read_word(&lpc_tpm_dev[0].did_vid);
+	int i;
+	const char *device_name = "unknown";
+	const char *vendor_name = device_name;
+	u16 vid, did;
+
+	if (vendor_dev_id)
+		return 0;  /* Already probed. */
+
+	if (!didvid || (didvid == 0xffffffff)) {
+		printf("%s: No TPM device found\n", __func__);
+		return TPM_DRIVER_ERR;
+	}
+
+	vendor_dev_id = didvid;
+
+	vid = didvid & 0xffff;
+	did = (didvid >> 16) & 0xffff;
+	for (i = 0; i < ARRAY_SIZE(vendor_names); i++) {
+		int j = 0;
+		u16 known_did;
+
+		if (vid == vendor_names[i].vendor_id)
+			vendor_name = vendor_names[i].vendor_name;
+
+		while ((known_did = vendor_names[i].dev_names[j].dev_id) != 0) {
+			if (known_did == did) {
+				device_name =
+					vendor_names[i].dev_names[j].dev_name;
+				break;
+			}
+			j++;
+		}
+		break;
+	}
+
+	printf("Found TPM %s by %s\n", device_name, vendor_name);
+	return 0;
+}
+
+/*
+ * tis_senddata()
+ *
+ * send the passed in data to the TPM device.
+ *
+ * @data - address of the data to send, byte by byte
+ * @len - length of the data to send
+ *
+ * Returns 0 on success, TPM_DRIVER_ERR on error (in case the device does
+ * not accept the entire command).
+ */
+static u32 tis_senddata(const u8 * const data, u32 len)
+{
+	u32 offset = 0;
+	u16 burst = 0;
+	u32 max_cycles = 0;
+	u8 locality = 0;
+	u32 value;
+
+	value = tis_wait_reg(&lpc_tpm_dev[locality].tpm_status,
+			     TIS_STS_COMMAND_READY, TIS_STS_COMMAND_READY);
+	if (value == TPM_TIMEOUT_ERR) {
+		printf("%s:%d - failed to get 'command_ready' status\n",
+		       __FILE__, __LINE__);
+		return TPM_DRIVER_ERR;
+	}
+	burst = burst_count(value);
+
+	while (1) {
+		unsigned count;
+
+		/* Wait till the device is ready to accept more data. */
+		while (!burst) {
+			if (max_cycles++ == MAX_DELAY_US) {
+				printf("%s:%d failed to feed %d bytes of %d\n",
+				       __FILE__, __LINE__, len - offset, len);
+				return TPM_DRIVER_ERR;
+			}
+			udelay(1);
+			burst = burst_count(tpm_read_word(&lpc_tpm_dev
+						     [locality].tpm_status));
+		}
+
+		max_cycles = 0;
+
+		/*
+		 * Calculate number of bytes the TPM is ready to accept in one
+		 * shot.
+		 *
+		 * We want to send the last byte outside of the loop (hence
+		 * the -1 below) to make sure that the 'expected' status bit
+		 * changes to zero exactly after the last byte is fed into the
+		 * FIFO.
+		 */
+		count = min(burst, len - offset - 1);
+		while (count--)
+			tpm_write_byte(data[offset++],
+				  &lpc_tpm_dev[locality].data);
+
+		value = tis_wait_reg(&lpc_tpm_dev[locality].tpm_status,
+				     TIS_STS_VALID, TIS_STS_VALID);
+
+		if ((value == TPM_TIMEOUT_ERR) || !(value & TIS_STS_EXPECT)) {
+			printf("%s:%d TPM command feed overflow\n",
+			       __FILE__, __LINE__);
+			return TPM_DRIVER_ERR;
+		}
+
+		burst = burst_count(value);
+		if ((offset == (len - 1)) && burst) {
+			/*
+			 * We need to be able to send the last byte to the
+			 * device, so burst size must be nonzero before we
+			 * break out.
+			 */
+			break;
+		}
+	}
+
+	/* Send the last byte. */
+	tpm_write_byte(data[offset++], &lpc_tpm_dev[locality].data);
+	/*
+	 * Verify that TPM does not expect any more data as part of this
+	 * command.
+	 */
+	value = tis_wait_reg(&lpc_tpm_dev[locality].tpm_status,
+			     TIS_STS_VALID, TIS_STS_VALID);
+	if ((value == TPM_TIMEOUT_ERR) || (value & TIS_STS_EXPECT)) {
+		printf("%s:%d unexpected TPM status 0x%x\n",
+		       __FILE__, __LINE__, value);
+		return TPM_DRIVER_ERR;
+	}
+
+	/* OK, sitting pretty, let's start the command execution. */
+	tpm_write_word(TIS_STS_TPM_GO, &lpc_tpm_dev[locality].tpm_status);
+	return 0;
+}
+
+/*
+ * tis_readresponse()
+ *
+ * read the TPM device response after a command was issued.
+ *
+ * @buffer - address where to read the response, byte by byte.
+ * @len - pointer to the size of buffer
+ *
+ * On success stores the number of received bytes to len and returns 0. On
+ * errors (misformatted TPM data or synchronization problems) returns
+ * TPM_DRIVER_ERR.
+ */
+static u32 tis_readresponse(u8 *buffer, u32 *len)
+{
+	u16 burst;
+	u32 value;
+	u32 offset = 0;
+	u8 locality = 0;
+	const u32 has_data = TIS_STS_DATA_AVAILABLE | TIS_STS_VALID;
+	u32 expected_count = *len;
+	int max_cycles = 0;
+
+	/* Wait for the TPM to process the command. */
+	value = tis_wait_reg(&lpc_tpm_dev[locality].tpm_status,
+			      has_data, has_data);
+	if (value == TPM_TIMEOUT_ERR) {
+		printf("%s:%d failed processing command\n",
+		       __FILE__, __LINE__);
+		return TPM_DRIVER_ERR;
+	}
+
+	do {
+		while ((burst = burst_count(value)) == 0) {
+			if (max_cycles++ == MAX_DELAY_US) {
+				printf("%s:%d TPM stuck on read\n",
+				       __FILE__, __LINE__);
+				return TPM_DRIVER_ERR;
+			}
+			udelay(1);
+			value = tpm_read_word(&lpc_tpm_dev
+					      [locality].tpm_status);
+		}
+
+		max_cycles = 0;
+
+		while (burst-- && (offset < expected_count)) {
+			buffer[offset++] = tpm_read_byte(&lpc_tpm_dev
+							 [locality].data);
+
+			if (offset == 6) {
+				/*
+				 * We got the first six bytes of the reply,
+				 * let's figure out how many bytes to expect
+				 * total - it is stored as a 4 byte number in
+				 * network order, starting with offset 2 into
+				 * the body of the reply.
+				 */
+				u32 real_length;
+				memcpy(&real_length,
+				       buffer + 2,
+				       sizeof(real_length));
+				expected_count = be32_to_cpu(real_length);
+
+				if ((expected_count < offset) ||
+				    (expected_count > *len)) {
+					printf("%s:%d bad response size %d\n",
+					       __FILE__, __LINE__,
+					       expected_count);
+					return TPM_DRIVER_ERR;
+				}
+			}
+		}
+
+		/* Wait for the next portion. */
+		value = tis_wait_reg(&lpc_tpm_dev[locality].tpm_status,
+				     TIS_STS_VALID, TIS_STS_VALID);
+		if (value == TPM_TIMEOUT_ERR) {
+			printf("%s:%d failed to read response\n",
+			       __FILE__, __LINE__);
+			return TPM_DRIVER_ERR;
+		}
+
+		if (offset == expected_count)
+			break;	/* We got all we needed. */
+
+	} while ((value & has_data) == has_data);
+
+	/*
+	 * Make sure we indeed read all there was. The TIS_STS_VALID bit is
+	 * known to be set.
+	 */
+	if (value & TIS_STS_DATA_AVAILABLE) {
+		printf("%s:%d wrong receive status %x\n",
+		       __FILE__, __LINE__, value);
+		return TPM_DRIVER_ERR;
+	}
+
+	/* Tell the TPM that we are done. */
+	tpm_write_word(TIS_STS_COMMAND_READY, &lpc_tpm_dev
+		  [locality].tpm_status);
+	*len = offset;
+	return 0;
+}
+
+
+/***********************************************************************/
+
+int sc_i2c_set_bus_speed(unsigned int speed)
+{
+    unsigned int i2c_clk = gd->i2c2_clk;
+
+    writeb(0, &sc_i2c_dev->cr);		/* stop controller */
+    sc_i2c_bus_speed =
+        sc_set_i2c_bus_speed(sc_i2c_dev, i2c_clk, speed);
+    writeb(I2C_CR_MEN, &sc_i2c_dev->cr);	/* start controller */
+
+    return 0;
+}
+
+
+unsigned int sc_i2c_get_bus_speed(void)
+{
+    return sc_i2c_bus_speed;
+}
+/**
+ * Set the I2C bus speed for a given I2C device
+ *
+ * @param dev: the I2C device
+ * @i2c_clk: I2C bus clock frequency
+ * @speed: the desired speed of the bus
+ *
+ * The I2C device must be stopped before calling this function.
+ *
+ * The return value is the actual bus speed that is set.
+ */
+static unsigned int sc_set_i2c_bus_speed(struct fsl_i2c *dev,
+        unsigned int i2c_clk, unsigned int speed)
+{
+    unsigned short divider = min(i2c_clk / speed, (unsigned short) -1);
+
+    /*
+     * We want to choose an FDR/DFSR that generates an I2C bus speed that
+     * is equal to or lower than the requested speed.  That means that we
+     * want the first divider that is equal to or greater than the
+     * calculated divider.
+     */
+#if defined (__PPC__) || defined (__powerpc__)
+    u8 dfsr, fdr = 0x31; /* Default if no FDR found */
+    /* a, b and dfsr matches identifiers A,B and C respectively in AN2919 */
+    unsigned short a, b, ga, gb;
+    unsigned long c_div, est_div;
+
+    /* Condition 1: dfsr <= 50/T */
+    dfsr = (5 * (i2c_clk / 1000)) / 100000;
+
+    debug("Requested speed:%d, i2c_clk:%d\n", speed, i2c_clk);
+    if (!dfsr)
+        dfsr = 1;
+
+    est_div = ~0;
+    for (ga = 0x4, a = 10; a <= 30; ga++, a += 2) {
+        for (gb = 0; gb < 8; gb++) {
+            b = 16 << gb;
+            c_div = b * (a + ((3*dfsr)/b)*2);
+            if ((c_div > divider) && (c_div < est_div)) {
+                unsigned short bin_gb, bin_ga;
+
+                est_div = c_div;
+                bin_gb = gb << 2;
+                bin_ga = (ga & 0x3) | ((ga & 0x4) << 3);
+                fdr = bin_gb | bin_ga;
+                speed = i2c_clk / est_div;
+                debug("FDR:0x%.2x, div:%ld, ga:0x%x, gb:0x%x, "
+                      "a:%d, b:%d, speed:%d\n",
+                      fdr, est_div, ga, gb, a, b, speed);
+                /* Condition 2 not accounted for */
+                debug("Tr <= %d ns\n",
+                      (b - 3 * dfsr) * 1000000 /
+                      (i2c_clk / 1000));
+            }
+        }
+        if (a == 20)
+            a += 2;
+        if (a == 24)
+            a += 4;
+    }
+    debug("divider:%d, est_div:%ld, DFSR:%d\n", divider, est_div, dfsr);
+    debug("FDR:0x%.2x, speed:%d\n", fdr, speed);
+
+    writeb(dfsr, &dev->dfsrr);	/* set default filter */
+    writeb(fdr, &dev->fdr);		/* set bus speed */
+#endif
+    return speed;
+}
+
+void
+sc_i2c_init(int speed, int slaveadd)
+{
+    /*
+     * init i2c bus first:
+     * because XTM3x has no i2c slave, so put i2c bus init in RTC init
+     */	
+    
+	struct fsl_i2c *dev;
+    unsigned int temp;
+
+    dev = (struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C_OFFSET);
+
+    writeb(0, &dev->cr);			/* stop I2C controller */
+    udelay(5);				/* let it shutdown in peace */
+    temp = sc_set_i2c_bus_speed(dev, gd->i2c1_clk, speed);
+    if (gd->flags & GD_FLG_RELOC)
+        sc_i2c_bus_speed = temp;
+    writeb(slaveadd << 1, &dev->adr);	/* write slave address */
+    writeb(0x0, &dev->sr);			/* clear status register */
+    writeb(I2C_CR_MEN , &dev->cr);		/* start I2C controller */   
+}
+
+static __inline__ int
+sc_i2c_wait(int write)
+{
+    u32 csr;
+    unsigned long long timeval = get_ticks();
+    const unsigned long long timeout = usec2ticks(SC_CONFIG_I2C_TIMEOUT);
+
+    do {
+        csr = readb(&sc_i2c_dev->sr);
+        if (!(csr & I2C_SR_MIF))
+            continue;
+        /* Read again to allow register to stabilise */
+        csr = readb(&sc_i2c_dev->sr);
+
+        writeb(0x0, &sc_i2c_dev->sr);
+
+        if (csr & I2C_SR_MAL) {
+            debug("i2c_wait: MAL\n");
+            return -1;
+        }
+
+        if (!(csr & I2C_SR_MCF))	{
+            debug("i2c_wait: unfinished\n");
+            return -1;
+        }
+
+        if (write == SC_I2C_WRITE_BIT && (csr & I2C_SR_RXAK)) {
+            debug("i2c_wait: No RXACK\n");
+            return -1;
+        }
+
+        return 0;
+    } while ((get_ticks() - timeval) < timeout);
+
+    debug("i2c_wait: timed out\n");
+    return -1;
+}
+
+/***********************************************************************/
+static inline void writeccr(struct fsl_i2c * dev, u32 x)
+{
+    writeb(x, &dev->cr);	
+}
+
+static void tpm_i2c_start(struct fsl_i2c * dev)
+{
+	/* Clear arbitration */
+	writeb(0, &dev->sr);
+	/* Start with MEN */
+	writeccr(dev, I2C_CR_MEN);
+}
+
+static void tpm_i2c_stop(struct fsl_i2c * dev)
+{
+	writeccr(dev, I2C_CR_MEN);
+}
+/* Sometimes 9th clock pulse isn't generated, and slave doesn't release
+ * the bus, because it wants to send ACK.
+ * Following sequence of enabling/disabling and sending start/stop generates
+ * the pulse, so it's all OK.
+ */
+static void tpm_i2c_fixup(struct fsl_i2c *i2c)
+{
+	writeccr(i2c, 0);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MEN);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MSTA | I2C_CR_MTX);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MSTA | I2C_CR_MTX | I2C_CR_MEN);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MEN);
+	udelay(30);
+}
+
+static int tpm_write(struct fsl_i2c *i2c, int target,
+		     const u8 *data, int length, int restart)
+{
+	int i, result;
+	u32 flags = restart ? I2C_CR_RSTA : 0;
+
+	/* Start as master */
+	writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_MTX | flags);
+	/* Write target byte */
+	writeb((target << 1), &i2c->dr);
+
+	result = sc_i2c_wait(SC_I2C_WRITE_BIT);
+	if (result < 0)
+		return result;
+
+	for (i = 0; i < length; i++) {
+		/* Write data byte */
+		writeb(data[i], &i2c->dr);
+
+		result = sc_i2c_wait(SC_I2C_WRITE_BIT);
+		if (result < 0)
+			return result;
+	}
+
+	return 0;
+}
+
+static int tpm_read(struct fsl_i2c *i2c, int target,
+		    u8 *data, int length, int restart)
+{
+	int i, result;
+	u32 flags = restart ? I2C_CR_RSTA : 0;
+
+	/* Switch to read - restart */
+	writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_MTX | flags);
+	/* Write target address byte - this time with the read flag set */
+	writeb((target << 1) | 1, &i2c->dr);
+
+	result = sc_i2c_wait(SC_I2C_WRITE_BIT);
+	if (result < 0)
+		return result;
+
+	if (length) {
+		if (length == 1)
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_TXAK);
+		else
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA);
+		/* Dummy read */
+		readb(&i2c->dr);
+	}
+
+	for (i = 0; i < length; i++) {
+		result = sc_i2c_wait(SC_I2C_READ_BIT);
+		if (result < 0)
+			return result;
+
+		/* Generate txack on next to last byte */
+		if (i == length - 2)
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_TXAK);
+		/* Do not generate stop on last byte */
+		if (i == length - 1)
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_MTX);
+		data[i] = readb(&i2c->dr);
+	}
+
+	return length;
+}
+
+static int tpm_xfer(struct fsl_i2c *i2c, struct i2c_msg *msgs, int num)
+{
+	struct i2c_msg *pmsg;
+	int i;
+	int ret = 0;
+	
+	unsigned long long timeval = get_ticks();
+	const unsigned long long timeout = usec2ticks(SC_CONFIG_I2C_MBB_TIMEOUT);
+	
+	tpm_i2c_start(i2c);
+
+	/* Allow bus up to 1s to become not busy */
+	while (readb(&i2c->sr) & I2C_SR_MBB) 
+	{
+		if ((get_ticks() - timeval) > timeout)
+		{
+			debug("%s %d : i2c bus always busy!\n", __func__, __LINE__);
+			tpm_i2c_fixup(i2c);
+			return -1;
+		}
+	}
+
+
+	for (i = 0; ret >= 0 && i < num; i++) {
+		pmsg = &msgs[i];
+		debug("Doing %s %d bytes to 0x%02x - %d of %d messages\n",
+			pmsg->flags & I2C_M_RD ? "read" : "write",
+			pmsg->len, pmsg->addr, i + 1, num);
+		if (pmsg->flags & I2C_M_RD)
+			ret =
+			    tpm_read(i2c, pmsg->addr, pmsg->buf, pmsg->len, i);
+		else
+			ret =
+			    tpm_write(i2c, pmsg->addr, pmsg->buf, pmsg->len, i);
+	}
+	tpm_i2c_stop(i2c);
+	return (ret < 0) ? ret : num;
+}
+
+int tpm_get_reg(struct fsl_i2c *i2c, int reg, char *buf, int len)
+{
+	struct i2c_msg msg = {
+		(RTC_DEV_S35390 << RTC_DEV_ADDR_SHIFT) | (reg << RTC_CMD_ADDR_SHIFT), 
+		SC_I2C_READ_BIT, len, (unsigned char *)buf
+	};
+
+	if (tpm_xfer(i2c, &msg, 1) != 1)
+		return -1;
+
+	return 0;
+}
+
+int tpm_set_reg(struct fsl_i2c *i2c, int reg, char *buf, int len)
+{
+
+	struct i2c_msg msg = {
+		(RTC_DEV_S35390 << RTC_DEV_ADDR_SHIFT) | (reg << RTC_CMD_ADDR_SHIFT), 
+		SC_I2C_WRITE_BIT, len, (unsigned char *)buf
+	};
+
+	if (tpm_xfer(i2c, &msg, 1) != 1)
+		return -1;
+
+	return 0;
+}
+
+int tpm_reset(struct fsl_i2c *i2c)
+{
+	char buf[1];
+
+	if (tpm_get_reg(i2c, CMD_STATUS_1ST, buf, sizeof(buf)) < 0)
+		return -1;
+
+	if (!(buf[0] & (S35390A_FLAG_POC | S35390A_FLAG_BLD)))
+		return 0;
+
+	buf[0] |= (S35390A_FLAG_RESET | S35390A_FLAG_24H);
+	buf[0] &= 0xf0;
+	return tpm_set_reg(i2c, CMD_STATUS_1ST, buf, sizeof(buf));
+}
+
+int sc_tpm_init(void)
+{
+
+}
+
+int tis_open(void)
+{
+	u8 locality = 0; /* we use locality zero for everything. */
+	sc_i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+	sc_tpm_init();
+
+	if (tis_close())
+		return TPM_DRIVER_ERR;
+
+	/* now request access to locality. */
+	tpm_write_word(TIS_ACCESS_REQUEST_USE, &lpc_tpm_dev[locality].access);
+
+	/* did we get a lock? */
+	if (tis_wait_reg(&lpc_tpm_dev[locality].access,
+			 TIS_ACCESS_ACTIVE_LOCALITY,
+			 TIS_ACCESS_ACTIVE_LOCALITY) == TPM_TIMEOUT_ERR) {
+		printf("%s:%d - failed to lock locality %d\n",
+		       __FILE__, __LINE__, locality);
+		return TPM_DRIVER_ERR;
+	}
+
+	tpm_write_word(TIS_STS_COMMAND_READY,
+		       &lpc_tpm_dev[locality].tpm_status);
+	return 0;
+}
+
+int tis_close(void)
+{
+	u8 locality = 0;
+
+	if (tpm_read_word(&lpc_tpm_dev[locality].access) &
+	    TIS_ACCESS_ACTIVE_LOCALITY) {
+		tpm_write_word(TIS_ACCESS_ACTIVE_LOCALITY,
+			       &lpc_tpm_dev[locality].access);
+
+		if (tis_wait_reg(&lpc_tpm_dev[locality].access,
+				 TIS_ACCESS_ACTIVE_LOCALITY, 0) ==
+		    TPM_TIMEOUT_ERR) {
+			printf("%s:%d - failed to release locality %d\n",
+			       __FILE__, __LINE__, locality);
+			return TPM_DRIVER_ERR;
+		}
+	}
+	return 0;
+}
+
+int tis_sendrecv(const u8 *sendbuf, size_t send_size,
+		 u8 *recvbuf, size_t *recv_len)
+{
+	if (tis_senddata(sendbuf, send_size)) {
+		printf("%s:%d failed sending data to TPM\n",
+		       __FILE__, __LINE__);
+		return TPM_DRIVER_ERR;
+	}
+
+	return tis_readresponse(recvbuf, recv_len);
+}
--- u-boot-2011.03/drivers/tpm/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/tpm/Makefile	2022-05-09 14:05:11.592053432 -0700
@@ -0,0 +1,43 @@
+# Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB := $(obj)libtpm.o
+
+COBJS-$(CONFIG_GENERIC_LPC_TPM) = generic_lpc_tpm.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB): $(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
--- u-boot-2011.03/drivers/rtc/s35390.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/rtc/s35390.c	2022-05-09 14:05:11.584053757 -0700
@@ -0,0 +1,606 @@
+#include <common.h>
+#include <command.h>
+#include <i2c.h>		/* Functional interface */
+
+#include <asm/io.h>
+#include <asm/fsl_i2c.h>	/* HW definitions */
+#include <rtc.h>
+
+#include "s35390.h"
+
+#undef DEBUG_RTC                                                                                                                                                                                                 
+                                                                                                                                                                                                                 
+#ifdef DEBUG_RTC                                                                                                                                                                                                 
+#define DEBUGR(fmt,args...) printf(fmt ,##args)                                                                                                                                                                  
+#else                                                                                                                                                                                                            
+#define DEBUGR(fmt,args...)                                                                                                                                                                                      
+#endif
+
+/**************************************************************************
+ * 	The I2C interface designed for S-35390, using P1020 I2C BUS controller
+ **************************************************************************/
+/* The maximum number of microseconds we will wait until another master has
+ * released the bus.  If not defined in the board header file, then use a
+ * generic value.
+ */
+#ifndef SC_CONFIG_I2C_MBB_TIMEOUT
+#define SC_CONFIG_I2C_MBB_TIMEOUT	100000
+#endif
+
+/* The maximum number of microseconds we will wait for a read or write
+ * operation to complete.  If not defined in the board header file, then use a
+ * generic value.
+ */
+#ifndef SC_CONFIG_I2C_TIMEOUT
+#define SC_CONFIG_I2C_TIMEOUT	10000
+#endif
+
+#define SC_I2C_READ_BIT  1
+#define SC_I2C_WRITE_BIT 0
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* Initialize the bus pointer to whatever one the SPD EEPROM is on.
+ * Default is bus 0.  This is necessary because the DDR initialization
+ * runs from ROM, and we can't switch buses because we can't modify
+ * the global variables.
+ */
+
+static unsigned int sc_i2c_bus_speed = CONFIG_SYS_I2C_SPEED;
+
+static struct fsl_i2c *sc_i2c_dev = (struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C_OFFSET);
+
+
+/* Function Protypes */
+static unsigned int sc_set_i2c_bus_speed(struct fsl_i2c *dev,
+        unsigned int i2c_clk, unsigned int speed);
+int sc_i2c_set_bus_speed(unsigned int speed);
+unsigned int sc_i2c_get_bus_speed(void);
+void sc_i2c_init(int speed, int slaveadd);
+static __inline__ int sc_i2c_wait(int write);
+// static int sc_i2c_wait4bus(void);
+
+
+/***********************************************************************/
+static inline void writeccr(struct fsl_i2c * dev, u32 x)
+{
+    writeb(x, &dev->cr);	
+}
+
+static void mpc_i2c_start(struct fsl_i2c * dev)
+{
+	/* Clear arbitration */
+	writeb(0, &dev->sr);
+	/* Start with MEN */
+	writeccr(dev, I2C_CR_MEN);
+}
+
+static void mpc_i2c_stop(struct fsl_i2c * dev)
+{
+	writeccr(dev, I2C_CR_MEN);
+}
+/* Sometimes 9th clock pulse isn't generated, and slave doesn't release
+ * the bus, because it wants to send ACK.
+ * Following sequence of enabling/disabling and sending start/stop generates
+ * the pulse, so it's all OK.
+ */
+static void mpc_i2c_fixup(struct fsl_i2c *i2c)
+{
+	writeccr(i2c, 0);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MEN);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MSTA | I2C_CR_MTX);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MSTA | I2C_CR_MTX | I2C_CR_MEN);
+	udelay(30);
+	writeccr(i2c, I2C_CR_MEN);
+	udelay(30);
+}
+
+static int mpc_write(struct fsl_i2c *i2c, int target,
+		     const u8 *data, int length, int restart)
+{
+	int i, result;
+	u32 flags = restart ? I2C_CR_RSTA : 0;
+
+	/* Start as master */
+	writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_MTX | flags);
+	/* Write target byte */
+	writeb((target << 1), &i2c->dr);
+
+	result = sc_i2c_wait(SC_I2C_WRITE_BIT);
+	if (result < 0)
+		return result;
+
+	for (i = 0; i < length; i++) {
+		/* Write data byte */
+		writeb(data[i], &i2c->dr);
+
+		result = sc_i2c_wait(SC_I2C_WRITE_BIT);
+		if (result < 0)
+			return result;
+	}
+
+	return 0;
+}
+
+static int mpc_read(struct fsl_i2c *i2c, int target,
+		    u8 *data, int length, int restart)
+{
+	int i, result;
+	u32 flags = restart ? I2C_CR_RSTA : 0;
+
+	/* Switch to read - restart */
+	writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_MTX | flags);
+	/* Write target address byte - this time with the read flag set */
+	writeb((target << 1) | 1, &i2c->dr);
+
+	result = sc_i2c_wait(SC_I2C_WRITE_BIT);
+	if (result < 0)
+		return result;
+
+	if (length) {
+		if (length == 1)
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_TXAK);
+		else
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA);
+		/* Dummy read */
+		readb(&i2c->dr);
+	}
+
+	for (i = 0; i < length; i++) {
+		result = sc_i2c_wait(SC_I2C_READ_BIT);
+		if (result < 0)
+			return result;
+
+		/* Generate txack on next to last byte */
+		if (i == length - 2)
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_TXAK);
+		/* Do not generate stop on last byte */
+		if (i == length - 1)
+			writeccr(i2c, I2C_CR_MEN | I2C_CR_MSTA | I2C_CR_MTX);
+		data[i] = readb(&i2c->dr);
+	}
+
+	return length;
+}
+
+static int mpc_xfer(struct fsl_i2c *i2c, struct i2c_msg *msgs, int num)
+{
+	struct i2c_msg *pmsg;
+	int i;
+	int ret = 0;
+	
+	unsigned long long timeval = get_ticks();
+	const unsigned long long timeout = usec2ticks(SC_CONFIG_I2C_MBB_TIMEOUT);
+	
+	mpc_i2c_start(i2c);
+
+	/* Allow bus up to 1s to become not busy */
+	while (readb(&i2c->sr) & I2C_SR_MBB) 
+	{
+		if ((get_ticks() - timeval) > timeout)
+		{
+			debug("%s %d : i2c bus always busy!\n", __func__, __LINE__);
+			mpc_i2c_fixup(i2c);
+			return -1;
+		}
+	}
+
+
+	for (i = 0; ret >= 0 && i < num; i++) {
+		pmsg = &msgs[i];
+		debug("Doing %s %d bytes to 0x%02x - %d of %d messages\n",
+			pmsg->flags & I2C_M_RD ? "read" : "write",
+			pmsg->len, pmsg->addr, i + 1, num);
+		if (pmsg->flags & I2C_M_RD)
+			ret =
+			    mpc_read(i2c, pmsg->addr, pmsg->buf, pmsg->len, i);
+		else
+			ret =
+			    mpc_write(i2c, pmsg->addr, pmsg->buf, pmsg->len, i);
+	}
+	mpc_i2c_stop(i2c);
+	return (ret < 0) ? ret : num;
+}
+
+int s35390a_get_reg(struct fsl_i2c *i2c, int reg, char *buf, int len)
+{
+	struct i2c_msg msg = {
+		(RTC_DEV_S35390 << RTC_DEV_ADDR_SHIFT) | (reg << RTC_CMD_ADDR_SHIFT), 
+		SC_I2C_READ_BIT, len, (unsigned char *)buf
+	};
+
+	if (mpc_xfer(i2c, &msg, 1) != 1)
+		return -1;
+
+	return 0;
+}
+
+int s35390a_set_reg(struct fsl_i2c *i2c, int reg, char *buf, int len)
+{
+	struct i2c_msg msg = {
+		(RTC_DEV_S35390 << RTC_DEV_ADDR_SHIFT) | (reg << RTC_CMD_ADDR_SHIFT), 
+		SC_I2C_WRITE_BIT, len, (unsigned char *)buf
+	};
+
+	if (mpc_xfer(i2c, &msg, 1) != 1)
+		return -1;
+
+	return 0;
+}
+
+int s35390a_reset(struct fsl_i2c *i2c)
+{
+	char buf[1];
+
+	if (s35390a_get_reg(i2c, CMD_STATUS_1ST, buf, sizeof(buf)) < 0)
+		return -1;
+
+	if (!(buf[0] & (S35390A_FLAG_POC | S35390A_FLAG_BLD)))
+		return 0;
+
+	buf[0] |= (S35390A_FLAG_RESET | S35390A_FLAG_24H);
+	buf[0] &= 0xf0;
+	return s35390a_set_reg(i2c, CMD_STATUS_1ST, buf, sizeof(buf));
+}
+
+static int s35390a_disable_test_mode(struct fsl_i2c *i2c)
+{
+	char buf[1];
+
+	if (s35390a_get_reg(i2c, CMD_STATUS_2ND, buf, sizeof(buf)) < 0)
+		return -1;
+
+	if (!(buf[0] & S35390A_FLAG_TEST))
+		return 0;
+
+	buf[0] &= ~S35390A_FLAG_TEST;
+	return s35390a_set_reg(i2c, CMD_STATUS_2ND, buf, sizeof(buf));
+}
+
+/***********************************************************************/
+
+int sc_i2c_set_bus_speed(unsigned int speed)
+{
+    unsigned int i2c_clk = gd->i2c2_clk;
+
+    writeb(0, &sc_i2c_dev->cr);		/* stop controller */
+    sc_i2c_bus_speed =
+        sc_set_i2c_bus_speed(sc_i2c_dev, i2c_clk, speed);
+    writeb(I2C_CR_MEN, &sc_i2c_dev->cr);	/* start controller */
+
+    return 0;
+}
+
+
+unsigned int sc_i2c_get_bus_speed(void)
+{
+    return sc_i2c_bus_speed;
+}
+/**
+ * Set the I2C bus speed for a given I2C device
+ *
+ * @param dev: the I2C device
+ * @i2c_clk: I2C bus clock frequency
+ * @speed: the desired speed of the bus
+ *
+ * The I2C device must be stopped before calling this function.
+ *
+ * The return value is the actual bus speed that is set.
+ */
+static unsigned int sc_set_i2c_bus_speed(struct fsl_i2c *dev,
+        unsigned int i2c_clk, unsigned int speed)
+{
+    unsigned short divider = min(i2c_clk / speed, (unsigned short) -1);
+
+    /*
+     * We want to choose an FDR/DFSR that generates an I2C bus speed that
+     * is equal to or lower than the requested speed.  That means that we
+     * want the first divider that is equal to or greater than the
+     * calculated divider.
+     */
+#if defined (__PPC__) || defined (__powerpc__)
+    u8 dfsr, fdr = 0x31; /* Default if no FDR found */
+    /* a, b and dfsr matches identifiers A,B and C respectively in AN2919 */
+    unsigned short a, b, ga, gb;
+    unsigned long c_div, est_div;
+
+    /* Condition 1: dfsr <= 50/T */
+    dfsr = (5 * (i2c_clk / 1000)) / 100000;
+
+    debug("Requested speed:%d, i2c_clk:%d\n", speed, i2c_clk);
+    if (!dfsr)
+        dfsr = 1;
+
+    est_div = ~0;
+    for (ga = 0x4, a = 10; a <= 30; ga++, a += 2) {
+        for (gb = 0; gb < 8; gb++) {
+            b = 16 << gb;
+            c_div = b * (a + ((3*dfsr)/b)*2);
+            if ((c_div > divider) && (c_div < est_div)) {
+                unsigned short bin_gb, bin_ga;
+
+                est_div = c_div;
+                bin_gb = gb << 2;
+                bin_ga = (ga & 0x3) | ((ga & 0x4) << 3);
+                fdr = bin_gb | bin_ga;
+                speed = i2c_clk / est_div;
+                debug("FDR:0x%.2x, div:%ld, ga:0x%x, gb:0x%x, "
+                      "a:%d, b:%d, speed:%d\n",
+                      fdr, est_div, ga, gb, a, b, speed);
+                /* Condition 2 not accounted for */
+                debug("Tr <= %d ns\n",
+                      (b - 3 * dfsr) * 1000000 /
+                      (i2c_clk / 1000));
+            }
+        }
+        if (a == 20)
+            a += 2;
+        if (a == 24)
+            a += 4;
+    }
+    debug("divider:%d, est_div:%ld, DFSR:%d\n", divider, est_div, dfsr);
+    debug("FDR:0x%.2x, speed:%d\n", fdr, speed);
+
+    writeb(dfsr, &dev->dfsrr);	/* set default filter */
+    writeb(fdr, &dev->fdr);		/* set bus speed */
+#endif
+    return speed;
+}
+
+void
+sc_i2c_init(int speed, int slaveadd)
+{
+    /*
+     * init i2c bus first:
+     * because XTM3x has no i2c slave, so put i2c bus init in RTC init
+     */	
+    struct fsl_i2c *dev;
+    unsigned int temp;
+
+    dev = (struct fsl_i2c *) (CONFIG_SYS_IMMR + CONFIG_SYS_I2C_OFFSET);
+
+    writeb(0, &dev->cr);			/* stop I2C controller */
+    udelay(5);				/* let it shutdown in peace */
+    temp = sc_set_i2c_bus_speed(dev, gd->i2c1_clk, speed);
+    if (gd->flags & GD_FLG_RELOC)
+        sc_i2c_bus_speed = temp;
+    writeb(slaveadd << 1, &dev->adr);	/* write slave address */
+    writeb(0x0, &dev->sr);			/* clear status register */
+    writeb(I2C_CR_MEN , &dev->cr);		/* start I2C controller */   
+}
+
+static __inline__ int
+sc_i2c_wait(int write)
+{
+    u32 csr;
+    unsigned long long timeval = get_ticks();
+    const unsigned long long timeout = usec2ticks(SC_CONFIG_I2C_TIMEOUT);
+
+    do {
+        csr = readb(&sc_i2c_dev->sr);
+        if (!(csr & I2C_SR_MIF))
+            continue;
+        /* Read again to allow register to stabilise */
+        csr = readb(&sc_i2c_dev->sr);
+
+        writeb(0x0, &sc_i2c_dev->sr);
+
+        if (csr & I2C_SR_MAL) {
+            debug("i2c_wait: MAL\n");
+            return -1;
+        }
+
+        if (!(csr & I2C_SR_MCF))	{
+            debug("i2c_wait: unfinished\n");
+            return -1;
+        }
+
+        if (write == SC_I2C_WRITE_BIT && (csr & I2C_SR_RXAK)) {
+            debug("i2c_wait: No RXACK\n");
+            return -1;
+        }
+
+        return 0;
+    } while ((get_ticks() - timeval) < timeout);
+
+    debug("i2c_wait: timed out\n");
+    return -1;
+}
+
+/********************************************************
+ * RTC Functions
+ ********************************************************/
+static char DEC_To_BCD(unsigned char dec)
+{
+    unsigned char temp1, temp2, temp;
+#if 0
+    printf("in : %d \n", dec);
+#endif
+    temp1 = dec/10;
+    temp2 = dec%10;
+
+    temp1 <<= 4;
+    temp = temp1|temp2;
+#if 0
+    printf("out : %d \n", temp);
+#endif
+    return temp;
+}
+
+/* BCD and DEC convert */
+static char BCD_To_DEC (unsigned char bcd)
+{
+    unsigned char temp1, temp2, temp;
+
+    temp1 = bcd&0xf0;
+    temp2 = bcd&0x0f;
+
+    temp1 >>= 4;
+    temp = temp1*10 + temp2;
+
+    return temp;
+}
+
+/*
+ * RTC init function for Seiko S-35390
+ */
+void sc_rtc_init(void)
+{
+	int err;
+	    
+    udelay(1000);
+
+    /* reset RTC */
+	err = s35390a_reset(sc_i2c_dev);
+	if (err < 0) {
+		debug("error resetting chip\n");
+		return;
+	}	
+	
+	err = s35390a_disable_test_mode(sc_i2c_dev);
+	if (err < 0) {
+		debug("error disabling test mode\n");
+		return;
+	}	
+}
+
+/*
+ * RTC get time 
+ */
+int sc_rtc_get_time(SC_RTC_TIME * time)
+{
+	SC_RTC_TIME time_in_bcd;
+	
+	if(s35390a_get_reg(sc_i2c_dev, CMD_TIME_YEAR, (char *)&(time_in_bcd), RTC_TIME_YEAR_LEN))
+	{
+		printf("Error : read rtc time failed!\n");
+		return RTC_OP_FAIL;
+	}
+	
+	/* bits convertion */
+	time_in_bcd.year 	= swap_bits_in_char(time_in_bcd.year );
+	time_in_bcd.month 	= swap_bits_in_char(time_in_bcd.month);
+	time_in_bcd.day 	= swap_bits_in_char(time_in_bcd.day  );
+	time_in_bcd.week 	= swap_bits_in_char(time_in_bcd.week );
+	time_in_bcd.hour 	= swap_bits_in_char(time_in_bcd.hour );
+	time_in_bcd.min 	= swap_bits_in_char(time_in_bcd.min  );
+	time_in_bcd.sec 	= swap_bits_in_char(time_in_bcd.sec  );	
+	
+	/* bcd -> dec */
+	time->year 	= BCD_To_DEC(time_in_bcd.year );
+	time->month = BCD_To_DEC(time_in_bcd.month);
+	time->day 	= BCD_To_DEC(time_in_bcd.day  );
+	time->week	= BCD_To_DEC(time_in_bcd.week );
+	time->hour 	= BCD_To_DEC(time_in_bcd.hour );
+	time->min  	= BCD_To_DEC(time_in_bcd.min  );
+	time->sec	= BCD_To_DEC(time_in_bcd.sec  );
+	
+	return RTC_OP_OK;
+}
+
+/* 
+ * RTC set time
+ */
+int sc_rtc_set_time(SC_RTC_TIME * time)
+{
+	SC_RTC_TIME time_in_bcd;
+	
+	if(time == NULL)
+	{
+		printf("Error : NULL time to set into RTC.\n");
+		return RTC_OP_FAIL;
+	}
+	
+	/* dec -> bcd */
+	time_in_bcd.year 	= DEC_To_BCD(time->year ); 			
+	time_in_bcd.month 	= DEC_To_BCD(time->month); 	
+	time_in_bcd.day 	= DEC_To_BCD(time->day 	);
+	time_in_bcd.week 	= DEC_To_BCD(time->week	);
+	time_in_bcd.hour 	= DEC_To_BCD(time->hour ); 	
+	time_in_bcd.min 	= DEC_To_BCD(time->min 	); 	
+	time_in_bcd.sec 	= DEC_To_BCD(time->sec	);	    
+
+	/* bits convertion */
+	time_in_bcd.year 	= swap_bits_in_char(time_in_bcd.year );
+	time_in_bcd.month 	= swap_bits_in_char(time_in_bcd.month);
+	time_in_bcd.day 	= swap_bits_in_char(time_in_bcd.day  );
+	time_in_bcd.week 	= swap_bits_in_char(time_in_bcd.week );
+	time_in_bcd.hour 	= swap_bits_in_char(time_in_bcd.hour );
+	time_in_bcd.min 	= swap_bits_in_char(time_in_bcd.min  );
+	time_in_bcd.sec 	= swap_bits_in_char(time_in_bcd.sec  );	
+	
+	/* set into RTC */
+	if(s35390a_set_reg(sc_i2c_dev, CMD_TIME_YEAR, (char *)&(time_in_bcd), RTC_TIME_YEAR_LEN))
+	{
+		printf("Error : set RTC time failed.\n");
+		return RTC_OP_FAIL;
+	}
+	else
+		return RTC_OP_OK;
+}
+
+
+/*
+ * Set the RTC
+ */
+int rtc_set (struct rtc_time *tmp)
+{	
+	SC_RTC_TIME sc_time;
+
+	DEBUGR ("Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	sc_time.year  = tmp->tm_year - 2000;
+	sc_time.month = tmp->tm_mon;
+	sc_time.day   = tmp->tm_mday;
+	sc_time.week  = tmp->tm_wday;
+	sc_time.hour  = tmp->tm_hour;
+	sc_time.min   = tmp->tm_min;
+	sc_time.sec   = tmp->tm_sec;
+
+	sc_rtc_set_time(&sc_time);
+	return 0;
+}
+
+/*
+ * Get the current time from the RTC
+ */
+int rtc_get (struct rtc_time *tmp)
+{
+	int rel = 0;
+	
+	SC_RTC_TIME sc_time;
+	
+	if(sc_rtc_get_time(&sc_time) != RTC_OP_OK)
+	{
+		printf("get RTC time failed!\n");
+		return -1;
+	}
+
+	tmp->tm_sec  = sc_time.sec;
+	tmp->tm_min  = sc_time.min;
+	tmp->tm_hour = sc_time.hour;
+	tmp->tm_mday = sc_time.day;
+	tmp->tm_mon  = sc_time.month;
+	tmp->tm_year = sc_time.year + 2000;
+	tmp->tm_wday = sc_time.week;
+	tmp->tm_yday = 0;
+	tmp->tm_isdst= 0;
+
+	DEBUGR ("Get DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	return rel;
+}
+
+void rtc_reset (void)
+{
+    /* reset RTC */
+	s35390a_reset(sc_i2c_dev);	
+}
+	
--- u-boot-2011.03/drivers/rtc/s35390.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/drivers/rtc/s35390.h	2022-05-09 14:05:11.584053757 -0700
@@ -0,0 +1,99 @@
+#ifndef _RTC_S35390_H_
+#define _RTC_S35390_H_
+
+/**************************************************************************
+ * 	This is for RTC Chip Seiko S-35390 definitions
+ **************************************************************************/
+struct i2c_msg {
+        unsigned short addr;     /* slave address                        */
+        unsigned short flags;
+#define I2C_M_TEN               0x0010  /* this is a ten bit chip address */
+#define I2C_M_RD                0x0001  /* read data, from slave to master */
+#define I2C_M_NOSTART           0x4000  /* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_REV_DIR_ADDR      0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_IGNORE_NAK        0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_NO_RD_ACK         0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */
+#define I2C_M_RECV_LEN          0x0400  /* length will be first received byte */
+        unsigned short len;              /* msg length                           */
+        unsigned char *buf;              /* pointer to msg data                  */
+};
+/* dev code */
+#define RTC_DEV_S35390 (0x6)
+
+/* register */
+#define CMD_STATUS_1ST	(0x0)
+#define CMD_STATUS_2ND	(0x1)
+#define CMD_TIME_YEAR	(0x2)
+#define CMD_TIME_HOUR	(0x3)
+#define CMD_INTREG_1ST	(0x4)
+#define CMD_INTREG_2ND	(0x5)
+#define CMD_CLK_CORRECT	(0x6)
+#define CMD_FREE_REG	(0x7)
+
+/* status flag */
+#define S35390A_FLAG_POC	0x01
+#define S35390A_FLAG_BLD	0x02
+#define S35390A_FLAG_24H	0x40
+#define S35390A_FLAG_RESET	0x80
+#define S35390A_FLAG_TEST	0x01
+
+/* address shift */
+#define RTC_DEV_ADDR_SHIFT	3
+#define RTC_CMD_ADDR_SHIFT	0
+
+/* Settings */
+#define RTC_STAT_1_RST_CHIP	(0x80)
+#define RTC_STAT_1_EXPR_24H	(0x40)
+
+#define RTC_STAT_2_TESTMODE				(0x01)
+#define RTC_STAT_2_INT2_USER_SET_FREQ	(0x08)
+#define RTC_STAT_2_INT2_PER_MIN_EDGE	(0x04)
+#define RTC_STAT_2_INT2_MIN_PERIODICAL	(0x0C)
+#define RTC_STAT_2_INT2_ALARM2			(0x02)
+#define RTC_STAT_2_INT1_USER_SET_FREQ	(0x80)
+#define RTC_STAT_2_INT1_PER_MIN_EDGE	(0x40)
+#define RTC_STAT_2_INT1_MIN_PERIODICAL1	(0xC0)
+#define RTC_STAT_2_INT1_ALARM1			(0x20)
+#define RTC_STAT_2_INT1_MIN_PERIODICAL2	(0xE0)
+#define RTC_STAT_2_32KE					(0x10)
+
+#define RTC_TIME_YEAR_LEN		(0x7)
+
+#define RTC_OP_OK				(0x0)
+#define RTC_OP_FAIL				(0x1)
+
+typedef struct
+{
+	unsigned char year;
+	unsigned char month;
+	unsigned char day;
+	unsigned char week;
+	unsigned char hour;
+	unsigned char min;
+	unsigned char sec;
+} SC_RTC_TIME;
+
+#define swap_bits_in_char(x)  (((x&0x01) <<7) | \
+					 ((x&0x02) <<5) | \
+					 ((x&0x04) <<3) | \
+					 ((x&0x08) <<1) | \
+					 ((x&0x10) >>1) | \
+					 ((x&0x20) >>3) | \
+					 ((x&0x40) >>5) | \
+					 ((x&0x80) >>7) )
+
+/* Function Protypes */
+void sc_i2c_init(int speed, int slaveadd);
+void sc_rtc_init(void);
+int sc_rtc_get_time(SC_RTC_TIME * time);
+int sc_rtc_set_time(SC_RTC_TIME * time);
+
+int s35390a_get_reg(struct fsl_i2c *i2c, int reg, char *buf, int len);
+int s35390a_set_reg(struct fsl_i2c *i2c, int reg, char *buf, int len);
+
+
+
+
+
+#endif /* _RTC_S35390_H_ */
+
--- u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p1020rdb_533M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p1020rdb_533M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,45 @@
+40:424f4f54
+44:00000000
+48:00080000
+4c:00000000
+50:00001000
+54:00000000
+58:11000000
+5c:00000000
+60:1107F000
+64:00000000
+68:00000011
+
+80:ff702110
+84:43080000
+88:ff702000
+8c:0000001f
+90:ff702080
+94:80014202
+98:ff702100
+9c:00020000
+a0:ff702104
+a4:00260802
+a8:ff702108
+ac:4c47c432
+b0:ff70210c
+b4:0f9848ce
+b8:ff702114
+bc:24401000
+c0:ff702118
+c4:00040642
+c8:ff702124
+cc:08200100
+d0:ff702130
+d4:02800000
+d8:40000001
+dc:00000100
+e0:ff702128
+e4:deadbeef
+e8:ff702110
+ec:c3080000
+f0:ff700C08
+f4:00000000
+f8:ff700D70
+fc:80F0001D
+100:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1014rdb_800M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1014rdb_800M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000001f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00020000
+0a0:ff702104
+0a4:00330004
+0a8:ff702108
+0ac:6f6b4644
+0b0:ff70210c
+0b4:0fa888cf
+0b8:ff702114
+0bc:04401000
+0c0:ff702118
+0c4:40461520
+0c8:ff70211c
+0cc:8000c000
+0d0:ff702124
+0d4:0c300100
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:03000000
+0e8:ff702160
+0ec:00000001
+0f0:ff702164
+0f4:03402400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8655a608
+108:ff702148
+10c:00000000
+110:ff702110
+114:c7140000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+130:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_2gb_p1_p2_rdb_pc.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_2gb_p1_p2_rdb_pc.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,54 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00020000
+0a0:ff702104
+0a4:00330004
+0a8:ff702108
+0ac:6f6b4846
+0b0:ff70210c
+0b4:0fa8c8cf
+0b8:ff702114
+0bc:04401040
+0c0:ff702118
+0c4:40461520
+0c8:ff702124
+0cc:0c300000
+0d0:ff702128
+0d4:deadbeef
+0d8:ff702130
+0dc:03000000
+0e0:ff702160
+0e4:00440001
+0e8:ff702164
+0ec:03402400
+0f0:ff70211c
+0f4:04000000
+0f8:ff702008
+0fc:0040007f
+100:ff702084
+104:80014202
+108:40000001
+10c:00000100
+110:ff702110
+114:c70c0000
+118:ff700C08
+11c:00000000
+120:ff700C10
+124:80f0001e
+128:efefefef
--- u-boot-2011.03/boot_format-20110419/config_sram_p2020ds.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_sram_p2020ds.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,24 @@
+40:424f4f54
+44:00000000
+48:00080000
+4c:00000000
+50:00000008
+54:00000000
+58:f8f80000
+5c:00000000
+60:f8fff000
+64:00000000
+68:00000006
+
+80:ff720100
+84:f8f80000
+88:ff720e44
+8c:0000000c
+90:ff720000
+94:80010000
+98:ff72e40c
+9c:00000040
+a0:40000001
+a4:00000100
+a8:80000001
+ac:80000001
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_667M_org.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_667M_org.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00010000
+0a0:ff702104
+0a4:00110004
+0a8:ff702108
+0ac:5d59e544
+0b0:ff70210c
+0b4:0fa890cd
+0b8:ff702114
+0bc:04401000
+0c0:ff702118
+0c4:00441210
+0c8:ff70211c
+0cc:00000000
+0d0:ff702124
+0d4:0a280000
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:03000000
+0e8:ff702160
+0ec:00000001
+0f0:ff702164
+0f4:03402400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8675f608
+108:ff702148
+10c:00000000
+110:ff702110
+114:c70c0000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+130:efefefef
--- u-boot-2011.03/boot_format-20110419/mkspi_p1010.sh.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/mkspi_p1010.sh	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1 @@
+./boot_format config_ddr3_1gb_p1010rdb_667M.dat ../u-boot.bin -spi ../u-boot-spi.bin
--- u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p1020rdb_667M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p1020rdb_667M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,45 @@
+40:424f4f54
+44:00000000
+48:00080000
+4c:00000000
+50:00001000
+54:00000000
+58:11000000
+5c:00000000
+60:1107F000
+64:00000000
+68:00000011
+
+80:ff702110
+84:43080000
+88:ff702000
+8c:0000001f
+90:ff702080
+94:80014202
+98:ff702100
+9c:00030000
+a0:ff702104
+a4:55770802
+a8:ff702108
+ac:5f599543
+b0:ff70210c
+b4:0fa074d1
+b8:ff702114
+bc:24401000
+c0:ff702118
+c4:00040852
+c8:ff702124
+cc:0a280100
+d0:ff702130
+d4:02800000
+d8:40000001
+dc:00000100
+e0:ff702128
+e4:deadbeef
+e8:ff702110
+ec:c3080000
+f0:ff700C08
+f4:00000000
+f8:ff700D70
+fc:80F0001D
+100:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_800M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_800M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00020000
+0a0:ff702104
+0a4:00330004
+0a8:ff702108
+0ac:6f6b4644
+0b0:ff70210c
+0b4:0fa888cf
+0b8:ff702114
+0bc:04401000
+0c0:ff702118
+0c4:40461520
+0c8:ff70211c
+0cc:8000c000
+0d0:ff702124
+0d4:0c300100
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:03000000
+0e8:ff702160
+0ec:00000001
+0f0:ff702164
+0f4:03402400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8655a608
+108:ff702148
+10c:00000000
+110:ff702110
+114:c70c0000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+130:efefefef
--- u-boot-2011.03/boot_format-20110419/boot_format.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/boot_format.h	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * Author: Chen Gong
+ * 	   Mingkai Hu <Mingiak.hu@freescale.com>
+ *
+ * This file is used for putting config words and U-Boot image to SDCard
+ * when boot from SDCard, or to SPI image when boot from SPI flash. This
+ * code puts the config words into the 1st partition, so please ensure
+ * the size is enough on the 1st partition.
+ *
+ * NOTE: DON'T support FAT12 (it looks obsolete)
+ *       DON'T support 64bit machine (it looks not necessary)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define CONFIG_REV_SPACE 0
+
+/**
+ * MMC/SD card bootup application code utility
+ *
+ * This application implements writing the bootup code to MMC/SD cards.
+ *
+ * It contains
+ *  Offset     Data Bits [0:31]
+ * 0x00-0x3F   Reserved
+ * 0x40-0x43   BOOT signature. This location should contain the value 0x424f_4f54,
+ * 0x44-0x47   Reserved
+ * 0x48-0x4B   User's code length. Number of bytes in the user's code to be copied.
+ *             It must be a multiple of the SD/MMC cards block size, It <= 2GBytes.
+ * 0x4C-0x4F   Reserved
+ * 0x50-0x53   Source Address. Contains the starting address of the user's code
+ *             as an offset from the SD/MMC card starting address. In Standard
+ *             Capacity SD/MMC Cards, it specifies the memory address in byte
+ *             address format. This must be a multiple of the SD/MMC cards block
+ *             size. In High Capacity SD/MMC Cards (>2GByte), the Address specifies
+ *             the memory address in block address format. Block length is fixed
+ *             to 512 bytes as per the SD High Capacity specification.
+ * 0x54-0x57   Reserved
+ * 0x58-0x5B   Target Address. Contains the target address in the system's local
+ *             memory address space in which the user's code will be copied to.
+ * 0x5C-0x5F   Reserved
+ * 0x60-0x63   Execution Starting Address. Contains the jump address in the
+ *             system's local memory address space into the user's code first
+ *             instruction to be executed.
+ * 0x64-0x67   Reserved
+ * 0x68-0x6B   N. Number of Configuration Address/Data pairs. Must be 1<=N<=1024
+ * 0x6C-0x7F   Reserved
+ * 0x80-0x83   Configuration Address 1
+ * 0x84-0x87   Configuration Data 1
+ * 0x88-0x8B   Configuration Address 2
+ * 0x8C-0x8F   Configuration Data 2
+ *  ...
+ * 0x80 + 8*(N-1) Configuration Address N
+ * 0x80 + 8*(N-1)+4  Configuration Data N
+ * ...
+ * User's Code
+ *
+ * NOTE: N <= 40 (Offset can be from first page up to 24th page in a 512 block)
+ */
+
+#ifdef DEBUG
+	#define debug(fmt, arg...) printf(fmt, ##arg)
+#else
+	#define debug(fmt, arg...)
+#endif
+
+#define BOOT_IMAGE_LEN_OFF	0x48
+#define BOOT_IMAGE_ADDR_OFF	0x50
+#define BOOT_MAX_CONFIG_WORDS   64
+
+#define BOOT_WORK_MODE_SD	0x1
+#define BOOT_WORK_MODE_SPI	0x2
+#define BOOT_REV_SPACE		0	/* Reserve spave for Env variabls */
+
+#define MBR_DPT_OFF	0x1be
+#define SECTOR_SIZE	512
+#define SEC_TO_BYTE(x)	((x) * SECTOR_SIZE)
+#define FSTYPE_FAT16	0
+#define FSTYPE_FAT32	1
+#define FAT32_BOUNDARYUNIT   8192
+#define EXFAT_BOUNDARYUNIT   32768
+
+#define LITTLE_ENDIAN_MODE	0
+#define BIG_ENDIAN_MODE		1
+
+#define uchar	unsigned char
+#define ushort	unsigned short
+#define uint	unsigned int
+
+#define MSG_OPEN_FILE_FAIL "Fail to open file \"%s\". Pls check whether it " \
+			   "exists and verify your permission.\n"
+
+#define MSG_READ_FILE_FAIL "Fail to read file \"%s\". Pls check whether it " \
+			   "exists and verify your read permission.\n"
+
+#define MSG_WRITE_FILE_FAIL "Fail to write file \"%s\". Pls check whether it "\
+			    "exists and verify your write permission.\n"
+
+#define MSG_SIGNATURE_FAIL "Fail to find MBR/DBR. Pls check whether the card "\
+			    "is formatted correctly\n"
+
+#define MSG_PARTLENGTH_FAIL "Partition is too small to save the user code. "\
+			    "Pls re-partition it again\n"
+
+#define DELIMITER	':'
+#define RET_FLG1	'\r'
+#define RET_FLG2	'\n'
+
+#define SWAP16(x) ((((x) & 0x00ff) << 8) | (((x) & 0xff00) >> 8))
+
+#define SWAP32(x) ((((x) & 0x000000ff) << 24) | \
+		   (((x) & 0x0000ff00) << 8)  | \
+		   (((x) & 0x00ff0000) >> 8)  | \
+		   (((x) & 0xff000000) >> 24))
+
+struct config_word {
+	uint off; /* if off = 0 means config word ends */
+	uint val;
+};
+
+#pragma pack(1)
+struct mbr_disk_part_tbl {
+	uchar	boot_ind;	/* Current state of partition (00h=Inactive, 80h=Active) */
+	uchar	start_head;	/* CHS address of first block in partition - Head */
+	ushort	start_cylsec;	/* CHS address of first block in partition - Cylinder/Sector
+			      		15 14 13 12 11 10 9 8 | 7 6      | 5 4 3 2 1 0
+			      		Cylinder Bits 7 to 0  | Cylinder | Sector Bits 5 to 0
+			      		                      | Bits9+8  |                    */
+	uchar	part_type;	/* Type of Partition
+					Value	Description
+					00h	Unknown or Nothing
+				 	01h	12-bit FAT
+					04h	16-bit FAT (Partition Smaller than 32MB)
+					05h	Extended MS-DOS Partition
+					06h	16-bit FAT (Partition Larger than 32MB)
+					0Bh	32-bit FAT (Partition Up to 2048GB)
+					0Ch	Same as 0BH, but uses LBA1 13h Extensions
+					0Eh	Same as 06H, but uses LBA1 13h Extensions
+					0Fh	Same as 05H, but uses LBA1 13h Extensions */
+	uchar	end_head;	/* CHS address of last block in partition - Head*/
+	ushort	end_cylsec;	/* CHS address of first block in partition - Cylinder/Sector */
+	uint	rel_sectors;	/* LBA of first sector in the partition */
+	uint	total_sectors;	/* Number of sectors in the partition */
+};
+
+/*
+ * BIOS Parameter Block
+ *
+ * BPB is a data structure in the Volume Boot Record describing the physical
+ * layout of a data storage volume. A basic BPB can appear and be used on any
+ * partition, however, certain filesystems also make use of it in describing
+ * basic filesystem structures. Filesystems making use of a BIOS parameter
+ * block include FAT16, FAT32, HPFS, and NTFS.
+ */
+struct bpb {
+	ushort	sector_size;		/* 0x0B: Byte Per Sector - must be one of 512, 1024, 2048, 4096 */
+	uchar	sectors_p_cluster;	/* 0x0D: Sectors Per Cluster - must be one of 1, 2, 4, 8, 16, 32, 64, 128 */
+	ushort	reserved_sectors;	/* 0x0E: Number of reserved sectors, FAT16 = 1. FAT32 = 32 */
+	uchar	fat_copys;		/* 0x10: Number of FAT copies - 1 or 2 */
+	ushort	root_entries;		/* 0x11: Number of root directory entries.
+						0 for FAT32(that means FAT32 doesn't use this field).
+						512 is recommended for FAT16i */
+	ushort	small_sectors;		/* 0x13: Number of small sectors
+						FAT32: must be 0
+						FAT16: in case the partition is not FAT32 and smaller than 32 MB */
+	uchar	media_type;		/* 0x15: f0: 1.4 MB floppy, f8: hard disk */
+	ushort	sectors_p_fat;		/* 0x16: Number of sectors per FAT. 0 for FAT32 */
+	ushort	sector_p_track;		/* 0x18: Number of sectors per track */
+	ushort	heads;			/* 0x1A: Number of heads */
+	uint	hidden_sectors;		/* 0x1C: Number of hidden sectors */
+	uint	large_sectors;		/* 0x20: in case the partition is FAT32 or larger than 32 MB */
+};
+
+/* Extended BPB */
+struct ext_bpb {
+	uchar	phy_disk_num;		/* Physical drive number */
+	uchar	res;
+	uchar	ext_boot_signature;	/* Extended boot signature. It must be 0x28 or 0x29 */
+	uint	vol;			/* Serial number of partition */
+	uchar	vol_label[11];
+	char	fs_type[8];		/* Filesystem type (E.g. "FAT32 ", "FAT16 ", or all zero.) */
+};
+
+struct ext_bpb_fat32 {
+	uint	sectors_p_fat;		/* 0x24: Sectors per FAT. Only used for FAT32 */
+	ushort	ext_flag;		/* Bits 0-3: number of active FAT (if bit 7 is 1)
+						Bits 4-6: reserveds
+						Bit 7: one: single active FAT; zero: all FATs are updated at runtimes
+						Bits 8-15: reserved */
+	ushort	fs_version;		/* Filesystem version */
+	uint	root_cluster;		/* First cluster of root directory (usually 2) */
+	ushort	fs_info;		/* Filesystem information sector number in reserved area (usually 1) */
+	ushort	backup_boot_sector;	/* Backup boot sector location: 0 or 0xffff if none (usually 6) */
+	char	res[12];
+};
+
+struct boot_sector {
+	uchar	jmp_code[3];
+	char	oem[8];
+	struct	bpb bpb;
+	union {
+		struct bpb16 {
+			struct ext_bpb ext_bpb;
+		}fat16;
+		struct bpb32 {
+			struct ext_bpb_fat32 ext;
+			struct ext_bpb ext_bpb;
+		}fat32;
+	};
+};
+#pragma pack()
--- u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p2020rdb_800M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p2020rdb_800M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,45 @@
+40:424f4f54
+44:00000000
+48:00080000
+4c:00000000
+50:00001000
+54:00000000
+58:11000000
+5c:00000000
+60:1107F000
+64:00000000
+68:00000011
+
+80:ff702110
+84:43000000
+88:ff702000
+8c:0000003f
+90:ff702080
+94:80014202
+98:ff702100
+9c:00040000
+a0:ff702104
+a4:00770802
+a8:ff702108
+ac:6f6b6543
+b0:ff70210c
+b4:0fa074d1
+b8:ff702114
+bc:24401000
+c0:ff702118
+c4:00040852
+c8:ff702124
+cc:0c300100
+d0:ff702130
+d4:02800000
+d8:40000001
+dc:00000100
+e0:ff702128
+e4:deadbeef
+e8:ff702110
+ec:c3000000
+f0:ff700C08
+f4:00000000
+f8:ff700D70
+fc:80F0001D
+100:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_T15.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_T15.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00050000
+0a0:ff702104
+0a4:00330004
+0a8:ff702108
+0ac:6f6bA644
+0b0:ff70210c
+0b4:0fa888cf
+0b8:ff702114
+0bc:04401000
+0c0:ff702118
+0c4:40461520
+0c8:ff70211c
+0cc:8080c000
+0d0:ff702124
+0d4:08201B4A
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:02800000
+0e8:ff702160
+0ec:00000001
+0f0:ff702164
+0f4:03402400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8655a605
+108:ff702148
+10c:00000000
+110:ff702110
+114:c70c0000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+130:efefefef
--- u-boot-2011.03/boot_format-20110419/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/Makefile	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,77 @@
+#
+# Copyright (C) 2009 Freescale Semiconductor, Inc.
+#
+# Author: Chen Gong
+# 	  Mingkai Hu <Mingkai.hu@freescale.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+OBJTARGET = boot_format
+
+DEBUG := 0
+
+# This is the prefix that will be used for almost all directories below.
+PREFIX := /usr/local
+
+CC = $(CROSS_COMPILE)gcc
+LD = $(CROSS_COMPILE)gcc
+
+# LDFLAGS = -v -fno-builtin -static  --cref,-Map,$@.map
+
+# Set flags to add preprocessor or compiler flags
+CFLAGS := -m32
+LDFLAGS := -m32
+
+# Determine the default compiler flags
+# Set CFLAGS above to add your own flags to all.
+ALL_CFLAGS := -Wall -I.
+ALL_LDFLAGS :=
+
+ifeq ($(DEBUG),1)
+ALL_CFLAGS += -DDEBUG;
+ALL_CFLAGS += -O -g
+else
+ALL_CFLAGS += -O2
+endif
+
+ALL_CFLAGS += $(CFLAGS)
+ALL_LDFLAGS += $(LDFLAGS)
+
+OBJS = boot_format.o
+
+.PHONY: all install clean $(OBJTARGET)
+
+ALL = $(OBJTARGET)
+
+all: $(ALL)
+
+$(OBJTARGET): $(OBJS)
+	$(LD) $(ALL_LDFLAGS) $(OBJS) -o $(OBJTARGET)
+
+install:
+	install -d $(PREFIX)/boot_format/
+	install boot_format $(PREFIX)/boot_format/
+	install -m 644 config_*.dat $(PREFIX)/boot_format/
+
+clean:
+	@rm -f *.dasm *.obj *.bin *.src *.o xref.txt $(OBJTARGET)
+
+%.o: %.c
+	$(CC) $(ALL_CFLAGS) -c $< -o $@
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1_p2_rdb_pc.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1_p2_rdb_pc.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,54 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00020000
+0a0:ff702104
+0a4:00330004
+0a8:ff702108
+0ac:6f6b4846
+0b0:ff70210c
+0b4:0fa8c8cf
+0b8:ff702114
+0bc:04401040
+0c0:ff702118
+0c4:40461520
+0c8:ff702124
+0cc:0c300000
+0d0:ff702128
+0d4:deadbeef
+0d8:ff702130
+0dc:03000000
+0e0:ff702160
+0e4:00440001
+0e8:ff702164
+0ec:03402400
+0f0:ff70211c
+0f4:04000000
+0f8:ff702008
+0fc:00000000
+100:ff702084
+104:80014202
+108:40000001
+10c:00000100
+110:ff702110
+114:c70c0000
+118:ff700C08
+11c:00000000
+120:ff700C10
+124:80f0001e
+128:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_64bit_p2020rdb_pc.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_64bit_p2020rdb_pc.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014202
+098:ff702100
+09c:00020000
+0a0:ff702104
+0a4:00330104
+0a8:ff702108
+0ac:6f6b4644
+0b0:ff70210c
+0b4:0fa88ccf
+0b8:ff702114
+0bc:24401000
+0c0:ff702118
+0c4:00421422
+0c8:ff70211c
+0cc:04000000
+0d0:ff702124
+0d4:0c300100
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:02000000
+0e8:ff702160
+0ec:00220001
+0f0:ff702164
+0f4:02401400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8655a608
+108:ff702148
+10c:00000000
+110:ff702110
+114:c7000000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+128:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_2gb_p1010rdb_667M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_2gb_p1010rdb_667M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00010000
+0a0:ff702104
+0a4:00110004
+0a8:ff702108
+0ac:5d59e544
+0b0:ff70210c
+0b4:0fa890cd
+0b8:ff702114
+0bc:04401000
+0c0:ff702118
+0c4:00441210
+0c8:ff70211c
+0cc:00000000
+0d0:ff702124
+0d4:0a280000
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:03000000
+0e8:ff702160
+0ec:00000001
+0f0:ff702164
+0f4:03402400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8675f608
+108:ff702148
+10c:00000000
+110:ff702110
+114:c70c0000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+130:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1014rdb_667M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1014rdb_667M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000001f
+090:ff702080
+094:80014302
+098:ff702100
+09c:00010000
+0a0:ff702104
+0a4:00110004
+0a8:ff702108
+0ac:5d59e544
+0b0:ff70210c
+0b4:0fa890cd
+0b8:ff702114
+0bc:04401000
+0c0:ff702118
+0c4:00441210
+0c8:ff70211c
+0cc:00000000
+0d0:ff702124
+0d4:0a280000
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:03000000
+0e8:ff702160
+0ec:00000001
+0f0:ff702164
+0f4:03402400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8675f608
+108:ff702148
+10c:00000000
+110:ff702110
+114:c7140000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+130:efefefef
--- u-boot-2011.03/boot_format-20110419/config_ddr3_2gb_p1022ds.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_2gb_p1022ds.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,55 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+
+080:ff702110
+084:47000008
+088:ff702000
+08c:0000003f
+090:ff702080
+094:80014202
+098:ff702100
+09c:00010000
+0a0:ff702104
+0a4:40330104
+0a8:ff702108
+0ac:5c5bd746
+0b0:ff70210c
+0b4:0fa8d4ca
+0b8:ff702114
+0bc:24401041
+0c0:ff702118
+0c4:00021221
+0c8:ff702124
+0cc:0a280100
+0d0:ff702128
+0d4:deadbeef
+0d8:ff702130
+0dc:02800000
+0e0:ff702160
+0e4:00220001
+0e8:ff702164
+0ec:02401400
+0f0:ff70211c
+0f4:00000000
+0f8:ff702008
+0fc:0040007f
+100:ff702084
+104:80014202
+108:40000001
+10c:00000100
+110:ff702110
+114:c7000008
+118:ff700C08
+11c:00000000
+120:ff700C10
+124:80f0001e
+128:efefefef
--- u-boot-2011.03/boot_format-20110419/boot_format.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/boot_format.c	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,807 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * Author: Chen Gong
+ * 	   Mingkai Hu <Mingiak.hu@freescale.com>
+ *     Jimmy Zhao <jimmy.zhao@freescale.com>
+ *  Rev: 1.0    Initial release
+ *       1.1:   Bug fix for generating SPI image
+ *              All the source code offset is byte mode instead of block mode
+ *
+ * This file is used for putting config words and U-Boot image to SDCard
+ * when boot from SDCard, or to SPI image when boot from SPI flash. This
+ * code puts the config words into the 1st partition, so please ensure
+ * the size is enough on the 1st partition.
+ *
+ * NOTE: DON'T support FAT12 (it looks obsolete)
+ *       DON'T support 64bit machine (it looks not necessary)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#define _LARGEFILE64_SOURCE
+#define _GNU_SOURCE
+#define DEBUG 1
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <errno.h>
+#include "boot_format.h"
+
+/*
+ * Print data buffer in hex and ascii form to the terminal.
+ *
+ * parameters:
+ *    data: pointer to data buffer
+ *    len: data length
+ *    width: data value width.  May be 1, 2, or 4.
+ */
+static void print_buf(void *data, uint len, uint width)
+{
+#ifdef DEBUG
+	uint i;
+	uint *uip = (uint *)data;
+	ushort *usp = (ushort *)data;
+	uchar *ucp = (uchar *)data;
+
+	debug("\n");
+	for (i = 0; i < len/width; i++) {
+		if ((i % (16/width)) == 0)
+			debug("0x%04x:", i);
+
+		if (width == 4)
+			debug(" %08x", uip[i]);
+		else if (width == 2)
+			debug(" %04x", usp[i]);
+		else
+			debug(" %02x", ucp[i]);
+
+		if (((i+1) % (16/width)) == 0)
+			debug("\n");
+	}
+	debug("\n");
+#endif
+}
+
+static void print_mbr(struct mbr_disk_part_tbl *mbr_dpt)
+{
+#ifdef DEBUG
+	debug("\n================== MBR ==================\n");
+	debug("boot_ind		= 0x%x\n", mbr_dpt->boot_ind);
+	debug("start_head	= 0x%x\n", mbr_dpt->start_head);
+	debug("start_cylesec	= 0x%x\n", mbr_dpt->start_cylsec);
+	debug("part_type	= 0x%x\n", mbr_dpt->part_type);
+	debug("end_head		= 0x%x\n", mbr_dpt->end_head);
+	debug("end_cylsec	= 0x%x\n", mbr_dpt->end_cylsec);
+	debug("rel_sectors	= 0x%x\n", mbr_dpt->rel_sectors);
+	debug("total_sectors	= 0x%x\n", mbr_dpt->total_sectors);
+	debug("=========================================\n");
+#endif
+}
+
+static void print_dbr(struct boot_sector *dbr)
+{
+#ifdef DEBUG
+	debug("\n================== DBR ==================\n");
+	debug("jmp_code[0]	= 0x%x\n", dbr->jmp_code[0]);
+
+	debug("\n");
+	debug("sector_size	= 0x%x\n", dbr->bpb.sector_size);
+	debug("root_entries	= 0x%x\n", dbr->bpb.root_entries);
+	debug("small_sector	= 0x%x\n", dbr->bpb.small_sectors);
+	debug("sectors_p_fat	= 0x%x\n", dbr->bpb.sectors_p_fat);
+	debug("=========================================\n");
+#endif
+}
+
+static uint get_endian_mode(void)
+{
+	ushort us = 0x1122;
+	uchar uc = *(uchar *)&us;
+	if (uc == 0x11)
+		return BIG_ENDIAN_MODE;
+	else
+		return LITTLE_ENDIAN_MODE;
+}
+
+static void swap_mbr(struct mbr_disk_part_tbl *mbr_dpt)
+{
+	mbr_dpt->start_cylsec = SWAP16(mbr_dpt->start_cylsec);
+	mbr_dpt->end_cylsec = SWAP16(mbr_dpt->end_cylsec);
+	mbr_dpt->rel_sectors = SWAP32(mbr_dpt->rel_sectors);
+	mbr_dpt->total_sectors = SWAP32(mbr_dpt->total_sectors);
+}
+
+static void swap_dbr(struct boot_sector *dbr)
+{
+	dbr->bpb.sector_size = SWAP16(dbr->bpb.sector_size);
+	dbr->bpb.reserved_sectors = SWAP16(dbr->bpb.reserved_sectors);
+	dbr->bpb.root_entries = SWAP16(dbr->bpb.root_entries);
+	dbr->bpb.small_sectors = SWAP16(dbr->bpb.small_sectors);
+	dbr->bpb.sectors_p_fat = SWAP16(dbr->bpb.sectors_p_fat);
+	dbr->bpb.sector_p_track = SWAP16(dbr->bpb.sector_p_track);
+	dbr->bpb.heads = SWAP16(dbr->bpb.heads);
+	dbr->bpb.hidden_sectors = SWAP32(dbr->bpb.hidden_sectors);
+	dbr->bpb.large_sectors = SWAP32(dbr->bpb.large_sectors);
+
+	dbr->fat16.ext_bpb.vol = SWAP32(dbr->fat16.ext_bpb.vol);
+
+	dbr->fat32.ext.ext_flag = SWAP16(dbr->fat32.ext.ext_flag);
+	dbr->fat32.ext.fs_version = SWAP16(dbr->fat32.ext.fs_version);
+	dbr->fat32.ext.root_cluster = SWAP32(dbr->fat32.ext.root_cluster);
+	dbr->fat32.ext.fs_info = SWAP16(dbr->fat32.ext.fs_info);
+	dbr->fat32.ext.backup_boot_sector =
+		SWAP16(dbr->fat32.ext.backup_boot_sector);
+}
+
+static inline ushort cylsec_to_sec(ushort cylsec)
+{
+	return cylsec & 0x3F;
+}
+
+static inline ushort cylsec_to_cyl(ushort cylsec)
+{
+	return ((cylsec & 0xC0) << 2) | ((cylsec & 0xFF00) >> 8);
+}
+
+static inline ushort back_to_cylsec(ushort sec, ushort cyl)
+{
+    return ((sec & 0x3F) || ((cyl & 0x300)>> 2) || ((cyl & 0xFF)<<8));
+}
+
+/* NOTE: some formatted card hasn't MBR, only DBR */
+static void parse_mbr(char *sd_data, struct mbr_disk_part_tbl **mbr)
+{
+	ushort cylsec, start_cyl;
+	uchar start_sec;
+	struct mbr_disk_part_tbl *mbr_dpt;
+
+    mbr_dpt = (struct mbr_disk_part_tbl *)(sd_data + MBR_DPT_OFF); //Partition Table
+	if (get_endian_mode() == BIG_ENDIAN_MODE)
+		swap_mbr(mbr_dpt);
+	print_mbr(mbr_dpt);
+
+	/* Check if it is a MBR */
+	cylsec = mbr_dpt->start_cylsec;
+	start_sec = cylsec_to_sec(cylsec);
+	start_cyl = cylsec_to_cyl(cylsec);
+
+	if (mbr_dpt->part_type == 0 ||
+	    (mbr_dpt->boot_ind != 0 && mbr_dpt->boot_ind != 0x80) ||
+/*-----------------8/12/2010 10:28AM----------------
+ * The start head does not necessary to be the 1st
+ * --------------------------------------------------*/
+//       mbr_dpt->start_head != 1 ||
+//       start_sec != 1 ||
+//       start_cyl != 0 ||
+	    mbr_dpt->end_head < mbr_dpt->start_head ||
+	    mbr_dpt->total_sectors < mbr_dpt->rel_sectors) {
+		*mbr = NULL;
+		debug("It is not a valid MBR.\n");
+	} else {
+		*mbr = mbr_dpt;
+		debug("It is a valid MBR\n");
+	}
+}
+
+static int parse_dbr(struct boot_sector *dbr)
+{
+	print_dbr(dbr);
+
+	if (dbr->jmp_code[0] != 0xEB || dbr->bpb.sector_size != SECTOR_SIZE)
+		return 1;
+	else
+		return 0;
+}
+
+static void write_config_file(char *out, int num, struct config_word *pword[])
+{
+	struct stat sb;
+	int h_config, i, n;
+	char buf[20];
+
+	stat(out, &sb);
+	if ((errno == ENOENT) || S_ISREG(sb.st_mode)) {
+		h_config = open(out, O_WRONLY|O_CREAT|O_TRUNC, 0666);
+		if (h_config == 0) {
+			printf(MSG_OPEN_FILE_FAIL, out);
+			return;
+		}
+		for (i = 0; i < num; i++) {
+			n = sprintf(buf, "%02x:%08x\n",
+					pword[i]->off, pword[i]->val);
+			write(h_config, buf, n);
+		}
+		close(h_config);
+	}
+}
+
+/* FIXME: the 1st line of the config file can't be a blank line */
+static int parse_config_file(char *config_data, int config_len,
+			struct config_word *word[])
+{
+	int i = 0, newline = 1;
+	char *tmp = config_data;
+
+	while (tmp < (config_data + config_len)) {
+		if (newline == 1) {
+			word[i++] = (struct config_word *)tmp;
+			newline = 0;
+		}
+
+		if ((*tmp == RET_FLG1) || (*tmp == RET_FLG2)) {
+			do {
+				*tmp++ = '\0';
+			} while ((*tmp == RET_FLG1) || (*tmp == RET_FLG2));
+
+			newline = 1;
+		} else
+			tmp++;
+
+		/* if overflow, just ignore left data */
+		if (i >= BOOT_MAX_CONFIG_WORDS)
+			break;
+	}
+
+	config_len = i;
+	for (i = 0; i < config_len; i++) {
+		config_data = (char *)word[i];
+		tmp = config_data;
+		word[i] = malloc(sizeof(struct config_word));
+
+		while (*tmp++ != DELIMITER) ;
+			*(tmp - 1) = '\0';
+
+		word[i]->off = strtoul(config_data, (char **)NULL, 16);
+		word[i]->val = strtoul(tmp, (char **)NULL, 16);
+	}
+
+	return config_len;
+}
+
+/*
+ * NOTE: partition can't cross cylinder
+ * sectors per cylinder = heads * (sectors per track)
+ * though heads can be 256, but because of limits of address registers in ASM,
+ * heads offten is 255.
+ * e.g. if heads = 255, sectors per track = 63
+ * sectors per cylinder = 16065(255 * 63)
+ *
+ * to 1st partition, which sectors amount equals total sectors + hidden sectors
+ *
+ * if left space in the 1st partition is enough to save user code, that's
+ * perfect, or related items in MBR/DBR tables must be fixed to exclude
+ * the space that is used by user code
+ * return: 0 -- normal capacity
+ *         1 -- high capacity
+ *         negtive -- error
+ */
+static uint adjust_partition_table(struct mbr_disk_part_tbl *mbr, struct boot_sector *pdbr,
+		int sectors, int *high_cap)
+{
+    uint cyl_secs, left_sec, total_sec, hidden_sec, extra, bu;
+    ushort start_sec, start_cyl;
+    int off, shrink_secs, i;
+
+	cyl_secs = pdbr->bpb.sector_p_track * pdbr->bpb.heads;
+	total_sec = pdbr->bpb.small_sectors;
+	if (total_sec == 0) /* partitions > 32M */
+		total_sec = pdbr->bpb.large_sectors;
+	hidden_sec = pdbr->bpb.hidden_sectors;
+
+	/* check whether 1st partition is enough big, maybe not needed */
+	if (total_sec < sectors)
+		goto bad;
+
+	/*
+	 * whether the card is a high capacity card. The judge standard
+	 * is the capacity whether or not is more than 2G
+     * JZ: For card less than 2GB, the data will pending on the end of the partition
+     *     For card > 2GB, need to put at the ahead of the Boot sector
+     *     Therefore, the start head, cylinder/sec need to be changed
+     *     However, the ending head & cylinder/sec is the same
+	 */
+    if (total_sec / ( 2 * 1024) > 2048) {  // (2 GB < Partition <= 32 GB)
+		*high_cap = 1;
+        off = 9; //Set to 9 See Figure 4-2 of File System Spec.
+        bu = FAT32_BOUNDARYUNIT;
+/*        if (total_sec / ( 2 * 1024) > 32768) {    // (32 GB < Partition < 2 TB)
+           *high_cap = 2;
+           off = 24; //Set to 24 See Figure 5-2 of File System Spec.
+           bu = EXFAT_BOUNDARYUNIT;
+        }
+ */
+        sectors += off;
+        if (hidden_sec < sectors) {
+            for ( i = 1; i< 32; i++) {
+                if (sectors < i*bu)   //Need to keep BU
+                   break;
+            }
+            if (i == 32) //boot image is too large. The limit size is 128 MB ( 1 byte)
+                 goto bad;
+            hidden_sec = i*bu;
+            extra = hidden_sec - mbr->rel_sectors;
+            debug("new/old hidden_sec %d/%d, difference %d, rel_sectors %d",
+                   hidden_sec, pdbr->bpb.hidden_sectors, extra, mbr->rel_sectors );
+            start_sec = (hidden_sec % pdbr->bpb.sector_p_track ) + 1;
+            start_cyl = hidden_sec / cyl_secs;
+            mbr->start_head = (uchar) (hidden_sec % cyl_secs)/ pdbr->bpb.sector_p_track;
+            mbr->start_cylsec = back_to_cylsec (start_sec, start_cyl);
+            mbr->rel_sectors = hidden_sec;
+            mbr->total_sectors = total_sec - extra;
+            debug("start_secotr %d, start_cyl %d, cylsec %x, start_head %d",
+                   start_sec, start_cyl, mbr->start_cylsec, mbr->start_head);
+
+            pdbr->bpb.hidden_sectors = hidden_sec;
+
+        }
+
+    }
+    else {              //partition <= 2 GB
+        *high_cap = 0;
+
+        /* check left sectors whether to save user code */
+        left_sec = (total_sec + hidden_sec) % cyl_secs;
+        off = total_sec + hidden_sec - left_sec;
+        shrink_secs = sectors - left_sec;
+
+        /*
+         * if shrink_secs <= 0, which means left space is enough large to
+         * save the user code + reserved space
+         */
+        if (shrink_secs <= 0)
+            goto end;
+
+        /* don't worry about the problem that crosses the cylinder */
+        total_sec -= shrink_secs;
+        off -= shrink_secs;
+
+        if (pdbr->bpb.small_sectors == 0)
+            pdbr->bpb.large_sectors = total_sec;
+        else
+            pdbr->bpb.small_sectors = total_sec;
+    }
+
+    if (mbr != NULL)
+        mbr->total_sectors = total_sec;
+
+end:
+	return off;
+bad:
+	return (uint)-1;
+}
+
+int main(int argc, char *argv[])
+{
+	int h_dev, h_spi_dev = 0, h_sd_dev = 0, h_config = 0, h_usercode = 0;
+	char *cfg_data_buf = NULL, *usercode_buf = NULL;
+	char *mbr_buf = NULL, *boot_sect_buf = NULL;
+	char p_configname[256], p_usercodename[256], p_devname[256];
+	struct mbr_disk_part_tbl *mbr_dpt = NULL;
+	struct boot_sector *boot_sector = NULL;
+	struct config_word *pconfig_word[BOOT_MAX_CONFIG_WORDS];
+	int exitcode = 0, h_cap, code_addr = 0, work_mode = 0;
+	uint i, n, config_num = 0, len, sec_user, rev_space = BOOT_REV_SPACE;
+	uchar *ptr = NULL;
+	struct stat sb;
+	int opt = 0;
+	uint endian_mode;
+	uint rel_sectors = 0;
+	struct option longopts[] = {
+		{"sd", required_argument, NULL, 'd'},
+		{"spi", required_argument, NULL, 'p'},
+		{"o", required_argument, NULL, 'o'},
+		{"r", required_argument, NULL, 'r'},
+		{0, 0, 0, 0},
+	};
+
+	memset(pconfig_word, 0, sizeof(struct config_word *) *
+			BOOT_MAX_CONFIG_WORDS);
+	if (argc < 5) {
+		printf("Usage: %s config_file image -sd dev [-o out_config]"
+			" | -spi spiimage", argv[0]);
+#if CONFIG_REV_SPACE
+		printf(" [-r size]");
+#endif
+		printf("\n");
+		printf("\n\tconfig_file : includes boot signature and config words");
+		printf("\n\timage       : the U-Boot image for booting from eSDHC/eSPI");
+		printf("\n\tdev         : SDCard's device node(e.g. /dev/sdb, /dev/mmcblk0)");
+		printf("\n\tspiimage    : boot image for SPI mode");
+		printf("\n\tout_config  : modified config file for SD mode");
+#if CONFIG_REV_SPACE
+		printf("\n\tsize        : reserved space (default 0K).");
+#endif
+		printf("\n");
+		exitcode = -EINVAL;
+		goto end;
+	}
+
+	/* Endian mode */
+	endian_mode = get_endian_mode();
+	debug("It is a %s endian machine.\n",
+			endian_mode == BIG_ENDIAN_MODE ? "big" : "little");
+
+	memset(p_devname, 0, sizeof(p_devname));
+	strncpy(p_configname, argv[1], 255);
+	strncpy(p_usercodename, argv[2], 255);
+	while((n = getopt_long_only(argc, argv, "", longopts, NULL)) != -1) {
+		/*
+		 * if "sd" and "spi" flags are used together,
+		 * work_mode must be wrong !
+         * JZ: added print information for more than 1 option
+		 */
+        if (work_mode != 0)
+        {
+            printf("\n Only one option is allowed. work_mode: %d \n", work_mode);
+            goto end;
+        }
+
+		switch (n) {
+		case 'd':
+            work_mode |= BOOT_WORK_MODE_SD;
+			strncpy(p_devname, optarg, 255);
+			break;
+		case 'p':
+            work_mode |= BOOT_WORK_MODE_SPI;
+			strncpy(p_devname, optarg, 255);
+			break;
+		}
+	}
+
+	memset(&sb, 0, sizeof(struct stat));
+	stat(p_devname, &sb);
+	if (((work_mode == BOOT_WORK_MODE_SD) && !S_ISBLK(sb.st_mode)) ||
+	    ((work_mode == BOOT_WORK_MODE_SPI) &&
+			((errno != ENOENT) && !S_ISREG(sb.st_mode)))) {
+		exitcode = -EINVAL;
+		goto end;
+	}
+
+	if (work_mode == BOOT_WORK_MODE_SD) {
+		/* Open SD device */
+		h_sd_dev = open(p_devname, O_RDWR, 0666);
+		if (h_sd_dev == 0) {
+			printf(MSG_OPEN_FILE_FAIL, p_devname);
+			exitcode = -EIO;
+			goto end;
+		}
+
+		/* Read first sector from sd */
+		mbr_buf = (char*)malloc(SEC_TO_BYTE(1));
+		if (mbr_buf == NULL) {
+			exitcode = -ENOMEM;
+			goto end;
+		}
+
+		if (read(h_sd_dev, mbr_buf, SEC_TO_BYTE(1))
+				!= SEC_TO_BYTE(1)) {
+			printf(MSG_READ_FILE_FAIL, p_devname);
+			exitcode = -EIO;
+			goto end;
+		}
+		debug("Read MBR from SDCard:\n");
+		print_buf(mbr_buf, SEC_TO_BYTE(1), 1);
+
+		parse_mbr(mbr_buf, &mbr_dpt);
+		rel_sectors = mbr_dpt->rel_sectors;
+
+		/* Some formatted card hasn't MBR, only DBR */
+		if (mbr_dpt == NULL) {
+			boot_sect_buf = mbr_buf;
+			mbr_buf = NULL;
+			boot_sector = (struct boot_sector *)boot_sect_buf;
+		} else {
+			lseek(h_sd_dev, mbr_dpt->rel_sectors * SECTOR_SIZE,
+					SEEK_SET);
+			boot_sect_buf = (char*)malloc(SEC_TO_BYTE(1));
+			if (boot_sect_buf == NULL) {
+				exitcode = -ENOMEM;
+				goto end;
+			}
+			if (read(h_sd_dev, boot_sect_buf, SEC_TO_BYTE(1)) !=
+					SEC_TO_BYTE(1)) {
+				printf(MSG_READ_FILE_FAIL, p_devname);
+				exitcode = -EIO;
+				goto end;
+			}
+			debug("Read DBR from SDCard:\n");
+			print_buf(boot_sect_buf, SEC_TO_BYTE(1), 1);
+
+			boot_sector = (struct boot_sector *)boot_sect_buf;
+			if (endian_mode == BIG_ENDIAN_MODE)
+				swap_dbr(boot_sector);
+		}
+
+		/* Parse partition. NOTE: mbr_dpt maybe always be NULL */
+		if (parse_dbr(boot_sector) != 0) {
+			printf(MSG_SIGNATURE_FAIL);
+			exitcode = -EINVAL;
+			goto end;
+		}
+	} else {
+		h_spi_dev = open(p_devname, O_WRONLY|O_CREAT|O_TRUNC, 0666);
+		if (h_spi_dev == 0) {
+			printf(MSG_OPEN_FILE_FAIL, p_devname);
+			exitcode = -EIO;
+			goto end;
+		}
+	}
+
+	/* Open config file */
+	h_config = open(p_configname, O_RDONLY);
+	if (h_config == 0) {
+		printf(MSG_OPEN_FILE_FAIL, p_configname);
+		exitcode = -EIO;
+		goto end;
+	}
+
+	len = lseek(h_config, 0, SEEK_END);
+	lseek(h_config, 0, SEEK_SET);
+	cfg_data_buf = malloc(len);
+	if (cfg_data_buf == NULL) {
+		exitcode = -ENOMEM;
+		goto end;
+	}
+
+	if (read(h_config, cfg_data_buf, len) != len) {
+		printf(MSG_READ_FILE_FAIL, p_configname);
+		exitcode = -EIO;
+		goto end;
+	}
+
+	/* Parse config file */
+	config_num = parse_config_file(cfg_data_buf, len, pconfig_word);
+
+#if CONFIG_REV_SPACE
+	optind = 0;
+	while((opt = getopt_long_only(argc, argv, "", longopts, NULL)) != -1) {
+		if (opt == 'r')
+			rev_space = strtoul(optarg, (char**)NULL, 10) * 1024;
+	}
+#endif
+
+	/* Open user code file */
+	h_usercode = open(p_usercodename, O_RDONLY);
+	if (h_usercode == 0) {
+		printf(MSG_OPEN_FILE_FAIL, p_usercodename);
+		exitcode = -EIO;
+		goto end;
+	}
+
+	n = lseek(h_usercode, 0, SEEK_END);
+	lseek(h_usercode, 0, SEEK_SET);
+	len = (n + SECTOR_SIZE - 1) & ~(SECTOR_SIZE - 1);
+	usercode_buf = malloc(len);
+	if (usercode_buf == NULL) {
+		exitcode = -ENOMEM;
+		goto end;
+	}
+	if (read(h_usercode, usercode_buf, n) != n) {
+		printf(MSG_READ_FILE_FAIL, p_usercodename);
+		exitcode = -EIO;
+		goto end;
+	}
+
+	/* User code + Reserved space */
+	len += rev_space;
+	sec_user = len / SECTOR_SIZE;
+	for (i = 0; i < config_num; i++) {
+		if (pconfig_word[i]->off == BOOT_IMAGE_LEN_OFF) {
+			/* The length must align sector size */
+			pconfig_word[i]->val = len;
+			break;
+		}
+	}
+
+	if (work_mode == BOOT_WORK_MODE_SD) {
+		/* FIXME: don't support disk clean up */
+		n = adjust_partition_table(mbr_dpt, boot_sector,
+				sec_user, &h_cap);
+        rel_sectors = mbr_dpt->rel_sectors;
+    } else {
+		h_cap = 0;
+		n = 2; /* Start address of user code in SPI mode,  */
+	}
+
+	if (n == (uint)-1) {
+		printf(MSG_PARTLENGTH_FAIL);
+		exitcode = -EINVAL;
+		goto end;
+	}
+
+    /* Change config word[0x50] to final user code position
+     * JZ: Source address should be always byte mode*/
+	for (i = 0; i < config_num; i++) {
+		if (pconfig_word[i]->off == BOOT_IMAGE_ADDR_OFF) {
+			code_addr = i;
+            pconfig_word[i]->val = n * SECTOR_SIZE;
+			break;
+		}
+	}
+
+	/* Only in SD mode config file is supported to output */
+	optind = 0;
+	if (work_mode == BOOT_WORK_MODE_SD) {
+		while((opt = getopt_long_only(argc, argv, "", longopts, NULL))
+			!= -1) {
+			if (opt == 'o')
+				write_config_file(optarg, config_num,
+						pconfig_word);
+		}
+	}
+
+	/*
+	 * Write back all data to sd card/spi image.
+	 * NOTE: sequence is important, user code must be first because of
+         * config word byte swap.
+         */
+	if (work_mode == BOOT_WORK_MODE_SD)
+		h_dev = h_sd_dev;
+	else
+		h_dev = h_spi_dev;
+
+	/* Write user code to sd card */
+	debug("\nWriting image to %s...",
+		(work_mode == BOOT_WORK_MODE_SD) ? "SDCard" : "SPI image");
+	if (h_cap)
+		/*
+		 * For high-capacity card, the byte offset maybe beyond
+		 * 0xffffffff, so it has to move step by step
+         * JZ: The source address is byte mode now.
+		 */
+        lseek64(h_dev, (off64_t)pconfig_word[code_addr]->val,
+				SEEK_SET);
+	else
+		lseek(h_dev, pconfig_word[code_addr]->val, SEEK_SET);
+
+	len = SEC_TO_BYTE(sec_user) - rev_space;
+	ptr = (uchar *)usercode_buf;
+	while (len > 0) {
+		n = write(h_dev, ptr, len);
+		if (n < 0) {
+			printf(MSG_WRITE_FILE_FAIL, p_devname);
+			exitcode = -EIO;
+			goto end;
+		}
+		ptr += n;
+		len -= n;
+	}
+	debug("OK.\n");
+
+	if ((work_mode == BOOT_WORK_MODE_SPI)&& (rev_space != 0)) {
+		/* Extend file size to accomodate reserved space */
+		lseek(h_dev, rev_space - 1, SEEK_CUR);
+		write(h_dev, &n, 1);
+	}
+
+	lseek(h_dev, 0, SEEK_SET);
+	if (work_mode == BOOT_WORK_MODE_SD) {
+		/* Write config words to sd card in proper byte endian */
+		debug("\nWriting config words to MBR's buffer first...");
+		ptr = (uchar *)mbr_buf;
+		if (ptr == NULL)
+			ptr = (uchar *)boot_sect_buf;
+
+		for (i = 0; i < config_num; i++) {
+			n = pconfig_word[i]->val;
+			/* Config words are provided with big endian mode */
+			if (endian_mode == LITTLE_ENDIAN_MODE)
+				n = SWAP32(n);
+			*(int *)(ptr + pconfig_word[i]->off) = n;
+		}
+		debug("OK.\n");
+
+		/* Write MBR */
+		debug("\nWriting MBR to SDCard...");
+		len = SEC_TO_BYTE(1);
+		if (mbr_buf) {
+			ptr = (uchar *)(mbr_buf + MBR_DPT_OFF);
+			if (endian_mode == BIG_ENDIAN_MODE)
+				swap_mbr((struct mbr_disk_part_tbl *)ptr);
+			print_mbr((struct mbr_disk_part_tbl *)ptr);
+
+			ptr = (uchar *)mbr_buf;
+			print_buf(ptr, SEC_TO_BYTE(1), 1);
+			while (len > 0) {
+				n = write(h_dev, ptr, len);
+				if (n < 0) {
+					printf(MSG_WRITE_FILE_FAIL, p_devname);
+					exitcode = -EIO;
+				}
+				ptr += n;
+				len -= n;
+			}
+			lseek(h_dev, rel_sectors * SECTOR_SIZE,	SEEK_SET);
+		}
+		debug("OK.\n");
+
+		/* Write DBR */
+		debug("\nWriting DBR to SDCard...");
+		len = SEC_TO_BYTE(1);
+		if (boot_sect_buf) {
+			if (endian_mode == BIG_ENDIAN_MODE)
+				swap_dbr((struct boot_sector *)boot_sect_buf);
+			print_dbr((struct boot_sector *)boot_sect_buf);
+
+			ptr = (uchar *)boot_sect_buf;
+			print_buf(ptr, SEC_TO_BYTE(1), 1);
+			while (len > 0) {
+				n = write(h_dev, ptr, len);
+				if (n < 0) {
+					printf(MSG_WRITE_FILE_FAIL, p_devname);
+					exitcode = -EIO;
+				}
+				ptr += n;
+				len -= n;
+			}
+		}
+		debug("OK.\n");
+	} else {
+		uchar sector[SECTOR_SIZE];
+
+		memset(sector, 0, SECTOR_SIZE);
+		for (i = 0; i < config_num; i++) {
+			n = pconfig_word[i]->val;
+			/* Config words are provided with big endian mode */
+			if (endian_mode == LITTLE_ENDIAN_MODE)
+				n = SWAP32(n);
+			*(int *)(sector + pconfig_word[i]->off) = n;
+		}
+
+		debug("\nWriting config words to SPI image...");
+		len = SEC_TO_BYTE(1);
+		while (len > 0) {
+			ptr = (uchar *)sector;
+			n = write(h_dev, ptr, len);
+			if (n < 0) {
+				printf(MSG_WRITE_FILE_FAIL, p_devname);
+				exitcode = -EIO;
+			}
+			ptr += n;
+			len -= n;
+		}
+		debug("OK.\n");
+	}
+	sync();
+
+end:
+	for (i = 0; i < config_num; i++)
+		free(pconfig_word[i]);
+	free(boot_sect_buf);
+	free(mbr_buf);
+	free(cfg_data_buf);
+	free(usercode_buf);
+	if (h_usercode != 0)
+		close(h_usercode);
+	if (h_config != 0)
+		close(h_config);
+	if (h_sd_dev != 0)
+		close(h_sd_dev);
+	if (h_spi_dev != 0)
+		close(h_spi_dev);
+
+	if (exitcode == 0)
+		printf("Congratulations! It is done successfully.\n");
+
+	return exitcode;
+}
--- u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p2020rdb_667M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr2_1g_p2020rdb_667M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,45 @@
+40:424f4f54
+44:00000000
+48:00080000
+4c:00000000
+50:00001000
+54:00000000
+58:11000000
+5c:00000000
+60:1107F000
+64:00000000
+68:00000011
+
+80:ff702110
+84:43000000
+88:ff702000
+8c:0000003f
+90:ff702080
+94:80014202
+98:ff702100
+9c:00030000
+a0:ff702104
+a4:55770802
+a8:ff702108
+ac:5f599543
+b0:ff70210c
+b4:0fa074d1
+b8:ff702114
+bc:24401000
+c0:ff702118
+c4:00040852
+c8:ff702124
+cc:0a280100
+d0:ff702130
+d4:03000000
+d8:40000001
+dc:00000100
+e0:ff702128
+e4:deadbeef
+e8:ff702110
+ec:c3000000
+f0:ff700C08
+f4:00000000
+f8:ff700D70
+fc:80F0001D
+100:efefefef
--- u-boot-2011.03/boot_format-20110419/mkspi_p1010_fbx_t15.sh.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/mkspi_p1010_fbx_t15.sh	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1 @@
+./boot_format config_ddr3_1gb_p1010rdb_T15.dat ../u-boot.bin -spi ../u-boot-spi.bin
--- u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_667M.dat.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2011.03/boot_format-20110419/config_ddr3_1gb_p1010rdb_667M.dat	2022-05-09 14:05:11.392061542 -0700
@@ -0,0 +1,56 @@
+040:424f4f54
+044:00000000
+048:00080000
+04c:00000000
+050:00001000
+054:00000000
+058:11000000
+05c:00000000
+060:1107f000
+064:00000000
+068:00000016
+080:ff702110
+084:470c0000
+088:ff702000
+08c:0000001f
+090:ff702080
+094:80014202
+098:ff702100
+09c:00010000
+0a0:ff702104
+0a4:00110004
+0a8:ff702108
+0ac:5d59e544
+0b0:ff70210c
+0b4:0fa890cd
+0b8:ff702114
+0bc:04401000
+0c0:ff702118
+0c4:00441210
+0c8:ff70211c
+0cc:00000000
+0d0:ff702124
+0d4:0a280000
+0d8:ff702128
+0dc:deadbeef
+0e0:ff702130
+0e4:03000000
+0e8:ff702160
+0ec:00000001
+0f0:ff702164
+0f4:03402400
+0f8:ff702170
+0fc:89080600
+100:ff702174
+104:8675f608
+108:ff702148
+10c:00000000
+110:ff702110
+114:c70c0000
+118:ff700d68
+11c:00000000
+120:ff700d70
+124:80f0001d
+128:20000001
+12c:02000000
+130:efefefef
