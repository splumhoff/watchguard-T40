WatchGuard patches to sources for u-boot-2015.01 as of
Mon May  9 14:10:24 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- u-boot-2015.01/include/jffs2/load_kernel.h.orig	2022-05-09 14:09:45.860950712 -0700
+++ u-boot-2015.01/include/jffs2/load_kernel.h	2022-05-09 14:09:48.276852930 -0700
@@ -2,7 +2,7 @@
 #define load_kernel_h
 /*-------------------------------------------------------------------------
  * Filename:      load_kernel.h
- * Version:       $Id: load_kernel.h,v 1.3 2002/01/25 01:34:11 nyet Exp $
+ * Version:       $Id$
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   header for load kernel modules
--- u-boot-2015.01/include/jffs2/compr_rubin.h.orig	2022-05-09 14:09:45.856950874 -0700
+++ u-boot-2015.01/include/jffs2/compr_rubin.h	2022-05-09 14:09:48.272853092 -0700
@@ -1,7 +1,7 @@
 /* Rubin encoder/decoder header       */
 /* work started at   : aug   3, 1994  */
 /* last modification : aug  15, 1994  */
-/* $Id: compr_rubin.h,v 1.1 2002/01/16 23:34:32 nyet Exp $ */
+/* $Id$ */
 
 #define RUBIN_REG_SIZE   16
 #define UPPER_BIT_RUBIN    (((long) 1)<<(RUBIN_REG_SIZE-1))
--- u-boot-2015.01/include/jffs2/jffs2.h.orig	2022-05-09 14:09:45.856950874 -0700
+++ u-boot-2015.01/include/jffs2/jffs2.h	2022-05-09 14:09:48.276852930 -0700
@@ -31,7 +31,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: jffs2.h,v 1.2 2002/01/17 00:53:20 nyet Exp $
+ * $Id$
  *
  */
 
--- u-boot-2015.01/include/jffs2/mini_inflate.h.orig	2022-05-09 14:09:45.860950712 -0700
+++ u-boot-2015.01/include/jffs2/mini_inflate.h	2022-05-09 14:09:48.276852930 -0700
@@ -1,6 +1,6 @@
 /*-------------------------------------------------------------------------
  * Filename:      mini_inflate.h
- * Version:       $Id: mini_inflate.h,v 1.2 2002/01/17 00:53:20 nyet Exp $
+ * Version:       $Id$
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   Mini deflate implementation
--- u-boot-2015.01/include/configs/T102xRDB.h.orig	2022-05-09 14:09:45.752955083 -0700
+++ u-boot-2015.01/include/configs/T102xRDB.h	2022-05-09 14:09:47.436886927 -0700
@@ -11,6 +11,8 @@
 #ifndef __T1024RDB_H
 #define __T1024RDB_H
 
+#define CONFIG_T35
+#define CONFIG_WG_BOOTMENU
 /* High Level Configuration Options */
 #define CONFIG_SYS_GENERIC_BOARD
 #define CONFIG_DISPLAY_BOARDINFO
@@ -34,6 +36,11 @@
 #define CONFIG_FSL_LAW			/* Use common FSL init code */
 #define CONFIG_ENV_OVERWRITE
 
+/* WG:Enable the 'boot from /boot' option on uboot menu */
+#ifdef CONFIG_WG_BOOTMENU
+ #define ADD_WGMENU_BOOTBOOT
+#endif
+
 /* support deep sleep */
 #ifdef CONFIG_PPC_T1024
 #define CONFIG_DEEP_SLEEP
@@ -282,11 +289,13 @@
 #define CONFIG_CHIP_SELECTS_PER_CTRL	(4 * CONFIG_DIMM_SLOTS_PER_CTLR)
 #define CONFIG_FSL_DDR_INTERACTIVE
 #if defined(CONFIG_T1024RDB)
-#define CONFIG_DDR_SPD
+/* #define CONFIG_DDR_SPD */ /* SENAO */
+#define CONFIG_SYS_DDR_RAW_TIMING /* SENAO */
 #define CONFIG_SYS_FSL_DDR3
 #define CONFIG_SYS_SPD_BUS_NUM	0
-#define SPD_EEPROM_ADDRESS	0x51
-#define CONFIG_SYS_SDRAM_SIZE	4096	/* for fixed parameter use */
+/* #define SPD_EEPROM_ADDRESS	0x51 */ /* SENAO */
+/*#define CONFIG_SYS_SDRAM_SIZE	4096*/	/* for fixed parameter use */ /*SENAO*/
+#define CONFIG_SYS_SDRAM_SIZE	2048
 #elif defined(CONFIG_T1023RDB)
 #define CONFIG_SYS_FSL_DDR4
 #define CONFIG_SYS_DDR_RAW_TIMING
@@ -573,7 +582,9 @@
 #define CONFIG_FSL_ESPI
 #define CONFIG_SPI_FLASH
 #if defined(CONFIG_T1024RDB)
-#define CONFIG_SPI_FLASH_STMICRO
+/* #define CONFIG_SPI_FLASH_STMICRO */
+#define CONFIG_SPI_FLASH_MACRONIX /* SENAO */
+#define CONFIG_SPI_FLASH_WINBOND /* SENAO */
 #elif defined(CONFIG_T1023RDB)
 #define CONFIG_SPI_FLASH_SPANSION
 #endif
@@ -689,6 +700,23 @@
 #endif	/* CONFIG_PCI */
 
 /*
+ *SATA, SENAO
+ */
+#define CONFIG_FSL_SATA_V2
+#ifdef CONFIG_FSL_SATA_V2
+#define CONFIG_LIBATA
+#define CONFIG_FSL_SATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_LBA48
+#define CONFIG_CMD_SATA
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
  * USB
  */
 #define CONFIG_HAS_FSL_DR_USB
@@ -922,6 +950,7 @@
 #define BANK_INTLV  null
 #endif
 
+#if 0   /*SENAO*/
 #define	CONFIG_EXTRA_ENV_SETTINGS				\
 	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
 	"bank_intlv=" __stringify(BANK_INTLV) "\0"		\
@@ -951,7 +980,95 @@
 	"setenv fdtaddr 0x00c00000;"			\
 	"setenv loadaddr 0x1000000;"			\
 	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+#else
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:ctlr_intlv=cacheline,"		\
+	"bank_intlv=" __stringify(BANK_INTLV) "\0"		\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"  \
+	"ramdiskfile=" __stringify(CONFIG_BOARDNAME) "/ramdisk.uboot\0" \
+	"fdtfile=" __stringify(CONFIG_BOARDNAME) "/"		\
+	__stringify(CONFIG_BOARDNAME) ".dtb\0"			\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"	\
+	"bootargs=root=/dev/ram rw console=ttyS0,115200\0" \
+	"netdev=eth0\0"						\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"fdtaddr=2000000\0"					\
+	"bdev=sda3\0"	\
+	"ethaddr=00:0B:6B:01:01:01\0"	\
+	"eth1addr=00:0B:6B:01:01:02\0"	\
+	"eth2addr=00:0B:6B:01:01:03\0"	\
+	"eth3addr=00:0B:6B:01:01:04\0"	\
+	"bootdelay=3\0"	\
+	"ethact=FM1@DTSEC4\0"	\
+	"ethprime=FM1@DTSEC4\0"	\
+	"loadaddr=1000000\0"	\
+	"fsaddr=4000000\0"	\
+	"boot1=setenv bootargs root=/dev/sda2 rw "	\
+	"console=ttyS0,115200 "					\
+    "rootdelay=15;"							\
+    "sata init;"	\
+	"ext2load sata 0:2 $loadaddr /boot/uImage-t1024rdb-64b.bin;"	\
+	"ext2load sata 0:2 $fdtaddr /boot/uImage-t1024rdb-64b.dtb;"			\
+	"bootm $loadaddr - $fdtaddr\0"  \
+	"boot2=setenv bootargs root=/dev/ram rw  "	\
+	"console=ttyS0,115200 "					\
+    "ramdisk_size=1024000;" 				\
+    "sata init;"	\
+	"ext2load sata 0:2 $loadaddr /boot/uImage-t1024rdb-32b.bin;"	\
+	"ext2load sata 0:2 $fdtaddr /boot/uImage-t1024rdb-32b.dtb;"		\
+	"ext2load sata 0:2 $fsaddr /boot/uImage-t1024rdb-32b.ext2.gz.u-boot;"		\
+	"bootm $loadaddr $fsaddr $fdtaddr\0"  \
+	"fdtfile=t35.dtb\0"                                    \
+	"WGKernelfile=uImage_t35\0"                                \
+	"SysARoot=sda3\0"	\
+	"SysBRoot=sda2\0"	\
+	"wgBootBoot=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"sata init; " \
+	"ext2load sata 0:1 $fdtaddr $fdtfile; " \
+	"ext2load sata 0:1 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"sata init; " \
+	"ext2load sata 0:3 $fdtaddr $fdtfile; " \
+	"ext2load sata 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"sata init; " \
+	"ext2load sata 0:2 $fdtaddr $fdtfile; " \
+	"ext2load sata 0:2 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs; "	\
+	"sata init; " \
+	"ext2load sata 0:3 $fdtaddr $fdtfile; " \
+	"ext2load sata 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr - $fdtaddr;\0"  \
+	"nuke_env=sf probe 0;sf erase 100000 10000;\0"  \
+	"setup_network=mii write 0x15 0x4 0x7f;" \
+	"ipaddr=10.0.1.1;" \
+	"serveraddr=10.0.1.13;" \
+	"netmask=255.255.255.0;" \
+	"mii write 0x11 0x4 0x7f; mii write 0x1c 0x18 0x9420;" \
+        "setenv ipaddr '10.0.1.1'; setenv serverip '10.0.1.13';" \
+        "setenv netmask '255.255.255.0';\0" \
+	"flash_bootloader=tftp 0x1000000 u-boot_T1024RDB_SPIFLASH.bin;" \
+	"sf probe 0; sf erase 0 0x100000; sf write 0x1000000 0 $filesize;" \
+	"sf read 300000 0 fff0; md 3000e0; cmp.b 1000000 300000 fff0;\0"
 
+#define CONFIG_LINUX					\
+	"run boot1"
+#endif
 
 #define CONFIG_NFSBOOTCOMMAND			\
 	"setenv bootargs root=/dev/nfs rw "	\
@@ -962,7 +1079,7 @@
 	"tftp $fdtaddr $fdtfile;"		\
 	"bootm $loadaddr - $fdtaddr"
 
-#define CONFIG_BOOTCOMMAND	CONFIG_LINUX
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
 
 #ifdef CONFIG_SECURE_BOOT
 #include <asm/fsl_secure_boot.h>
--- u-boot-2015.01/include/linux_logo.h.orig	2022-05-09 14:09:45.876950065 -0700
+++ u-boot-2015.01/include/linux_logo.h	2022-05-09 14:09:48.160857625 -0700
@@ -1,4 +1,4 @@
-/* $Id: linux_logo.h,v 1.5 1998/07/30 16:30:58 jj Exp $
+/* $Id$
  * include/linux/linux_logo.h: This is a linux logo
  *                             to be displayed on boot.
  *
--- u-boot-2015.01/include/lxt971a.h.orig	2022-05-09 14:09:45.876950065 -0700
+++ u-boot-2015.01/include/lxt971a.h	2022-05-09 14:09:48.208855682 -0700
@@ -3,7 +3,7 @@
  * Copyright (C) 2004 by FS Forth-Systeme GmbH.
  * All rights reserved.
  *
- * $Id: ns9750_eth.h,v 1.2 2004/02/24 13:25:39 mpietrek Exp $
+ * $Id$
  * @Author: Markus Pietrek
  * @References: [1] NS9750 Hardware Reference, December 2003
  *              [2] Intel LXT971 Datasheet #249414 Rev. 02
--- u-boot-2015.01/arch/mips/include/asm/posix_types.h.orig	2022-05-09 14:09:44.593002031 -0700
+++ u-boot-2015.01/arch/mips/include/asm/posix_types.h	2022-05-09 14:09:48.936826218 -0700
@@ -1,4 +1,4 @@
-/* $Id: posix_types.h,v 1.6 2000/02/04 23:32:54 ralf Exp $
+/* $Id$
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
--- u-boot-2015.01/arch/powerpc/cpu/mpc85xx/cpu_init.c.orig	2022-05-09 14:09:44.625000737 -0700
+++ u-boot-2015.01/arch/powerpc/cpu/mpc85xx/cpu_init.c	2022-05-09 14:09:46.628919629 -0700
@@ -46,6 +46,9 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+/*SENAO*/
+extern void led_all_off(void);
+
 #ifdef CONFIG_SYS_FSL_SINGLE_SOURCE_CLK
 /*
  * For deriving usb clock from 100MHz sysclk, reference divisor is set
@@ -997,6 +1000,10 @@
 
 	init_used_tlb_cams();
 
+    /*SENAO*/
+    led_all_off();
+    led_all_off();
+
 	return 0;
 }
 
--- u-boot-2015.01/Makefile.orig	2022-05-09 14:09:44.205017735 -0700
+++ u-boot-2015.01/Makefile	2022-05-09 14:09:46.232935656 -0700
@@ -1,6 +1,6 @@
 VERSION = 2015
 PATCHLEVEL = 01
-SUBLEVEL =
+SUBLEVEL = 
 EXTRAVERSION =
 NAME =
 
--- u-boot-2015.01/drivers/pci/fsl_pci_init.c.orig	2022-05-09 14:09:45.604961073 -0700
+++ u-boot-2015.01/drivers/pci/fsl_pci_init.c	2022-05-09 14:09:47.332891136 -0700
@@ -706,6 +706,36 @@
 {
 	int is_endpoint;
 
+{
+#define readl(a) (*((volatile u32 *)(a)))
+#define writel(a, b) (*((volatile u32 *)(b)) = ((volatile u32)a))
+    /*SENAO*/
+    int reg;
+    
+    reg = readl(0xfe133000);
+    reg |= 0x00040000;
+    //printf("\nreg =0x%08x\n", reg);
+    //writel(0xfe133000, &reg);
+    writel(reg, 0xfe133000);
+    
+    //signal
+    //    __   _____
+    //___|  |_|
+    
+    //low
+    reg = readl(0xfe133008);
+    reg &= ~(0x00040000);
+    //printf("\nreg =0x%08x\n", reg);
+    writel(reg, 0xfe133008);
+    
+    //high
+    udelay(1000000);
+    reg = readl(0xfe133008);
+    reg |= 0x00040000;
+    //printf("reg =0x%08x\n", reg);
+    writel(reg, 0xfe133008);
+}
+    
 	set_next_law(info->mem_phys, law_size_bits(info->mem_size), info->law);
 	set_next_law(info->io_phys, law_size_bits(info->io_size), info->law);
 
--- u-boot-2015.01/drivers/mtd/spi/sf_params.c.orig	2022-05-09 14:09:45.556963016 -0700
+++ u-boot-2015.01/drivers/mtd/spi/sf_params.c	2022-05-09 14:09:47.308892108 -0700
@@ -39,10 +39,13 @@
 #ifdef CONFIG_SPI_FLASH_MACRONIX	/* MACRONIX */
 	{"MX25L2006E",	   0xc22012, 0x0,	64 * 1024,     4, RD_NORM,			  0},
 	{"MX25L4005",	   0xc22013, 0x0,	64 * 1024,     8, RD_NORM,			  0},
-	{"MX25L8005",	   0xc22014, 0x0,	64 * 1024,    16, RD_NORM,			  0},
+	/*{"MX25L8005",	   0xc22014, 0x0,	64 * 1024,    16, RD_NORM,			  0},*/
+	{"MX25L8006E",	   0xc22014, 0x0,	64 * 1024,    32, RD_NORM,			  0}, /*SENAO*/
 	{"MX25L1605D",	   0xc22015, 0x0,	64 * 1024,    32, RD_NORM,			  0},
 	{"MX25L3205D",	   0xc22016, 0x0,	64 * 1024,    64, RD_NORM,			  0},
-	{"MX25L6405D",	   0xc22017, 0x0,	64 * 1024,   128, RD_NORM,			  0},
+	/*{"MX25L6405D",	   0xc22017, 0x0,	64 * 1024,   128, RD_NORM,			  0},*/
+	{"MX25L6433F",	   0xc22017, 0x0,	64 * 1024,   128, RD_NORM,			  0}, /*SENAO*/
+	{"MX25U3235F",	   0xc22536, 0x0,	64 * 1024,    64, RD_NORM,			  0}, /*SENAO*/
 	{"MX25L12805",	   0xc22018, 0x0,	64 * 1024,   256, RD_FULL,		     WR_QPP},
 	{"MX25L25635F",	   0xc22019, 0x0,	64 * 1024,   512, RD_FULL,		     WR_QPP},
 	{"MX25L51235F",	   0xc2201a, 0x0,	64 * 1024,  1024, RD_FULL,		     WR_QPP},
--- u-boot-2015.01/fs/yaffs2/Makefile.orig	2022-05-09 14:09:45.712956702 -0700
+++ u-boot-2015.01/fs/yaffs2/Makefile	2022-05-09 14:09:50.720754014 -0700
@@ -14,7 +14,7 @@
 #
 # NB Warning this Makefile does not include header dependencies.
 #
-# $Id: Makefile,v 1.15 2007/07/18 19:40:38 charles Exp $
+# $Id$
 
 obj-y := \
 	yaffs_allocator.o yaffs_attribs.o yaffs_bitmap.o yaffs_uboot_glue.o\
--- u-boot-2015.01/fs/jffs2/compr_rtime.c.orig	2022-05-09 14:09:45.700957188 -0700
+++ u-boot-2015.01/fs/jffs2/compr_rtime.c	2022-05-09 14:09:50.776751748 -0700
@@ -31,7 +31,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: compr_rtime.c,v 1.2 2002/01/24 22:58:42 rfeany Exp $
+ * $Id$
  *
  *
  * Very simple lz77-ish encoder.
--- u-boot-2015.01/fs/jffs2/compr_zlib.c.orig	2022-05-09 14:09:45.700957188 -0700
+++ u-boot-2015.01/fs/jffs2/compr_zlib.c	2022-05-09 14:09:50.776751748 -0700
@@ -31,7 +31,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: compr_zlib.c,v 1.2 2002/01/24 22:58:42 rfeany Exp $
+ * $Id$
  *
  */
 
--- u-boot-2015.01/fs/jffs2/compr_rubin.c.orig	2022-05-09 14:09:45.700957188 -0700
+++ u-boot-2015.01/fs/jffs2/compr_rubin.c	2022-05-09 14:09:50.772751909 -0700
@@ -34,7 +34,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: compr_rubin.c,v 1.2 2002/01/24 22:58:42 rfeany Exp $
+ * $Id$
  *
  */
 
--- u-boot-2015.01/fs/jffs2/compr_lzo.c.orig	2022-05-09 14:09:45.700957188 -0700
+++ u-boot-2015.01/fs/jffs2/compr_lzo.c	2022-05-09 14:09:50.764752234 -0700
@@ -7,7 +7,7 @@
  * For licensing information, see the file 'LICENCE' in the
  * jffs2 directory.
  *
- * $Id: compr_lzo.c,v 1.3 2004/06/23 16:34:39 havasi Exp $
+ * $Id$
  *
  */
 
--- u-boot-2015.01/fs/jffs2/mini_inflate.c.orig	2022-05-09 14:09:45.700957188 -0700
+++ u-boot-2015.01/fs/jffs2/mini_inflate.c	2022-05-09 14:09:50.776751748 -0700
@@ -1,6 +1,6 @@
 /*-------------------------------------------------------------------------
  * Filename:      mini_inflate.c
- * Version:       $Id: mini_inflate.c,v 1.3 2002/01/24 22:58:42 rfeany Exp $
+ * Version:       $Id$
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   Mini inflate implementation (RFC 1951)
--- u-boot-2015.01/fs/jffs2/jffs2_1pass.c.orig	2022-05-09 14:09:45.700957188 -0700
+++ u-boot-2015.01/fs/jffs2/jffs2_1pass.c	2022-05-09 14:09:50.772751909 -0700
@@ -1,7 +1,7 @@
 /*
 -------------------------------------------------------------------------
  * Filename:      jffs2.c
- * Version:       $Id: jffs2_1pass.c,v 1.7 2002/01/25 01:56:47 nyet Exp $
+ * Version:       $Id$
  * Copyright:     Copyright (C) 2001, Russ Dill
  * Author:        Russ Dill <Russ.Dill@asu.edu>
  * Description:   Module to load kernel from jffs2
@@ -42,7 +42,7 @@
  * provisions above, a recipient may use your version of this file
  * under either the RHEPL or the GPL.
  *
- * $Id: jffs2_1pass.c,v 1.7 2002/01/25 01:56:47 nyet Exp $
+ * $Id$
  *
  */
 
--- u-boot-2015.01/board/freescale/t102xrdb/t1024_rcw.cfg.orig	2022-05-09 14:09:45.020984709 -0700
+++ u-boot-2015.01/board/freescale/t102xrdb/t1024_rcw.cfg	2022-05-09 14:09:46.924907649 -0700
@@ -1,8 +1,29 @@
 #PBL preamble and RCW header for T1024RDB
 aa55aa55 010e0100
-#SerDes Protocol: 0x95
-#Core/DDR: 1400Mhz/1600MT/s with single source clock
+#SerDes Protocol: 0x5A
+#Core/DDR: 1200Mhz/800MT/s with single source clock
+#0808000c 00000000 00000000 00000000
+#2d000003 00000012 5c027000 21000000
+#00000000 00000000 00000000 00033f00
+#00000704 49260208 00000000 00000006
+
+#SENAO
+#Core/DDR: 1200Mhz/1600MT/s with single source clock
+#0810000c 00000000 00000000 00000000
+#2d000003 00000012 5c027000 21000000
+#00000000 00000000 00000000 00033f00
+#00000704 49260208 00000000 00000006
+
+#SENAO
+#Core/DDR: 1200Mhz/1600MT/s with single source clock, SATA 125MHz
+#0810000c 00000000 00000000 00000000
+#2d000003 0000001a 5c027000 21000000
+#00000000 00000000 00000000 00033f00
+#00000704 49260208 00000000 00000006
+
+#SENAO
+#Core/DDR: 1200Mhz/1600MT/s with single source clock, SATA 125MHz, 1G, 436-437: 10 (3.3V)
 0810000c 00000000 00000000 00000000
-4a800003 80000012 ec027000 21000000
-00000000 00000000 00000000 00030810
-00000000 0b005a08 00000000 00000006
+2d000003 0000001a 5c027000 21000000
+00000000 00000000 00000000 00033f00
+00000704 49260a08 00000000 00000006
--- u-boot-2015.01/board/freescale/t102xrdb/ddr.c.orig	2022-05-09 14:09:45.020984709 -0700
+++ u-boot-2015.01/board/freescale/t102xrdb/ddr.c	2022-05-09 14:09:46.924907649 -0700
@@ -13,6 +13,9 @@
 #include <asm/fsl_law.h>
 #include <asm/mpc85xx_gpio.h>
 
+#define SENAO_2G
+//#define SENAO_1G
+
 DECLARE_GLOBAL_DATA_PTR;
 
 struct board_specific_parameters {
@@ -39,7 +42,8 @@
 	{2,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},
 	{1,  833,   0,  4,  6,  0x06060607,  0x08080807,},
 	{1,  1350,  0,  4,  7,  0x0708080A,  0x0A0B0C09,},
-	{1,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},
+	/*{1,  1666,  0,  4,  7,  0x0808090B,  0x0C0D0E0A,},*/
+    {1,  1666,  0,  4,  6,  0x00000000,  0x00000000,}, /*SENAO*/
 	{}
 };
 
@@ -143,6 +147,82 @@
 }
 
 #ifdef CONFIG_SYS_DDR_RAW_TIMING
+#if defined(SENAO_2G) /*SENAO*/
+/* 2GB discrete DDR3 NT5CC256M16DP on T1024RDB */ /* SENAO */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 0x80000000,
+	.capacity = 0x80000000,
+	.primary_sdram_width = 64,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 16,   //A0-A15, p.1
+	.n_col_addr = 10,   //A0-A9, p.1
+	.n_banks_per_sdram_device=8, //??
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+	//.tckmin_x_ps = 938,   //page.25
+	//.tckmax_ps = 1500,   //page.25
+	.tckmin_x_ps = 1250,   //DDR3-1600, CL11, page.140
+	.tckmax_ps = 1500,   //DDR3-1600, CL11, page.140
+	.caslat_x = 0x000DFA00,
+
+	.tfaw_ps = 30000,   //30ns, p.146 (1KB page size)
+
+	.taa_ps = 13910,  //13.91ns, p.2
+	.trc_ps = 48750,   //48.75ns, p.2
+	.trcd_ps = 13910,  //13.91ns, p.2
+	.trp_ps = 13910,   //13.91ns, p.2
+	.tras_ps = 35000,  //35ns, p.2
+    
+	.twr_ps = 15000,    //15ns, p.146
+	.trfc_ps = 260000,  //260ns, p.89
+	.trrd_ps = 6000,    //6ns, p.146
+	.twtr_ps = 7500,    //7.5ns, p.146
+	.trtp_ps = 7500,    //7.5ns, p.146
+
+	//.refresh_rate_ps = 7800000,
+	.refresh_rate_ps = 3900000, //high temperature
+
+};
+#elif defined(SENAO_1G) /*SENAO*/
+/* 1GB discrete DDR3 NT5CC128M16IP on T1024RDB */ /* SENAO */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 0x40000000,
+	.capacity = 0x40000000,
+	.primary_sdram_width = 64,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 14,   //A0-A13, p.1
+	.n_col_addr = 10,   //A0-A9, p.1
+	.n_banks_per_sdram_device=8, //BA0-BA2, p.1
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+	.tckmin_x_ps = 1250,   //1.25ns, page.24, CL8
+	.tckmax_ps = 1500,   //1.5ns, page.24, CL8
+	.caslat_x = 0x000DFA00,
+
+	.tfaw_ps = 30000,   //30ns, p.146 (1KB page size)
+
+	.taa_ps = 13750,  //13.75ns, p.2
+	.trc_ps = 48750,   //48.75ns, p.2
+	.trcd_ps = 13750,  //13.75ns, p.2
+	.trp_ps = 13750,   //13.75ns, p.2
+	.tras_ps = 35000,  //35ns, p.2
+
+	.twr_ps = 15000,    //15ns, p.146
+	.trfc_ps = 160000,  //160ns, p.1
+	.trrd_ps = 6000,    //6ns, p.146
+	.twtr_ps = 7500,    //7.5ns, p.146
+	.trtp_ps = 7500,    //7.5ns, p.146
+
+	//.refresh_rate_ps = 7800000,
+	.refresh_rate_ps = 3900000, //high temperature
+};
+#else
 /* 2GB discrete DDR4 MT40A512M8HX on T1023RDB */
 dimm_params_t ddr_raw_timing = {
 	.n_ranks = 1,
@@ -194,6 +274,7 @@
 	.dq_mapping[17] = 0x0,
 	.dq_mapping_ors = 1,
 };
+#endif
 
 int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
 		unsigned int controller_number,
--- u-boot-2015.01/board/freescale/t102xrdb/eth_t102xrdb.c.orig	2022-05-09 14:09:45.020984709 -0700
+++ u-boot-2015.01/board/freescale/t102xrdb/eth_t102xrdb.c	2022-05-09 14:09:46.924907649 -0700
@@ -46,7 +46,17 @@
 
 	/* Register the 1G MDIO bus */
 	fm_memac_mdio_init(bis, &dtsec_mdio_info);
-
+{/*SENAO*/
+    int i=0;
+    struct mii_dev *bus;
+    bus = mdio_get_current_dev();
+    /* Port 5 cascading port, 1G */
+    memac_mdio_write(bus, 0x15, MDIO_DEVAD_NONE, 0x1, 0xC002);
+    /* Port 6 cascading port, 1G */
+    memac_mdio_write(bus, 0x16, MDIO_DEVAD_NONE, 0x1, 0xC002);
+    /* GPIO 5 generate 125Hz clock */
+    /*memac_mdio_write(bus, 0x1c, MDIO_DEVAD_NONE, 0x1a, 0xEA70);*/
+}
 	tgec_mdio_info.regs =
 		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
 	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
--- u-boot-2015.01/common/cmd_jffs2.c.orig	2022-05-09 14:09:45.292973700 -0700
+++ u-boot-2015.01/common/cmd_jffs2.c	2022-05-09 14:09:52.048700266 -0700
@@ -15,7 +15,7 @@
  *   Parsing routines are based on driver/mtd/cmdline.c from the linux 2.4
  *   kernel tree.
  *
- *   $Id: cmdlinepart.c,v 1.17 2004/11/26 11:18:47 lavinen Exp $
+ *   $Id$
  *   Copyright 2002 SYSGO Real-Time Solutions GmbH
  *
  * SPDX-License-Identifier:	GPL-2.0+
--- u-boot-2015.01/common/Makefile.orig	2022-05-09 14:09:45.276974348 -0700
+++ u-boot-2015.01/common/Makefile	2022-05-09 14:09:47.092900850 -0700
@@ -8,12 +8,16 @@
 # core
 ifndef CONFIG_SPL_BUILD
 obj-y += main.o
+obj-$(CONFIG_WG_BOOTMENU) += wgmenu.o
 obj-y += exports.o
 obj-y += hash.o
 ifdef CONFIG_SYS_HUSH_PARSER
 obj-y += cli_hush.o
 endif
 
+#SENAO
+obj-y += cmd_led_senao.o
+
 # This option is not just y/n - it can have a numeric value
 ifdef CONFIG_BOOTDELAY
 obj-y += autoboot.o
--- u-boot-2015.01/common/autoboot.c.orig	2022-05-09 14:09:45.276974348 -0700
+++ u-boot-2015.01/common/autoboot.c	2022-05-09 14:09:47.092900850 -0700
@@ -13,6 +13,11 @@
 #include <menu.h>
 #include <post.h>
 
+#ifdef CONFIG_WG_BOOTMENU
+#include <wgmenu.h>
+#include <u-boot/sha1.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define MAX_DELAY_STOP_STR 32
@@ -147,6 +152,15 @@
 	int abort = 0;
 	unsigned long ts;
 
+#ifdef CONFIG_WG_BOOTMENU
+	wgmenu_show();
+	int wg_break = 0;
+	int wg_keypress = 0;
+	int wg_selected = 0;
+	const char wg_pw_hash[] = { 0xe5, 0x97, 0x30, 0x1a, 0x1d, 0x89, 0xff, 0x3f, 0x6d, 0x31, 0x8d, 0xbf, 0x4d, 0xba, 0x0a, 0x5a, 0xbc, 0x5e, 0xcb, 0xea};
+	char wg_csum_output[20];
+#endif
+
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
 #else
@@ -174,6 +188,54 @@
 		ts = get_timer(0);
 		do {
 			if (tstc()) {	/* we got a key press	*/
+# ifdef CONFIG_WG_BOOTMENU
+				/* Carriage return breaks us out of while() */
+				while (wg_keypress != 13) {
+					wg_keypress = getc();
+					wgmenu_hook(wg_keypress);
+					wg_selected = wgmenu_selected();
+					if (wg_keypress == 3) {	// CTRL+C
+						int wg_pw_len = 0;
+						wgmenu_exit();
+						printf("\x0D"); // go to the beginning of the line
+						printf("\e[2K"); // clear the line
+						wg_pw_len = cli_readline("password> ");
+						/* This if statement will not break from while if
+						 * we type a carriage return. */
+						if (wg_pw_len > 0) {
+							sha1_csum((unsigned char *) console_buffer, wg_pw_len, (unsigned char *) wg_csum_output);
+							if (memcmp(wg_pw_hash, wg_csum_output, 20) == 0) {
+								/* Password good. Assert abort and break
+								 * to prompt. */
+								abort = 1;
+								bootdelay = 0;
+								wg_break = 1;
+								break;
+							} else {
+								/* Bad password. */
+								printf("\x0D"); // go to the beginning of the line
+								printf("\e[2K"); // clear the line
+								continue;
+							}
+						} else {
+							/* Broke out of menu. Start the menu over.
+							 * Tell me how you got here, becuase this shouldn't happen. */
+							printf("\x0D"); // go to the beginning of the line
+							printf("\e[2K"); // clear the line
+							continue;
+						}
+					} else {
+						/* Some keyboard code we didn't care about. Start
+						 * the menu over. */
+						continue;
+					}
+					udelay(10000);
+				}
+				bootdelay = 0;
+				wg_break = 1;
+				wgmenu_exit();
+				break;
+# else /* !CONFIG_WG_BOOTMENU */
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
 # ifdef CONFIG_MENUKEY
@@ -181,12 +243,44 @@
 # else
 				(void) getc();  /* consume input	*/
 # endif
+# endif /* CONFIG_WG_BOOTMENU */
 				break;
 			}
 			udelay(10000);
 		} while (!abort && get_timer(ts) < 1000);
 
+#ifdef CONFIG_WG_BOOTMENU
+		if (!wg_break) {
+#endif /* CONFIG_WG_BOOTMENU */
 		printf("\b\b\b%2d ", bootdelay);
+#ifdef CONFIG_WG_BOOTMENU
+		}
+		if(getenv("Burn_In_Time") == NULL) {
+			if ((bootdelay == 0) && (abort != 1)) {
+				if (wg_selected >= 0) {
+					printf("\x0D"); // go to the beginning of the line
+					printf("\e[2K"); // clear the line
+					switch (wg_selected) {
+						case 1:
+							setenv("bootcmd", "run wgBootSysB");
+							printf("Booting SYSB");
+							break;
+#ifdef ADD_WGMENU_BOOTBOOT
+						case 2:
+							setenv("bootcmd", "run wgBootBoot");
+							printf("Booting SYSA from /boot");
+							break;
+#endif
+						case 0:
+						default:
+							setenv("bootcmd", "run wgBootSysA");
+							printf("Booting SYSA");
+							break;
+					}
+				}
+			}
+		}
+#endif /* CONFIG_WG_BOOTMENU */
 	}
 
 	putc('\n');
--- u-boot-2015.01/common/cmd_mtdparts.c.orig	2022-05-09 14:09:45.296973539 -0700
+++ u-boot-2015.01/common/cmd_mtdparts.c	2022-05-09 14:09:52.056699942 -0700
@@ -18,7 +18,7 @@
  * (C) Copyright 2008
  * Harald Welte, OpenMoko, Inc., Harald Welte <laforge@openmoko.org>
  *
- *   $Id: cmdlinepart.c,v 1.17 2004/11/26 11:18:47 lavinen Exp $
+ *   $Id$
  *   Copyright 2002 SYSGO Real-Time Solutions GmbH
  *
  * SPDX-License-Identifier:	GPL-2.0+
--- u-boot-2015.01/common/main.c.orig	2022-05-09 14:09:45.312972891 -0700
+++ u-boot-2015.01/common/main.c	2022-05-09 14:09:47.120899716 -0700
@@ -52,10 +52,51 @@
 #endif /* CONFIG_PREBOOT */
 }
 
+
+#if defined(CONFIG_T35)
+
+#define CONFIG_T35_RESET_BUTTON_GPIO_ADDR 0xfe133008
+#define BUTTON_RESET			(17)
+
+/*
+* Read button status by given gpio number
+*/
+int read_btn_status(unsigned int btn)
+{
+	unsigned int reg_val = *(int *)(CONFIG_T35_RESET_BUTTON_GPIO_ADDR);
+	
+	/* Low active */
+	if (reg_val & (1 << (31 - btn)) )
+		return 0;
+	else
+		return 1;
+}
+
+unsigned char detect_SYSB_keypress(void)
+{
+	int status = 0;
+	int i;
+	for(i = 0; i < 3; i++) {
+
+	        if (read_btn_status(BUTTON_RESET)) {
+			printf("booting into SYSB ... \n");
+			status = 1;
+			break;
+		}
+        	udelay(1000);
+	}
+
+	return status;
+}
+#endif /* end of CONFIG_T35 */
+
 /* We come here after U-Boot is initialised and ready to process commands */
 void main_loop(void)
 {
 	const char *s;
+ #if defined(CONFIG_T35)
+       unsigned char sysbReq;
+ #endif
 
 	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");
 
@@ -82,6 +123,24 @@
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
 
+#if defined(CONFIG_T35) 
+	sysbReq = detect_SYSB_keypress();
+	if(sysbReq == 1) {
+		if(getenv("Burn_In_Time") != NULL) {
+			 /* Assuming that mfgsys is the only user of "Burn_In_Time" */
+			setenv("bootcmd", "run wgBootSenao");
+		} else {
+			if(!getenv ("wgBootSysB")) /* Can remove this if wgBootSysB is defined in header file */
+				setenv("wgBootSysB", "setenv bootargs root=/dev/sda2 rw rootdelay=2 console=ttyS0,115200 ; sata init; ext2load sata 0:2 fc0000 t35.dtb; ext2load sata 0:2 1000000 uImage_t35; bootm 1000000 - fc0000");
+			setenv("bootcmd", "run wgBootSysB");
+		}
+
+		s = getenv ("bootcmd");
+		printf("string = %s\n", s);
+		run_command (s, 0);
+	}
+#endif /* endof CONFIG_T35 */
+
 	autoboot_command(s);
 
 	cli_loop();
--- u-boot-2015.01/include/wgmenu.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2015.01/include/wgmenu.h	2022-05-09 14:09:47.608879966 -0700
@@ -0,0 +1,11 @@
+#ifndef _WGMENU_H
+#define _WGMENU_H
+
+int wgmenu_hook(int key);
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user);
+void wgmenu_show(void);
+int wgmenu_selected(void);
+int wgmenu_inmenu(void);
+void wgmenu_exit(void);
+
+#endif /* _WGMENU_H */
--- u-boot-2015.01/include/linux/compiler-gcc6.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2015.01/include/linux/compiler-gcc6.h	2022-05-09 14:09:47.560881908 -0700
@@ -0,0 +1,61 @@
+#ifdef CONFIG_WG_PLATFORM_BACKPORT /* FBX-9469 */
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc6.h> directly, include <linux/compiler.h> instead."
+#endif
+
+#define __used				__attribute__((__used__))
+#define __must_check			__attribute__((warn_unused_result))
+#define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+
+/* Mark functions as cold. gcc will assume any path leading to a call
+   to them will be unlikely.  This means a lot of manual unlikely()s
+   are unnecessary now for any paths leading to the usual suspects
+   like BUG(), printk(), panic() etc. [but let's keep them for now for
+   older compilers]
+
+   gcc also has a __attribute__((__hot__)) to move hot functions into
+   a special section, but I don't see any sense in this right now in
+   the kernel context */
+#define __cold			__attribute__((__cold__))
+
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+
+/*
+ * Mark a position in code as unreachable.  This can be used to
+ * suppress control flow warnings after asm blocks that transfer
+ * control elsewhere.
+ */
+#define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__))
+
+/*
+ * Tell the optimizer that something else uses this function or variable.
+ */
+#define __visible __attribute__((externally_visible))
+
+/*
+ * GCC 'asm goto' miscompiles certain code sequences:
+ *
+ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+ *
+ * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+ *
+ * (asm goto is automatically volatile - the naming reflects this.)
+ */
+#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+
+#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+#define __HAVE_BUILTIN_BSWAP32__
+#define __HAVE_BUILTIN_BSWAP64__
+#define __HAVE_BUILTIN_BSWAP16__
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
+
+#define KASAN_ABI_VERSION 4
+#endif /* CONFIG_WG_PLATFORM_BACKPORT */
--- u-boot-2015.01/tools/env/fw_env.config.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2015.01/tools/env/fw_env.config	2022-05-09 14:09:46.012944560 -0700
@@ -0,0 +1,22 @@
+# Configuration file for fw_(printenv/setenv) utility.
+# Up to two entries are valid, in this case the redundant
+# environment sector is assumed present.
+# Notice, that the "Number of sectors" is not required on NOR and SPI-dataflash.
+# Futhermore, if the Flash sector size is ommitted, this value is assumed to
+# be the same as the Environment size, which is valid for NOR and SPI-dataflash
+
+# NOR example
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+/dev/mtd1		0x0000		0x4000		0x4000
+/dev/mtd2		0x0000		0x4000		0x4000
+
+# MTD SPI-dataflash example
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+#/dev/mtd5		0x4200		0x4200
+#/dev/mtd6		0x4200		0x4200
+
+# NAND example
+#/dev/mtd0		0x4000		0x4000		0x20000			2
+
+# Block device example
+#/dev/mmcblk0		0xc0000		0x20000
--- u-boot-2015.01/common/wgmenu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2015.01/common/wgmenu.c	2022-05-09 14:09:47.124899555 -0700
@@ -0,0 +1,184 @@
+#include <common.h>
+#ifndef DO_DEPS_ONLY
+#include "generated/version_autogenerated.h"
+#include "generated/timestamp_autogenerated.h"
+#endif
+#include <wgmenu.h>
+
+#define WG_VERSION_STRING ("WatchGuard " U_BOOT_VERSION " - " U_BOOT_DATE " " U_BOOT_TIME)
+#define ANSI_CLEAR		"\e[2J"
+#define ANSI_REVERSE		"\e[7m"
+#define	ANSI_NORMAL		"\e[m"
+#define ANSI_GOTOYX		"\e[%d;%dH"
+
+#define SCREEN_HIGH		24
+#define SCREEN_WIDTH		80
+#define MAX_MENU_ITEMS		10
+
+#define FIRST_LINE_Y		2
+#define FIRST_LINE_X_FUN(len)	((SCREEN_WIDTH - len)/2)
+#define FIRST_LINE_X		FIRST_LINE_X_FUN(58)
+
+#define TABLE_START_Y		4
+#define TABLE_START_X		2 
+#define TABLE_LENGHT		(SCREEN_WIDTH - 6)
+#define TABLE_HIGH		(SCREEN_HIGH/2)
+
+#define	TOP_ROW			(TABLE_START_X + 1)
+#define	MENU_0_ROW		(TABLE_START_Y + 1)
+
+struct __wgmenu_option {
+	const char *label;		// WG:BH - We really only use the label...
+	void (*fn)(void *user);		// but we could add functionality to add dynamically generated menu items.
+	void *user;			// <<< this one is the argument to fn.
+};
+
+static struct __wgmenu_option wg_options[MAX_MENU_ITEMS];
+static int __wgmenu_max_width = TABLE_LENGHT - 4;
+static int __wgmenu_num_options = 0;
+static int __wgmenu_option_pos = 0;
+static int __wgmenu_boot_menu = 1;
+
+static void __wgmenu_print_option(const struct __wgmenu_option *opt, int reverse)
+{
+	int n = (opt - wg_options);
+	char format[10] = {'\0'};
+
+	printf(ANSI_GOTOYX, MENU_0_ROW+n, TABLE_START_X + 1);
+	if (reverse) {
+		printf(ANSI_REVERSE);
+	}
+
+	sprintf(format, "%%-%ds", __wgmenu_max_width);
+	printf(format, opt->label);
+
+	if (reverse) {
+		printf(ANSI_NORMAL);
+	}
+
+	printf(ANSI_GOTOYX ,SCREEN_HIGH + 2 , 1); 
+}
+
+static void __wgmenu_show_bootmenu_table(void)
+{
+	int i = 0,j = 0 ;
+
+	printf(ANSI_CLEAR ANSI_GOTOYX "%s", FIRST_LINE_Y,
+			(int)FIRST_LINE_X_FUN((strlen(WG_VERSION_STRING))), WG_VERSION_STRING);
+
+	for (i = 0 ; i < TABLE_LENGHT ; i++) {	//the above horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y, TABLE_START_X + i);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	//the left line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	// the right line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X + TABLE_LENGHT);
+	}
+	for (i = 1 ; i < TABLE_LENGHT ; i++) {	//the below horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y + TABLE_HIGH, TABLE_START_X + i);
+	}
+
+	printf(ANSI_GOTOYX "+",TABLE_START_Y, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y , TABLE_START_X + TABLE_LENGHT); 
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X + TABLE_LENGHT);
+
+	printf(ANSI_GOTOYX "Use the ^ and v keys to select which entry is highlighted.",
+			TABLE_START_Y + TABLE_HIGH + 2, 7);
+	printf(ANSI_GOTOYX "Press enter to boot the selected OS.",
+			TABLE_START_Y + TABLE_HIGH + 3, 7);
+
+	printf(ANSI_GOTOYX , SCREEN_HIGH + 2, 1);
+}
+
+static void __wgmenu_show_bootmenu(void)
+{
+	const struct __wgmenu_option *opt = {NULL};
+
+	__wgmenu_show_bootmenu_table();
+
+	for (opt = wg_options; opt != (wg_options + __wgmenu_num_options); opt++) {
+		__wgmenu_print_option(opt, opt == wg_options);
+	}
+}
+
+static int __wgmenu_wg_display_menu(int key)
+{
+	static struct __wgmenu_option *opt = wg_options;
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 0);
+
+	switch (key) {
+		case 65: //up
+			if(__wgmenu_option_pos > 0)
+				__wgmenu_option_pos--;
+			break; 
+		case 66: //down
+			if(__wgmenu_option_pos < (__wgmenu_num_options - 1))
+				__wgmenu_option_pos++;
+			break; 
+		case 13:
+		default:
+			break;
+	}
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 1);
+
+	return opt - wg_options ;
+}
+
+int wgmenu_hook(int key)
+{
+	static const struct __wgmenu_option *opt = wg_options;
+	int hooked = 0;
+
+	if ((key == 65 || key == 66) && opt && __wgmenu_num_options) {
+		hooked = 1;
+		__wgmenu_wg_display_menu(key);
+	}
+
+	return hooked;
+}
+
+
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user)
+{
+	int len;
+
+	wg_options[__wgmenu_num_options].label = label;
+	wg_options[__wgmenu_num_options].fn = fn;
+	wg_options[__wgmenu_num_options].user = user;
+	__wgmenu_num_options++;
+
+	len = strlen(label);
+
+	if (len > __wgmenu_max_width)
+		__wgmenu_max_width = len;
+}
+
+
+void wgmenu_show(void)
+{
+	wgmenu_add("WatchGuard (SYSA)", NULL, NULL);
+	wgmenu_add("WatchGuard (SYSB Recovery/Diagnostic Mode)", NULL, NULL);
+#ifdef ADD_WGMENU_BOOTBOOT
+	wgmenu_add("WatchGuard (SYSA from /boot)", NULL, NULL);
+#endif
+	__wgmenu_show_bootmenu();
+}
+
+int wgmenu_selected(void)
+{
+	return __wgmenu_option_pos;
+}
+
+int wgmenu_inmenu(void)
+{
+	return __wgmenu_boot_menu;
+}
+
+void wgmenu_exit(void)
+{
+	__wgmenu_boot_menu = 0;
+}
--- u-boot-2015.01/common/cmd_led_senao.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2015.01/common/cmd_led_senao.c	2022-05-09 14:09:47.104900364 -0700
@@ -0,0 +1,242 @@
+#include <common.h>
+#include <command.h>
+
+#define GPIO_BASE	0xfe130000
+#define GPIO1		(GPIO_BASE+0x0000)
+#define GPIO2		(GPIO_BASE+0x1000)
+#define GPIO3		(GPIO_BASE+0x2000)
+#define GPIO4		(GPIO_BASE+0x3000)
+#define GPIO_DIRECTION  0x0
+#define GPIO_DATA	0x8
+
+#define GPIO4_DIRECTION (GPIO4+GPIO_DIRECTION)
+#define GPIO4_DATA	(GPIO4+GPIO_DATA)
+//#define LED_CLR_GPIO
+#define LED_DATA_GPIO 	3
+#define LED_CLOCK_GPIO 	2
+
+#define LEDNUM 6
+
+#define OUTPUT		1
+#define INPUT		0
+
+//#define DEBUG
+
+int led_stat = 1;
+int wifi_led_stat = 1;
+
+int myatoi(char *str)
+{
+	int i = 0, result = 0;
+
+	while(str[i] != '\0') {
+		result += (result * 10) + (str[i] - '0');
+		i++;
+	}
+	return result;
+}
+
+void gpio_write_bit(ulong addr, int pos, int value)
+{
+	ulong bytes = 1;
+	uint32_t writeval, readval;
+
+	const void *buf = map_sysmem(addr, bytes);
+
+	readval = *(volatile uint32_t *)buf;
+#ifdef DEBUG
+	printf("0x%08lx - Before modify: 0x%08x\n", addr, readval);
+#endif
+	if (value == 1)
+		writeval = readval | (0x1 << (32 - pos - 1));
+	else
+		writeval = readval & ~(0x1 << (32 - pos - 1));
+#ifdef DEBUG
+	printf("0x%08lx - After modify: 0x%08x\n", addr, writeval);
+#endif
+	*(volatile uint32_t *)buf = writeval;
+	unmap_sysmem(buf);
+}
+
+int gpio_read_bit(ulong addr, int pos)
+{
+	ulong bytes = 1;
+	uint32_t readvalue = 0;
+
+	const void *buf = map_sysmem(addr, bytes);
+
+	readvalue = *(volatile uint32_t *)buf;
+	unmap_sysmem(buf);
+
+	return (int)(readvalue & ( 0x1 << (32 - pos - 1))) >> (32 - pos - 1);
+}
+
+static int do_gpio_wb(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	if (argc < 4 || argc > 5)
+		return CMD_RET_USAGE;
+
+	gpio_write_bit(simple_strtoul(argv[1], NULL, 16), myatoi(argv[2]) - 1, myatoi(argv[3]));
+
+	return 0;
+}
+
+static int do_gpio_rb(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int value;
+	if (argc < 3 || argc > 4)
+		return CMD_RET_USAGE;
+
+	value = gpio_read_bit(simple_strtoul(argv[1], NULL, 16), myatoi(argv[2]) - 1);
+	if (value != 0 || value != 1)
+		return 1;
+#ifdef DEBUG
+	printf("%d\n", value);
+#endif
+	return 0;
+}
+
+uint usdelay(int us)
+{
+    int count=0;
+    for(count=0; count < us; count++)
+    {
+        udelay(1000);
+    }
+    return 0;
+}
+
+#ifdef LED_CLR_GPIO
+void led_start_symbol(void)
+{
+	int default_val = gpio_read_bit(GPIO4_DIRECTION, LED_CLR_GPIO);
+
+	gpio_write_bit(GPIO4_DIRECTION, LED_CLR_GPIO, OUTPUT);
+
+	usdelay(1);
+	gpio_write_bit(GPIO4_DATA, LED_CLR_GPIO, 1);
+	usdelay(1);
+	gpio_write_bit(GPIO4_DATA, LED_CLR_GPIO, 0);
+	usdelay(1);
+	gpio_write_bit(GPIO4_DATA, LED_CLR_GPIO, 1);
+
+	gpio_write_bit(GPIO4_DIRECTION, LED_CLR_GPIO, default_val);
+}
+#endif
+
+void led_init(void)
+{
+#ifdef LED_CLR_GPIO
+	led_start_symbol();
+#endif
+}
+
+void SDA(bool val)
+{
+	gpio_write_bit(GPIO4_DATA, LED_DATA_GPIO, val);
+	gpio_write_bit(GPIO4_DIRECTION, LED_DATA_GPIO, OUTPUT);
+        gpio_write_bit(GPIO4_DATA, LED_DATA_GPIO, val);
+}
+
+void SCL(bool val)
+{
+	gpio_write_bit(GPIO4_DATA, LED_CLOCK_GPIO, val);
+	gpio_write_bit(GPIO4_DIRECTION, LED_CLOCK_GPIO, OUTPUT);
+	gpio_write_bit(GPIO4_DATA, LED_CLOCK_GPIO, val);
+}
+
+void led_SDA(bool val)
+{
+	usdelay(1);
+	SDA(val);
+	usdelay(1);
+	SCL(1);
+	usdelay(2);
+	SCL(0);
+}
+
+void led_all_on(void)
+{
+	led_stat=0;
+
+	led_SDA(1);
+	led_SDA(1);
+	led_SDA(0);
+	led_SDA(0);
+	led_SDA(0);
+	led_SDA(0);
+}
+
+void led_all_off(void)
+{
+	led_stat = 1;
+	wifi_led_stat = 1;
+
+	int i;
+	for (i = 0; i < LEDNUM; i++) {
+		led_SDA(1);
+	}
+}
+
+void led_2G(void)
+{
+	wifi_led_stat = 2;
+	led_SDA(1);
+	led_SDA(0);
+	led_SDA(1);
+	led_SDA(1);
+	led_SDA(1);
+	led_SDA(1);
+}
+
+void led_5G(void)
+{
+	led_SDA(0);
+	led_SDA(1);
+	led_SDA(1);
+	led_SDA(1);
+	led_SDA(1);
+	led_SDA(1);
+}
+
+
+static int do_led(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	led_init();
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	if (!strcmp(argv[1],"on"))
+		led_all_on();
+	else if (!strcmp(argv[1],"off") || !strcmp(argv[1],"reset"))
+		led_all_off();
+	else if (!strcmp(argv[1],"2G"))
+		led_2G();	
+	else if (!strcmp(argv[1],"5G"))
+		led_5G();
+	else
+		return CMD_RET_USAGE;
+	return 0;
+}
+static int do_ledtest(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int i=0;
+	for (i = 1; i < argc; i++) {
+		led_SDA(myatoi(argv[i]));
+		printf("%d\n", myatoi(argv[i]));
+	}
+	return 0;
+}
+
+
+U_BOOT_CMD(ledtest, 9, 1, do_ledtest,"test","test");
+U_BOOT_CMD(led, 2, 1, do_led,
+	   "led control",
+	   " \n"
+	   "\tled on \n"
+	   "\tled off\n"
+	   "\tled 2G \n"
+	   "\tled 5G \n"
+	   "\tled reset \n");
+U_BOOT_CMD(gpiowrite, 4, 1, do_gpio_wb, "write a bit to gpio", "ex: gpiowrite 0xfe133000 15 1");
+U_BOOT_CMD(gpioread, 3, 1, do_gpio_rb, "read a bit of gpio", "ex: gpioread 0xfe133000 15");
