WatchGuard patches to sources for u-boot-2018.09 as of
Mon May  9 14:12:33 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- u-boot-2018.09/common/board_f.c.orig	2022-05-09 14:11:31.304682397 -0700
+++ u-boot-2018.09/common/board_f.c	2022-05-09 14:11:36.400476095 -0700
@@ -749,6 +749,10 @@
 	return 0;
 }
 
+#ifdef CONFIG_WG1008_VM1P
+extern int wg1008_vm1p_gpio_init(void);
+#endif
+
 static const init_fnc_t init_sequence_f[] = {
 	setup_mon_len,
 #ifdef CONFIG_OF_CONTROL
@@ -813,6 +817,9 @@
 #if defined(CONFIG_HARD_SPI)
 	init_func_spi,
 #endif
+#ifdef CONFIG_WG1008_VM1P
+	wg1008_vm1p_gpio_init,
+#endif
 	announce_dram_init,
 	dram_init,		/* configure available RAM banks */
 #ifdef CONFIG_POST
--- u-boot-2018.09/common/main.c.orig	2022-05-09 14:11:31.408678187 -0700
+++ u-boot-2018.09/common/main.c	2022-05-09 14:11:36.436474638 -0700
@@ -37,17 +37,75 @@
 #endif /* CONFIG_PREBOOT */
 }
 
+
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || defined(CONFIG_TARGET_LS1043AQDS_WG_T20) || defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+/* T80 */
+#if defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+#define RESET_BUTTON_GPIO_ADDR 0x2300008
+#define BUTTON_RESET                (7)
+#else /* T20/T40 */
+#define RESET_BUTTON_GPIO_ADDR 0x2330008
+#define BUTTON_RESET                (12)
+#endif
+
+/*
+* Read button status by given gpio number
+*/
+int read_btn_status(unsigned int btn)
+{
+	unsigned int reg_val = *(int *)(RESET_BUTTON_GPIO_ADDR);
+	
+	/* printf("read_btn_status: btn = %d, reg_val(%p) = 0x%x\n", btn, RESET_BUTTON_GPIO_ADDR, reg_val); */
+	/* Low active */
+	if (reg_val & (1 << (31 - btn - 8)) )
+		return 0;
+	else
+		return 1;
+}
+
+unsigned char detect_SYSB_keypress(void)
+{
+	int status = 0;
+	int i;
+	for(i = 0; i < 3; i++) {
+
+	        if (read_btn_status(BUTTON_RESET)) {
+			printf("booting into SYSB ... \n");
+			status = 1;
+			break;
+		}
+        	udelay(1000);
+	}
+
+	return status;
+}
+#endif /* end of CONFIG_TARGET_LS1043AQDS_WG_T40 || defined(CONFIG_TARGET_LS1043AQDS_WG_T20) || defined(CONFIG_TARGET_LS1046ARDB_WG_T80) */
+
+#ifdef CONFIG_MV88E6190_SWITCH
+extern int switch_mv88e6190_all_port_enable_once(void);
+#endif
+
 /* We come here after U-Boot is initialised and ready to process commands */
 void main_loop(void)
 {
 	const char *s;
+ #if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || defined(CONFIG_TARGET_LS1043AQDS_WG_T20) || defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+       unsigned char sysbReq;
+ #endif
 
 	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");
 
 #ifdef CONFIG_VERSION_VARIABLE
 	env_set("ver", version_string);  /* set version variable */
 #endif /* CONFIG_VERSION_VARIABLE */
+#ifdef CONFIG_WG1008_VM1P
+extern int resetBtnPressFlag;
 
+    char othbootargsStr[1024] = "";
+    char *firstMacAddr = env_get("ethaddr");
+    snprintf(othbootargsStr, sizeof(othbootargsStr) - 1, "DUT=%d ethaddr='%s' uboot_ver='%s'", resetBtnPressFlag?1:0, firstMacAddr, U_BOOT_VERSION_STRING);
+    env_set("othbootargs", othbootargsStr);  /* set version variable */
+#endif
 	cli_init();
 
 	run_preboot_environment_command();
@@ -60,8 +118,33 @@
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
 
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || defined(CONFIG_TARGET_LS1043AQDS_WG_T20) || defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+	sysbReq = detect_SYSB_keypress();
+	if(sysbReq == 1) {
+		if(env_get("Burn_In_Time") != NULL) {
+			 /* Assuming that mfgsys is the only user of "Burn_In_Time" */
+			env_set("bootcmd", "run wgBootODMOS");
+		} else {
+			if(!env_get("wgBootSysB")) {
+				/* throw an errors and exit booting */
+				printf("Reset button is pressed, but fail to boot into SYSB since env variable \"wgBootSysB\" can't be found!\n");
+				run_command("print wgBootSysB", 0);
+				cli_loop();
+			}
+			else {
+				env_set("bootcmd", "run wgBootSysB");
+			}
+		}
+		s = env_get("bootcmd");
+		run_command (s, 0);
+	}
+#endif /* end of CONFIG_TARGET_LS1043AQDS_WG_T40 || defined(CONFIG_TARGET_LS1043AQDS_WG_T20) || defined(CONFIG_TARGET_LS1046ARDB_WG_T80) */
+
 	autoboot_command(s);
 
+#ifdef CONFIG_MV88E6190_SWITCH
+	switch_mv88e6190_all_port_enable_once(); /* Make switch forward for network commands */
+#endif
 	cli_loop();
 	panic("No CLI available");
 }
--- u-boot-2018.09/common/Makefile.orig	2022-05-09 14:11:31.304682397 -0700
+++ u-boot-2018.09/common/Makefile	2022-05-09 14:11:36.388476581 -0700
@@ -7,6 +7,7 @@
 ifndef CONFIG_SPL_BUILD
 obj-y += init/
 obj-y += main.o
+obj-$(CONFIG_WG_BOOTMENU) += wgmenu.o
 obj-y += exports.o
 obj-$(CONFIG_HASH) += hash.o
 obj-$(CONFIG_HUSH_PARSER) += cli_hush.o
--- u-boot-2018.09/common/autoboot.c.orig	2022-05-09 14:11:31.304682397 -0700
+++ u-boot-2018.09/common/autoboot.c	2022-05-09 14:11:36.392476419 -0700
@@ -3,6 +3,7 @@
  * (C) Copyright 2000
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  */
+#define DEBUG
 
 #include <common.h>
 #include <autoboot.h>
@@ -208,25 +209,42 @@
 static int menukey;
 #endif
 
-static int __abortboot(int bootdelay)
+static int abortboot_normal(int bootdelay)
 {
 	int abort = 0;
 	unsigned long ts;
 
+#ifdef CONFIG_WG_BOOTMENU
+	int wg_env_vars_not_found = 0;
+	const char *s;
+	wgmenu_show();
+	int wg_break = 0;
+	int wg_keypress = 0;
+	int wg_selected = 0;
+	const char wg_pw_hash[] = { 0xe5, 0x97, 0x30, 0x1a, 0x1d, 0x89, 0xff, 0x3f, 0x6d, 0x31, 0x8d, 0xbf, 0x4d, 0xba, 0x0a, 0x5a, 0xbc, 0x5e, 0xcb, 0xea};
+	char wg_csum_output[20];
+#endif
+
 #ifdef CONFIG_MENUPROMPT
 	printf(CONFIG_MENUPROMPT);
 #else
-	printf("Hit any key to stop autoboot: %2d ", bootdelay);
+	if (bootdelay >= 0)
+		printf("Hit any key to stop autoboot: %2d ", bootdelay);
 #endif
 
+#if defined CONFIG_ZERO_BOOTDELAY_CHECK
 	/*
 	 * Check if key already pressed
+	 * Don't check if bootdelay < 0
 	 */
-	if (tstc()) {	/* we got a key press	*/
-		(void) getc();  /* consume input	*/
-		puts("\b\b\b 0");
-		abort = 1;	/* don't auto boot	*/
+	if (bootdelay >= 0) {
+		if (tstc()) {	/* we got a key press	*/
+			(void) getc();  /* consume input	*/
+			puts("\b\b\b 0");
+			abort = 1;	/* don't auto boot	*/
+		}
 	}
+#endif
 
 	while ((bootdelay > 0) && (!abort)) {
 		--bootdelay;
@@ -234,6 +252,54 @@
 		ts = get_timer(0);
 		do {
 			if (tstc()) {	/* we got a key press	*/
+# ifdef CONFIG_WG_BOOTMENU
+				/* Carriage return breaks us out of while() */
+				while (wg_keypress != 13) {
+					wg_keypress = getc();
+					wgmenu_hook(wg_keypress);
+					wg_selected = wgmenu_selected();
+					if (wg_keypress == 3) {	// CTRL+C
+						int wg_pw_len = 0;
+						wgmenu_exit();
+						printf("\x0D"); // go to the beginning of the line
+						printf("\e[2K"); // clear the line
+						wg_pw_len = cli_readline("password> ");
+						/* This if statement will not break from while if
+						 * we type a carriage return. */
+						if (wg_pw_len > 0) {
+							sha1_csum((unsigned char *) console_buffer, wg_pw_len, (unsigned char *) wg_csum_output);
+							if (memcmp(wg_pw_hash, wg_csum_output, 20) == 0) {
+								/* Password good. Assert abort and break
+								 * to prompt. */
+								abort = 1;
+								bootdelay = 0;
+								wg_break = 1;
+								break;
+							} else {
+								/* Bad password. */
+								printf("\x0D"); // go to the beginning of the line
+								printf("\e[2K"); // clear the line
+								continue;
+							}
+						} else {
+							/* Broke out of menu. Start the menu over.
+							 * Tell me how you got here, becuase this shouldn't happen. */
+							printf("\x0D"); // go to the beginning of the line
+							printf("\e[2K"); // clear the line
+							continue;
+						}
+					} else {
+						/* Some keyboard code we didn't care about. Start
+						 * the menu over. */
+						continue;
+					}
+					udelay(10000);
+				}
+				bootdelay = 0;
+				wg_break = 1;
+				wgmenu_exit();
+				break;
+# else /* !CONFIG_WG_BOOTMENU */
 				abort  = 1;	/* don't auto boot	*/
 				bootdelay = 0;	/* no more delay	*/
 # ifdef CONFIG_MENUKEY
@@ -241,16 +307,63 @@
 # else
 				(void) getc();  /* consume input	*/
 # endif
+# endif /* CONFIG_WG_BOOTMENU */
 				break;
 			}
 			udelay(10000);
 		} while (!abort && get_timer(ts) < 1000);
 
+#ifdef CONFIG_WG_BOOTMENU
+		if (!wg_break) {
+#endif /* CONFIG_WG_BOOTMENU */
 		printf("\b\b\b%2d ", bootdelay);
+#ifdef CONFIG_WG_BOOTMENU
+		}
+		if(env_get("Burn_In_Time") == NULL) {
+			if ((bootdelay == 0) && (abort != 1)) {
+				if (wg_selected >= 0) {
+					printf("\x0D"); // go to the beginning of the line
+					printf("\e[2K"); // clear the line
+					switch (wg_selected) {
+						case 1:
+							if(!env_get("wgBootSysB")) {/* Can remove this if wgBootSysB is defined in header file */
+								wg_env_vars_not_found = 1;
+								env_set("wgBootSysB", "setenv bootargs console=ttyS0,115200 root=/dev/sda2 earlycon=uart8250,mmio,0x21c0500; scsi scan; ext4load scsi 0:2 0x82000000 kernel_T20_T40.itb; bootm 0x82000000");
+							}
+							env_set("bootcmd", "run wgBootSysB");
+							printf("Booting SYSB");
+							break;
+
+						case 0:
+						default:
+							if(!env_get("wgBootSysA")) {/* Can remove this if wgBootSysA is defined in header file */
+								wg_env_vars_not_found = 1;
+								env_set("wgBootSysA", "setenv bootargs console=ttyS0,115200 root=/dev/sda3 earlycon=uart8250,mmio,0x21c0500; scsi scan; ext4load scsi 0:3 0x82000000 kernel_T20_T40.itb; bootm 0x82000000");
+							}
+								
+							env_set("bootcmd", "run wgBootSysA");
+							printf("Booting SYSA");
+							break;
+					}
+
+					if(wg_env_vars_not_found) {/* Can remove this if unneeded */
+						s = env_get("bootcmd");
+						printf("\nbootcmd string = \"%s\"\n", s);
+						run_command (s, 0);
+					}
+				}
+			}
+		}
+#endif /* CONFIG_WG_BOOTMENU */
 	}
 
 	putc('\n');
 
+#ifdef CONFIG_SILENT_CONSOLE
+	if (abort)
+		gd->flags &= ~GD_FLG_SILENT;
+#endif
+
 	return abort;
 }
 # endif	/* CONFIG_AUTOBOOT_KEYED */
@@ -260,7 +373,7 @@
 	int abort = 0;
 
 	if (bootdelay >= 0)
-		abort = __abortboot(bootdelay);
+		abort = abortboot_normal(bootdelay);
 
 #ifdef CONFIG_SILENT_CONSOLE
 	if (abort)
@@ -287,6 +400,7 @@
 #endif /* CONFIG_OF_CONTROL && CONFIG_SYS_TEXT_BASE */
 }
 
+#define DEBUG
 const char *bootdelay_process(void)
 {
 	char *s;
--- u-boot-2018.09/common/board_r.c.orig	2022-05-09 14:11:31.304682397 -0700
+++ u-boot-2018.09/common/board_r.c	2022-05-09 14:11:36.408475771 -0700
@@ -510,12 +510,64 @@
 #endif
 
 #ifdef CONFIG_CMD_NET
+#ifdef CONFIG_WG1008_VM1P
+extern int eth_env_get_enetaddr_by_index(const char *base_name, int index, uchar *enetaddr);
+extern int eth_env_set_enetaddr_by_index(const char *base_name, int index, uchar *enetaddr);
+
+static int incr_ethaddr(uchar *enetaddr, uchar incVal)
+{
+    uint tmpDigit = 0, idx = 0;
+    uchar tmpEnetaddr[6] = {0};
+
+    memcpy((void *)tmpEnetaddr, (void *)enetaddr, 6);
+    for(idx = 5; idx >= 0; idx--)
+    {
+        tmpDigit = (uint)tmpEnetaddr[idx] + (uint)incVal;
+        if(tmpDigit > 0xff)
+        {
+            tmpEnetaddr[idx] = tmpDigit - 0x100;
+            incVal = 1;
+        }
+        else
+        {
+            tmpEnetaddr[idx] = (uchar)tmpDigit;
+            break;
+        }
+    }
+    memcpy(enetaddr, tmpEnetaddr, 6);
+
+    return 0;
+}
+#endif
 static int initr_ethaddr(void)
 {
 	bd_t *bd = gd->bd;
 
 	/* kept around for legacy kernels only ... ignore the next section */
+#ifdef CONFIG_WG1008_VM1P
+    uchar tmpEnetaddr[6] = {0};
+    int idx = 0;
+    char tmpEthaddrStr[20] = "", tmpEthStr[32] = "";
+
+    if(!eth_env_get_enetaddr("ethaddr", bd->bi_enetaddr))
+    {
+        env_set("ethaddr", __stringify(CONFIG_ETHADDR));
+    }
+    memcpy(tmpEnetaddr, bd->bi_enetaddr, 6);
+    printf("MAC Addr of ethaddr : %s set.\n", env_get("ethaddr"));
+    for(idx = 1; idx < 8; idx++)
+    {
+        eth_env_get_enetaddr_by_index("eth", 0, tmpEnetaddr);
+        incr_ethaddr(tmpEnetaddr, idx);
+        snprintf(tmpEthaddrStr, sizeof(tmpEthaddrStr), "%02x:%02x:%02x:%02x:%02x:%02x"
+                , tmpEnetaddr[0], tmpEnetaddr[1], tmpEnetaddr[2], tmpEnetaddr[3], tmpEnetaddr[4], tmpEnetaddr[5]);
+        snprintf(tmpEthStr, sizeof(tmpEthStr), "eth%daddr", idx);
+        env_set(tmpEthStr, tmpEthaddrStr);
+        printf("MAC Addr of %s : %s set.\n", tmpEthStr, env_get(tmpEthStr));
+    }
+#else
 	eth_env_get_enetaddr("ethaddr", bd->bi_enetaddr);
+#endif
 #ifdef CONFIG_HAS_ETH1
 	eth_env_get_enetaddr("eth1addr", bd->bi_enet1addr);
 #endif
--- u-boot-2018.09/drivers/net/phy/phy.c.orig	2022-05-09 14:11:32.568631226 -0700
+++ u-boot-2018.09/drivers/net/phy/phy.c	2022-05-09 14:11:36.868457149 -0700
@@ -446,6 +446,207 @@
 	return 0;
 }
 
+#ifdef CONFIG_MV88E6190_SWITCH
+#define TIME_OUT 10
+#define _DPRINTF DBG_PRINTF
+
+unsigned short ReadReg(unsigned short addr, unsigned short reg)
+{
+    unsigned short	data = 0;
+    int ret = 0;
+    const char	*devname = NULL;
+
+    devname = miiphy_get_current_dev();
+    ret = miiphy_read (devname, addr, reg, &data);
+    DBG_PRINTF(
+        "miiphy_read (devname=%s, addr=0x%02x, reg=0x%02x, data=0x%02x), ret=%d\n",
+        devname, addr, reg, data, ret);
+    if(!ret)
+    {
+        return data;
+    }
+    else
+    {
+        printf(
+            "Error reading from the PHY addr=%02x reg=%02x\n",
+            addr, reg);
+        return 0xff;
+    }
+}
+
+void WriteReg(unsigned short addr, unsigned short reg, unsigned short data)
+{
+    int ret = 0;
+    const char	*devname = NULL;
+
+    devname = miiphy_get_current_dev();
+    ret = miiphy_write (devname, addr, reg, data);
+    DBG_PRINTF(
+        "miiphy_write (devname=%s, addr=0x%02x, reg=0x%02x, data=0x%02x), ret=%d\n",
+        devname, addr, reg, data, ret);
+    if(ret)
+    {
+        printf("Error writing to the PHY addr=%02x reg=%02x\n",
+               addr, reg);
+    }
+}
+
+
+unsigned short marvell_phy_read(unsigned short smi_id, unsigned short offset, unsigned short *output )
+{
+    unsigned short l_value, l_command, l_status;
+
+    l_command = 0 ;
+    l_command = smi_id << 5  | offset ;
+    //phy_command |=  0x9c00  ;  //read
+    l_command |=  0x9800  ;  //read
+    WriteReg(0x1c, 0x18, l_command);
+
+    do
+    {
+        l_status = ReadReg(0x1c,0x18) ;
+    }
+    while (l_status & 0x8000);
+
+    l_value = ReadReg(0x1c,0x19) ;
+    *output = l_value ;
+    return 0  ;
+}
+
+unsigned short marvell_phy_write(unsigned short smi_id, unsigned short offset, unsigned short data )
+{
+    unsigned short l_command, l_status;
+
+    l_command = 0 ;
+    l_command = smi_id << 5  | offset ;
+    l_command |=  0x9400  ;  //write
+
+    WriteReg(0x1c, 0x19, data);
+    WriteReg(0x1c, 0x18, l_command);
+
+    do
+    {
+        l_status = ReadReg(0x1c,0x18) ;
+    }
+    while (l_status & 0x8000);
+
+    mdelay(5);
+
+    return 0 ;
+}
+
+unsigned short osDelay(int second )
+{
+    int l_i = 0;
+    int l_j = 0;
+    int l_t = 0;
+    int l_temp = 0;
+
+    if(l_temp); /* Make compiler happy */
+    for(l_i=0; l_i < second; l_i++)
+    {
+        for(l_j=0; l_j <30000; l_j++)
+        {
+            for(l_t=0; l_t < 20  ; l_t++)
+            {
+                l_temp = l_i+ l_j + l_t;
+            }
+        }
+    }
+
+    return 0 ;
+}
+
+//
+//  if input SMI_ID > 2 ,that mean is a MAC side serdes access
+//  SMI mode will use "internal"
+unsigned short xsmi_read(unsigned short smi_mode,unsigned short smi_id,unsigned short deviceId, unsigned short offset, unsigned short *output )
+{
+    int l_temp = 0;
+    unsigned short l_value, l_command;
+
+    if(smi_mode==SMI_I)
+        l_temp = 0x8000;
+    else
+        l_temp = 0xa000;
+
+    l_command = 0x0;
+    l_command = smi_id << 5  | deviceId ;
+    l_command |=  l_temp ;//write address
+    WriteReg(0x1c, 0x19, offset);
+    WriteReg(0x1c, 0x18, l_command);
+
+    do
+    {
+        l_value = ReadReg(0x1c,0x18) ;
+    }
+    while (l_value & 0x8000) ;
+
+    if(smi_mode==SMI_I)
+        l_temp = 0x8C00;
+    else
+        l_temp = 0xac00;
+
+    l_command = smi_id << 5  | deviceId ;
+    l_command |=  l_temp ;  //read data
+    WriteReg(0x1c, 0x18, l_command);
+
+    do
+    {
+        l_value = ReadReg(0x1c,0x18) ;
+    }
+    while (l_value & 0x8000) ;
+
+    l_value = ReadReg(0x1c,0x19) ;
+    *output = l_value;
+
+    return 0;
+}
+
+
+unsigned short xsmi_write(unsigned short smi_mode,unsigned short smi_id,unsigned short deviceId, unsigned short offset, unsigned short input )
+{
+    int l_temp = 0;
+    unsigned short l_value, l_command;
+
+    if(smi_mode==SMI_I)
+        l_temp = 0x8000;
+    else
+        l_temp = 0xa000;
+
+    l_command = 0x0;
+    l_command = smi_id << 5  | deviceId ;
+    l_command |=  l_temp  ;  //write address
+
+    WriteReg(0x1c, 0x19, offset);
+    WriteReg(0x1c, 0x18, l_command);
+
+    do
+    {
+        l_value = ReadReg(0x1c,0x18) ;
+    }
+    while (l_value & 0x8000) ;
+
+    if(smi_mode==SMI_I)
+        l_temp = 0x8400;
+    else
+        l_temp = 0xa400;
+
+    l_command = smi_id << 5  | deviceId ;
+    l_command |=  l_temp	;  //write data
+    WriteReg(0x1c, 0x19, input);
+    WriteReg(0x1c, 0x18, l_command);
+
+    do
+    {
+        l_value = ReadReg(0x1c,0x18) ;
+    }
+    while (l_value & 0x8000) ;
+
+    return 0 ;
+}
+#endif
+
 static struct phy_driver genphy_driver = {
 	.uid		= 0xffffffff,
 	.mask		= 0xffffffff,
@@ -645,12 +846,17 @@
 	dev->link = 0;
 	dev->interface = interface;
 
-#ifdef CONFIG_DM_ETH
+#ifndef CONFIG_WG1008_VM1P
+ #ifdef CONFIG_DM_ETH
 	dev->node = ofnode_null();
+ #endif
 #endif
 
+#ifdef CONFIG_WG1008_VM1P
+	dev->autoneg = AUTONEG_DISABLE;
+#else
 	dev->autoneg = AUTONEG_ENABLE;
-
+#endif
 	dev->addr = addr;
 	dev->phy_id = phy_id;
 	dev->bus = bus;
--- u-boot-2018.09/drivers/net/fm/init.c.orig	2022-05-09 14:11:32.464635436 -0700
+++ u-boot-2018.09/drivers/net/fm/init.c	2022-05-09 14:11:36.844458120 -0700
@@ -139,7 +139,16 @@
 
 		enet_if = fman_port_enet_if(fm_info[i].port);
 		if (enet_if != PHY_INTERFACE_MODE_NONE) {
+#ifdef CONFIG_WG1008_VM1P
+			if(FM1_DTSEC9 == fm_info[i].port \
+			   || FM1_DTSEC10 == fm_info[i].port) {
+				fm_info[i].enabled = 1;
+			} else {
+				fm_info[i].enabled = 0;
+			}
+#else
 			fm_info[i].enabled = 1;
+#endif
 			fm_info[i].enet_if = enet_if;
 		} else {
 			fm_info[i].enabled = 0;
--- u-boot-2018.09/drivers/net/fm/memac_phy.c.orig	2022-05-09 14:11:32.464635436 -0700
+++ u-boot-2018.09/drivers/net/fm/memac_phy.c	2022-05-09 14:11:36.844458120 -0700
@@ -41,14 +41,21 @@
 {
 	u32 mdio_ctl;
 	struct memac_mdio_controller *regs = bus->priv;
-	u32 c45 = 1; /* Default to 10G interface */
 
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+	defined(CONFIG_TARGET_LS1043AQDS_WG_T20) 
+	dev_addr = regnum & 0x1f;
+	memac_clrbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
+#else
+	u32 c45 = 1; /* Default to 10G interface */
+ 
 	if (dev_addr == MDIO_DEVAD_NONE) {
 		c45 = 0; /* clause 22 */
 		dev_addr = regnum & 0x1f;
 		memac_clrbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
 	} else
 		memac_setbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
+#endif
 
 	/* Wait till the bus is free */
 	while ((memac_in_32(&regs->mdio_stat)) & MDIO_STAT_BSY)
@@ -58,10 +65,14 @@
 	mdio_ctl = MDIO_CTL_PORT_ADDR(port_addr) | MDIO_CTL_DEV_ADDR(dev_addr);
 	memac_out_32(&regs->mdio_ctl, mdio_ctl);
 
+#if !defined(CONFIG_TARGET_LS1043AQDS_WG_T40) && \
+	!defined(CONFIG_TARGET_LS1043AQDS_WG_T20) 
 	/* Set the register address */
 	if (c45)
 		memac_out_32(&regs->mdio_addr, regnum & 0xffff);
 
+#endif
+
 	/* Wait till the bus is free */
 	while ((memac_in_32(&regs->mdio_stat)) & MDIO_STAT_BSY)
 		;
@@ -86,8 +97,10 @@
 {
 	u32 mdio_ctl;
 	struct memac_mdio_controller *regs = bus->priv;
+#if !defined(CONFIG_TARGET_LS1043AQDS_WG_T40) && \
+	!defined(CONFIG_TARGET_LS1043AQDS_WG_T20) 
 	u32 c45 = 1;
-
+ 
 	if (dev_addr == MDIO_DEVAD_NONE) {
 		if (!strcmp(bus->name, DEFAULT_FM_TGEC_MDIO_NAME))
 			return 0xffff;
@@ -96,6 +109,12 @@
 		memac_clrbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
 	} else
 		memac_setbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
+#else
+	dev_addr = regnum & 0x1f;
+	memac_clrbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
+#endif
+	dev_addr = regnum & 0x1f;
+	memac_clrbits_32(&regs->mdio_stat, MDIO_STAT_ENC);
 
 	/* Wait till the bus is free */
 	while ((memac_in_32(&regs->mdio_stat)) & MDIO_STAT_BSY)
@@ -105,10 +124,13 @@
 	mdio_ctl = MDIO_CTL_PORT_ADDR(port_addr) | MDIO_CTL_DEV_ADDR(dev_addr);
 	memac_out_32(&regs->mdio_ctl, mdio_ctl);
 
+#if !defined(CONFIG_TARGET_LS1043AQDS_WG_T40) && \
+	!defined(CONFIG_TARGET_LS1043AQDS_WG_T20) 
 	/* Set the register address */
 	if (c45)
 		memac_out_32(&regs->mdio_addr, regnum & 0xffff);
 
+#endif
 	/* Wait till the bus is free */
 	while ((memac_in_32(&regs->mdio_stat)) & MDIO_STAT_BSY)
 		;
--- u-boot-2018.09/drivers/net/fm/eth.c.orig	2022-05-09 14:11:32.464635436 -0700
+++ u-boot-2018.09/drivers/net/fm/eth.c	2022-05-09 14:11:36.844458120 -0700
@@ -478,7 +478,11 @@
 	fm_eth->phydev->link = 1;
 	fm_eth->phydev->duplex = DUPLEX_FULL;
 #endif
-
+#ifdef CONFIG_WG1008_VM1P
+    fm_eth->phydev->speed = 2500;
+    fm_eth->phydev->link = 1;
+    fm_eth->phydev->duplex = DUPLEX_FULL;
+#endif
 	/* set the MAC-PHY mode */
 	mac->set_if_mode(mac, fm_eth->enet_if, fm_eth->phydev->speed);
 
@@ -726,6 +730,945 @@
 	return 0;
 }
 
+
+#ifdef CONFIG_MV88E6190_SWITCH
+//#define CONFIG_ERRATA_FIX
+#if 1
+#define GPORT_START_NUM 1
+#define GPORT_END_NUM 8
+#else
+#define GPORT_START_NUM 0
+#define GPORT_END_NUM -1
+#endif
+#define CPU_PORT_START_NUM 9
+#define CPU_PORT_END_NUM 10
+#define SW_DBG_PRINTF(format, args...) printf("[%s:%d] "format, __FUNCTION__, __LINE__, ##args)
+
+int switch_mv88e6190_port_led(u32 mode)
+{
+    int i = 0;
+    u16 regVal = 0x0;
+
+    switch(mode)
+    {
+        case PORT_LED_MODE_OFF:
+            regVal = 0x80ee;
+            break;
+        case PORT_LED_MODE_GREEN:
+            regVal = 0x80fe;
+            break;
+        case PORT_LED_MODE_AMBER:
+            regVal = 0x80ef;
+            break;
+        case PORT_LED_MODE_NORMAL:
+            regVal = 0x8012;
+            break;
+        case PORT_LED_MODE_ALLON:
+            regVal = 0x80ff;
+            break;
+        default:
+            return -1;
+    }
+    for (i=1; i<=8; i++)
+    {
+        WriteReg(i,0x16,regVal); // Set the LED mode
+    }
+
+    return 0;
+}
+
+#define MV88E6190_PAGE_ACCESS_REG            0x16
+
+#define MV88E6190_COPPER_CTRL_PAGE            0x0
+#define MV88E6190_COPPER_CTRL_REG             0x0
+#define MV88E6190_COPPER_CTRL_SW_RESET_BIT    15
+#define MV88E6190_COPPER_CTRL_LB_BIT          14
+#define MV88E6190_COPPER_CTRL_SPD_SEL_LSB_BIT 13 /* Bit 6,3 */
+#define MV88E6190_COPPER_CTRL_SPD_SEL_MSB_BIT  6 /* 11 = Reserved, 10 = 1000 Mbps, 01 = 100 Mbps, 00 = 10 Mbps */
+#define MV88E6190_COPPER_CTRL_AN_EN_BIT       12
+#define MV88E6190_COPPER_CTRL_PWR_DOWN_BIT    11
+#define MV88E6190_COPPER_CTRL_RESTART_AN_BIT   9
+#define MV88E6190_COPPER_CTRL_DUPLEX_MOD_BIT   8
+#define MV88E6190_COPPER_CTRL_DUPLEX_MOD_BIT   8
+
+#define MV88E6190_COPPER_SPECIFIC_CTRL_1_PAGE 0x0
+#define MV88E6190_COPPER_SPECIFIC_CTRL_1_REG 0x10
+#define MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_0_BIT 5
+#define MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_1_BIT 6
+
+#define MV88E6190_COPPER_STATUS_PAGE                 0x0
+#define MV88E6190_COPPER_STATUS_REG                  0x1
+#define MV88E6190_COPPER_STATUS_COP_AN_COMP_BIT      5
+#define MV88E6190_COPPER_STATUS_COP_REMOTE_FAULT_BIT 4
+#define MV88E6190_COPPER_STATUS_COP_LINK_STATUS_BIT  2
+#define MV88E6190_COPPER_STATUS_JABBER_DETECT_BIT    1
+#define MAX_AN_COMPLETE_WAIT_RETRY       100
+#define MAX_AN_COMPLETE_WAIT_RETRY_DELAY 100000 /* micro-seconds */
+#define DEFAULT_AN_DELAY 4 /* seconds */
+
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE                0x0
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_REG                0x11
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_SPEED_BIT            14
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_SPEED_MASK          0x3
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_DUPLEX_BIT           13
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_COP_LINK_RT_BIT      10
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_MDI_BIT               6
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_GLOB_LINK_STATUS_BIT  3
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_DTE_PWR_STATUS_BIT    2
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_POLARITY_RT_BIT       1
+#define MV88E6190_COPPER_SPECIFIC_STATUS_1_JABBER_RT_BIT         0
+
+
+int switch_mv88e6190_port_autonego(u16 port, u32 *an, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_CTRL_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG, MV88E6190_COPPER_CTRL_PAGE);
+        return -1;
+    }
+
+    if(marvell_phy_read(port, MV88E6190_COPPER_CTRL_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG);
+        return -1;
+    }
+
+    if(read)
+    {
+        *an = (val & (1<<MV88E6190_COPPER_CTRL_AN_EN_BIT))?1:0;
+        return 0;
+    }
+    if(*an)
+    {
+        val |= (1<<MV88E6190_COPPER_CTRL_AN_EN_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    }
+    else
+    {
+        val &= ~(1<<MV88E6190_COPPER_CTRL_AN_EN_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    }
+
+    if(marvell_phy_write(port, MV88E6190_COPPER_CTRL_REG, val))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG, val);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_speed(u16 port, u32 *speed, int read) /* speed unit : Mbps */
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_CTRL_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG, MV88E6190_COPPER_CTRL_PAGE);
+        return -1;
+    }
+
+    if(marvell_phy_read(port, MV88E6190_COPPER_CTRL_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG);
+        return -1;
+    }
+    /* Bit 6,3 : 11 = Reserved, 10 = 1000 Mbps, 01 = 100 Mbps, 00 = 10 Mbps */
+    if(read)
+    {
+        u16 msb = (val & (1<<MV88E6190_COPPER_CTRL_SPD_SEL_MSB_BIT))?1:0;
+        u16 lsb = (val & (1<<MV88E6190_COPPER_CTRL_SPD_SEL_LSB_BIT))?1:0;
+        if(msb && !lsb)
+        {
+            *speed = 1000;
+        }
+        else if(!msb && lsb)
+        {
+            *speed = 100;
+        }
+        else if(!msb && !lsb)
+        {
+            *speed = 10;
+        }
+        else
+        {
+            *speed = 0;
+            return -1;
+        }
+        return 0;
+    }
+
+    /* Bit 6,3 : 11 = Reserved, 10 = 1000 Mbps, 01 = 100 Mbps, 00 = 10 Mbps */
+    if(*speed == 10)
+    {
+        val &= ~(1<<MV88E6190_COPPER_CTRL_SPD_SEL_MSB_BIT);
+        val &= ~(1<<MV88E6190_COPPER_CTRL_SPD_SEL_LSB_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    }
+    else if(*speed == 100)
+    {
+        val &= ~(1<<MV88E6190_COPPER_CTRL_SPD_SEL_MSB_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SPD_SEL_LSB_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    }
+    else if(*speed == 1000)
+    {
+        val |= (1<<MV88E6190_COPPER_CTRL_SPD_SEL_MSB_BIT);
+        val &= ~(1<<MV88E6190_COPPER_CTRL_SPD_SEL_LSB_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    }
+    else
+    {
+        printf("Port %u invalid speed %u!!!\n", port, *speed);
+        return -1;
+    }
+
+    if(marvell_phy_write(port, MV88E6190_COPPER_CTRL_REG, val))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG, val);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_duplex(u16 port, u32 *fullDupex, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_CTRL_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG, MV88E6190_COPPER_CTRL_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_CTRL_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG);
+        return -1;
+    }
+    if(read)
+    {
+        *fullDupex = (val & (1<<MV88E6190_COPPER_CTRL_DUPLEX_MOD_BIT))?1:0;
+        return 0;
+    }
+
+    if(*fullDupex)
+    {
+        val |= (1<<MV88E6190_COPPER_CTRL_DUPLEX_MOD_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    }
+    else
+    {
+        val &= ~(1<<MV88E6190_COPPER_CTRL_DUPLEX_MOD_BIT);
+        val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    }
+
+    if(marvell_phy_write(port, MV88E6190_COPPER_CTRL_REG, val))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG, val);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_mdi_mode(u16 port, u32 *mdiMode, int read)
+{
+    u16 val = 0, msb = 0, lsb = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_CTRL_1_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_CTRL_1_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_SPECIFIC_CTRL_1_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_SPECIFIC_CTRL_1_REG);
+        return -1;
+    }
+    /*
+     00 = Manual MDI
+     01 = Manual MDIX
+     10 = Resverved
+     11 = Enable auto crossover for all modes
+     */
+    if(read)
+    {
+        msb = (val & (1<<MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_1_BIT))?1:0;
+        lsb = (val & (1<<MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_0_BIT))?1:0;
+        *mdiMode = lsb | (msb << 1);
+        return 0;
+    }
+
+    lsb = (*mdiMode & (1<<0))?1:0;
+    msb = (*mdiMode & (1<<1))?1:0;
+    if(lsb)
+    {
+        val |= (1<<MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_0_BIT);
+    }
+    else
+    {
+        val &= ~(1<<MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_0_BIT);
+    }
+    if(msb)
+    {
+        val |= (1<<MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_1_BIT);
+    }
+    else
+    {
+        val &= ~(1<<MV88E6190_COPPER_SPECIFIC_CTRL_MDI_MOD_1_BIT);
+    }
+
+    if(marvell_phy_write(port, MV88E6190_COPPER_SPECIFIC_CTRL_1_REG, val))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_SPECIFIC_CTRL_1_REG, val);
+        return -1;
+    }
+
+    /* Software Reset to take effect */
+    if(marvell_phy_read(port, MV88E6190_COPPER_CTRL_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG);
+        return -1;
+    }
+    val |= (1<<MV88E6190_COPPER_CTRL_SW_RESET_BIT);
+    if(marvell_phy_write(port, MV88E6190_COPPER_CTRL_REG, val))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_COPPER_CTRL_REG, val);
+        return -1;
+    }
+    /* Software Reset to take effect */
+
+    return 0;
+}
+
+int switch_mv88e6190_port_copper_link_status_read(u16 port, u32 *status, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_STATUS_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_STATUS_REG);
+        return -1;
+    }
+    *status = (val & (1<<MV88E6190_COPPER_STATUS_COP_LINK_STATUS_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_copper_remote_fault_read(u16 port, u32 *fault, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_STATUS_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_STATUS_REG);
+        return -1;
+    }
+    *fault = (val & (1<<MV88E6190_COPPER_STATUS_COP_REMOTE_FAULT_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_jabber_detect_read(u16 port, u32 *jabber, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_STATUS_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_STATUS_REG);
+        return -1;
+    }
+    *jabber = (val & (1<<MV88E6190_COPPER_STATUS_JABBER_DETECT_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_autonego_complete_read(u16 port, u32 *complete, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_STATUS_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_STATUS_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_STATUS_REG);
+        return -1;
+    }
+    *complete = (val & (1<<MV88E6190_COPPER_STATUS_COP_AN_COMP_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_cop_specific_speed_read(u16 port, u32 *speed, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG);
+        return -1;
+    }
+    val = (val>>MV88E6190_COPPER_SPECIFIC_STATUS_1_SPEED_BIT) & MV88E6190_COPPER_SPECIFIC_STATUS_1_SPEED_MASK;
+    if(val == 2)
+    {
+        *speed = 1000;
+    }
+    else if(val == 1)
+    {
+        *speed = 100;
+    }
+    else if(val == 0)
+    {
+        *speed = 10;
+    }
+    else
+    {
+        printf("Port 0x%x invalid speed 0x%x!!!\n", port, val);
+        return -1;
+    }
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_cop_specific_duplex_read(u16 port, u32 *duplex, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG);
+        return -1;
+    }
+    *duplex = (val & (1<<MV88E6190_COPPER_SPECIFIC_STATUS_1_DUPLEX_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_cop_specific_mdix_read(u16 port, u32 *mdix, int read) /* midx : 1; mdi : 0 */
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG);
+        return -1;
+    }
+    *mdix = (val & (1<<MV88E6190_COPPER_SPECIFIC_STATUS_1_MDI_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_cop_specific_cop_link_rt_read(u16 port, u32 *staus, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG);
+        return -1;
+    }
+    *staus = (val & (1<<MV88E6190_COPPER_SPECIFIC_STATUS_1_COP_LINK_RT_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_cop_specific_global_link_status_read(u16 port, u32 *staus, int read)
+{
+    u16 val = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+    /* Switch Page */
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, MV88E6190_COPPER_SPECIFIC_STATUS_1_PAGE);
+        return -1;
+    }
+    if(marvell_phy_read(port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG, &val))
+    {
+        printf("Failed to read port 0x%x, reg 0x%x!!!\n", port, MV88E6190_COPPER_SPECIFIC_STATUS_1_REG);
+        return -1;
+    }
+    *staus = (val & (1<<MV88E6190_COPPER_SPECIFIC_STATUS_1_GLOB_LINK_STATUS_BIT))?1:0;
+
+    if(marvell_phy_write(port, MV88E6190_PAGE_ACCESS_REG, 0))
+    {
+        printf("Failed to write port 0x%x, reg 0x%x, val 0x%x!!!\n", port, MV88E6190_PAGE_ACCESS_REG, 0);
+        return -1;
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_wait_autonego_complete(u16 port)
+{
+    u32 complete = 0, retryCount = 0;
+    int ret = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("Invalid port %u!!!\n", port);
+        return -1;
+    }
+
+    do
+    {
+        ret = switch_mv88e6190_port_autonego_complete_read(port, &complete, 1);
+        if(ret)
+        {
+            complete = 0;
+        }
+        udelay(MAX_AN_COMPLETE_WAIT_RETRY_DELAY);
+        retryCount++;
+    }
+    while(!complete && (retryCount <= MAX_AN_COMPLETE_WAIT_RETRY));
+
+    if(retryCount > MAX_AN_COMPLETE_WAIT_RETRY)
+    {
+        printf("Port 0x%x failed to complete autonego!!!\n", port);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+int switch_mv88e6190_port_cop_failure_recover(u16 port, int isAnWait, u32 *linkup, int isLog)
+{
+    u32 tmpStaus = 0, rtLink = 0, copLink = 0, glbLink = 0;
+
+    if(port > GPORT_END_NUM || port < GPORT_START_NUM)
+    {
+        printf("\nInvalid port %u!!!\n", port);
+        return -1;
+    }
+    if(linkup)
+        *linkup = 0;
+
+    switch_mv88e6190_port_cop_specific_cop_link_rt_read(port, &rtLink, 1);
+    if(isLog)printf("\nPort %d realtime link status : %u", port, rtLink);
+    switch_mv88e6190_port_copper_link_status_read(port, &copLink, 1);
+    if(isLog)printf(", copper link status : %u", copLink);
+    switch_mv88e6190_port_cop_specific_global_link_status_read(port, &glbLink, 1);
+    if(isLog)printf(", global link status : %u", glbLink);
+    switch_mv88e6190_port_autonego_complete_read(port, &tmpStaus, 1);
+    if(isLog)printf(", autonego complete : %u", tmpStaus);
+    switch_mv88e6190_port_copper_remote_fault_read(port, &tmpStaus, 1);
+    if(isLog)printf(", remote fault : %u", tmpStaus);
+    switch_mv88e6190_port_jabber_detect_read(port, &tmpStaus, 1);
+    if(isLog)printf(", jabber detect : %u\n", tmpStaus);
+
+    if((rtLink ^ copLink) || (copLink ^ glbLink) || (glbLink ^ rtLink))
+    {
+        printf("\nPort %d realtime link status : %u", port, rtLink);
+        printf(", copper link status : %u", copLink);
+        printf(", global link status : %u are not the same!!!\n", glbLink);
+    }
+
+    if(rtLink || copLink || rtLink)
+    {
+        if(linkup)
+            *linkup = 1;
+        if(isLog)printf("\nPort %d AN restart...", port);
+        marvell_phy_write(port, 0,0x1340); // Restart AN
+        if(isAnWait)switch_mv88e6190_port_wait_autonego_complete(port);
+        if(isLog)printf("done\n");
+    }
+
+    return 0;
+}
+
+int switch_mv88e6190_port_cop_failure_recover_all(int isLog)
+{
+    u16 i = 0;
+    u32 LinkStatus[8] = {0};
+
+    for (i = GPORT_START_NUM; i <= GPORT_END_NUM; i ++)
+    {
+        switch_mv88e6190_port_cop_failure_recover(i, 0, &LinkStatus[i - 1], isLog);
+    }
+    for (i = GPORT_START_NUM; i <= GPORT_END_NUM; i ++)
+    {
+        if(LinkStatus[i - 1])
+        {
+            switch_mv88e6190_port_wait_autonego_complete(i);
+        }
+    }
+
+    return 0;
+}
+
+void phyInit(void)
+{
+    unsigned short PHY = 0;
+    //Begin Errata workarounds
+
+    //C22RegWrite(PHY, 0, 0x1140, 0);
+
+    //Begin PHY recalibration
+    for (PHY = GPORT_START_NUM; PHY <= GPORT_END_NUM; PHY ++)
+    {
+        marvell_phy_write(PHY, 0, 0x1140);
+    }
+    //osDelay(1);
+    udelay(1000000); // use udelay for 1sec delay ..
+
+
+    for (PHY = GPORT_START_NUM; PHY <= GPORT_END_NUM; PHY ++)
+    {
+        marvell_phy_write(PHY, 0x16, 0x00F8);
+    }
+    for (PHY = GPORT_START_NUM; PHY <= GPORT_END_NUM; PHY ++)
+    {
+        marvell_phy_write(PHY, 0x8, 0x0036);
+    }
+    for (PHY = GPORT_START_NUM; PHY <= GPORT_END_NUM; PHY ++)
+    {
+        marvell_phy_write(PHY, 0x16, 0x0000);
+    }
+    for (PHY = GPORT_START_NUM; PHY <= GPORT_END_NUM; PHY ++)
+    {
+        marvell_phy_write(PHY, 0x0, 0x9140);
+    }
+    // Adjust 10M IEEE VOD
+    for (PHY = GPORT_START_NUM; PHY <= GPORT_END_NUM; PHY ++)
+    {
+        marvell_phy_write(PHY, 0x16, 0xfc);
+        marvell_phy_write(PHY, 0x11, 0xaaff);
+        marvell_phy_write(PHY, 0x16, 0x0);
+        marvell_phy_write(PHY, 0x14, 0x0020);
+    }
+}
+
+void PeridotErrata(void)
+{
+	//End PHY recalibration
+	
+	//Begin stuck port issue
+	//Disable all Ports
+	//Perform Workaround
+	WriteReg(5,0x1A,0x01C0);
+	WriteReg(4,0x1A,0xFC00);
+	WriteReg(4,0x1A,0xFC20);
+	WriteReg(4,0x1A,0xFC40);
+	WriteReg(4,0x1A,0xFC60);
+	WriteReg(4,0x1A,0xFC80);
+	WriteReg(4,0x1A,0xFCA0);
+	WriteReg(4,0x1A,0xFCC0);
+	WriteReg(4,0x1A,0xFCE0);
+	WriteReg(4,0x1A,0xFD00);
+	WriteReg(4,0x1A,0xFD20);
+	WriteReg(4,0x1A,0xFD40);
+
+	/* reset */
+	WriteReg(0x1b, 0x4, 0xC001);
+
+	//End Stuck port issue
+}
+
+int switch_mv88e6190_andelay = DEFAULT_AN_DELAY;
+
+int resetBtnPressFlag = 0;
+
+int switch_mv88e6190_all_port_enable_once(void)
+{
+    int i = 0;
+    static int has_run = 0;
+
+    if(has_run)
+    {
+        return 0;
+    }
+    else
+    {
+        has_run = 1;
+    }
+    printf("Switch 88E6190 all ports enable.\n");
+    for (i=GPORT_START_NUM;i<=GPORT_END_NUM;i++)
+    {
+        WriteReg(i,4,0x7f); //Set port as fowarding ..
+    }
+
+    for (i=CPU_PORT_START_NUM;i<=CPU_PORT_END_NUM;i++)
+    {
+        WriteReg(i,4,0x7f); //Set port as fowarding ..
+    }
+    udelay(100000);
+
+    return 0;
+}
+
+int switch_mv88e6190_init(void)
+{
+    int i = 0;
+    char *anDelayChar = NULL;
+
+    resetBtnPressFlag = resetBtnPressed();
+    if(resetBtnPressFlag)
+    {
+        printf("Reset button pressed.\n");
+    }
+
+    printf("Marvell Switch 88E6190 init...");
+    anDelayChar = env_get("andelay");
+    if (anDelayChar)
+        switch_mv88e6190_andelay = simple_strtol(anDelayChar, NULL, 10);
+
+    DBG_PRINTF("===== Change all pot to disabled mode ..\n");
+
+    WriteReg(0,1,0x13);     // Port 0
+    WriteReg(CPU_PORT_START_NUM,1,0x13);    // Port 9/10
+    WriteReg(CPU_PORT_END_NUM,1,0x13);  // Turn off Link in default ..
+
+    //PeridotErrata(); //Move to end of init procedure 
+
+    // Set C_MODE for port 9 and 10
+    WriteReg(CPU_PORT_START_NUM,0,0xb);
+    WriteReg(CPU_PORT_END_NUM,0,0xb);
+
+    DBG_PRINTF("=====Marvell 1G Port PHYs Reset delay...");
+    udelay(1000000);
+    DBG_PRINTF("done\n");
+
+    // Power up on-chip serdes 
+    // Port 9, Lane 9 
+    xsmi_write(SMI_I,CPU_PORT_START_NUM,4,0x2000,0xA040); //Clear power down bit and set bit 15 for reset ,16 and 3 for speed
+    // Port 10 Lane 0xA 
+    xsmi_write(SMI_I,CPU_PORT_END_NUM,4,0x2000,0xA040);   //Clear power down bit and set bit 15 for reset ,16 and 3 for speed
+    udelay(100000);
+
+    PeridotErrata();
+
+    phyInit();
+
+    DBG_PRINTF("===== Change all pot to fowarding mode ..\n");
+    for (i=GPORT_START_NUM;i<=GPORT_END_NUM;i++)
+    {
+        WriteReg(i,0x1,0x102); // Turn off integrated gigabit port EEE from MAC side
+        WriteReg(i,4,0x7c); //Set port as disabled ..
+    }
+
+    for (i=CPU_PORT_START_NUM;i<=CPU_PORT_END_NUM;i++)
+    {
+        WriteReg(i,0x1,0x103); //Force EEE mode off for P9 and P10 for lower core power when not linked
+        WriteReg(i,4,0x7c); //Set port as disabled .. 
+    }
+    udelay(100000);
+
+#if 0
+	for (i = GPORT_START_NUM; i <= GPORT_END_NUM; i++)
+	{
+        marvell_phy_write(i, 0x9, 0x1e00); // Set Port Type as Master
+		marvell_phy_write(i, 0x0, 0x9140); // Power up
+	}
+    udelay(300000);
+#endif
+
+//    switch_mv88e6190_port_cop_failure_recover_all(1);
+
+    printf("done\n");
+
+    return 0;
+}
+#endif
+
+int marvell_nxp_sgmii_init(void)
+{
+    volatile u32 *tmpPtr = NULL, tmpVal = 0;
+
+#ifdef CONFIG_MV88E6190_SWITCH
+#ifdef CONFIG_MV88E6190_SWITCH_CPU_ATTACHED
+    switch_mv88e6190_init();
+#else
+    WriteReg(0x9, 0x0, 0xb);
+    DBG_PRINTF("WriteReg(0x9, 0x0) = 0x%04x\n", ReadReg(0x9, 0x0));
+    WriteReg(0xa, 0x0, 0xb);
+    DBG_PRINTF("WriteReg(0xa, 0x0) = 0x%04x\n", ReadReg(0xa, 0x0));
+#endif /* CONFIG_MV88E6190_SWITCH_CPU_ATTACHED */
+#endif /* CONFIG_MV88E6190_SWITCH */
+    tmpPtr = (volatile u32 *)0x1af0034;
+    *((u32 *)tmpPtr) = 0x00800000;
+    DBG_PRINTF("%p : 0x%08x\n", tmpPtr, *((u32 *)tmpPtr));
+    tmpPtr = (volatile u32 *)0x1af0038;
+    tmpVal = *tmpPtr;
+    *((u32 *)tmpPtr) = tmpVal & ~(1<<20);
+    DBG_PRINTF("%p : 0x%08x\n", tmpPtr, *((u32 *)tmpPtr));
+
+    tmpPtr = (volatile u32 *)0x1af2034;
+    *((u32 *)tmpPtr) = 0x00800000;
+    DBG_PRINTF("%p : 0x%08x\n", tmpPtr, *((u32 *)tmpPtr));
+    tmpPtr = (volatile u32 *)0x1af2038;
+    tmpVal = *tmpPtr;
+    *((u32 *)tmpPtr) = tmpVal & ~(1<<20);
+    DBG_PRINTF("%p : 0x%08x\n", tmpPtr, *((u32 *)tmpPtr));
+
+    return 0;
+}
+
 int fm_eth_initialize(struct ccsr_fman *reg, struct fm_eth_info *info)
 {
 	struct eth_device *dev;
--- u-boot-2018.09/drivers/mtd/spi/spi_flash_ids.c.orig	2022-05-09 14:11:32.376638999 -0700
+++ u-boot-2018.09/drivers/mtd/spi/spi_flash_ids.c	2022-05-09 14:11:36.824458930 -0700
@@ -88,6 +88,7 @@
 	{"mx25l25635f",	   INFO(0xc22019, 0x0, 64 * 1024,   512, RD_FULL | WR_QPP) },
 	{"mx25l51235f",	   INFO(0xc2201a, 0x0, 64 * 1024,  1024, RD_FULL | WR_QPP) },
 	{"mx25l1633e",	   INFO(0xc22415, 0x0, 64 * 1024,    32, RD_FULL | WR_QPP | SECT_4K) },
+	{"mx25u3235f",	   INFO(0xc22536, 0x0, 64 * 1024,    64, RD_FULL | WR_QPP) },
 	{"mx25u6435f",	   INFO(0xc22537, 0x0, 64 * 1024,   128, RD_FULL | WR_QPP) },
 	{"mx25l12855e",	   INFO(0xc22618, 0x0, 64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"mx25u1635e",     INFO(0xc22535, 0x0, 64 * 1024,  32, SECT_4K) },
--- u-boot-2018.09/arch/arm/include/asm/arch-fsl-layerscape/soc.h.orig	2022-05-09 14:11:25.920900355 -0700
+++ u-boot-2018.09/arch/arm/include/asm/arch-fsl-layerscape/soc.h	2022-05-09 14:11:35.384517226 -0700
@@ -113,7 +113,43 @@
 #define SVR_DEV(svr)		((svr) >> 8)
 #define IS_SVR_DEV(svr, dev)	(((svr) >> 16) == (dev))
 
+#if defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+/* ahci port register default value */
+#define AHCI_PORT_PHY_1_CFG    0xa003fffe
+#define AHCI_PORT_PHY2_CFG	0x28184d1f
+#define AHCI_PORT_PHY3_CFG	0x0e081509
+#define AHCI_PORT_TRANS_CFG    0x08000029
+#define AHCI_PORT_AXICC_CFG	0x3fffffff
+#endif // defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+
 #ifndef __ASSEMBLY__
+#if defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+/* AHCI (sata) register map */
+struct ccsr_ahci {
+	u32 res1[0xa4/4];	/* 0x0 - 0xa4 */
+	u32 pcfg;	/* port config */
+	u32 ppcfg;	/* port phy1 config */
+	u32 pp2c;	/* port phy2 config */
+	u32 pp3c;	/* port phy3 config */
+	u32 pp4c;	/* port phy4 config */
+	u32 pp5c;	/* port phy5 config */
+	u32 axicc;	/* AXI cache control */
+	u32 paxic;	/* port AXI config */
+	u32 axipc;	/* AXI PROT control */
+	u32 ptc;	/* port Trans Config */
+	u32 pts;	/* port Trans Status */
+	u32 plc;	/* port link config */
+	u32 plc1;	/* port link config1 */
+	u32 plc2;	/* port link config2 */
+	u32 pls;	/* port link status */
+	u32 pls1;	/* port link status1 */
+	u32 pcmdc;	/* port CMD config */
+	u32 ppcs;	/* port phy control status */
+	u32 pberr;	/* port 0/1 BIST error */
+	u32 cmds;	/* port 0/1 CMD status error */
+};
+#endif // defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+
 #ifdef CONFIG_FSL_LSCH3
 void fsl_lsch3_early_init_f(void);
 int get_core_volt_from_fuse(void);
--- u-boot-2018.09/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h.orig	2022-05-09 14:11:25.920900355 -0700
+++ u-boot-2018.09/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h	2022-05-09 14:11:35.384517226 -0700
@@ -395,7 +395,13 @@
 #define SCFG_USB3PRM2CR_USB3		0x08c
 #define SCFG_USB_TXVREFTUNE			0x9
 #define SCFG_USB_SQRXTUNE_MASK		0x7
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+	defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+#define SCFG_USB_PCSTXSWINGFULL		0x73
+#define SCFG_USB_TXVBOOSTLVL		0x7
+#else
 #define SCFG_USB_PCSTXSWINGFULL		0x47
+#endif
 #define SCFG_USB_PHY1			0x084F0000
 #define SCFG_USB_PHY2			0x08500000
 #define SCFG_USB_PHY3			0x08510000
--- u-boot-2018.09/arch/arm/include/asm/gpio.h.orig	2022-05-09 14:11:26.276885944 -0700
+++ u-boot-2018.09/arch/arm/include/asm/gpio.h	2022-05-09 14:11:35.460514149 -0700
@@ -1,4 +1,4 @@
-#if !defined(CONFIG_ARCH_UNIPHIER) && !defined(CONFIG_ARCH_STI)
+#if !defined(CONFIG_ARCH_UNIPHIER) && !defined(CONFIG_ARCH_STI) && !defined(CONFIG_ARCH_LS1043A)
 #include <asm/arch/gpio.h>
 #endif
 #include <asm-generic/gpio.h>
--- u-boot-2018.09/arch/arm/Kconfig.orig	2022-05-09 14:11:25.296925616 -0700
+++ u-boot-2018.09/arch/arm/Kconfig	2022-05-09 14:11:35.144526942 -0700
@@ -1189,6 +1189,30 @@
 	help
 	  Support for Freescale LS1043AQDS platform.
 
+config TARGET_LS1043AQDS_WG_T40
+	bool "Support WG T40"
+	select ARCH_LS1043A
+	select ARM64
+	select ARMV8_MULTIENTRY
+	select BOARD_EARLY_INIT_F
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+	imply SCSI
+	help
+	  Support for WatchGuard t40 bases off Freescale LS1043AQDS platform.
+
+config TARGET_LS1043AQDS_WG_T20
+	bool "Support WG T20"
+	select ARCH_LS1043A
+	select ARM64
+	select ARMV8_MULTIENTRY
+	select BOARD_EARLY_INIT_F
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+	imply SCSI
+	help
+	  Support for WatchGuard t20 bases off Freescale LS1043AQDS platform.
+
 config TARGET_LS1043ARDB
 	bool "Support ls1043ardb"
 	select ARCH_LS1043A
@@ -1234,6 +1258,23 @@
 	  development platform that supports the QorIQ LS1046A
 	  Layerscape Architecture processor.
 
+config TARGET_LS1046ARDB_WG_T80
+	bool "Support ls1046ardb t80"
+	select ARCH_LS1046A
+	select ARM64
+	select ARMV8_MULTIENTRY
+	select BOARD_EARLY_INIT_F
+	select BOARD_LATE_INIT
+	select DM_SPI_FLASH if DM_SPI
+	select POWER_MC34VR500
+	select SUPPORT_SPL
+	imply SCSI
+	help
+	  Support for Freescale LS1046ARDB T80 platform.
+	  The LS1046A Reference Design Board (RDB) is a high-performance
+	  development platform that supports the QorIQ LS1046A
+	  Layerscape Architecture processor.
+
 config TARGET_H2200
 	bool "Support h2200"
 	select CPU_PXA
@@ -1484,11 +1525,14 @@
 source "board/freescale/ls1088a/Kconfig"
 source "board/freescale/ls1021aqds/Kconfig"
 source "board/freescale/ls1043aqds/Kconfig"
+source "board/freescale/ls1043aqds_t40/Kconfig"
+source "board/freescale/ls1043aqds_t20/Kconfig"
 source "board/freescale/ls1021atwr/Kconfig"
 source "board/freescale/ls1021aiot/Kconfig"
 source "board/freescale/ls1046aqds/Kconfig"
 source "board/freescale/ls1043ardb/Kconfig"
 source "board/freescale/ls1046ardb/Kconfig"
+source "board/freescale/ls1046ardb_t80/Kconfig"
 source "board/freescale/ls1012aqds/Kconfig"
 source "board/freescale/ls1012ardb/Kconfig"
 source "board/freescale/ls1012afrdm/Kconfig"
--- u-boot-2018.09/arch/arm/cpu/armv8/fsl-layerscape/Kconfig.orig	2022-05-09 14:11:25.364922863 -0700
+++ u-boot-2018.09/arch/arm/cpu/armv8/fsl-layerscape/Kconfig	2022-05-09 14:11:35.176525646 -0700
@@ -46,9 +46,9 @@
 	select BOARD_EARLY_INIT_F
 	select SYS_I2C_MXC
 	select SYS_I2C_MXC_I2C1
-	select SYS_I2C_MXC_I2C2
-	select SYS_I2C_MXC_I2C3
-	select SYS_I2C_MXC_I2C4
+	select SYS_I2C_MXC_I2C2 if TARGET_LS1043AQDS || TARGET_LS1043ARDB
+	select SYS_I2C_MXC_I2C3 if TARGET_LS1043AQDS || TARGET_LS1043ARDB
+	select SYS_I2C_MXC_I2C4 if TARGET_LS1043AQDS || TARGET_LS1043ARDB
 	imply SCSI
 	imply SCSI_AHCI
 	imply CMD_PCI
@@ -597,3 +597,15 @@
        help
          Enabling this will make a U-Boot binary that is capable of being
          booted via TFA.
+
+config WG_BOOTMENU
+        bool "Support WG boot menu"
+	default y
+        help
+          Support WG boot menu.
+
+config HAS_GPIO4_12_13
+	bool
+	default y if TARGET_LS1043AQDS_WG_T40 || TARGET_LS1043AQDS_WG_T20
+	help
+	  For T40 & T20, GPIO use pins, select it when the pins are assigned to GPIO.
--- u-boot-2018.09/arch/arm/cpu/armv8/fsl-layerscape/soc.c.orig	2022-05-09 14:11:25.372922540 -0700
+++ u-boot-2018.09/arch/arm/cpu/armv8/fsl-layerscape/soc.c	2022-05-09 14:11:35.200524675 -0700
@@ -6,6 +6,10 @@
 #include <common.h>
 #include <fsl_immap.h>
 #include <fsl_ifc.h>
+#if defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+#include <ahci.h>
+#include <scsi.h>
+#endif // defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
 #include <asm/arch/fsl_serdes.h>
 #include <asm/arch/soc.h>
 #include <asm/io.h>
@@ -112,6 +116,19 @@
 			0x7F << 9,
 			SCFG_USB_PCSTXSWINGFULL << 9);
 }
+
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+	defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+/*Senao: Jeff*/
+static inline void set_usb_txvboostlvl(u32 __iomem *scfg, u32 offset)
+{
+	scfg_clrsetbits32(scfg + offset / 4,
+			0x7 << 3,
+			SCFG_USB_TXVBOOSTLVL << 3);
+}
+#else
+static inline void set_usb_txvboostlvl(u32 __iomem *scfg, u32 offset) {}
+#endif
 #endif
 
 static void erratum_a008997(void)
@@ -120,11 +137,20 @@
 #if defined(CONFIG_ARCH_LS1043A) || defined(CONFIG_ARCH_LS1046A) || \
 	defined(CONFIG_ARCH_LS1012A)
 	u32 __iomem *scfg = (u32 __iomem *)SCFG_BASE;
-
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+	defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
 	set_usb_pcstxswingfull(scfg, SCFG_USB3PRM2CR_USB1);
+	set_usb_txvboostlvl(scfg, SCFG_USB3PRM2CR_USB1);
+#else
+	set_usb_pcstxswingfull(scfg, SCFG_USB3PRM2CR_USB1);
+#endif
 #if defined(CONFIG_ARCH_LS1043A) || defined(CONFIG_ARCH_LS1046A)
 	set_usb_pcstxswingfull(scfg, SCFG_USB3PRM2CR_USB2);
 	set_usb_pcstxswingfull(scfg, SCFG_USB3PRM2CR_USB3);
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+	defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+	set_usb_txvboostlvl(scfg, SCFG_USB3PRM2CR_USB2);
+#endif
 #endif
 #endif
 #endif /* CONFIG_SYS_FSL_ERRATUM_A008997 */
@@ -334,6 +360,38 @@
 #endif
 }
 
+#if defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+#if defined(CONFIG_SCSI_AHCI_PLAT) && !defined(CONFIG_DM_SCSI)
+int sata_init(void)
+{
+	struct ccsr_ahci __iomem *ccsr_ahci;
+
+#ifdef CONFIG_SYS_SATA2
+	ccsr_ahci  = (void *)CONFIG_SYS_SATA2;
+	out_le32(&ccsr_ahci->ppcfg, AHCI_PORT_PHY_1_CFG);
+	out_le32(&ccsr_ahci->pp2c, AHCI_PORT_PHY2_CFG);
+	out_le32(&ccsr_ahci->pp3c, AHCI_PORT_PHY3_CFG);
+	out_le32(&ccsr_ahci->ptc, AHCI_PORT_TRANS_CFG);
+	out_le32(&ccsr_ahci->axicc, AHCI_PORT_AXICC_CFG);
+#endif
+
+#ifdef CONFIG_SYS_SATA1
+	ccsr_ahci  = (void *)CONFIG_SYS_SATA1;
+	out_le32(&ccsr_ahci->ppcfg, AHCI_PORT_PHY_1_CFG);
+	out_le32(&ccsr_ahci->pp2c, AHCI_PORT_PHY2_CFG);
+	out_le32(&ccsr_ahci->pp3c, AHCI_PORT_PHY3_CFG);
+	out_le32(&ccsr_ahci->ptc, AHCI_PORT_TRANS_CFG);
+	out_le32(&ccsr_ahci->axicc, AHCI_PORT_AXICC_CFG);
+
+	ahci_init((void __iomem *)CONFIG_SYS_SATA1);
+	scsi_scan(false);
+#endif
+
+	return 0;
+}
+#endif
+#endif // defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+
 /* Get VDD in the unit mV from voltage ID */
 int get_core_volt_from_fuse(void)
 {
@@ -374,6 +432,27 @@
 }
 
 #elif defined(CONFIG_FSL_LSCH2)
+#if defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+#if defined(CONFIG_SCSI_AHCI_PLAT) && !defined(CONFIG_DM_SCSI)
+int sata_init(void)
+{
+	struct ccsr_ahci __iomem *ccsr_ahci = (void *)CONFIG_SYS_SATA;
+
+	/* Disable SATA ECC */
+	out_le32((void *)CONFIG_SYS_DCSR_DCFG_ADDR + 0x520, 0x80000000);
+	out_le32(&ccsr_ahci->ppcfg, AHCI_PORT_PHY_1_CFG);
+	out_le32(&ccsr_ahci->pp2c, AHCI_PORT_PHY2_CFG);
+	out_le32(&ccsr_ahci->pp3c, AHCI_PORT_PHY3_CFG);
+	out_le32(&ccsr_ahci->ptc, AHCI_PORT_TRANS_CFG);
+	out_le32(&ccsr_ahci->axicc, AHCI_PORT_AXICC_CFG);
+
+	ahci_init((void __iomem *)CONFIG_SYS_SATA);
+	scsi_scan(false);
+
+	return 0;
+}
+#endif
+#endif // defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
 
 static void erratum_a009929(void)
 {
@@ -839,6 +918,11 @@
 #ifdef CONFIG_BOARD_LATE_INIT
 int board_late_init(void)
 {
+#if defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
+ #if defined(CONFIG_SCSI_AHCI_PLAT) && !defined(CONFIG_DM_SCSI)
+	sata_init();
+ #endif
+#endif // defined(CONFIG_TARGET_LS1046ARDB_WG_T80)
 #ifdef CONFIG_CHAIN_OF_TRUST
 	fsl_setenv_chain_of_trust();
 #endif
--- u-boot-2018.09/arch/arm/cpu/armv8/Kconfig.orig	2022-05-09 14:11:25.364922863 -0700
+++ u-boot-2018.09/arch/arm/cpu/armv8/Kconfig	2022-05-09 14:11:35.168525971 -0700
@@ -104,7 +104,9 @@
 		   !TARGET_LS1012A2G5RDB && !TARGET_LS1012AQDS && \
 		   !TARGET_LS1012AFRWY && \
 		   !TARGET_LS1043ARDB && !TARGET_LS1043AQDS && \
-		   !TARGET_LS1046ARDB && !TARGET_LS1046AQDS && \
+		   !TARGET_LS1043AQDS_WG_T20 && !TARGET_LS1043AQDS_WG_T40 && \
+		   !TARGET_LS1046ARDB && !TARGET_LS1046ARDB_WG_T80 && \
+		   !TARGET_LS1046AQDS && \
 		   !TARGET_LS2081ARDB && !TARGET_LX2160ARDB && \
 		   !ARCH_UNIPHIER && !TARGET_S32V234EVB
 	help
--- u-boot-2018.09/arch/arm/dts/fsl-ls1046a-rdb.dts.orig	2022-05-09 14:11:25.500917358 -0700
+++ u-boot-2018.09/arch/arm/dts/fsl-ls1046a-rdb.dts	2022-05-09 14:11:35.256522408 -0700
@@ -19,11 +19,12 @@
 
 };
 
+/*Albert.Ke.B*/
 &qspi {
 	bus-num = <0>;
 	status = "okay";
 
-	qflash0: s25fs512s@0 {
+	qflash0: mx25u6435f@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
 		compatible = "spi-flash";
@@ -31,7 +32,7 @@
 		reg = <0>;
 	};
 
-	qflash1: s25fs512s@1 {
+	qflash1: mx25u6435f@1 {
 		#address-cells = <1>;
 		#size-cells = <1>;
 		compatible = "spi-flash";
@@ -40,6 +41,27 @@
 	 };
 };
 
-&sata {
+
+/*
+&qspi {
+	bus-num = <0>;
 	status = "okay";
+
+	qflash0: s25fs512s@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <50000000>;
+		reg = <0>;
+	};
+
+	qflash1: s25fs512s@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <50000000>;
+		reg = <1>;
+	 };
 };
+*/
+/*Albert.Ke.E*/
--- u-boot-2018.09/arch/arm/dts/Makefile.orig	2022-05-09 14:11:25.380922216 -0700
+++ u-boot-2018.09/arch/arm/dts/Makefile	2022-05-09 14:11:35.216524027 -0700
@@ -228,7 +228,8 @@
 	fsl-ls1088a-rdb.dtb \
 	fsl-ls1088a-qds.dtb \
 	fsl-lx2160a-rdb.dtb
-dtb-$(CONFIG_FSL_LSCH2) += fsl-ls1043a-qds-duart.dtb \
+dtb-$(CONFIG_FSL_LSCH2) += fsl-ls1043a-qds-wg_t40_t20-duart.dtb \
+        fsl-ls1043a-qds-duart.dtb \
 	fsl-ls1043a-qds-lpuart.dtb \
 	fsl-ls1043a-rdb.dtb \
 	fsl-ls1046a-qds-duart.dtb \
--- u-boot-2018.09/include/env_default.h.orig	2022-05-09 14:11:33.612588963 -0700
+++ u-boot-2018.09/include/env_default.h	2022-05-09 14:11:37.264441117 -0700
@@ -49,9 +49,32 @@
 #ifdef	CONFIG_LOADS_ECHO
 	"loads_echo="	__stringify(CONFIG_LOADS_ECHO)	"\0"
 #endif
+#ifdef  CONFIG_ETHADDR
+        "ethaddr="      __stringify(CONFIG_ETHADDR)     "\0"
+#endif
+#ifdef  CONFIG_ETH1ADDR
+        "eth1addr="     __stringify(CONFIG_ETH1ADDR)    "\0"
+#endif
+#ifdef  CONFIG_ETH2ADDR
+        "eth2addr="     __stringify(CONFIG_ETH2ADDR)    "\0"
+#endif
+#ifdef  CONFIG_ETH3ADDR
+        "eth3addr="     __stringify(CONFIG_ETH3ADDR)    "\0"
+#endif
+#ifdef  CONFIG_ETH4ADDR
+        "eth4addr="     __stringify(CONFIG_ETH4ADDR)    "\0"
+#endif
+#ifdef  CONFIG_ETH5ADDR
+        "eth5addr="     __stringify(CONFIG_ETH5ADDR)    "\0"
+#endif
 #ifdef	CONFIG_ETHPRIME
 	"ethprime="	CONFIG_ETHPRIME			"\0"
 #endif
+
+#ifdef  CONFIG_ETHPRIME
+        "ethact="     CONFIG_ETHPRIME                 "\0"
+#endif
+
 #ifdef	CONFIG_IPADDR
 	"ipaddr="	__stringify(CONFIG_IPADDR)	"\0"
 #endif
--- u-boot-2018.09/include/common.h.orig	2022-05-09 14:11:33.380598355 -0700
+++ u-boot-2018.09/include/common.h	2022-05-09 14:11:37.064449214 -0700
@@ -69,6 +69,46 @@
  */
 #include <init.h>
 
+#ifdef CONFIG_WG1008_VM1P
+typedef enum
+{
+    GPIO_NUM_RESET_IN,
+    GPIO_NUM_ATT_LED,
+    GPIO_NUM_SW_STATUS_LED,
+    GPIO_NUM_SW_MODE_LED,
+    GPIO_NUM_FAILOVER_LED,
+    GPIO_NUM_POWER_LED,
+    GPIO_NUM_TMP_RESET,
+    GPIO_NUM_MARVELL_SWITCH_RESET,
+    GPIO_NUM_RST_MOD_RESET,
+    GPIO_NUM_FAN_DRIVER_FON,
+    GPIO_NUM_INT_ALL_ALM_7904D_CPU_N,
+    GPIO_NUM_MOD_BRD_TYPE_0,
+    GPIO_NUM_MOD_BRD_TYPE_1,
+    GPIO_NUM_INT_RTC_PHY_N,
+    GPIO_NUM_MOD_BAY_PRESENT_N,
+    GPIO_NUM_LED_CPU_MOD_1,
+    GPIO_NUM_LED_CPU_MOD_2,
+    GPIO_NUM_LED_CPU_MOD_3,
+    GPIO_NUM_LED_CPU_MOD_4,
+} GPIO_NUM_t;
+
+typedef struct
+{
+    u32 gpio_bus;
+    u32 gpio_shift;
+    u32 gpio_dir;
+    u32 gpio_default_val;
+} GPIO_t;
+
+typedef struct
+{
+    GPIO_NUM_t gpio_num;
+    char led_name[32];
+    u32 active_high;
+} LED_t;
+#endif
+
 /*
  * Function Prototypes
  */
--- u-boot-2018.09/include/configs/ls1046a_common.h.orig	2022-05-09 14:11:33.444595764 -0700
+++ u-boot-2018.09/include/configs/ls1046a_common.h	2022-05-09 14:11:37.132446461 -0700
@@ -6,6 +6,8 @@
 #ifndef __LS1046A_COMMON_H
 #define __LS1046A_COMMON_H
 
+#define CONFIG_WG1008_VM1P
+
 /* SPL build */
 #ifdef CONFIG_SPL_BUILD
 #define SPL_NO_QBMAN
@@ -27,6 +29,7 @@
 
 #define CONFIG_REMAKE_ELF
 #define CONFIG_FSL_LAYERSCAPE
+#define CONFIG_MP
 #define CONFIG_GICV2
 
 #include <asm/arch/config.h>
@@ -56,6 +59,7 @@
 #define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024 * 1024)
 
 /* Serial Port */
+#define CONFIG_CONS_INDEX		1
 #define CONFIG_SYS_NS16550_SERIAL
 #define CONFIG_SYS_NS16550_REG_SIZE	1
 #define CONFIG_SYS_NS16550_CLK          (get_serial_clock())
@@ -111,6 +115,7 @@
 #define CONFIG_SPL_ENV_SUPPORT
 #define CONFIG_SPL_WATCHDOG_SUPPORT
 #define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
 #define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
 
 #define CONFIG_SPL_NAND_SUPPORT
@@ -158,6 +163,7 @@
 /* MMC */
 #ifndef SPL_NO_MMC
 #ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
 #define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
 #endif
 #endif
@@ -186,7 +192,13 @@
 #define CONFIG_SYS_FMAN_FW_ADDR		(512 * 0x4800)
 #elif defined(CONFIG_QSPI_BOOT)
 #define CONFIG_SYS_QE_FW_IN_SPIFLASH
+/*Albert.Ke.B*/
+#ifdef CONFIG_WG1008_VM1P
+#define CONFIG_SYS_FMAN_FW_ADDR		0x40220000
+#else
 #define CONFIG_SYS_FMAN_FW_ADDR		0x40900000
+#endif
+/*Albert.Ke.E*/
 #define CONFIG_ENV_SPI_BUS		0
 #define CONFIG_ENV_SPI_CS		0
 #define CONFIG_ENV_SPI_MAX_HZ		1000000
@@ -287,8 +299,12 @@
 		"env exists secureboot && mmc read $kernelheader_addr_r "		\
 		"$kernelhdr_addr_sd $kernelhdr_size_sd "		\
 		" && esbc_validate ${kernelheader_addr_r};"	\
+        "bootdelay=3\0"      \
+        "ipaddr=192.168.0.10\0"     \
+        "serverip=192.168.0.20\0"     \
+        "gatewayip=192.168.0.20\0"     \
+        "boot_targets=usb0 usb1 scsi0 mmc0\0"     \
 		"bootm $load_addr#$board\0"
-
 #endif
 
 /* Monitor Command Prompt */
--- u-boot-2018.09/include/configs/ls1043a_common.h.orig	2022-05-09 14:11:33.444595764 -0700
+++ u-boot-2018.09/include/configs/ls1043a_common.h	2022-05-09 14:11:37.108447432 -0700
@@ -215,7 +215,12 @@
 #define CONFIG_SYS_QE_FW_ADDR		(512 * 0x4a08)
 #elif defined(CONFIG_QSPI_BOOT)
 #define CONFIG_SYS_QE_FW_IN_SPIFLASH
-#define CONFIG_SYS_FMAN_FW_ADDR		0x40900000
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+	defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+#define CONFIG_SYS_FMAN_FW_ADDR		0x220000	/* 2.2MB */
+#else
+#define CONFIG_SYS_FMAN_FW_ADDR		0x300000	/* 3MB */
+#endif
 #define CONFIG_ENV_SPI_BUS		0
 #define CONFIG_ENV_SPI_CS		0
 #define CONFIG_ENV_SPI_MAX_HZ		1000000
@@ -274,7 +279,7 @@
 	"mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0"	\
 	BOOTENV					\
 	"boot_scripts=ls1043ardb_boot.scr\0"	\
-	"boot_script_hdr=hdr_ls1043ardb_bs.out\0"	\
+	"boot_script_hdr=hdr_ls1043ardb_bs.out\0"/*	\
 	"scan_dev_for_boot_part="		\
 		"part list ${devtype} ${devnum} devplist; "	\
 		"env exists devplist || setenv devplist 1; "	\
@@ -325,7 +330,7 @@
 		"$kernelhdr_addr_sd $kernelhdr_size_sd "		\
 		" && esbc_validate ${kernelheader_addr_r};"	\
 		"bootm $load_addr#$board\0"
-
+*/
 
 #undef CONFIG_BOOTCOMMAND
 #ifdef CONFIG_TFABOOT
@@ -338,6 +343,8 @@
 #define IFC_NAND_BOOTCOMMAND "run distro_bootcmd; run nand_bootcmd; "	\
 			   "env exists secureboot && esbc_halt;"
 #else
+#define CONFIG_BOOTCOMMAND "scsi scan; ext4load scsi 0:1 $load_addr lsdk_linux_arm64_LS_tiny.itb; bootm $load_addr#ls1043ardb"
+/*
 #if defined(CONFIG_QSPI_BOOT) || defined(CONFIG_SD_BOOT_QSPI)
 #define CONFIG_BOOTCOMMAND "run distro_bootcmd; run qspi_bootcmd; "	\
 			   "env exists secureboot && esbc_halt;"
@@ -347,7 +354,9 @@
 #else
 #define CONFIG_BOOTCOMMAND "run distro_bootcmd; run nor_bootcmd; "	\
 			   "env exists secureboot && esbc_halt;"
+
 #endif
+*/
 #endif
 #endif
 
--- u-boot-2018.09/include/configs/ls1043aqds.h.orig	2022-05-09 14:11:33.444595764 -0700
+++ u-boot-2018.09/include/configs/ls1043aqds.h	2022-05-09 14:11:37.116447109 -0700
@@ -13,8 +13,14 @@
 unsigned long get_board_ddr_clk(void);
 #endif
 
-#define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
-#define CONFIG_DDR_CLK_FREQ		get_board_ddr_clk()
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+    defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ #define CONFIG_SYS_CLK_FREQ		100000000
+ #define CONFIG_DDR_CLK_FREQ		100000000
+#else
+ #define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
+ #define CONFIG_DDR_CLK_FREQ		get_board_ddr_clk()
+#endif
 
 #define CONFIG_SKIP_LOWLEVEL_INIT
 
@@ -24,9 +30,14 @@
 /* Physical Memory Map */
 #define CONFIG_CHIP_SELECTS_PER_CTRL	4
 
-#define CONFIG_DDR_SPD
-#define SPD_EEPROM_ADDRESS		0x51
-#define CONFIG_SYS_SPD_BUS_NUM		0
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+    defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ #define CONFIG_SYS_DDR_RAW_TIMING
+#else
+ #define CONFIG_DDR_SPD
+ #define SPD_EEPROM_ADDRESS		0x51
+ #define CONFIG_SYS_SPD_BUS_NUM		0
+#endif
 
 #ifndef CONFIG_SPL
 #define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
@@ -41,24 +52,58 @@
 #ifdef CONFIG_SYS_DPAA_FMAN
 #define CONFIG_FMAN_ENET
 #define CONFIG_PHY_VITESSE
-#define CONFIG_PHY_REALTEK
-#define CONFIG_PHYLIB_10G
+
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+    defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ #define CONFIG_PHY_ATHEROS
+#else
+ #define CONFIG_PHY_REALTEK
+ #define CONFIG_PHYLIB_10G
+#endif
+
 #define RGMII_PHY1_ADDR		0x1
-#define RGMII_PHY2_ADDR		0x2
-#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
-#define SGMII_CARD_PORT2_PHY_ADDR 0x1D
-#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
-#define SGMII_CARD_PORT4_PHY_ADDR 0x1F
-/* PHY address on QSGMII riser card on slot 1 */
-#define QSGMII_CARD_PORT1_PHY_ADDR_S1 0x4
-#define QSGMII_CARD_PORT2_PHY_ADDR_S1 0x5
-#define QSGMII_CARD_PORT3_PHY_ADDR_S1 0x6
-#define QSGMII_CARD_PORT4_PHY_ADDR_S1 0x7
-/* PHY address on QSGMII riser card on slot 2 */
-#define QSGMII_CARD_PORT1_PHY_ADDR_S2 0x8
-#define QSGMII_CARD_PORT2_PHY_ADDR_S2 0x9
-#define QSGMII_CARD_PORT3_PHY_ADDR_S2 0xA
-#define QSGMII_CARD_PORT4_PHY_ADDR_S2 0xB
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+    defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ #define QSGMII_CARD_PORT1_PHY_ADDR_S1 0x0
+ #define QSGMII_CARD_PORT2_PHY_ADDR_S1 0x1
+ #define QSGMII_CARD_PORT3_PHY_ADDR_S1 0x2
+ #define QSGMII_CARD_PORT4_PHY_ADDR_S1 0x3
+
+ #define CONFIG_IPADDR		192.168.1.1
+ #define CONFIG_SERVERIP		192.168.1.100
+ #define CONFIG_NETMASK		255.255.255.0
+
+ #define CONFIG_HAS_ETH1
+ #define CONFIG_HAS_ETH2
+ #define CONFIG_HAS_ETH3
+ #define CONFIG_HAS_ETH4
+ #define CONFIG_HAS_ETH5
+
+ #define CONFIG_ETHADDR		00:0B:6B:01:01:01
+ #define CONFIG_ETH1ADDR		00:0B:6B:01:01:02
+ #define CONFIG_ETH2ADDR		00:0B:6B:01:01:03
+ #define CONFIG_ETH3ADDR		00:0B:6B:01:01:04
+ #define CONFIG_ETH4ADDR		00:0B:6B:01:01:05
+ #define CONFIG_ETH5ADDR		00:0B:6B:01:01:06
+ #define CONFIG_ETHPRIME         "FM1@DTSEC1"
+#else
+ #define RGMII_PHY2_ADDR		0x2
+ #define SGMII_CARD_PORT1_PHY_ADDR 0x1C
+ #define SGMII_CARD_PORT2_PHY_ADDR 0x1D
+ #define SGMII_CARD_PORT3_PHY_ADDR 0x1E
+ #define SGMII_CARD_PORT4_PHY_ADDR 0x1F
+ /* PHY address on QSGMII riser card on slot 1 */
+ #define QSGMII_CARD_PORT1_PHY_ADDR_S1 0x4
+ #define QSGMII_CARD_PORT2_PHY_ADDR_S1 0x5
+ #define QSGMII_CARD_PORT3_PHY_ADDR_S1 0x6
+ #define QSGMII_CARD_PORT4_PHY_ADDR_S1 0x7
+ /* PHY address on QSGMII riser card on slot 2 */
+ #define QSGMII_CARD_PORT1_PHY_ADDR_S2 0x8
+ #define QSGMII_CARD_PORT2_PHY_ADDR_S2 0x9
+ #define QSGMII_CARD_PORT3_PHY_ADDR_S2 0xA
+ #define QSGMII_CARD_PORT4_PHY_ADDR_S2 0xB
+#endif
+
 #endif
 
 #ifdef CONFIG_RAMBOOT_PBL
@@ -86,14 +131,17 @@
 /* SATA */
 #define CONFIG_SCSI_AHCI_PLAT
 
-/* EEPROM */
-#define CONFIG_ID_EEPROM
-#define CONFIG_SYS_I2C_EEPROM_NXID
-#define CONFIG_SYS_EEPROM_BUS_NUM		0
-#define CONFIG_SYS_I2C_EEPROM_ADDR		0x57
-#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		1
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS	3
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	5
+#if !defined(CONFIG_TARGET_LS1043AQDS_WG_T40) && \
+    !defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ /* EEPROM */
+ #define CONFIG_ID_EEPROM
+ #define CONFIG_SYS_I2C_EEPROM_NXID
+ #define CONFIG_SYS_EEPROM_BUS_NUM		0
+ #define CONFIG_SYS_I2C_EEPROM_ADDR		0x57
+ #define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		1
+ #define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS	3
+ #define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	5
+#endif
 
 #define CONFIG_SYS_SATA				AHCI_BASE_ADDR
 
@@ -102,92 +150,95 @@
 #define CONFIG_SYS_SCSI_MAX_DEVICE		(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
 						CONFIG_SYS_SCSI_MAX_LUN)
 
-/*
- * IFC Definitions
- */
-#if !defined(CONFIG_QSPI_BOOT) && !defined(CONFIG_SD_BOOT_QSPI)
-#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
-				CSPR_PORT_SIZE_16 | \
-				CSPR_MSEL_NOR | \
-				CSPR_V)
-#define CONFIG_SYS_NOR1_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
-				+ 0x8000000) | \
-				CSPR_PORT_SIZE_16 | \
-				CSPR_MSEL_NOR | \
-				CSPR_V)
-#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128 * 1024 * 1024)
-
-#define CONFIG_SYS_NOR_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
-					CSOR_NOR_TRHZ_80)
-#define CONFIG_SYS_NOR_FTIM0		(FTIM0_NOR_TACSE(0x4) | \
-					FTIM0_NOR_TEADC(0x5) | \
-					FTIM0_NOR_TEAHC(0x5))
-#define CONFIG_SYS_NOR_FTIM1		(FTIM1_NOR_TACO(0x35) | \
-					FTIM1_NOR_TRAD_NOR(0x1a) | \
-					FTIM1_NOR_TSEQRAD_NOR(0x13))
-#define CONFIG_SYS_NOR_FTIM2		(FTIM2_NOR_TCS(0x4) | \
-					FTIM2_NOR_TCH(0x4) | \
-					FTIM2_NOR_TWPH(0xe) | \
-					FTIM2_NOR_TWP(0x1c))
-#define CONFIG_SYS_NOR_FTIM3		0
-
-#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
-#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
-#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
-#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
-
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS, \
-					CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000}
-
-#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
-#define CONFIG_SYS_WRITE_SWAPPED_DATA
-
-/*
- * NAND Flash Definitions
- */
-#define CONFIG_NAND_FSL_IFC
-
-#define CONFIG_SYS_NAND_BASE		0x7e800000
-#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+#if !defined(CONFIG_TARGET_LS1043AQDS_WG_T40) && \
+    !defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ /*
+  * IFC Definitions
+  */
+ #if !defined(CONFIG_QSPI_BOOT) && !defined(CONFIG_SD_BOOT_QSPI)
+  #define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+  #define CONFIG_SYS_NOR0_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				  CSPR_PORT_SIZE_16 | \
+				  CSPR_MSEL_NOR | \
+				  CSPR_V)
+  #define CONFIG_SYS_NOR1_CSPR_EXT	(0x0)
+  #define CONFIG_SYS_NOR1_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS \
+				  + 0x8000000) | \
+				  CSPR_PORT_SIZE_16 | \
+				  CSPR_MSEL_NOR | \
+				  CSPR_V)
+  #define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128 * 1024 * 1024)
+
+  #define CONFIG_SYS_NOR_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
+					  CSOR_NOR_TRHZ_80)
+  #define CONFIG_SYS_NOR_FTIM0		(FTIM0_NOR_TACSE(0x4) | \
+					  FTIM0_NOR_TEADC(0x5) | \
+					  FTIM0_NOR_TEAHC(0x5))
+  #define CONFIG_SYS_NOR_FTIM1		(FTIM1_NOR_TACO(0x35) | \
+					  FTIM1_NOR_TRAD_NOR(0x1a) | \
+					  FTIM1_NOR_TSEQRAD_NOR(0x13))
+  #define CONFIG_SYS_NOR_FTIM2		(FTIM2_NOR_TCS(0x4) | \
+					  FTIM2_NOR_TCH(0x4) | \
+					  FTIM2_NOR_TWPH(0xe) | \
+					  FTIM2_NOR_TWP(0x1c))
+  #define CONFIG_SYS_NOR_FTIM3		0
+
+  #define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+  #define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+  #define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+  #define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+  #define CONFIG_SYS_FLASH_EMPTY_INFO
+  #define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS, \
+					  CONFIG_SYS_FLASH_BASE_PHYS + 0x8000000}
+
+  #define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+  #define CONFIG_SYS_WRITE_SWAPPED_DATA
+
+  /*
+   * NAND Flash Definitions
+   */
+  #define CONFIG_NAND_FSL_IFC
+
+  #define CONFIG_SYS_NAND_BASE		0x7e800000
+  #define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+
+  #define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
+
+  #define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				  | CSPR_PORT_SIZE_8	\
+				  | CSPR_MSEL_NAND	\
+				  | CSPR_V)
+  #define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
+  #define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				  | CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
+				  | CSOR_NAND_ECC_MODE_4	/* 4-bit ECC */ \
+				  | CSOR_NAND_RAL_3	/* RAL = 3 Bytes */ \
+				  | CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				  | CSOR_NAND_SPRZ_64	/* Spare size = 64 */ \
+				  | CSOR_NAND_PB(64))	/* 64 Pages Per Block */
+
+  #define CONFIG_SYS_NAND_ONFI_DETECTION
+
+  #define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x7) | \
+					  FTIM0_NAND_TWP(0x18)   | \
+					  FTIM0_NAND_TWCHT(0x7) | \
+					  FTIM0_NAND_TWH(0xa))
+  #define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					  FTIM1_NAND_TWBE(0x39)  | \
+					  FTIM1_NAND_TRR(0xe)   | \
+					  FTIM1_NAND_TRP(0x18))
+  #define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0xf) | \
+					  FTIM2_NAND_TREH(0xa) | \
+					  FTIM2_NAND_TWHRE(0x1e))
+  #define CONFIG_SYS_NAND_FTIM3           0x0
+
+  #define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+  #define CONFIG_SYS_MAX_NAND_DEVICE	1
+  #define CONFIG_MTD_NAND_VERIFY_WRITE
 
-#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
-
-#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8	\
-				| CSPR_MSEL_NAND	\
-				| CSPR_V)
-#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64*1024)
-#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
-				| CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
-				| CSOR_NAND_ECC_MODE_4	/* 4-bit ECC */ \
-				| CSOR_NAND_RAL_3	/* RAL = 3 Bytes */ \
-				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
-				| CSOR_NAND_SPRZ_64	/* Spare size = 64 */ \
-				| CSOR_NAND_PB(64))	/* 64 Pages Per Block */
-
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x7) | \
-					FTIM0_NAND_TWP(0x18)   | \
-					FTIM0_NAND_TWCHT(0x7) | \
-					FTIM0_NAND_TWH(0xa))
-#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
-					FTIM1_NAND_TWBE(0x39)  | \
-					FTIM1_NAND_TRR(0xe)   | \
-					FTIM1_NAND_TRP(0x18))
-#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0xf) | \
-					FTIM2_NAND_TREH(0xa) | \
-					FTIM2_NAND_TWHRE(0x1e))
-#define CONFIG_SYS_NAND_FTIM3           0x0
-
-#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define CONFIG_MTD_NAND_VERIFY_WRITE
-
-#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+  #define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+ #endif
 #endif
 
 #ifdef CONFIG_NAND_BOOT
@@ -390,6 +441,10 @@
 #define CONFIG_FSL_QSPI
 #ifdef CONFIG_FSL_QSPI
 #define CONFIG_SPI_FLASH_SPANSION
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+    defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ #define CONFIG_SPI_FLASH_MACRONIX
+#endif
 #define FSL_QSPI_FLASH_SIZE		(1 << 24)
 #define FSL_QSPI_FLASH_NUM		2
 #endif
@@ -435,7 +490,13 @@
 #define CONFIG_ENV_SIZE			0x2000
 #elif defined(CONFIG_QSPI_BOOT)
 #define CONFIG_ENV_SIZE			0x2000          /* 8KB */
-#define CONFIG_ENV_OFFSET		0x300000        /* 3MB */
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+    defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ #define CONFIG_ENV_OFFSET		0x200000        /* 2MB */
+#else
+ #define CONFIG_ENV_OFFSET		0x300000        /* 3MB */
+#endif
+#define CONFIG_ENV_OFFSET		0x200000        /* 2MB */
 #define CONFIG_ENV_SECT_SIZE		0x10000
 #else
 #define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x300000)
@@ -446,6 +507,23 @@
 
 #define CONFIG_CMDLINE_TAG
 
+#if defined(CONFIG_TARGET_LS1043AQDS_WG_T40) || \
+    defined(CONFIG_TARGET_LS1043AQDS_WG_T20)
+ /* GPIO1[13:14, 23:31] */
+ #define GPIO1_SUPPORT			((0x3 << 13) | (0x1ff << 23))
+ /* GPIO2[0:9][12:15] */
+ #define GPIO2_SUPPORT			((0x1ff << 0))| (0xf << 12)
+ /* GPIO3[15:27] */
+ #define GPIO3_SUPPORT			(0x1fff << 15)
+ /* GPIO4[2:3, 12:13, 29:30] */
+ #define GPIO4_SUPPORT			((0x3 << 2) | (0x3 << 12) | (0x3 << 29))
+
+ #define CONFIG_SN74LV164A
+ #define SN74LV164A_CLR_GPIO		205
+ #define SN74LV164A_CLK_GPIO		127
+ #define SN74LV164A_INA_GPIO		128
+#endif
+
 #include <asm/fsl_secure_boot.h>
 
 #endif /* __LS1043AQDS_H__ */
--- u-boot-2018.09/cmd/gpio.c.orig	2022-05-09 14:11:31.280683368 -0700
+++ u-boot-2018.09/cmd/gpio.c	2022-05-09 14:11:36.352478038 -0700
@@ -8,6 +8,213 @@
 
 #include <common.h>
 #include <command.h>
+
+#ifdef CONFIG_WG1008_VM1P
+extern GPIO_t wg1008_vm1p_gpio[];
+extern LED_t wg1008_vm1p_led[];
+extern int gpioWrite(u32 gpio_bus, u32 gpio_shift, u32 gpio_type, u32 val);
+extern int gpioRead(u32 gpio_bus, u32 gpio_shift, u32 gpio_type, u32 *val);
+extern int wg1008_vm1p_gpio_init(void);
+extern int getGpioNumByLedName(char *ledName, u32 *gpioNum, u32 *active_high);
+extern int setGpioLedAllOnOff(u32 mode);
+
+void printHelp(char *daemonName)
+{
+    int idx =0;
+
+    printf("%s init\n", daemonName);
+    printf("%s read <gpio bus> <gpio shift>\n", daemonName);
+    printf("%s write <gpio bus> <gpio shift> <value>\n", daemonName);
+    printf("%s dir <gpio bus> <gpio shift> <value>\n", daemonName);
+    printf("%s led <led name> <on/off>\n", daemonName);
+    printf("%s led all <on/off/normal>\n", daemonName);
+    printf("%s led list\n", daemonName);
+    printf("Supported <led name>: ");
+    for(idx =0; wg1008_vm1p_led[idx].led_name != NULL; idx++)
+    {
+        printf("%s ", wg1008_vm1p_led[idx].led_name);
+    }
+    printf("\n");
+}
+
+int do_gpio(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int ret = 0, idx =0;
+    u32 gpio_bus = 0, gpio_shift = 0, val = 0, gpioNum = 0, active_high = 0;
+
+    if(argc < 2)
+    {
+        printHelp(argv[0]);
+        return CMD_RET_FAILURE;
+    }
+
+    if(argc == 2 && !strncmp(argv[1], "init", strlen("init")))
+    {
+        return wg1008_vm1p_gpio_init();
+    }
+
+    if(argc >= 4)
+    {
+        gpio_bus = strtoul(argv[2], NULL, 0);
+        gpio_shift = strtoul(argv[3], NULL, 0);
+        if(!strncmp(argv[1], "read", strlen("read")))
+        {
+            ret = gpioRead(gpio_bus, gpio_shift, GPIO_TYPE_DATA, &val);
+            if(ret == 0)
+            {
+                printf("%u\n", val);
+            }
+            return ret;
+        }
+        else if(argc == 5 && !strncmp(argv[1], "write", strlen("write")))
+        {
+            val = strtoul(argv[4], NULL, 0);
+            ret = gpioWrite(gpio_bus, gpio_shift, GPIO_TYPE_DATA, val);
+            if(ret == 0)
+            {
+                printf("%u written.\n", val);
+            }
+            return ret;
+        }
+        else if(argc == 5 && !strncmp(argv[1], "dir", strlen("dir")))
+        {
+            val = strtoul(argv[4], NULL, 0);
+            ret = gpioWrite(gpio_bus, gpio_shift, GPIO_TYPE_DIR, val);
+            if(ret == 0)
+            {
+                printf("%u written.\n", val);
+            }
+            return ret;
+        }
+        else if(argc == 4 && !strncmp(argv[1], "dir", strlen("dir")))
+        {
+            ret = gpioRead(gpio_bus, gpio_shift, GPIO_TYPE_DIR, &val);
+            if(ret == 0)
+            {
+                printf("%u\n", val);
+            }
+            return ret;
+        }
+        else if(argc == 4 && !strncmp(argv[1], "led", strlen("led")))
+        {
+            if(!strncmp(argv[2], "all", strlen("all")))
+            {
+                if(!strncmp(argv[3], "on", strlen("on")))
+                {
+                    if(setGpioLedAllOnOff(GPIO_LED_MODE_ON))
+                    {
+                        printHelp(argv[0]);
+                        return CMD_RET_FAILURE;
+                    }
+                    else
+                    {
+                        return 0;
+                    }
+                }
+                else if(!strncmp(argv[3], "off", strlen("off")))
+                {
+                    if(setGpioLedAllOnOff(GPIO_LED_MODE_OFF))
+                    {
+                        printHelp(argv[0]);
+                        return CMD_RET_FAILURE;
+                    }
+                    else
+                    {
+                        return 0;
+                    }
+                }
+                else if(!strncmp(argv[3], "normal", strlen("normal")))
+                {
+                    if(setGpioLedAllOnOff(GPIO_LED_MODE_NORMAL))
+                    {
+                        printHelp(argv[0]);
+                        return CMD_RET_FAILURE;
+                    }
+                    else
+                    {
+                        return 0;
+                    }
+                }
+                else
+                {
+                    printf("Invalid arguments!!!\n");
+                    printHelp(argv[0]);
+                    return CMD_RET_FAILURE;
+                }
+            }
+            ret = getGpioNumByLedName(argv[2], &gpioNum, &active_high);
+            if(!ret)
+            {
+                if(!strncmp(argv[3], "on", strlen("on")))
+                {
+                    val = active_high?1:0;
+                }
+                else if(!strncmp(argv[3], "off", strlen("off")))
+                {
+                    val = active_high?0:1;
+                }
+                else
+                {
+                    printf("Invalid arguments!!!\n");
+                    printHelp(argv[0]);
+                    return CMD_RET_FAILURE;
+                }
+                gpio_bus = wg1008_vm1p_gpio[gpioNum].gpio_bus;
+                gpio_shift = wg1008_vm1p_gpio[gpioNum].gpio_shift;
+                if(gpioWrite(gpio_bus, gpio_shift, GPIO_TYPE_DATA, val))
+                {
+                    printHelp(argv[0]);
+                    return CMD_RET_FAILURE;
+                }
+            }
+        }
+        else
+        {
+            printf("Invalid arguments!!!\n");
+            printHelp(argv[0]);
+            return CMD_RET_FAILURE;
+        }
+    }
+    else if(argc == 3 && !strncmp(argv[1], "led", strlen("led")))
+    {
+            if(!strncmp(argv[2], "list", strlen("list")))
+            {
+                for(idx =0; wg1008_vm1p_led[idx].led_name != NULL; idx++)
+                {
+                    printf("%s ", wg1008_vm1p_led[idx].led_name);
+                }
+                return 0;
+            }
+            else
+            {
+                printf("Invalid arguments!!!\n");
+                printHelp(argv[0]);
+                return CMD_RET_FAILURE;
+            }
+    }
+    else
+    {
+        printf("Invalid arguments!!!\n");
+        printHelp(argv[0]);
+        return CMD_RET_FAILURE;
+    }
+
+    return 0;
+}
+
+
+U_BOOT_CMD(
+	gpio, 5, 1, do_gpio,
+	"manage GPIOs",
+	"gpio init\n"
+	"gpio read <gpio bus> <gpio shift>\n"
+	"gpio write <gpio bus> <gpio shift> <value>\n"
+	"gpio dir <gpio bus> <gpio shift> <value>\n"
+	"gpio led <led name> <on/off>\n"
+	"gpio led all <on/off/normal>\n"
+	"gpio led list\t\tshow a list of LEDs"
+);
+#else
 #include <errno.h>
 #include <dm.h>
 #include <asm/gpio.h>
@@ -238,3 +445,4 @@
 	   "<input|set|clear|toggle> <pin>\n"
 	   "    - input/set/clear/toggle the specified pin\n"
 	   "gpio status [-a] [<bank> | <pin>]  - show [all/claimed] GPIOs");
+#endif
--- u-boot-2018.09/cmd/mii.c.orig	2022-05-09 14:11:31.284683207 -0700
+++ u-boot-2018.09/cmd/mii.c	2022-05-09 14:11:36.368477391 -0700
@@ -250,6 +250,8 @@
 static uint last_reg_hi;
 static uint last_mask;
 
+
+#ifndef CONFIG_MV88E6190_SWITCH
 static void extract_range(
 	char * input,
 	unsigned char * plo,
@@ -257,21 +259,63 @@
 {
 	char * end;
 	*plo = simple_strtoul(input, &end, 16);
-	if (*end == '-') {
+    if (*end == '-')
+    {
 		end++;
 		*phi = simple_strtoul(end, NULL, 16);
 	}
-	else {
+    else
+    {
 		*phi = *plo;
 	}
 }
+#else
+static void extract_range(
+    char * input,
+    unsigned short * plo,
+    unsigned short * phi)
+{
+    unsigned char * end;
+    *plo = simple_strtoul(input, &end, 16);
+    if (*end == '-')
+    {
+        end++;
+        *phi = simple_strtoul(end, NULL, 16);
+    }
+    else
+    {
+        *phi = *plo;
+    }
+}
+#endif
 
+#ifdef CONFIG_MV88E6190_SWITCH
+extern int switch_mv88e6190_port_autonego(u16 port, u32 *an, int read);
+extern int switch_mv88e6190_port_speed(u16 port, u32 *speed, int read); /* speed unit : Mbps */
+extern int switch_mv88e6190_port_duplex(u16 port, u32 *fullDupex, int read);
+extern int switch_mv88e6190_port_mdi_mode(u16 port, u32 *mdiMode, int read);
+extern int switch_mv88e6190_port_autonego_complete_read(u16 port, u32 *complete, int read);
+extern int switch_mv88e6190_port_copper_link_status_read(u16 port, u32 *status, int read);
+extern int switch_mv88e6190_port_copper_remote_fault_read(u16 port, u32 *fault, int read);
+extern int switch_mv88e6190_port_jabber_detect_read(u16 port, u32 *jabber, int read);
+extern int switch_mv88e6190_port_cop_specific_speed_read(u16 port, u32 *speed, int read);
+extern int switch_mv88e6190_port_cop_specific_duplex_read(u16 port, u32 *duplex, int read);
+extern int switch_mv88e6190_port_cop_specific_mdix_read(u16 port, u32 *mdix, int read); /* midx : 1; mdi : 0 */
+extern int switch_mv88e6190_port_cop_specific_cop_link_rt_read(u16 port, u32 *staus, int read);
+extern int switch_mv88e6190_port_cop_specific_global_link_status_read(u16 port, u32 *staus, int read);
+#endif
 /* ---------------------------------------------------------------- */
 static int do_mii(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	char		op[2];
+#ifdef CONFIG_MV88E6190_SWITCH
+	unsigned short	addrlo, addrhi, reglo, reghi;
+	unsigned short	addr, reg;
+#else
 	unsigned char	addrlo, addrhi, reglo, reghi;
 	unsigned char	addr, reg;
+#endif /* ifdef CONFIG_MV88E6190_SWITCH */
+
 	unsigned short	data, mask;
 	int		rcode = 0;
 	const char	*devname;
@@ -305,12 +349,36 @@
 
 		if (argc >= 3)
 			extract_range(argv[2], &addrlo, &addrhi);
-		if (argc >= 4)
-			extract_range(argv[3], &reglo, &reghi);
-		if (argc >= 5)
-			data = simple_strtoul(argv[4], NULL, 16);
-		if (argc >= 6)
-			mask = simple_strtoul(argv[5], NULL, 16);
+		if (argc >= 4) {
+#ifdef CONFIG_MV88E6190_SWITCH
+			if(!strncmp(argv[3], "mvl", strlen("mvl"))) {
+				extract_range(argv[2], &addrlo, &addrhi);
+			}
+			else
+#endif
+			{
+				extract_range(argv[3], &reglo, &reghi);
+			}
+		}
+		if (argc >= 5) {
+#ifdef CONFIG_MV88E6190_SWITCH
+			if(!strncmp(argv[4], "mvl", strlen("mvl"))) {
+				extract_range(argv[3], &reglo, &reghi);
+			} else
+#endif
+			{
+				data = simple_strtoul(argv[4], NULL, 16);
+			}
+		}
+		if (argc >= 6) 
+		{
+#ifdef CONFIG_MV88E6190_SWITCH
+			if(strncmp(argv[5], "mvl", strlen("mvl")))
+#endif
+			{
+				mask = simple_strtoul(argv[5], NULL, 16);
+			}
+	        }
 	}
 
 	if (addrhi > 31) {
@@ -354,49 +422,223 @@
 						? "FDX" : "HDX");
 			}
 		}
-	} else if (op[0] == 'r') {
-		for (addr = addrlo; addr <= addrhi; addr++) {
-			for (reg = reglo; reg <= reghi; reg++) {
+    }
+#ifdef CONFIG_MV88E6190_SWITCH
+    else if ((!strncmp(argv[1], "an", 2) || !strncmp(argv[1], "speed", 5) || !strncmp(argv[1], "duplex", 6) || !strncmp(argv[1], "mdi", 3)
+           || !strncmp(argv[1], "ancomp", 6) || !strncmp(argv[1], "coplink", 7) || !strncmp(argv[1], "rtlink", 6) || !strncmp(argv[1], "glblink", 7) 
+           || !strncmp(argv[1], "remflt", 6) || !strncmp(argv[1], "jabdet", 6) || !strncmp(argv[1], "speedrd", 7) || !strncmp(argv[1], "duplexrd", 8) || !strncmp(argv[1], "mdixrd", 6))
+          && (!strncmp(argv[argc - 1], "mvl", strlen("mvl"))))
+    {
+        int(*mvOp)(u16, u32*, int);
+        u32 val = 0;
+
+        if(!strncmp(argv[1], "ancomp", 6) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_autonego_complete_read;
+        }
+        else if(!strncmp(argv[1], "coplink", 7) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_copper_link_status_read;
+        }
+        else if(!strncmp(argv[1], "rtlink", 6) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_cop_specific_cop_link_rt_read;
+        }
+        else if(!strncmp(argv[1], "glblink", 7) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_cop_specific_global_link_status_read;
+        }
+        else if(!strncmp(argv[1], "remflt", 6) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_copper_remote_fault_read;
+        }
+        else if(!strncmp(argv[1], "jabdet", 6) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_jabber_detect_read;
+        }
+        else if(!strncmp(argv[1], "speedrd", 7) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_cop_specific_speed_read;
+        }
+        else if(!strncmp(argv[1], "duplexrd", 8) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_cop_specific_duplex_read;
+        }
+        else if(!strncmp(argv[1], "mdixrd", 6) && (argc == 4))
+        {
+            mvOp = switch_mv88e6190_port_cop_specific_mdix_read;
+        }
+        else if(!strncmp(argv[1], "an", 2))
+        {
+            mvOp = switch_mv88e6190_port_autonego;
+        }
+        else if(!strncmp(argv[1], "speed", 5))
+        {
+            mvOp = switch_mv88e6190_port_speed;
+        }
+        else if(!strncmp(argv[1], "duplex", 6))
+        {
+            mvOp = switch_mv88e6190_port_duplex;
+        }
+        else if(!strncmp(argv[1], "mdi", 3))
+        {
+            mvOp = switch_mv88e6190_port_mdi_mode;
+        }
+
+        if (argc == 5)
+        {
+#if 0
+            addr = simple_strtoul(argv[2], NULL, 16); 
+            reg = simple_strtoul(argv[3], NULL, 16);
+#else
+            for (addr = addrlo; addr <= addrhi; addr++)
+#endif
+            {
+                for (reg = reglo; reg <= reghi; reg++)
+                {
+                    val = (u32)reg;
+                    if (mvOp && mvOp(addr, &val, 0))
+                    {
+                        printf("Error writing %s from the port:", argv[1]);
+                        printf(" port=%02x", addr);
+                        printf(" %s=0x%x(%u)\n", argv[1], val, val);
+                        rcode = 1;
+                    }
+                    else
+                    {
+                        printf("Written %s from the port:", argv[1]);
+                        printf(" port=%02x", addr);
+                        printf(" %s=0x%x(%u)\n", argv[1], val, val);
+                    }
+                }
+            }
+        }
+        else if (argc == 4)
+        {
+#if 0
+            addr = simple_strtoul(argv[2], NULL, 16); 
+#else
+            for (addr = addrlo; addr <= addrhi; addr++)
+#endif
+            {
+                if (mvOp && mvOp(addr, &val, 1))
+                {
+                    printf("Error reading %s from the port:", argv[1]);
+                    printf(" port=%02x\n", addr);
+                    rcode = 1;
+                }
+                else
+                {
+                    printf("Reading %s from the port:", argv[1]);
+                    printf(" port=%02x", addr);
+                    printf(" %s=0x%x(%u)\n", argv[1], val, val);
+                }
+            }
+        }
+        else
+        {
+            rcode = CMD_RET_USAGE;
+        }
+    }
+#endif
+    else if (op[0] == 'r')
+    {
+        for (addr = addrlo; addr <= addrhi; addr++)
+        {
+            for (reg = reglo; reg <= reghi; reg++)
+            {
 				data = 0xffff;
-				if (miiphy_read (devname, addr, reg, &data) != 0) {
+#ifdef CONFIG_MV88E6190_SWITCH
+                if(!strncmp(argv[4], "mvl", strlen("mvl")))
+                {
+                    if (marvell_phy_read (addr, reg, &data) != 0)
+                    {
+                        printf(
+                            "Error reading from the Marvell PHY addr=0x%02x reg=0x%02x\n",
+                            addr, reg);
+                        rcode = 1;
+                    }
+                    else
+                    {
+                        if ((addrlo != addrhi) || (reglo != reghi))
+                            printf("Marvell addr=0x%02x reg=0x%02x data=",
+                                   (uint)addr, (uint)reg);
+                        printf("0x%04X\n", data & 0x0000FFFF);
+                    }
+                }
+                else
+#endif
+                {
+                    if (miiphy_read (devname, addr, reg, &data) != 0)
+                    {
 					printf(
 					"Error reading from the PHY addr=%02x reg=%02x\n",
 						addr, reg);
 					rcode = 1;
-				} else {
+                    }
+                    else
+                    {
 					if ((addrlo != addrhi) || (reglo != reghi))
 						printf("addr=%02x reg=%02x data=",
 							(uint)addr, (uint)reg);
 					printf("%04X\n", data & 0x0000FFFF);
 				}
 			}
+            }
 			if ((addrlo != addrhi) && (reglo != reghi))
 				printf("\n");
 		}
-	} else if (op[0] == 'w') {
-		for (addr = addrlo; addr <= addrhi; addr++) {
-			for (reg = reglo; reg <= reghi; reg++) {
-				if (miiphy_write (devname, addr, reg, data) != 0) {
+    }
+    else if (op[0] == 'w')
+    {
+        for (addr = addrlo; addr <= addrhi; addr++)
+        {
+            for (reg = reglo; reg <= reghi; reg++)
+            {
+#ifdef CONFIG_MV88E6190_SWITCH
+                if(!strncmp(argv[5], "mvl", strlen("mvl")))
+                {
+                    if (marvell_phy_write (addr, reg, data) != 0)
+                    {
+                        printf("Error writing to the Marvell PHY addr=%02x reg=%02x\n",
+                               addr, reg);
+                        rcode = 1;
+                    }
+                }
+                else
+#endif
+                {
+                    if (miiphy_write (devname, addr, reg, data) != 0)
+                    {
 					printf("Error writing to the PHY addr=%02x reg=%02x\n",
 						addr, reg);
 					rcode = 1;
 				}
 			}
 		}
-	} else if (op[0] == 'm') {
-		for (addr = addrlo; addr <= addrhi; addr++) {
-			for (reg = reglo; reg <= reghi; reg++) {
+        }
+    }
+    else if (op[0] == 'm')
+    {
+        for (addr = addrlo; addr <= addrhi; addr++)
+        {
+            for (reg = reglo; reg <= reghi; reg++)
+            {
 				unsigned short val = 0;
 				if (miiphy_read(devname, addr,
-						reg, &val)) {
+                                reg, &val))
+                {
 					printf("Error reading from the PHY");
 					printf(" addr=%02x", addr);
 					printf(" reg=%02x\n", reg);
 					rcode = 1;
-				} else {
+                }
+                else
+                {
 					val = (val & ~mask) | (data & mask);
 					if (miiphy_write(devname, addr,
-							 reg, val)) {
+                                     reg, val))
+                    {
 						printf("Error writing to the PHY");
 						printf(" addr=%02x", addr);
 						printf(" reg=%02x\n", reg);
@@ -405,18 +647,24 @@
 				}
 			}
 		}
-	} else if (strncmp(op, "du", 2) == 0) {
+    }
+    else if (strncmp(op, "du", 2) == 0)
+    {
 		ushort regs[6];
 		int ok = 1;
-		if ((reglo > 5) || (reghi > 5)) {
+        if ((reglo > 5) || (reghi > 5))
+        {
 			printf(
 				"The MII dump command only formats the "
 				"standard MII registers, 0-5.\n");
 			return 1;
 		}
-		for (addr = addrlo; addr <= addrhi; addr++) {
-			for (reg = reglo; reg < reghi + 1; reg++) {
-				if (miiphy_read(devname, addr, reg, &regs[reg]) != 0) {
+        for (addr = addrlo; addr <= addrhi; addr++)
+        {
+            for (reg = reglo; reg < reghi + 1; reg++)
+            {
+                if (miiphy_read(devname, addr, reg, &regs[reg]) != 0)
+                {
 					ok = 0;
 					printf(
 					"Error reading from the PHY addr=%02x reg=%02x\n",
@@ -428,12 +676,16 @@
 				MII_dump_0_to_5(regs, reglo, reghi);
 			printf("\n");
 		}
-	} else if (strncmp(op, "de", 2) == 0) {
+    }
+    else if (strncmp(op, "de", 2) == 0)
+    {
 		if (argc == 2)
 			miiphy_listdev ();
 		else
 			miiphy_set_current_dev (argv[2]);
-	} else {
+    }
+    else
+    {
 		return CMD_RET_USAGE;
 	}
 
@@ -465,5 +717,22 @@
 	"mii modify <addr> <reg> <data> <mask> - modify MII PHY <addr> register <reg>\n"
 	"                                        updating bits identified in <mask>\n"
 	"mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)\n"
+#ifdef CONFIG_MV88E6190_SWITCH
+    "mii read     <addr> <reg>        mvl  - Marvell PHY read  MII PHY <addr> register <reg>\n"
+    "mii write    <addr> <reg> <data> mvl  - Marvell PHY write MII PHY <addr> register <reg>\n"
+    "mii an       <port> [<an>]       mvl  - Marvell PHY read/write <port> <an>\n"
+    "mii speed    <port> [<speed>]    mvl  - Marvell PHY read/write <port> <speed>\n"
+    "mii duplex   <port> [<duplex>]   mvl  - Marvell PHY read/write <port> <duplex>, 1:full;0:half\n"
+    "mii mdi      <port> [<mdi mode>] mvl  - Marvell PHY read/write <port> <mdi/mdix mode>, 0:Manual MDI;1:Manual MDIX;3:Auto MDI/MDIX\n"
+    "mii speedrd  <port>              mvl  - Marvell PHY read       <port> speed\n"
+    "mii duplexrd <port>              mvl  - Marvell PHY read       <port> duplex\n"
+    "mii mdixrd   <port>              mvl  - Marvell PHY read       <port> MDI/MDIX crossover read\n"
+    "mii ancomp   <port>              mvl  - Marvell PHY read       <port> autonego complete\n"
+    "mii coplink  <port>              mvl  - Marvell PHY read       <port> copper link status\n"
+    "mii rtlink   <port>              mvl  - Marvell PHY read       <port> copper link status of realtime\n"
+    "mii glblink  <port>              mvl  - Marvell PHY read       <port> global link status\n"
+    "mii remflt   <port>              mvl  - Marvell PHY read       <port> remote fault detect\n"
+    "mii jabdet   <port>              mvl  - Marvell PHY read       <port> jabber detect\n"
+#endif
 	"Addr and/or reg may be ranges, e.g. 2-7."
 );
--- u-boot-2018.09/cmd/sf.c.orig	2022-05-09 14:11:31.296682721 -0700
+++ u-boot-2018.09/cmd/sf.c	2022-05-09 14:11:36.376477066 -0700
@@ -541,6 +541,32 @@
 }
 #endif /* CONFIG_CMD_SF_TEST */
 
+void read_wg_sn(char *p_wg_sn)
+{
+	int flash_probe_argc = 2;
+	char * const flash_probe_argv[] = {"probe", "0:0"};
+	int flash_read_argc = 4;
+	char * const flash_read_argv[] = {"read", "0x82000000", "0x280018", "0xd"};
+	const char *p_buf = (const char *)0x82000000;
+	int wg_sn_len = 13;
+	
+	do_spi_flash_probe(flash_probe_argc, flash_probe_argv);
+	do_spi_flash_read_write(flash_read_argc, flash_read_argv);
+	strncpy(p_wg_sn, p_buf, wg_sn_len);
+	p_wg_sn[wg_sn_len] = 0;
+}
+
+int is_t40cw(void)
+{
+	char wg_sn[14] = {0};
+	const char t40cw_wg_sn_prefix[5] = "D02A";
+
+	read_wg_sn(wg_sn);
+	if(!strncmp(wg_sn, t40cw_wg_sn_prefix, strlen(t40cw_wg_sn_prefix)))
+		return 1;
+	return 0;
+}
+
 static int do_spi_flash(cmd_tbl_t *cmdtp, int flag, int argc,
 			char * const argv[])
 {
--- u-boot-2018.09/configs/ls1043aqds_qspi_defconfig.orig	2022-05-09 14:11:31.592670738 -0700
+++ u-boot-2018.09/configs/ls1043aqds_qspi_defconfig	2022-05-09 14:11:36.564469456 -0700
@@ -52,3 +52,6 @@
 CONFIG_SCSI_AHCI=y
 CONFIG_SCSI=y
 CONFIG_AHCI=y
+CONFIG_CMD_DATE=y
+CONFIG_RTC_S35392A=y
+CONFIG_CMD_GPIO=y
--- u-boot-2018.09/net/Kconfig.orig	2022-05-09 14:11:34.432555766 -0700
+++ u-boot-2018.09/net/Kconfig	2022-05-09 14:11:37.388436098 -0700
@@ -22,4 +22,12 @@
 	  Support the 'nc' input/output device for networked console.
 	  See README.NetConsole for details.
 
+# Forest Tsao B
+config MV88E6190_SWITCH
+    default 0
+config MV88E6190_SWITCH_CPU_ATTACHED
+	depends on MV88E6190_SWITCH
+    default 1
+# Forest Tsao E
+
 endif   # if NET
--- u-boot-2018.09/scripts/config_whitelist.txt.orig	2022-05-09 14:11:34.500553013 -0700
+++ u-boot-2018.09/scripts/config_whitelist.txt	2022-05-09 14:11:37.428434478 -0700
@@ -540,6 +540,9 @@
 CONFIG_ET1100_BASE
 CONFIG_ETH1ADDR
 CONFIG_ETH2ADDR
+CONFIG_ETH3ADDR
+CONFIG_ETH4ADDR
+CONFIG_ETH5ADDR
 CONFIG_ETHADDR
 CONFIG_ETHBASE
 CONFIG_ETHER_INDEX
@@ -1812,6 +1815,7 @@
 CONFIG_SMSTP7_ENA
 CONFIG_SMSTP8_ENA
 CONFIG_SMSTP9_ENA
+CONFIG_SN74LV164A
 CONFIG_SOCRATES
 CONFIG_SOC_DM355
 CONFIG_SOC_DM365
--- u-boot-2018.09/common/wgmenu.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/common/wgmenu.c	2022-05-09 14:11:36.448474151 -0700
@@ -0,0 +1,181 @@
+#include <common.h>
+#ifndef DO_DEPS_ONLY
+#include "generated/version_autogenerated.h"
+#include "generated/timestamp_autogenerated.h"
+#endif
+#include <wgmenu.h>
+
+#define WG_VERSION_STRING ("WatchGuard " U_BOOT_VERSION " - " U_BOOT_DATE " " U_BOOT_TIME)
+#define ANSI_CLEAR		"\e[2J"
+#define ANSI_REVERSE		"\e[7m"
+#define	ANSI_NORMAL		"\e[m"
+#define ANSI_GOTOYX		"\e[%d;%dH"
+
+#define SCREEN_HIGH		24
+#define SCREEN_WIDTH		80
+#define MAX_MENU_ITEMS		10
+
+#define FIRST_LINE_Y		2
+#define FIRST_LINE_X_FUN(len)	((SCREEN_WIDTH - len)/2)
+#define FIRST_LINE_X		FIRST_LINE_X_FUN(58)
+
+#define TABLE_START_Y		4
+#define TABLE_START_X		2 
+#define TABLE_LENGHT		(SCREEN_WIDTH - 6)
+#define TABLE_HIGH		(SCREEN_HIGH/2)
+
+#define	TOP_ROW			(TABLE_START_X + 1)
+#define	MENU_0_ROW		(TABLE_START_Y + 1)
+
+struct __wgmenu_option {
+	const char *label;		// WG:BH - We really only use the label...
+	void (*fn)(void *user);		// but we could add functionality to add dynamically generated menu items.
+	void *user;			// <<< this one is the argument to fn.
+};
+
+static struct __wgmenu_option wg_options[MAX_MENU_ITEMS];
+static int __wgmenu_max_width = TABLE_LENGHT - 4;
+static int __wgmenu_num_options = 0;
+static int __wgmenu_option_pos = 0;
+static int __wgmenu_boot_menu = 1;
+
+static void __wgmenu_print_option(const struct __wgmenu_option *opt, int reverse)
+{
+	int n = (opt - wg_options);
+	char format[10] = {'\0'};
+
+	printf(ANSI_GOTOYX, MENU_0_ROW+n, TABLE_START_X + 1);
+	if (reverse) {
+		printf(ANSI_REVERSE);
+	}
+
+	sprintf(format, "%%-%ds", __wgmenu_max_width);
+	printf(format, opt->label);
+
+	if (reverse) {
+		printf(ANSI_NORMAL);
+	}
+
+	printf(ANSI_GOTOYX ,SCREEN_HIGH + 2 , 1); 
+}
+
+static void __wgmenu_show_bootmenu_table(void)
+{
+	int i = 0,j = 0 ;
+
+	printf(ANSI_CLEAR ANSI_GOTOYX "%s", FIRST_LINE_Y,
+			(int)FIRST_LINE_X_FUN((strlen(WG_VERSION_STRING))), WG_VERSION_STRING);
+
+	for (i = 0 ; i < TABLE_LENGHT ; i++) {	//the above horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y, TABLE_START_X + i);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	//the left line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X);
+	}
+	for (j = 0 ; j < TABLE_HIGH ; j++) {	// the right line
+		printf(ANSI_GOTOYX "|", TABLE_START_Y + j , TABLE_START_X + TABLE_LENGHT);
+	}
+	for (i = 1 ; i < TABLE_LENGHT ; i++) {	//the below horizontal line
+		printf(ANSI_GOTOYX "-", TABLE_START_Y + TABLE_HIGH, TABLE_START_X + i);
+	}
+
+	printf(ANSI_GOTOYX "+",TABLE_START_Y, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y , TABLE_START_X + TABLE_LENGHT); 
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X);
+	printf(ANSI_GOTOYX "+",TABLE_START_Y + TABLE_HIGH, TABLE_START_X + TABLE_LENGHT);
+
+	printf(ANSI_GOTOYX "Use the ^ and v keys to select which entry is highlighted.",
+			TABLE_START_Y + TABLE_HIGH + 2, 7);
+	printf(ANSI_GOTOYX "Press enter to boot the selected OS.",
+			TABLE_START_Y + TABLE_HIGH + 3, 7);
+
+	printf(ANSI_GOTOYX , SCREEN_HIGH + 2, 1);
+}
+
+static void __wgmenu_show_bootmenu(void)
+{
+	const struct __wgmenu_option *opt = {NULL};
+
+	__wgmenu_show_bootmenu_table();
+
+	for (opt = wg_options; opt != (wg_options + __wgmenu_num_options); opt++) {
+		__wgmenu_print_option(opt, opt == wg_options);
+	}
+}
+
+static int __wgmenu_wg_display_menu(int key)
+{
+	static struct __wgmenu_option *opt = wg_options;
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 0);
+
+	switch (key) {
+		case 65: //up
+			if(__wgmenu_option_pos > 0)
+				__wgmenu_option_pos--;
+			break; 
+		case 66: //down
+			if(__wgmenu_option_pos < (__wgmenu_num_options - 1))
+				__wgmenu_option_pos++;
+			break; 
+		case 13:
+		default:
+			break;
+	}
+
+	__wgmenu_print_option(&wg_options[__wgmenu_option_pos], 1);
+
+	return opt - wg_options ;
+}
+
+int wgmenu_hook(int key)
+{
+	static const struct __wgmenu_option *opt = wg_options;
+	int hooked = 0;
+
+	if ((key == 65 || key == 66) && opt && __wgmenu_num_options) {
+		hooked = 1;
+		__wgmenu_wg_display_menu(key);
+	}
+
+	return hooked;
+}
+
+
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user)
+{
+	int len;
+
+	wg_options[__wgmenu_num_options].label = label;
+	wg_options[__wgmenu_num_options].fn = fn;
+	wg_options[__wgmenu_num_options].user = user;
+	__wgmenu_num_options++;
+
+	len = strlen(label);
+
+	if (len > __wgmenu_max_width)
+		__wgmenu_max_width = len;
+}
+
+
+void wgmenu_show(void)
+{
+	wgmenu_add("WatchGuard (SYSA)", NULL, NULL);
+	wgmenu_add("WatchGuard (SYSB Recovery/Diagnostic Mode)", NULL, NULL);
+	__wgmenu_show_bootmenu();
+}
+
+int wgmenu_selected(void)
+{
+	return __wgmenu_option_pos;
+}
+
+int wgmenu_inmenu(void)
+{
+	return __wgmenu_boot_menu;
+}
+
+void wgmenu_exit(void)
+{
+	__wgmenu_boot_menu = 0;
+}
--- u-boot-2018.09/arch/mips/dts/sagem,f@st1704.dts.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/arch/mips/dts/sagem,f@st1704.dts	2022-05-09 14:11:35.624507510 -0700
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2017 Álvaro Fernández Rojas <noltari@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "brcm,bcm6338.dtsi"
+
+/ {
+	model = "Sagem F@ST1704";
+	compatible = "sagem,f@st1704", "brcm,bcm6338";
+
+	aliases {
+		serial0 = &uart0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		inet_green {
+			label = "F@ST1704:green:inet";
+			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
+		};
+
+		power_green {
+			label = "F@ST1704:green:power";
+			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
+		};
+
+		inet_red {
+			label = "F@ST1704:red:inet";
+			gpios = <&gpio 2 GPIO_ACTIVE_LOW>;
+		};
+	};
+};
+
+&gpio {
+	status = "okay";
+};
+
+&spi {
+	status = "okay";
+
+	spi-flash@0 {
+		compatible = "spi-flash";
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <20000000>;
+	};
+};
+
+&uart0 {
+	u-boot,dm-pre-reloc;
+	status = "okay";
+};
--- u-boot-2018.09/arch/arm/dts/fsl-ls1043a-qds-wg_t40_t20-duart.dts.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/arch/arm/dts/fsl-ls1043a-qds-wg_t40_t20-duart.dts	2022-05-09 14:11:35.256522408 -0700
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0+ OR X11
+/*
+ * Device Tree file for Freescale Layerscape-1043A family SoC.
+ *
+ * Copyright (C) 2015, Freescale Semiconductor
+ */
+
+/dts-v1/;
+#include "fsl-ls1043a-qds.dtsi"
+
+/ {
+	model = "LS1043A QDS Board - T40/T20";
+       chosen {
+               stdout-path = &duart0;
+       };
+};
+
+&dspi0 {
+	status = "disabled";
+};
+
+&i2c0 {
+	/delete-node/ pca9547@77;
+
+	rtc@30 {
+		compatible = "sii,s35392a-rtc";
+		reg = <0x30>;
+	};
+};
+
+&ifc {
+	/delete-node/ nand@1,0;
+	/delete-node/ board-control@2,0;
+};
--- u-boot-2018.09/include/wgmenu.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/include/wgmenu.h	2022-05-09 14:11:37.340438040 -0700
@@ -0,0 +1,11 @@
+#ifndef _WGMENU_H
+#define _WGMENU_H
+
+int wgmenu_hook(int key);
+void wgmenu_add(const char *label, void (*fn)(void *user), void *user);
+void wgmenu_show(void);
+int wgmenu_selected(void);
+int wgmenu_inmenu(void);
+void wgmenu_exit(void);
+
+#endif /* _WGMENU_H */
--- u-boot-2018.09/include/configs/ls1043aqds_t20.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/include/configs/ls1043aqds_t20.h	2022-05-09 14:11:37.128446623 -0700
@@ -0,0 +1,436 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __LS1043AQDS_H__
+#define __LS1043AQDS_H__
+
+#include "ls1043a_common.h"
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ		100000000
+#define CONFIG_DDR_CLK_FREQ		100000000
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+
+#define CONFIG_LAYERSCAPE_NS_ACCESS
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+/* Physical Memory Map */
+#define CONFIG_CHIP_SELECTS_PER_CTRL	4
+
+#define CONFIG_SYS_DDR_RAW_TIMING
+
+#ifndef CONFIG_SPL
+#define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
+#endif
+
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE           0xdeadbeef
+#endif
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_ATHEROS
+#define RGMII_PHY1_ADDR		0x1
+#define QSGMII_CARD_PORT1_PHY_ADDR_S1 0x4
+#define QSGMII_CARD_PORT2_PHY_ADDR_S1 0x5
+#define QSGMII_CARD_PORT3_PHY_ADDR_S1 0x6
+#define QSGMII_CARD_PORT4_PHY_ADDR_S1 0x7
+
+#define CONFIG_IPADDR		192.168.1.1
+#define CONFIG_SERVERIP		192.168.1.100
+#define CONFIG_NETMASK		255.255.255.0
+
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#define CONFIG_HAS_ETH3
+#define CONFIG_HAS_ETH4
+#define CONFIG_HAS_ETH5
+
+#define CONFIG_ETHADDR		00:0B:6B:01:01:01
+#define CONFIG_ETH1ADDR		00:0B:6B:01:01:02
+#define CONFIG_ETH2ADDR		00:0B:6B:01:01:03
+#define CONFIG_ETH3ADDR		00:0B:6B:01:01:04
+#define CONFIG_ETH4ADDR		00:0B:6B:01:01:05
+#define CONFIG_ETH5ADDR		00:0B:6B:01:01:06
+#define CONFIG_ETHPRIME         "FM1@DTSEC1"
+#endif
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI board/freescale/ls1043aqds/ls1043aqds_pbi.cfg
+#endif
+
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW board/freescale/ls1043aqds/ls1043aqds_rcw_nand.cfg
+#endif
+
+#ifdef CONFIG_SD_BOOT
+#ifdef CONFIG_SD_BOOT_QSPI
+#define CONFIG_SYS_FSL_PBL_RCW \
+	board/freescale/ls1043aqds/ls1043aqds_rcw_sd_qspi.cfg
+#else
+#define CONFIG_SYS_FSL_PBL_RCW board/freescale/ls1043aqds/ls1043aqds_rcw_sd_ifc.cfg
+#endif
+#endif
+
+/* LPUART */
+#ifdef CONFIG_LPUART
+#define CONFIG_LPUART_32B_REG
+#endif
+
+/* SATA */
+#define CONFIG_SCSI_AHCI_PLAT
+
+#define CONFIG_SYS_SATA				AHCI_BASE_ADDR
+
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID		1
+#define CONFIG_SYS_SCSI_MAX_LUN			1
+#define CONFIG_SYS_SCSI_MAX_DEVICE		(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+						CONFIG_SYS_SCSI_MAX_LUN)
+
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SPL_PAD_TO		0x20000		/* block aligned */
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	CONFIG_SPL_PAD_TO
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(640 << 10)
+#endif
+
+#if defined(CONFIG_TFABOOT) || \
+	defined(CONFIG_QSPI_BOOT) || defined(CONFIG_SD_BOOT_QSPI)
+#define CONFIG_QIXIS_I2C_ACCESS
+#define CONFIG_SYS_I2C_EARLY_INIT
+#endif
+
+/*
+ * QIXIS Definitions
+ */
+#define CONFIG_FSL_QIXIS
+
+#ifdef CONFIG_FSL_QIXIS
+#define QIXIS_BASE			0x7fb00000
+#define QIXIS_BASE_PHYS			QIXIS_BASE
+#define CONFIG_SYS_I2C_FPGA_ADDR	0x66
+#define QIXIS_LBMAP_SWITCH		6
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_LBMAP_NAND		0x09
+#define QIXIS_LBMAP_SD			0x00
+#define QIXIS_LBMAP_SD_QSPI		0xff
+#define QIXIS_LBMAP_QSPI		0xff
+#define QIXIS_RCW_SRC_NAND		0x106
+#define QIXIS_RCW_SRC_SD		0x040
+#define QIXIS_RCW_SRC_QSPI		0x045
+#define QIXIS_RST_CTL_RESET		0x41
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+
+#define CONFIG_SYS_FPGA_CSPR_EXT	(0x0)
+#define CONFIG_SYS_FPGA_CSPR		(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) | \
+					CSPR_PORT_SIZE_8 | \
+					CSPR_MSEL_GPCM | \
+					CSPR_V)
+#define CONFIG_SYS_FPGA_AMASK		IFC_AMASK(64 * 1024)
+#define CONFIG_SYS_FPGA_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
+					CSOR_NOR_NOR_MODE_AVD_NOR | \
+					CSOR_NOR_TRHZ_80)
+
+/*
+ * QIXIS Timing parameters for IFC GPCM
+ */
+#define CONFIG_SYS_FPGA_FTIM0		(FTIM0_GPCM_TACSE(0xc) | \
+					FTIM0_GPCM_TEADC(0x20) | \
+					FTIM0_GPCM_TEAHC(0x10))
+#define CONFIG_SYS_FPGA_FTIM1		(FTIM1_GPCM_TACO(0x50) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_FPGA_FTIM2		(FTIM2_GPCM_TCS(0x8) | \
+					FTIM2_GPCM_TCH(0x8) | \
+					FTIM2_GPCM_TWP(0xf0))
+#define CONFIG_SYS_FPGA_FTIM3		0x0
+#endif
+
+#ifdef CONFIG_TFABOOT
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#else
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#endif
+#endif
+
+/*
+ * I2C bus multiplexer
+ */
+#define I2C_MUX_PCA_ADDR_PRI		0x77
+#define I2C_MUX_PCA_ADDR_SEC		0x76 /* Secondary multiplexer */
+#define I2C_RETIMER_ADDR		0x18
+#define I2C_MUX_CH_DEFAULT		0x8
+#define I2C_MUX_CH_CH7301		0xC
+#define I2C_MUX_CH5			0xD
+#define I2C_MUX_CH7			0xF
+
+#define I2C_MUX_CH_VOL_MONITOR 0xa
+
+/* Voltage monitor on channel 2*/
+#define I2C_VOL_MONITOR_ADDR           0x40
+#define I2C_VOL_MONITOR_BUS_V_OFFSET   0x2
+#define I2C_VOL_MONITOR_BUS_V_OVF      0x1
+#define I2C_VOL_MONITOR_BUS_V_SHIFT    3
+
+#define CONFIG_VID_FLS_ENV		"ls1043aqds_vdd_mv"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_VID
+#endif
+#define CONFIG_VOL_MONITOR_IR36021_SET
+#define CONFIG_VOL_MONITOR_INA220
+/* The lowest and highest voltage allowed for LS1043AQDS */
+#define VDD_MV_MIN			819
+#define VDD_MV_MAX			1212
+
+/* QSPI device */
+#if defined(CONFIG_TFABOOT) || \
+	(defined(CONFIG_QSPI_BOOT) || defined(CONFIG_SD_BOOT_QSPI))
+#define CONFIG_FSL_QSPI
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_MACRONIX
+#define FSL_QSPI_FLASH_SIZE		(1 << 24)
+#define FSL_QSPI_FLASH_NUM		2
+#endif
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		0x9fffffff
+
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#ifdef CONFIG_TFABOOT
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		0x500000        /* 5MB */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x500000)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#else
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(24 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SD_BOOT)
+#define CONFIG_ENV_OFFSET		(3 * 1024 * 1024)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x2000
+#elif defined(CONFIG_QSPI_BOOT)
+#define CONFIG_ENV_SIZE			0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET		0x200000        /* 2MB */
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#else
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x300000)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#define CONFIG_ENV_SIZE			0x20000
+#endif
+#endif
+
+#define CONFIG_CMDLINE_TAG
+
+#undef	CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"fdt_high=0xffffffffffffffff\0"		\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"fdt_addr=0x64f00000\0"		 	\
+	"kernel_addr=0x61000000\0"		\
+	"scriptaddr=0x80000000\0"		\
+	"scripthdraddr=0x80080000\0"		\
+	"fdtheader_addr_r=0x80100000\0"		\
+	"kernelheader_addr_r=0x80200000\0"	\
+	"kernel_addr_r=0x81000000\0"		\
+	"kernel_start=0x1000000\0"		\
+	"kernelheader_start=0x800000\0"		\
+	"fdt_addr_r=0x90000000\0"		\
+	"load_addr=0xa0000000\0"		\
+	"kernelheader_addr=0x60800000\0"	\
+	"kernel_size=0x2800000\0"		\
+	"kernelheader_size=0x40000\0"		\
+	"kernel_addr_sd=0x8000\0"		\
+	"kernel_size_sd=0x14000\0"		\
+	"kernelhdr_addr_sd=0x4000\0"		\
+	"kernelhdr_size_sd=0x10\0"		\
+	"boot_os=y\0"				\
+	"mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0"	\
+	BOOTENV					\
+	"boot_scripts=ls1043ardb_boot.scr\0"	\
+	"boot_script_hdr=hdr_ls1043ardb_bs.out\0"	\
+	"consoledev=ttyS0\0"					\
+	"loadaddr=82000000\0"					\
+	"WGKernelfile=kernel_T20_T40_prod.itb\0"                                \
+	"SysARoot=mmcblk0p3\0"	\
+	"SysBRoot=mmcblk0p2\0"	\
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"mmc info; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw rootdelay=2 " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"mmc info; " \
+	"ext2load mmc 0:2 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"mmc info; " \
+	"ext2load mmc 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"  \
+	"nuke_env=sf probe 0;sf erase 0x200000 10000;\0"  \
+	"ipaddr=10.0.1.1;\0" \
+	"serveraddr=10.0.1.13;\0" \
+	"netmask=255.255.255.0;\0" \
+	"flash_bootloader=tftp 0x82000000 u-boot_ls1043aqds_wg_t20_qspi.bin;" \
+	"sf probe 0; sf erase 0 0x100000; sf write 0x82000000 0 $filesize;" \
+	"sf read 0x80000000 0 $filesize; cmp.b 0x82000000 0x80000000 $filesize;\0"
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+
+/* GPIO1[13:14, 23:31] */
+#define GPIO1_SUPPORT			((0x3 << 13) | (0x1ff << 23))
+/* GPIO2[0:9][11:15] */
+#define GPIO2_SUPPORT                  ((0x1ff << 0))| (0x1f << 11)
+/* GPIO3[15:27] */
+#define GPIO3_SUPPORT			(0x1fff << 15)
+/* GPIO4[2:3, 12:13, 29:30] */
+#define GPIO4_SUPPORT			((0x3 << 2) | (0x3 << 12) | (0x3 << 29))
+
+#define CONFIG_SN74LV164A
+#define SN74LV164A_CLR_GPIO		205
+#define SN74LV164A_CLK_GPIO		127
+#define SN74LV164A_INA_GPIO		128
+
+#include <asm/fsl_secure_boot.h>
+
+#endif /* __LS1043AQDS_H__ */
--- u-boot-2018.09/include/configs/ls1043aqds_t40.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/include/configs/ls1043aqds_t40.h	2022-05-09 14:11:37.132446461 -0700
@@ -0,0 +1,435 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __LS1043AQDS_H__
+#define __LS1043AQDS_H__
+
+#include "ls1043a_common.h"
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ		100000000
+#define CONFIG_DDR_CLK_FREQ		100000000
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+
+#define CONFIG_LAYERSCAPE_NS_ACCESS
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+/* Physical Memory Map */
+#define CONFIG_CHIP_SELECTS_PER_CTRL	4
+
+#define CONFIG_SYS_DDR_RAW_TIMING
+
+#ifndef CONFIG_SPL
+#define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
+#endif
+
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE           0xdeadbeef
+#endif
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_ATHEROS
+#define RGMII_PHY1_ADDR		0x1
+#define QSGMII_CARD_PORT1_PHY_ADDR_S1 0x4
+#define QSGMII_CARD_PORT2_PHY_ADDR_S1 0x5
+#define QSGMII_CARD_PORT3_PHY_ADDR_S1 0x6
+#define QSGMII_CARD_PORT4_PHY_ADDR_S1 0x7
+
+#define CONFIG_IPADDR		192.168.1.1
+#define CONFIG_SERVERIP		192.168.1.100
+#define CONFIG_NETMASK		255.255.255.0
+
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#define CONFIG_HAS_ETH3
+#define CONFIG_HAS_ETH4
+#define CONFIG_HAS_ETH5
+
+#define CONFIG_ETHADDR		00:0B:6B:01:01:01
+#define CONFIG_ETH1ADDR		00:0B:6B:01:01:02
+#define CONFIG_ETH2ADDR		00:0B:6B:01:01:03
+#define CONFIG_ETH3ADDR		00:0B:6B:01:01:04
+#define CONFIG_ETH4ADDR		00:0B:6B:01:01:05
+#define CONFIG_ETH5ADDR		00:0B:6B:01:01:06
+#define CONFIG_ETHPRIME         "FM1@DTSEC1"
+#endif
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI board/freescale/ls1043aqds/ls1043aqds_pbi.cfg
+#endif
+
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW board/freescale/ls1043aqds/ls1043aqds_rcw_nand.cfg
+#endif
+
+#ifdef CONFIG_SD_BOOT
+#ifdef CONFIG_SD_BOOT_QSPI
+#define CONFIG_SYS_FSL_PBL_RCW \
+	board/freescale/ls1043aqds/ls1043aqds_rcw_sd_qspi.cfg
+#else
+#define CONFIG_SYS_FSL_PBL_RCW board/freescale/ls1043aqds/ls1043aqds_rcw_sd_ifc.cfg
+#endif
+#endif
+
+/* LPUART */
+#ifdef CONFIG_LPUART
+#define CONFIG_LPUART_32B_REG
+#endif
+
+/* SATA */
+#define CONFIG_SCSI_AHCI_PLAT
+
+#define CONFIG_SYS_SATA				AHCI_BASE_ADDR
+
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID		1
+#define CONFIG_SYS_SCSI_MAX_LUN			1
+#define CONFIG_SYS_SCSI_MAX_DEVICE		(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+						CONFIG_SYS_SCSI_MAX_LUN)
+
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SPL_PAD_TO		0x20000		/* block aligned */
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	CONFIG_SPL_PAD_TO
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(640 << 10)
+#endif
+
+#if defined(CONFIG_TFABOOT) || \
+	defined(CONFIG_QSPI_BOOT) || defined(CONFIG_SD_BOOT_QSPI)
+#define CONFIG_QIXIS_I2C_ACCESS
+#define CONFIG_SYS_I2C_EARLY_INIT
+#endif
+
+/*
+ * QIXIS Definitions
+ */
+#define CONFIG_FSL_QIXIS
+
+#ifdef CONFIG_FSL_QIXIS
+#define QIXIS_BASE			0x7fb00000
+#define QIXIS_BASE_PHYS			QIXIS_BASE
+#define CONFIG_SYS_I2C_FPGA_ADDR	0x66
+#define QIXIS_LBMAP_SWITCH		6
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_LBMAP_NAND		0x09
+#define QIXIS_LBMAP_SD			0x00
+#define QIXIS_LBMAP_SD_QSPI		0xff
+#define QIXIS_LBMAP_QSPI		0xff
+#define QIXIS_RCW_SRC_NAND		0x106
+#define QIXIS_RCW_SRC_SD		0x040
+#define QIXIS_RCW_SRC_QSPI		0x045
+#define QIXIS_RST_CTL_RESET		0x41
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+
+#define CONFIG_SYS_FPGA_CSPR_EXT	(0x0)
+#define CONFIG_SYS_FPGA_CSPR		(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) | \
+					CSPR_PORT_SIZE_8 | \
+					CSPR_MSEL_GPCM | \
+					CSPR_V)
+#define CONFIG_SYS_FPGA_AMASK		IFC_AMASK(64 * 1024)
+#define CONFIG_SYS_FPGA_CSOR		(CSOR_NOR_ADM_SHIFT(4) | \
+					CSOR_NOR_NOR_MODE_AVD_NOR | \
+					CSOR_NOR_TRHZ_80)
+
+/*
+ * QIXIS Timing parameters for IFC GPCM
+ */
+#define CONFIG_SYS_FPGA_FTIM0		(FTIM0_GPCM_TACSE(0xc) | \
+					FTIM0_GPCM_TEADC(0x20) | \
+					FTIM0_GPCM_TEAHC(0x10))
+#define CONFIG_SYS_FPGA_FTIM1		(FTIM1_GPCM_TACO(0x50) | \
+					FTIM1_GPCM_TRAD(0x1f))
+#define CONFIG_SYS_FPGA_FTIM2		(FTIM2_GPCM_TCS(0x8) | \
+					FTIM2_GPCM_TCH(0x8) | \
+					FTIM2_GPCM_TWP(0xf0))
+#define CONFIG_SYS_FPGA_FTIM3		0x0
+#endif
+
+#ifdef CONFIG_TFABOOT
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#else
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR1_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR3_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR3		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_AMASK3		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR3		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS3_FTIM0		CONFIG_SYS_FPGA_FTIM0
+#define CONFIG_SYS_CS3_FTIM1		CONFIG_SYS_FPGA_FTIM1
+#define CONFIG_SYS_CS3_FTIM2		CONFIG_SYS_FPGA_FTIM2
+#define CONFIG_SYS_CS3_FTIM3		CONFIG_SYS_FPGA_FTIM3
+#endif
+#endif
+
+/*
+ * I2C bus multiplexer
+ */
+#define I2C_MUX_PCA_ADDR_PRI		0x77
+#define I2C_MUX_PCA_ADDR_SEC		0x76 /* Secondary multiplexer */
+#define I2C_RETIMER_ADDR		0x18
+#define I2C_MUX_CH_DEFAULT		0x8
+#define I2C_MUX_CH_CH7301		0xC
+#define I2C_MUX_CH5			0xD
+#define I2C_MUX_CH7			0xF
+
+#define I2C_MUX_CH_VOL_MONITOR 0xa
+
+/* Voltage monitor on channel 2*/
+#define I2C_VOL_MONITOR_ADDR           0x40
+#define I2C_VOL_MONITOR_BUS_V_OFFSET   0x2
+#define I2C_VOL_MONITOR_BUS_V_OVF      0x1
+#define I2C_VOL_MONITOR_BUS_V_SHIFT    3
+
+#define CONFIG_VID_FLS_ENV		"ls1043aqds_vdd_mv"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_VID
+#endif
+#define CONFIG_VOL_MONITOR_IR36021_SET
+#define CONFIG_VOL_MONITOR_INA220
+/* The lowest and highest voltage allowed for LS1043AQDS */
+#define VDD_MV_MIN			819
+#define VDD_MV_MAX			1212
+
+/* QSPI device */
+#if defined(CONFIG_TFABOOT) || \
+	(defined(CONFIG_QSPI_BOOT) || defined(CONFIG_SD_BOOT_QSPI))
+#define CONFIG_FSL_QSPI
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_MACRONIX
+#define FSL_QSPI_FLASH_SIZE		(1 << 24)
+#define FSL_QSPI_FLASH_NUM		2
+#endif
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		0x9fffffff
+
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_OVERWRITE
+
+#ifdef CONFIG_TFABOOT
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		0x500000        /* 5MB */
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x500000)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#else
+#ifdef CONFIG_NAND_BOOT
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_ENV_OFFSET		(24 * CONFIG_SYS_NAND_BLOCK_SIZE)
+#elif defined(CONFIG_SD_BOOT)
+#define CONFIG_ENV_OFFSET		(3 * 1024 * 1024)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE			0x2000
+#elif defined(CONFIG_QSPI_BOOT)
+#define CONFIG_ENV_SIZE			0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET		0x200000        /* 2MB */
+#define CONFIG_ENV_SECT_SIZE		0x10000
+#else
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x300000)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#define CONFIG_ENV_SIZE			0x20000
+#endif
+#endif
+
+#define CONFIG_CMDLINE_TAG
+
+#undef	CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"fdt_high=0xffffffffffffffff\0"		\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"fdt_addr=0x64f00000\0"		 	\
+	"kernel_addr=0x61000000\0"		\
+	"scriptaddr=0x80000000\0"		\
+	"scripthdraddr=0x80080000\0"		\
+	"fdtheader_addr_r=0x80100000\0"		\
+	"kernelheader_addr_r=0x80200000\0"	\
+	"kernel_addr_r=0x81000000\0"		\
+	"kernel_start=0x1000000\0"		\
+	"kernelheader_start=0x800000\0"		\
+	"fdt_addr_r=0x90000000\0"		\
+	"load_addr=0xa0000000\0"		\
+	"kernelheader_addr=0x60800000\0"	\
+	"kernel_size=0x2800000\0"		\
+	"kernelheader_size=0x40000\0"		\
+	"kernel_addr_sd=0x8000\0"		\
+	"kernel_size_sd=0x14000\0"		\
+	"kernelhdr_addr_sd=0x4000\0"		\
+	"kernelhdr_size_sd=0x10\0"		\
+	"boot_os=y\0"				\
+	"mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0"	\
+	BOOTENV					\
+	"boot_scripts=ls1043ardb_boot.scr\0"	\
+	"boot_script_hdr=hdr_ls1043ardb_bs.out\0"	\
+	"consoledev=ttyS0\0"					\
+	"loadaddr=82000000\0"					\
+	"WGKernelfile=kernel_T20_T40_prod.itb\0"                \
+	"SysARoot=sda3\0"	\
+	"SysBRoot=sda2\0"	\
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"scsi scan; " \
+	"ext2load scsi 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"scsi scan; " \
+	"ext2load scsi 0:2 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"scsi scan; " \
+	"ext2load scsi 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"  \
+	"nuke_env=sf probe 0;sf erase 0x200000 10000;\0"  \
+	"ipaddr=10.0.1.1;\0" \
+	"serveraddr=10.0.1.13;\0" \
+	"netmask=255.255.255.0;\0" \
+	"flash_bootloader=tftp 0x82000000 u-boot_ls1043aqds_wg_t40_qspi.bin;" \
+	"sf probe 0; sf erase 0 0x100000; sf write 0x82000000 0 $filesize;" \
+	"sf read 0x80000000 0 $filesize; cmp.b 0x82000000 0x80000000 $filesize;\0"
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+/* GPIO1[13:14, 23:31] */
+#define GPIO1_SUPPORT			((0x3 << 13) | (0x1ff << 23))
+/* GPIO2[0:9][11:15] */
+#define GPIO2_SUPPORT                  ((0x1ff << 0))| (0x1f << 11)
+/* GPIO3[15:27] */
+#define GPIO3_SUPPORT			(0x1fff << 15)
+/* GPIO4[2:3, 12:13, 29:30] */
+#define GPIO4_SUPPORT			((0x3 << 2) | (0x3 << 12) | (0x3 << 29))
+
+#define CONFIG_SN74LV164A
+#define SN74LV164A_CLR_GPIO		205
+#define SN74LV164A_CLK_GPIO		127
+#define SN74LV164A_INA_GPIO		128
+
+#include <asm/fsl_secure_boot.h>
+
+#endif /* __LS1043AQDS_H__ */
--- u-boot-2018.09/include/configs/sagem_f@st1704.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/include/configs/sagem_f@st1704.h	2022-05-09 14:11:37.168445004 -0700
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2017 Álvaro Fernández Rojas <noltari@gmail.com>
+ */
+
+#include <configs/bmips_common.h>
+#include <configs/bmips_bcm6338.h>
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
--- u-boot-2018.09/include/configs/ls1046ardb_t80.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/include/configs/ls1046ardb_t80.h	2022-05-09 14:11:37.144445975 -0700
@@ -0,0 +1,496 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2016 Freescale Semiconductor
+ */
+
+#ifndef __LS1046ARDB_T80_H__
+#define __LS1046ARDB_T80_H__
+
+#include "ls1046a_common.h"
+
+
+#if 0
+#define DEBUG_UBOOT
+#endif
+#ifdef DEBUG_UBOOT
+#define DBG_PRINTF(format, args...) printf("[%s:%d] "format, __FUNCTION__, __LINE__, ##args)
+#else
+#define DBG_PRINTF(args...)
+#endif
+
+/*Albert.Ke.B*/
+#define CONFIG_WG1008_VM1P
+/*Albert.Ke.E*/
+#define CONFIG_CMD_GPIO
+
+#define CONFIG_SYS_CLK_FREQ		100000000
+#define CONFIG_DDR_CLK_FREQ		100000000
+
+#define CONFIG_LAYERSCAPE_NS_ACCESS
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+/* Physical Memory Map */
+#define CONFIG_CHIP_SELECTS_PER_CTRL	4
+
+/*Albert.Ke.B*/
+#ifdef CONFIG_WG1008_VM1P
+/*
+#define DEBUG
+*/
+#define CONFIG_CMD_DM
+#define CONFIG_FSL_QSPI
+#define CONFIG_DM_SPI
+#define CONFIG_DM_SPI_FLASH
+#else
+
+#define CONFIG_DDR_SPD
+#define SPD_EEPROM_ADDRESS		0x51
+#define CONFIG_SYS_SPD_BUS_NUM		0
+
+#endif
+/*Albert.Ke.E*/
+
+#define CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE           0xdeadbeef
+#define CONFIG_FSL_DDR_BIST	/* enable built-in memory test */
+#ifndef CONFIG_SPL
+
+/*Albert.Ke.B*/
+#ifdef CONFIG_WG1008_VM1P
+#define CONFIG_SYS_DDR_RAW_TIMING
+#define CONFIG_FSL_DDR_INTERACTIVE  /* Interactive debugging */
+#define CONFIG_FSL_DDR_BIST
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE           0xdeadbeef
+#define CONFIG_VERSION_VARIABLE
+#else
+#define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
+#endif
+/*Albert.Ke.E*/
+
+#define LS1046A_GPIO1_DIR  0x2300000
+#define LS1046A_GPIO1_DATA 0x2300008
+#define LS1046A_GPIO2_DIR  0x2310000
+#define LS1046A_GPIO2_DATA 0x2310008
+#define LS1046A_GPIO3_DIR  0x2320000
+#define LS1046A_GPIO3_DATA 0x2320008
+#define LS1046A_GPIO4_DIR  0x2330000
+#define LS1046A_GPIO4_DATA 0x2330008
+    
+#define GPIO_BUS_RESET_IN 1
+#define GPIO_BUS_ATT_LED 1
+#define GPIO_BUS_SW_STATUS_LED 1
+#define GPIO_BUS_SW_MODE_LED 1
+#define GPIO_BUS_FAILOVER_LED 1
+#define GPIO_BUS_POWER_LED 1
+#define GPIO_BUS_TMP_RESET 1
+#define GPIO_BUS_MARVELL_SWITCH_RESET 1
+#define GPIO_BUS_RST_MOD_RESET 2
+#define GPIO_BUS_FAN_DRIVER_FON 2
+#define GPIO_BUS_INT_ALL_ALM_7904D_CPU_N 2
+#define GPIO_BUS_MOD_BRD_TYPE_0 2
+#define GPIO_BUS_MOD_BRD_TYPE_1 2
+#define GPIO_BUS_INT_RTC_PHY_N 2
+#define GPIO_BUS_MOD_BAY_PRESENT_N 2
+#define GPIO_BUS_LED_CPU_MOD_1 2
+#define GPIO_BUS_LED_CPU_MOD_2 2
+#define GPIO_BUS_LED_CPU_MOD_3 2
+#define GPIO_BUS_LED_CPU_MOD_4 2
+    
+#define GPIO_SHIFT_RESET_IN 23
+#define GPIO_SHIFT_POWER_LED 24
+#define GPIO_SHIFT_SW_STATUS_LED 25
+#define GPIO_SHIFT_SW_MODE_LED 26
+#define GPIO_SHIFT_FAILOVER_LED 27
+#define GPIO_SHIFT_ATT_LED 28
+#define GPIO_SHIFT_TMP_RESET 29
+#define GPIO_SHIFT_MARVELL_SWITCH_RESET 30
+#define GPIO_SHIFT_RST_MOD_RESET 4
+#define GPIO_SHIFT_FAN_DRIVER_FON 5
+#define GPIO_SHIFT_INT_ALL_ALM_7904D_CPU_N 6
+#define GPIO_SHIFT_MOD_BRD_TYPE_0 7
+#define GPIO_SHIFT_MOD_BRD_TYPE_1 8
+#define GPIO_SHIFT_INT_RTC_PHY_N 9
+#define GPIO_SHIFT_MOD_BAY_PRESENT_N 10
+#define GPIO_SHIFT_LED_CPU_MOD_1 0
+#define GPIO_SHIFT_LED_CPU_MOD_2 1
+#define GPIO_SHIFT_LED_CPU_MOD_3 2
+#define GPIO_SHIFT_LED_CPU_MOD_4 3
+    
+    /* GPIO Direction, 1:output; 0:input */
+#define GPIO_DIR_RESET_IN 0
+#define GPIO_DIR_ATT_LED 1
+#define GPIO_DIR_SW_STATUS_LED 1
+#define GPIO_DIR_SW_MODE_LED 1
+#define GPIO_DIR_FAILOVER_LED 1
+#define GPIO_DIR_POWER_LED 1
+#define GPIO_DIR_TMP_RESET 1
+#define GPIO_DIR_MARVELL_SWITCH_RESET 1
+#define GPIO_DIR_RST_MOD_RESET 1
+#define GPIO_DIR_FAN_DRIVER_FON 1
+#define GPIO_DIR_INT_ALL_ALM_7904D_CPU_N 0
+#define GPIO_DIR_MOD_BRD_TYPE_0 0
+#define GPIO_DIR_MOD_BRD_TYPE_1 0
+#define GPIO_DIR_INT_RTC_PHY_N 0
+#define GPIO_DIR_MOD_BAY_PRESENT_N 0
+#define GPIO_DIR_LED_CPU_MOD_1 1
+#define GPIO_DIR_LED_CPU_MOD_2 1
+#define GPIO_DIR_LED_CPU_MOD_3 1
+#define GPIO_DIR_LED_CPU_MOD_4 1
+
+#define GPIO_TYPE_DIR 0
+#define GPIO_TYPE_DATA 1
+
+#define GPIO_LED_MODE_OFF    0
+#define GPIO_LED_MODE_ON     1
+#define GPIO_LED_MODE_NORMAL 2
+#endif
+
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_SYS_FSL_PBL_PBI board/freescale/ls1046ardb/ls1046ardb_pbi.cfg
+#endif
+
+#ifdef CONFIG_SD_BOOT
+#define CONFIG_SYS_FSL_PBL_PBI board/freescale/ls1046ardb/ls1046ardb_pbi.cfg
+#ifdef CONFIG_EMMC_BOOT
+#define CONFIG_SYS_FSL_PBL_RCW \
+	board/freescale/ls1046ardb/ls1046ardb_rcw_emmc.cfg
+#else
+#define CONFIG_SYS_FSL_PBL_RCW board/freescale/ls1046ardb/ls1046ardb_rcw_sd.cfg
+#endif
+#elif defined(CONFIG_QSPI_BOOT)
+#define CONFIG_SYS_FSL_PBL_RCW \
+	board/freescale/ls1046ardb/ls1046ardb_rcw_qspi.cfg
+#define CONFIG_SYS_FSL_PBL_PBI \
+	board/freescale/ls1046ardb/ls1046ardb_qspi_pbi.cfg
+#define CONFIG_SYS_UBOOT_BASE		0x40100000
+#define CONFIG_SYS_SPL_ARGS_ADDR	0x90000000
+#endif
+
+#ifndef SPL_NO_IFC
+/* IFC */
+#define CONFIG_FSL_IFC
+/*
+ * NAND Flash Definitions
+ */
+#define CONFIG_NAND_FSL_IFC
+#endif
+
+#define CONFIG_SYS_NAND_BASE		0x7e800000
+#define CONFIG_SYS_NAND_BASE_PHYS	CONFIG_SYS_NAND_BASE
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8	\
+				| CSPR_MSEL_NAND	\
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
+#define CONFIG_SYS_NAND_CSOR	(CSOR_NAND_ECC_ENC_EN	/* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN	/* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_8	/* 8-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3 Bytes */ \
+				| CSOR_NAND_PGS_4K	/* Page Size = 4K */ \
+				| CSOR_NAND_SPRZ_224	/* Spare size = 224 */ \
+				| CSOR_NAND_PB(64))	/* 64 Pages Per Block */
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x7) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x7) | \
+					FTIM0_NAND_TWH(0xa))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0xe)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0xf) | \
+					FTIM2_NAND_TREH(0xa) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+/*
+ * CPLD
+ */
+#define CONFIG_SYS_CPLD_BASE		0x7fb00000
+#define CPLD_BASE_PHYS			CONFIG_SYS_CPLD_BASE
+
+#define CONFIG_SYS_CPLD_CSPR_EXT	(0x0)
+#define CONFIG_SYS_CPLD_CSPR		(CSPR_PHYS_ADDR(CPLD_BASE_PHYS) | \
+					CSPR_PORT_SIZE_8 | \
+					CSPR_MSEL_GPCM | \
+					CSPR_V)
+#define CONFIG_SYS_CPLD_AMASK		IFC_AMASK(64 * 1024)
+#define CONFIG_SYS_CPLD_CSOR		CSOR_NOR_ADM_SHIFT(16)
+
+/* CPLD Timing parameters for IFC GPCM */
+#define CONFIG_SYS_CPLD_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CPLD_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define CONFIG_SYS_CPLD_FTIM2		(FTIM2_GPCM_TCS(0xf) | \
+					FTIM2_GPCM_TCH(0xf) | \
+					FTIM2_GPCM_TWP(0x3E))
+#define CONFIG_SYS_CPLD_FTIM3		0x0
+
+/* IFC Timing Params */
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_CPLD_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_CPLD_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_CPLD_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_CPLD_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_CPLD_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_CPLD_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_CPLD_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_CPLD_FTIM3
+
+/* EEPROM */
+#if 0
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM		3
+#define CONFIG_SYS_I2C_EEPROM_ADDR		0xac
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS	3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	5
+#define I2C_RETIMER_ADDR			0x18
+#endif
+
+/* PMIC */
+#define CONFIG_POWER
+#ifdef CONFIG_POWER
+#define CONFIG_POWER_I2C
+#endif
+
+/*
+ * Environment
+ */
+#ifndef SPL_NO_ENV
+#define CONFIG_ENV_OVERWRITE
+#endif
+
+#ifdef CONFIG_TFABOOT
+#define CONFIG_SYS_MMC_ENV_DEV		0
+
+#define CONFIG_ENV_SIZE			0x2000		/* 8KB */
+#define CONFIG_ENV_OFFSET		0x500000	/* 5MB */
+#define CONFIG_ENV_SECT_SIZE		0x40000		/* 256KB */
+#else
+#if defined(CONFIG_SD_BOOT)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_OFFSET		(3 * 1024 * 1024)
+#define CONFIG_ENV_SIZE			0x2000
+#else
+#if 0 /*Forest.Tsao.B*/
+#define CONFIG_ENV_SIZE			0x2000		/* 8KB */
+#define CONFIG_ENV_OFFSET		0x300000	/* 3MB */
+#define CONFIG_ENV_SECT_SIZE		0x40000		/* 256KB */
+#else
+#define CONFIG_ENV_SIZE			0x2000		/* 8KB */
+#define CONFIG_ENV_OFFSET		0x210000	/* 2MB  (approx) */
+#define CONFIG_ENV_SECT_SIZE	0x10000	                /* 64KB */
+#endif /*Forest.Tsao.E*/
+#endif
+#endif
+
+#define AQR105_IRQ_MASK			0x80000000
+/* FMan */
+#ifndef SPL_NO_FMAN
+
+#ifdef CONFIG_NET
+#define CONFIG_PHY_REALTEK
+/*Forest.Tsao.B*/
+#define CONFIG_MV88E6190_SWITCH
+#define CONFIG_MV88E6190_SWITCH_CPU_ATTACHED
+#define CONFIG_ETHADDR		00:90:4c:06:a5:72
+#define PORT_LED_MODE_NORMAL 0
+#define PORT_LED_MODE_GREEN  1
+#define PORT_LED_MODE_AMBER  2
+#define PORT_LED_MODE_ALLON  3
+#define PORT_LED_MODE_OFF    4
+/*Forest.Tsao.E*/
+#endif
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHY_AQUANTIA
+#define CONFIG_PHYLIB_10G
+#define RGMII_PHY1_ADDR			0x1
+#define RGMII_PHY2_ADDR			0x2
+
+#ifdef CONFIG_WG1008_VM1P
+#define SGMII_PHY1_ADDR			0x9
+#define SGMII_PHY2_ADDR			0xa
+#else
+#define SGMII_PHY1_ADDR			0x3
+#define SGMII_PHY2_ADDR			0x4
+#endif
+
+#define FM1_10GEC1_PHY_ADDR		0x0
+
+#define FDT_SEQ_MACADDR_FROM_ENV
+
+#ifdef CONFIG_WG1008_VM1P
+#define CONFIG_ETHPRIME			"FM1@DTSEC9"
+#else
+#define CONFIG_ETHPRIME			"FM1@DTSEC3"
+#endif
+#endif
+#endif
+
+/*  Marvell 88E6190 switch */
+#define SMI_I 1
+#define SMI_E (!SMI_I)
+
+
+
+/* QSPI device */
+#ifndef SPL_NO_QSPI
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_SPI_FLASH_SPANSION
+/*Albert.Ke.B*/
+#ifdef CONFIG_WG1008_VM1P
+
+/*#define CONFIG_SPI_FLASH*/
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		0
+#define CONFIG_SF_DEFAULT_SPEED		40000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#define FSL_QSPI_FLASH_NUM		1
+#define FSL_QSPI_FLASH_SIZE		SZ_4M
+/*
+#define QSPI0_BASE_ADDR			QSPI1_IPS_BASE_ADDR
+#define QSPI0_AMBA_BASE			QSPI0_ARB_BASE_ADDR
+*/
+#else
+
+#define FSL_QSPI_FLASH_SIZE		(1 << 26)
+#define FSL_QSPI_FLASH_NUM		2
+
+#endif
+/*Albert.Ke.E*/
+#endif
+#endif
+
+#ifndef SPL_NO_MISC
+#undef CONFIG_BOOTCOMMAND
+#ifdef CONFIG_TFABOOT
+#define QSPI_NOR_BOOTCOMMAND "run distro_bootcmd; run qspi_bootcmd; "	\
+			   "env exists secureboot && esbc_halt;;"
+#define SD_BOOTCOMMAND "run distro_bootcmd;run sd_bootcmd; "	\
+			   "env exists secureboot && esbc_halt;"
+#else
+#if defined(CONFIG_QSPI_BOOT)
+#define CONFIG_BOOTCOMMAND "run distro_bootcmd; run qspi_bootcmd; "	\
+			   "env exists secureboot && esbc_halt;;"
+#elif defined(CONFIG_SD_BOOT)
+#define CONFIG_BOOTCOMMAND "run distro_bootcmd;run sd_bootcmd; "	\
+			   "env exists secureboot && esbc_halt;"
+#endif
+#endif
+#endif
+
+#ifdef CONFIG_WG1008_VM1P
+
+#undef	CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"fdt_high=0xffffffffffffffff\0"		\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"fdt_addr=0x64f00000\0"		 	\
+	"kernel_addr=0x61000000\0"		\
+	"scriptaddr=0x80000000\0"		\
+	"scripthdraddr=0x80080000\0"		\
+	"fdtheader_addr_r=0x80100000\0"		\
+	"kernelheader_addr_r=0x80200000\0"	\
+	"kernel_addr_r=0x81000000\0"		\
+	"kernel_start=0x1000000\0"		\
+	"kernelheader_start=0x800000\0"		\
+	"fdt_addr_r=0x90000000\0"		\
+	"load_addr=0xa0000000\0"		\
+	"kernelheader_addr=0x60800000\0"	\
+	"kernel_size=0x2800000\0"		\
+	"kernelheader_size=0x40000\0"		\
+	"kernel_addr_sd=0x8000\0"		\
+	"kernel_size_sd=0x14000\0"		\
+	"kernelhdr_addr_sd=0x4000\0"		\
+	"kernelhdr_size_sd=0x10\0"		\
+	"boot_os=y\0"				\
+	"mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0"	\
+	BOOTENV					\
+	"boot_scripts=ls1046ardb_boot.scr\0"	\
+	"boot_script_hdr=hdr_ls1046ardb_bs.out\0"	\
+	"scan_dev_for_boot_part="               \
+		"part list ${devtype} ${devnum} devplist; "   \
+		"env exists devplist || setenv devplist 1; "  \
+		"for distro_bootpart in ${devplist}; do "     \
+		  "if fstype ${devtype} "                  \
+			"${devnum}:${distro_bootpart} "      \
+			"bootfstype; then "                  \
+			"run scan_dev_for_boot; "            \
+		  "fi; "                                   \
+		"done\0"                                   \
+	"scan_dev_for_boot="				  \
+		"echo Scanning ${devtype} "		  \
+				"${devnum}:${distro_bootpart}...; "  \
+		"for prefix in ${boot_prefixes}; do "	  \
+			"run scan_dev_for_scripts; "	  \
+		"done;"					  \
+		"\0"					  \
+	"consoledev=ttyS0\0"					\
+	"loadaddr=82000000\0"					\
+	"WGKernelfile=kernel_T80.itb\0"                \
+	"SysARoot=sda3\0"	\
+	"SysBRoot=sda2\0"	\
+	"wgBootSysA=setenv bootargs root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"scsi scan; " \
+	"ext2load scsi 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"             \
+	"wgBootSysB=setenv bootargs root=/dev/$SysBRoot rw " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"scsi scan; " \
+	"ext2load scsi 0:2 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"             \
+	"wgBootRecovery=setenv bootargs wgmode=safe root=/dev/$SysARoot rw " \
+	"console=$consoledev,$baudrate $othbootargs "	\
+	"earlycon=uart8250,mmio,0x21c0500; "	\
+	"scsi scan; " \
+	"ext2load scsi 0:3 $loadaddr $WGKernelfile; " \
+	"bootm $loadaddr;\0"  \
+	"nuke_env=sf probe 0;sf erase 0x210000 10000;\0"  \
+	"ipaddr=10.0.1.1;\0" \
+	"serveraddr=10.0.1.13;\0" \
+	"netmask=255.255.255.0;\0" \
+	"flash_bootloader=tftp 0x82000000 u-boot_ls1046ardb_wg_t80_qspi.bin;" \
+	"sf probe 0; sf erase 0x100000 +$filesize; sf write 0x82000000 0x100000 $filesize;" \
+	"sf read 0x80000000 0 $filesize; cmp.b 0x82000000 0x80000000 $filesize;\0"
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND		"run wgBootSysA"
+
+#endif /* CONFIG_WG1008_VM1P */
+
+#include <asm/fsl_secure_boot.h>
+
+#endif /* __LS1046ARDB_T80_H__ */
--- u-boot-2018.09/configs/ls1043aqds_wg_t40_qspi_defconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/configs/ls1043aqds_wg_t40_qspi_defconfig	2022-05-09 14:11:36.584468646 -0700
@@ -0,0 +1,57 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS1043AQDS_WG_T40=y
+CONFIG_SYS_TEXT_BASE=0x40100000
+CONFIG_FSL_LS_PPA=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="QSPI_BOOT"
+CONFIG_QSPI_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS0,115200 root=/dev/ram0 earlycon=uart8250,mmio,0x21c0500 mtdparts=spi0.0:1m(uboot),5m(kernel),1m(dtb),9m(file_system)"
+# CONFIG_USE_BOOTCOMMAND is not set
+CONFIG_MISC_INIT_R=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_MP=y
+CONFIG_MTDPARTS_DEFAULT="mtdparts=spi0.0:1m(uboot),5m(kernel),1m(dtb),9m(file_system)"
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls1043a-qds-wg_t40_t20-duart"
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DM=y
+CONFIG_FSL_CAAM=y
+CONFIG_FSL_ESDHC=y
+CONFIG_SPI_FLASH=y
+CONFIG_PHYLIB=y
+CONFIG_E1000=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCIE_LAYERSCAPE=y
+CONFIG_SYS_NS16550=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_DM_MMC=y
+CONFIG_DM_SCSI=y
+CONFIG_SATA_CEVA=y
+CONFIG_SCSI_AHCI=y
+CONFIG_SCSI=y
+CONFIG_AHCI=y
+CONFIG_CMD_DATE=y
+CONFIG_RTC_S35392A=y
+CONFIG_CMD_GPIO=y
--- u-boot-2018.09/configs/ls1046ardb_wg_t80_qspi_SECURE_BOOT_defconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/configs/ls1046ardb_wg_t80_qspi_SECURE_BOOT_defconfig	2022-05-09 14:11:36.588468484 -0700
@@ -0,0 +1,44 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS1046ARDB_WG_T80=y
+CONFIG_SYS_TEXT_BASE=0x40100000
+CONFIG_SECURE_BOOT=y
+CONFIG_FSL_LS_PPA=y
+CONFIG_QSPI_AHB_INIT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_QSPI_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS0,115200 root=/dev/ram0 earlycon=uart8250,mmio,0x21c0500 mtdparts=1550000.quadspi:1m(rcw),15m(u-boot),48m(kernel.itb);7e800000.flash:16m(nand_uboot),48m(nand_kernel),448m(nand_free)"
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_NAND=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_MTDPARTS_DEFAULT="mtdparts=1550000.quadspi:1m(rcw),15m(u-boot),48m(kernel.itb);7e800000.flash:16m(nand_uboot),48m(nand_kernel),448m(nand_free)"
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls1046a-rdb"
+CONFIG_DM=y
+CONFIG_SPI_FLASH=y
+CONFIG_PHYLIB=y
+CONFIG_NETDEVICES=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCIE_LAYERSCAPE=y
+CONFIG_SYS_NS16550=y
+CONFIG_DM_SPI=y
+CONFIG_FSL_QSPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_RSA=y
+CONFIG_WG1008_VM1P=y
--- u-boot-2018.09/configs/sagem_f@st1704_ram_defconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/configs/sagem_f@st1704_ram_defconfig	2022-05-09 14:11:36.632466703 -0700
@@ -0,0 +1,50 @@
+CONFIG_MIPS=y
+CONFIG_SYS_TEXT_BASE=0x80010000
+CONFIG_ARCH_BMIPS=y
+CONFIG_SOC_BMIPS_BCM6338=y
+# CONFIG_MIPS_BOOT_CMDLINE_LEGACY is not set
+# CONFIG_MIPS_BOOT_ENV_LEGACY is not set
+CONFIG_MIPS_BOOT_FDT=y
+CONFIG_NR_DRAM_BANKS=1
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_OF_STDOUT_VIA_ALIAS=y
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="F@ST1704 # "
+CONFIG_CMD_CPU=y
+CONFIG_CMD_LICENSE=y
+# CONFIG_CMD_BOOTD is not set
+# CONFIG_CMD_ELF is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_EXPORTENV is not set
+# CONFIG_CMD_IMPORTENV is not set
+# CONFIG_CMD_EDITENV is not set
+# CONFIG_CMD_SAVEENV is not set
+# CONFIG_CMD_ENV_EXISTS is not set
+# CONFIG_CMD_CRC32 is not set
+CONFIG_CMD_MEMINFO=y
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_LOADS is not set
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+# CONFIG_CMD_MISC is not set
+CONFIG_OF_EMBED=y
+CONFIG_DEFAULT_DEVICE_TREE="sagem,f@st1704"
+# CONFIG_NET is not set
+# CONFIG_DM_DEVICE_REMOVE is not set
+CONFIG_DM_GPIO=y
+CONFIG_BCM6345_GPIO=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_DM_RESET=y
+CONFIG_RESET_BCM6345=y
+# CONFIG_SPL_SERIAL_PRESENT is not set
+CONFIG_DM_SERIAL=y
+CONFIG_BCM6345_SERIAL=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_BCM63XX_SPI=y
--- u-boot-2018.09/configs/ls1043aqds_wg_t20_qspi_defconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/configs/ls1043aqds_wg_t20_qspi_defconfig	2022-05-09 14:11:36.584468646 -0700
@@ -0,0 +1,57 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS1043AQDS_WG_T20=y
+CONFIG_SYS_TEXT_BASE=0x40100000
+CONFIG_FSL_LS_PPA=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="QSPI_BOOT"
+CONFIG_QSPI_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS0,115200 root=/dev/ram0 earlycon=uart8250,mmio,0x21c0500 mtdparts=spi0.0:1m(uboot),5m(kernel),1m(dtb),9m(file_system)"
+# CONFIG_USE_BOOTCOMMAND is not set
+CONFIG_MISC_INIT_R=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_MP=y
+CONFIG_MTDPARTS_DEFAULT="mtdparts=spi0.0:1m(uboot),5m(kernel),1m(dtb),9m(file_system)"
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls1043a-qds-wg_t40_t20-duart"
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DM=y
+CONFIG_FSL_CAAM=y
+CONFIG_FSL_ESDHC=y
+CONFIG_SPI_FLASH=y
+CONFIG_PHYLIB=y
+CONFIG_E1000=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCIE_LAYERSCAPE=y
+CONFIG_SYS_NS16550=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_DM_MMC=y
+CONFIG_DM_SCSI=y
+CONFIG_SATA_CEVA=y
+CONFIG_SCSI_AHCI=y
+CONFIG_SCSI=y
+CONFIG_AHCI=y
+CONFIG_CMD_DATE=y
+CONFIG_RTC_S35392A=y
+CONFIG_CMD_GPIO=y
--- u-boot-2018.09/configs/ls1046ardb_wg_t80_qspi_defconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/configs/ls1046ardb_wg_t80_qspi_defconfig	2022-05-09 14:11:36.588468484 -0700
@@ -0,0 +1,46 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS1046ARDB_WG_T80=y
+CONFIG_SYS_TEXT_BASE=0x40100000
+CONFIG_FSL_LS_PPA=y
+CONFIG_QSPI_AHB_INIT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_QSPI_BOOT=y
+CONFIG_BOOTDELAY=3
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyS0,115200 root=/dev/ram0 earlycon=uart8250,mmio,0x21c0500 mtdparts=1550000.quadspi:1m(rcw),15m(u-boot),48m(kernel.itb);7e800000.flash:16m(nand_uboot),48m(nand_kernel),448m(nand_free)"
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_NAND=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_MTDPARTS_DEFAULT="mtdparts=1550000.quadspi:1m(rcw),15m(u-boot),48m(kernel.itb);7e800000.flash:16m(nand_uboot),48m(nand_kernel),448m(nand_free)"
+CONFIG_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls1046a-rdb"
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DM=y
+CONFIG_FSL_CAAM=y
+CONFIG_SPI_FLASH=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_PHYLIB=y
+CONFIG_NETDEVICES=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCIE_LAYERSCAPE=y
+CONFIG_SYS_NS16550=y
+CONFIG_DM_SPI=y
+CONFIG_FSL_QSPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_USB_STORAGE=y
+CONFIG_WG1008_VM1P=y
--- u-boot-2018.09/tools/env/fw_env.config.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/tools/env/fw_env.config	2022-05-09 14:11:34.828539735 -0700
@@ -0,0 +1,38 @@
+# Configuration file for fw_(printenv/setenv) utility.
+# Up to two entries are valid, in this case the redundant
+# environment sector is assumed present.
+# Notice, that the "Number of sectors" is not required on NOR and SPI-dataflash.
+# Futhermore, if the Flash sector size is omitted, this value is assumed to
+# be the same as the Environment size, which is valid for NOR and SPI-dataflash
+# Device offset must be prefixed with 0x to be parsed as a hexadecimal value.
+
+# NOR example
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+/dev/mtd1		0x0000		0x4000		0x4000
+/dev/mtd2		0x0000		0x4000		0x4000
+
+# MTD SPI-dataflash example
+# MTD device name	Device offset	Env. size	Flash sector size	Number of sectors
+#/dev/mtd5		0x4200		0x4200
+#/dev/mtd6		0x4200		0x4200
+
+# NAND example
+#/dev/mtd0		0x4000		0x4000		0x20000			2
+
+# On a block device a negative offset is treated as a backwards offset from the
+# end of the device/partition, rather than a forwards offset from the start.
+
+# Block device example
+#/dev/mmcblk0		0xc0000		0x20000
+#/dev/mmcblk0		-0x20000	0x20000
+
+# VFAT example
+#/boot/uboot.env	0x0000          0x4000
+
+# UBI volume
+#/dev/ubi0_0		0x0		0x1f000		0x1f000
+#/dev/ubi0_1		0x0		0x1f000		0x1f000
+
+# UBI volume by name
+#/dev/ubi0:env		0x0		0x1f000		0x1f000
+#/dev/ubi0:env-redund	0x0		0x1f000		0x1f000
--- u-boot-2018.09/tools/binman/test/u_boot_binman_syms_bad.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/tools/binman/test/u_boot_binman_syms_bad.c	2022-05-09 14:11:37.480432373 -0700
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2017 Google, Inc
+ *
+ * Simple program to create some binman symbols. This is used by binman tests.
+ */
+
+#define CONFIG_BINMAN
+#include <binman_sym.h>
+
+binman_sym_declare(unsigned long, u_boot_spl, offset);
+binman_sym_declare(unsigned long long, u_boot_spl2, offset);
+binman_sym_declare(unsigned long, u_boot_any, image_pos);
--- u-boot-2018.09/board/sagem/f@st1704/f@st1704.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/sagem/f@st1704/f@st1704.c	2022-05-09 14:11:36.204484030 -0700
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2017 Álvaro Fernández Rojas <noltari@gmail.com>
+ */
+
+#include <common.h>
--- u-boot-2018.09/board/sagem/f@st1704/Kconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/sagem/f@st1704/Kconfig	2022-05-09 14:11:36.204484030 -0700
@@ -0,0 +1,12 @@
+if BOARD_SAGEM_FAST1704
+
+config SYS_BOARD
+	default "f@st1704"
+
+config SYS_VENDOR
+	default "sagem"
+
+config SYS_CONFIG_NAME
+	default "sagem_f@st1704"
+
+endif
--- u-boot-2018.09/board/sagem/f@st1704/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/sagem/f@st1704/Makefile	2022-05-09 14:11:36.204484030 -0700
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-y += f@st1704.o
--- u-boot-2018.09/board/sagem/f@st1704/MAINTAINERS.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/sagem/f@st1704/MAINTAINERS	2022-05-09 14:11:36.204484030 -0700
@@ -0,0 +1,6 @@
+SAGEM F@ST1704 BOARD
+M:	Álvaro Fernández Rojas <noltari@gmail.com>
+S:	Maintained
+F:	board/sagem/f@st1704/
+F:	include/configs/sagem_f@st1704.h
+F:	configs/sagem_f@st1704_ram_defconfig
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ddr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ddr.h	2022-05-09 14:11:35.928495203 -0700
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+
+extern void erratum_a008850_post(void);
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+	u32 cpo_override;
+	u32 write_data_delay;
+	u32 force_2t;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+#ifdef CONFIG_SYS_FSL_DDR4
+	{2,  1666, 0,  8,     7, 0x0808090B, 0x0C0D0E0A,},
+	{2,  1900, 0,  8,     6, 0x08080A0C, 0x0D0E0F0A,},
+	{1,  1666, 0, 10,     7, 0x05080800, 0x00000000,},
+	{1,  1900, 0,  8,     9, 0x0A0B0C0B, 0x0D0E0F0D,},
+	{1,  2200, 0,  8,    10, 0x0B0C0D0C, 0x0E0F110E,},
+#elif defined(CONFIG_SYS_FSL_DDR3)
+	{1,  833,  1, 12,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{1,  1350, 1, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{1,  833,  2, 12,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{1,  1350, 2, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  833,  4, 12,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{2,  1350, 4, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  1350, 0, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  1666, 4,  8,   0xa, 0x0B08090C, 0x0B0E0D0A,   0x1f,    2,  0},
+	{2,  1666, 0,  8,   0xa, 0x0B08090C, 0x0B0E0D0A,   0x1f,    2,  0},
+#else
+#error DDR type not defined
+#endif
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/README	2022-05-09 14:11:35.908496013 -0700
@@ -0,0 +1,64 @@
+Overview
+--------
+The LS1043A Development System (QDS) is a high-performance computing,
+evaluation, and development platform that supports the QorIQ LS1043A
+LayerScape Architecture processor. The LS1043AQDS provides SW development
+platform for the Freescale LS1043A processor series, with a complete
+debugging environment.
+
+LS1043A SoC Overview
+--------------------
+Please refer arch/arm/cpu/armv8/fsl-layerscape/doc/README.soc for LS1043A
+SoC overview.
+
+ LS1043AQDS board Overview
+ -----------------------
+ - SERDES Connections, 4 lanes supporting:
+      - PCI Express - 3.0
+      - SGMII, SGMII 2.5
+      - QSGMII
+      - SATA 3.0
+      - XFI
+ - DDR Controller
+     - 2GB 40bits (8-bits ECC) DDR4 SDRAM. Support rates of up to 1600MT/s
+ -IFC/Local Bus
+    - One in-socket 128 MB NOR flash 16-bit data bus
+    - One 512 MB NAND flash with ECC support
+    - PromJet Port
+    - FPGA connection
+ - USB 3.0
+    - Three high speed USB 3.0 ports
+    - First USB 3.0 port configured as Host with Type-A connector
+    - The other two USB 3.0 ports configured as OTG with micro-AB connector
+ - SDHC port connects directly to an adapter card slot, featuring:
+    - Optional clock feedback paths, and optional high-speed voltage translation assistance
+    - SD slots for SD, SDHC (1x, 4x, 8x), and/or MMC
+    - eMMC memory devices
+ - DSPI: Onboard support for three SPI flash memory devices
+ - 4 I2C controllers
+ - One SATA onboard connectors
+ - UART
+   - Two 4-pin serial ports at up to 115.2 Kbit/s
+   - Two DB9 D-Type connectors supporting one Serial port each
+ - ARM JTAG support
+
+Memory map from core's view
+----------------------------
+Start Address	End Address	Description		Size
+0x00_0000_0000	0x00_000F_FFFF	Secure Boot ROM		1MB
+0x00_0100_0000	0x00_0FFF_FFFF	CCSRBAR			240MB
+0x00_1000_0000	0x00_1000_FFFF	OCRAM0			64KB
+0x00_1001_0000	0x00_1001_FFFF	OCRAM1			64KB
+0x00_2000_0000	0x00_20FF_FFFF	DCSR			16MB
+0x00_6000_0000	0x00_67FF_FFFF	IFC - NOR Flash		128MB
+0x00_7E80_0000	0x00_7E80_FFFF	IFC - NAND Flash	64KB
+0x00_7FB0_0000	0x00_7FB0_0FFF	IFC - FPGA		4KB
+0x00_8000_0000	0x00_FFFF_FFFF	DRAM1			2GB
+
+Booting Options
+---------------
+a) Promjet Boot
+b) NOR boot
+c) NAND boot
+d) SD boot
+e) QSPI boot
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_rcw_nand.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_rcw_nand.cfg	2022-05-09 14:11:35.940494718 -0700
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# serdes protocol
+08100010 0a000000 00000000 00000000
+14550002 80004012 e0106000 c1002000
+00000000 00000000 00000000 00038800
+00000000 00001100 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/sn74lv164a.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/sn74lv164a.h	2022-05-09 14:11:35.952494232 -0700
@@ -0,0 +1,36 @@
+#ifndef _74LV164A_H_
+#define _74LV164A_H_
+#include <asm/gpio.h>
+
+#ifndef SN74LV164A_CLR_GPIO
+#error "GPIO pin for SN74LV164A_CLR_GPIO must be defined."
+#endif
+#ifndef SN74LV164A_CLK_GPIO
+#error "GPIO pin for SN74LV164A_CLK_GPIO must be defined."
+#endif
+#ifndef SN74LV164A_INA_GPIO
+#error "GPIO pin for SN74LV164A_INA_GPIO must be defined."
+#endif
+
+enum {
+	SN74LV164A_OUT_QA = 0,
+	SN74LV164A_OUT_QB,
+	SN74LV164A_OUT_QC,
+	SN74LV164A_OUT_QD,
+	SN74LV164A_OUT_QE,
+	SN74LV164A_OUT_QF,
+	SN74LV164A_OUT_QG,
+	SN74LV164A_OUT_QH,
+	SN74LV164A_OUT_NUM,
+	SN74LV164A_OUT_MAX = SN74LV164A_OUT_NUM,
+};
+
+#define SN74LV164A_OUT_HIGH	1
+#define SN74LV164A_OUT_LOW	0
+
+void sn74lv164a_clear(void);
+void sn74lv164a_set_value(int pin, int val);
+void sn74lv164a_set_value_all_high(void);
+void sn74lv164a_set_value_all_low(void);
+
+#endif /* _74LV164A_H_ */
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/Kconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/Kconfig	2022-05-09 14:11:35.900496336 -0700
@@ -0,0 +1,33 @@
+if TARGET_LS1043AQDS_WG_T40
+
+config SYS_BOARD
+	default "ls1043aqds_t40"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls1043aqds_t40"
+
+if FSL_LS_PPA
+config SYS_LS_PPA_FW_ADDR
+	hex "PPA Firmware Addr"
+	default 0x40400000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x60400000 if SYS_LS_PPA_FW_IN_XIP
+	default 0x400000 if SYS_LS_PPA_FW_IN_MMC || SYS_LS_PPA_FW_IN_NAND
+
+if CHAIN_OF_TRUST
+config SYS_LS_PPA_ESBC_ADDR
+	hex "PPA Firmware HDR Addr"
+	default 0x40680000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x60680000 if SYS_LS_PPA_FW_IN_XIP
+	default 0x680000 if SYS_LS_PPA_FW_IN_MMC || SYS_LS_PPA_FW_IN_NAND
+endif
+endif
+
+source "board/freescale/common/Kconfig"
+
+endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_rcw_sd_ifc.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_rcw_sd_ifc.cfg	2022-05-09 14:11:35.940494718 -0700
@@ -0,0 +1,8 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# RCW
+# Enable IFC; disable QSPI
+08100010 0a000000 00000000 00000000
+14550002 80004012 60040000 c1002000
+00000000 00000000 00000000 00038800
+00000000 00001100 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/gpio.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/gpio.c	2022-05-09 14:11:35.936494879 -0700
@@ -0,0 +1,171 @@
+#include <common.h>
+#include <mapmem.h>
+#include <asm/gpio.h>
+
+#define GPIO_BASE		0x2300000
+#define GPIO_DIRECTION		0x0
+#define GPIO_DATA               0x8
+
+#define GPIO1_BASE		(GPIO_BASE + 0x00000)
+#define GPIO1_DIRECTION         (GPIO1_BASE + GPIO_DIRECTION)
+#define GPIO1_DATA              (GPIO1_BASE + GPIO_DATA)
+
+#define GPIO2_BASE		(GPIO_BASE + 0x10000)
+#define GPIO2_DIRECTION         (GPIO2_BASE + GPIO_DIRECTION)
+#define GPIO2_DATA              (GPIO2_BASE + GPIO_DATA)
+
+#define GPIO3_BASE		(GPIO_BASE + 0x20000)
+#define GPIO3_DIRECTION         (GPIO3_BASE + GPIO_DIRECTION)
+#define GPIO3_DATA              (GPIO3_BASE + GPIO_DATA)
+
+#define GPIO4_BASE		(GPIO_BASE + 0x30000)
+#define GPIO4_DIRECTION         (GPIO4_BASE + GPIO_DIRECTION)
+#define GPIO4_DATA              (GPIO4_BASE + GPIO_DATA)
+
+#define BYTE_SWAP(x)		(((x / 8) * 16 + 7) - x)
+
+#ifndef GPIO1_SUPPORT
+#define GPIO1_SUPPORT		(0x0 << 0)
+#endif
+#ifndef GPIO2_SUPPORT
+#define GPIO2_SUPPORT		(0x0 << 0)
+#endif
+#ifndef GPIO3_SUPPORT
+#define GPIO3_SUPPORT		(0x0 << 0)
+#endif
+#ifndef GPIO4_SUPPORT
+#define GPIO4_SUPPORT		(0x0 << 0)
+#endif
+
+uint32_t gpio_direction[4] = {
+	GPIO1_DIRECTION,
+	GPIO2_DIRECTION,
+	GPIO3_DIRECTION,
+	GPIO4_DIRECTION,
+};
+
+uint32_t gpio_data[4] = {
+	GPIO1_DATA,
+	GPIO2_DATA,
+	GPIO3_DATA,
+	GPIO4_DATA,
+};
+
+uint32_t gpio_support[4] = {
+	GPIO1_SUPPORT,
+	GPIO2_SUPPORT,
+	GPIO3_SUPPORT,
+	GPIO4_SUPPORT,
+};
+
+static int is_support(unsigned gpio)
+{
+	int grp, pos, sup = 0;
+
+	grp = (gpio/100);
+	pos = (gpio%100);
+	sup = ((gpio_support[grp-1] >> pos) & 0x1);
+
+	return (!sup);
+}
+
+int gpio_request(unsigned gpio, const char *label)
+{
+	if (!is_support(gpio))
+		return 0;
+
+	return -1;
+}
+
+int gpio_free(unsigned gpio)
+{
+	return 0;
+}
+
+int gpio_direction_input(unsigned gpio)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_direction[grp-1]);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	val &= ~(1 << pos);
+	*(volatile uint32_t *)buf = val;
+	unmap_sysmem(buf);
+
+	return 0;
+}
+
+int gpio_direction_output(unsigned gpio, int value)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_direction[grp-1]);
+
+	gpio_set_value(gpio, value);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	val |= (1 << pos);
+	*(volatile uint32_t *)buf = (val);
+	unmap_sysmem(buf);
+
+	return 0;
+}
+
+int gpio_get_value(unsigned gpio)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_data[grp-1]);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	unmap_sysmem(buf);
+
+	return ((val >> pos) & 0x1);
+}
+
+int gpio_set_value(unsigned gpio, int value)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_data[grp-1]);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	if (value)
+		val |= (1 << pos);
+	else
+		val &= ~(1 << pos);
+
+	*(volatile uint32_t *)buf = (val);
+	unmap_sysmem(buf);
+
+	return 0;
+}
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/Makefile	2022-05-09 14:11:35.908496013 -0700
@@ -0,0 +1,14 @@
+#
+# Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += ddr.o
+obj-y += gpio.o
+obj-y += sn74lv164a.o
+obj-y += led.o
+ifndef CONFIG_SPL_BUILD
+obj-y += eth.o
+endif
+obj-y += ls1043aqds.o
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_rcw_sd_qspi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_rcw_sd_qspi.cfg	2022-05-09 14:11:35.940494718 -0700
@@ -0,0 +1,8 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# RCW
+# Enable QSPI; disable IFC
+08100010 0a000000 00000000 00000000
+14550002 80004012 60040000 c1002000
+00000000 00000000 00000000 00038800
+20124000 00001100 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/eth.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/eth.c	2022-05-09 14:11:35.928495203 -0700
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <netdev.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <fsl_dtsec.h>
+#include <malloc.h>
+
+#include "../common/fman.h"
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	struct memac_mdio_info dtsec_mdio_info;
+	struct memac_mdio_info tgec_mdio_info;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	struct mii_dev *dev;
+	u32 srds_s1;
+
+	srds_s1 = in_be32(&gur->rcwsr[4]) &
+			FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	dtsec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the 1G MDIO bus */
+	fm_memac_mdio_init(bis, &dtsec_mdio_info);
+
+	tgec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tgec_mdio_info);
+
+	/* Set the on-board RGMII PHY address */
+	fm_info_set_phy_address(FM1_DTSEC3, RGMII_PHY1_ADDR);
+
+	switch (srds_s1) {
+	case 0x4558:
+		/* QSGMII on lane A, MAC 1/2/5/6 */
+		fm_info_set_phy_address(FM1_DTSEC1,
+					QSGMII_CARD_PORT1_PHY_ADDR_S1);
+		fm_info_set_phy_address(FM1_DTSEC2,
+					QSGMII_CARD_PORT2_PHY_ADDR_S1);
+		fm_info_set_phy_address(FM1_DTSEC5,
+					QSGMII_CARD_PORT3_PHY_ADDR_S1);
+		fm_info_set_phy_address(FM1_DTSEC6,
+					QSGMII_CARD_PORT4_PHY_ADDR_S1);
+		break;
+	default:
+		printf("Invalid SerDes protocol 0x%x for LS1043AQDS\n",
+		       srds_s1);
+		break;
+	}
+
+	dev = miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME);
+	fm_info_set_mdio(FM1_DTSEC1, dev);
+	fm_info_set_mdio(FM1_DTSEC2, dev);
+	fm_info_set_mdio(FM1_DTSEC5, dev);
+	fm_info_set_mdio(FM1_DTSEC6, dev);
+
+	dev = miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME);
+	fm_info_set_mdio(FM1_DTSEC3, dev);
+
+	cpu_eth_init(bis);
+#endif /* CONFIG_FMAN_ENET */
+
+	return pci_eth_init(bis);
+}
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/sn74lv164a.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/sn74lv164a.c	2022-05-09 14:11:35.944494555 -0700
@@ -0,0 +1,102 @@
+#include <common.h>
+#include "sn74lv164a.h"
+
+#define SN74LV164A_CLR(v)	{ \
+	gpio_direction_output(SN74LV164A_CLR_GPIO, v); \
+}
+
+#define SN74LV164A_CLK(v)	{ \
+	gpio_direction_output(SN74LV164A_CLK_GPIO, v); \
+}
+
+#define SN74LV164A_INA(v)	{ \
+	gpio_direction_output(SN74LV164A_INA_GPIO, v); \
+}
+
+int SN74LV164A_OUT_VAL[SN74LV164A_OUT_NUM] = { SN74LV164A_OUT_LOW };
+
+void sn74lv164a_set(void) {
+	for(int i = 0; i < SN74LV164A_OUT_NUM; i++) {
+		SN74LV164A_INA(SN74LV164A_OUT_VAL[(SN74LV164A_OUT_NUM-(i+1))]);
+		SN74LV164A_CLK(1);
+		SN74LV164A_CLK(0);
+	}
+}
+
+void sn74lv164a_clear(void)
+{
+	SN74LV164A_CLR(1); \
+	SN74LV164A_CLR(0); \
+	SN74LV164A_CLR(1); \
+}
+
+void sn74lv164a_set_value(int pin, int val)
+{
+	SN74LV164A_OUT_VAL[pin] = val;
+	sn74lv164a_set();
+}
+
+void sn74lv164a_set_value_all_high(void)
+{
+	for(int i = 0; i < SN74LV164A_OUT_NUM; i++)
+		SN74LV164A_OUT_VAL[i] = SN74LV164A_OUT_HIGH;
+	sn74lv164a_set();
+}
+
+void sn74lv164a_set_value_all_low(void)
+{
+	for(int i = 0; i < SN74LV164A_OUT_NUM; i++)
+		SN74LV164A_OUT_VAL[i] = SN74LV164A_OUT_LOW;
+	sn74lv164a_set();
+}
+
+static int do_74lv164(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int __maybe_unused pin, val;
+
+	if (argc == 2) {
+		if (!strcmp(argv[1], "clear")) {
+			sn74lv164a_clear();
+		} else if (!strcmp(argv[1], "high")) {
+			sn74lv164a_set_value_all_high();
+		} else if (!strcmp(argv[1], "low")) {
+			sn74lv164a_set_value_all_low();
+		} else {
+			return CMD_RET_USAGE;
+		}
+	} else if (argc == 3) {
+		if (!strcmp(argv[1], "qa")) {
+			pin = SN74LV164A_OUT_QA;
+		} else if (!strcmp(argv[1], "qb")) {
+			pin = SN74LV164A_OUT_QB;
+		} else if (!strcmp(argv[1], "qc")) {
+			pin = SN74LV164A_OUT_QC;
+		} else if (!strcmp(argv[1], "qd")) {
+			pin = SN74LV164A_OUT_QD;
+		} else if (!strcmp(argv[1], "qe")) {
+			pin = SN74LV164A_OUT_QE;
+		} else if (!strcmp(argv[1], "qf")) {
+			pin = SN74LV164A_OUT_QF;
+		} else if (!strcmp(argv[1], "qg")) {
+			pin = SN74LV164A_OUT_QG;
+		} else if (!strcmp(argv[1], "qh")) {
+			pin = SN74LV164A_OUT_QH;
+		} else {
+			return CMD_RET_USAGE;
+		}
+		val = simple_strtoul(argv[2], NULL, 10);
+		sn74lv164a_set_value(pin, val);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(74lv164, 3, 0, do_74lv164,
+	   "74lv164 control",
+	   "\n"
+	   "    clear/high/low\n"
+	   "    [<qa|qb|qc|qd|qe|qf|qg|qh>  <0|1>] \n"
+	   "\n"
+	   );
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/led.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/led.c	2022-05-09 14:11:35.936494879 -0700
@@ -0,0 +1,61 @@
+#include <common.h>
+#include "sn74lv164a.h"
+
+enum {
+	LED_FAIL = SN74LV164A_OUT_QA,
+	LED_ATTN = SN74LV164A_OUT_QB,
+        LED_STAT = SN74LV164A_OUT_QC,
+        LED_MODE = SN74LV164A_OUT_QD,
+        LED_WAP0 = SN74LV164A_OUT_QE,
+        LED_WAP1 = SN74LV164A_OUT_QF,
+	LED_MAX = LED_WAP1,
+};
+
+#define LED_ON		0
+#define LED_OFF		1
+
+static int do_led(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	if (!strcmp(argv[1],"on")) {
+		sn74lv164a_set_value_all_low();
+	} else if (!strcmp(argv[1],"off")) {
+		sn74lv164a_set_value_all_high();
+	} else if (!strcmp(argv[1],"reset")) {
+		sn74lv164a_clear();
+	} else if (!strcmp(argv[1],"fail")) {
+		sn74lv164a_set_value(LED_FAIL, LED_ON);
+	} else if (!strcmp(argv[1],"attn")) {
+		sn74lv164a_set_value(LED_ATTN, LED_ON);
+	} else if (!strcmp(argv[1],"stat")) {
+		sn74lv164a_set_value(LED_STAT, LED_ON);
+	} else if (!strcmp(argv[1],"mode")) {
+		sn74lv164a_set_value(LED_MODE, LED_ON);
+	} else if (!strcmp(argv[1],"2g")) {
+		sn74lv164a_set_value(LED_WAP1, LED_OFF);
+		sn74lv164a_set_value(LED_WAP0, LED_ON);
+	} else if (!strcmp(argv[1],"5g")) {
+		sn74lv164a_set_value(LED_WAP1, LED_ON);
+		sn74lv164a_set_value(LED_WAP0, LED_OFF);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(led, 2, 0, do_led,
+	   "LED control",
+	   "\n"
+	   "\tled on    - Turn on all LEDs, except 2g/5g.\n"
+	   "\tled off   - Turn off all LEDs.\n"
+	   "\tled reset - Clear 74LV174A buffer\n"
+	   "\tled fail\n"
+	   "\tled attn \n"
+	   "\tled stat \n"
+	   "\tled mode \n"
+	   "\tled 2g \n"
+	   "\tled 5g \n"
+	   );
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ddr.c	2022-05-09 14:11:35.916495689 -0700
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 3) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				popts->cpo_override = pbsp->cpo_override;
+				popts->write_data_delay =
+					pbsp->write_data_delay;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for %lu MT/s\n",
+		       ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n",
+	      pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb);
+
+	/* force DDR bus width to 32 bits */
+	popts->data_bus_width = 1;
+	popts->otf_burst_chop_en = 0;
+	popts->burst_length = DDR_BL8;
+	popts->bstopre = 0;		/* enable auto precharge */
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 1;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+#ifdef CONFIG_SYS_FSL_DDR4
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_80ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_80ohm) |
+			  DDR_CDR2_VREF_OVRD(70);	/* Vref = 70% */
+
+	/* optimize cpo for erratum A-009942 */
+	popts->cpo_sample = 0x59;
+#else
+	popts->cswl_override = DDR_CSWL_CS0;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+#endif
+	popts->cpo_sample = 0x41;
+}
+
+/* DDR model number: NT5AD1024M8A3-HR (1024Mb x 8) */
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 0x100000000,
+	.capacity = 0x100000000,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 16,				// p.2
+	.n_col_addr = 10,				// p.2
+	.bank_addr_bits = 2,			// p.2
+	.bank_group_bits = 2,			// p.2
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tckmin_x_ps = 1250,			// p.281
+	.tckmax_ps = 1500,				// p.281
+	.caslat_x = 0x000DFA00,
+	.taa_ps = 13750,				// p.253 taa = tCK * CL
+	.trcd_ps = 13750,				// p.262 11 nCK
+	.trp_ps = 13750,				// p.262 11 nCK
+	.tras_ps = 35000,				// p.262 28 nCK
+	.trc_ps = 48750,				// p.262 39 nCK
+	.trfc1_ps = 350000,				// p.286 350 ns
+	.trfc2_ps = 260000,				// p.286 260 ns
+	.trfc4_ps = 160000,				// p.286 160 ns
+	.tfaw_ps = 25000,				// p.282 20 nCK
+	.trrds_ps = 5000,				// p.282 4 nCK
+	.trrdl_ps = 6250,				// p.282 5 nCK
+	.tccdl_ps = 6250,				// p.282 5 nCK
+	.refresh_rate_ps = 3900000,		// Tc > 85 C
+	.dq_mapping[0] = 0x15,			// 3,1,0,2
+	.dq_mapping[1] = 0x36,			// 7,5,6,4
+	.dq_mapping[2] = 0x15,			// 11,9,8,10 (3,1,0,2)
+	.dq_mapping[3] = 0x22,			// 12,13,15,14 (4,5,7,6)
+	.dq_mapping[4] = 0x16,			// 19,17,18,16 (3,1,2,0)
+	.dq_mapping[5] = 0x36,			// 23,21,22,20 (7,5,6,4)
+	.dq_mapping[6] = 0x15,			// 27,25,24,26 (3.1,0,2)
+	.dq_mapping[7] = 0x36,			// 31,29,30,28 (7,5,6,4)
+	.dq_mapping[8] = 0x0,
+	.dq_mapping[9] = 0x0,
+	.dq_mapping[10] = 0x0,
+	.dq_mapping[11] = 0x0,
+	.dq_mapping[12] = 0x0,
+	.dq_mapping[13] = 0x0,
+	.dq_mapping[14] = 0x0,
+	.dq_mapping[15] = 0x0,
+	.dq_mapping[16] = 0x0,
+	.dq_mapping[17] = 0x0,
+	.dq_mapping_ors = 0,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR4 on board";
+
+	if (((controller_number == 0) && (dimm_number == 0)) ||
+		((controller_number == 1) && (dimm_number == 0))) {
+			memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+			memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+			memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_TFABOOT
+int fsl_initdram(void)
+{
+	gd->ram_size = tfa_get_dram_size();
+	if (!gd->ram_size)
+		gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+}
+#else
+int fsl_initdram(void)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
+	gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+#else
+#ifndef CONFIG_SYS_DDR_RAW_TIMING
+	puts("Initializing DDR....using SPD\n");
+#else
+	puts("Initializing DDR...\n");
+#endif
+
+	dram_size = fsl_ddr_sdram();
+#endif
+	erratum_a008850_post();
+
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	fsl_dp_ddr_restore();
+#endif
+
+	gd->ram_size = dram_size;
+
+	return 0;
+}
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_qixis.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_qixis.h	2022-05-09 14:11:35.940494718 -0700
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __LS1043AQDS_QIXIS_H__
+#define __LS1043AQDS_QIXIS_H__
+
+/* Definitions of QIXIS Registers for LS1043AQDS */
+
+/* BRDCFG4[4:7] select EC1 and EC2 as a pair */
+#define BRDCFG4_EMISEL_MASK		0xe0
+#define BRDCFG4_EMISEL_SHIFT		5
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+#define QIXIS_SYSCLK_64			0x8
+
+/* DDRCLK */
+#define QIXIS_DDRCLK_66			0x0
+#define QIXIS_DDRCLK_100		0x1
+#define QIXIS_DDRCLK_125		0x2
+#define QIXIS_DDRCLK_133		0x3
+
+/* BRDCFG2 - SD clock*/
+#define QIXIS_SDCLK1_100		0x0
+#define QIXIS_SDCLK1_125		0x1
+#define QIXIS_SDCLK1_165		0x2
+#define QIXIS_SDCLK1_100_SP		0x3
+
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds_pbi.cfg	2022-05-09 14:11:35.940494718 -0700
@@ -0,0 +1,14 @@
+#Configure Scratch register
+09570600 00000000
+09570604 10000000
+#Alt base register
+09570158 00001000
+#Disable CCI barrier tranaction
+09570178 0000e010
+09180000 00000008
+#USB PHY frequency sel
+09570418 0000009e
+0957041c 0000009e
+09570420 0000009e
+#flush PBI data
+096100c0 000fffff
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/ls1043aqds.c	2022-05-09 14:11:35.940494718 -0700
@@ -0,0 +1,510 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <fdt_support.h>
+#include <fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/ppa.h>
+#include <asm/arch/fdt.h>
+#include <asm/arch/mmu.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+#include <asm/arch-fsl-layerscape/fsl_icid.h>
+#include <asm/gpio.h>
+#include <ahci.h>
+#include <hwconfig.h>
+#include <mmc.h>
+#include <scsi.h>
+#include <fm_eth.h>
+#include <fsl_esdhc.h>
+#include <fsl_ifc.h>
+#include <spl.h>
+
+#include "../common/qixis.h"
+#include "ls1043aqds_qixis.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+enum {
+	MUX_TYPE_GPIO,
+};
+
+/* LS1043AQDS serdes mux */
+#define CFG_SD_MUX1_SLOT2	0x0 /* SLOT2 TX/RX0 */
+#define CFG_SD_MUX1_SLOT1	0x1 /* SLOT1 TX/RX1 */
+#define CFG_SD_MUX2_SLOT3	0x0 /* SLOT3 TX/RX0 */
+#define CFG_SD_MUX2_SLOT1	0x1 /* SLOT1 TX/RX2 */
+#define CFG_SD_MUX3_SLOT4	0x0 /* SLOT4 TX/RX0 */
+#define CFG_SD_MUX3_MUX4	0x1 /* MUX4 */
+#define CFG_SD_MUX4_SLOT3	0x0 /* SLOT3 TX/RX1 */
+#define CFG_SD_MUX4_SLOT1	0x1 /* SLOT1 TX/RX3 */
+#define CFG_UART_MUX_MASK	0x6
+#define CFG_UART_MUX_SHIFT	1
+#define CFG_LPUART_EN		0x1
+
+#ifdef CONFIG_TFABOOT
+struct ifc_regs ifc_cfg_nor_boot[CONFIG_SYS_FSL_IFC_BANK_COUNT] = {
+	{
+		"nor0",
+		CONFIG_SYS_NOR0_CSPR,
+		CONFIG_SYS_NOR0_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+
+	},
+	{
+		"nor1",
+		CONFIG_SYS_NOR1_CSPR,
+		CONFIG_SYS_NOR1_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+	},
+	{
+		"nand",
+		CONFIG_SYS_NAND_CSPR,
+		CONFIG_SYS_NAND_CSPR_EXT,
+		CONFIG_SYS_NAND_AMASK,
+		CONFIG_SYS_NAND_CSOR,
+		{
+			CONFIG_SYS_NAND_FTIM0,
+			CONFIG_SYS_NAND_FTIM1,
+			CONFIG_SYS_NAND_FTIM2,
+			CONFIG_SYS_NAND_FTIM3
+		},
+	},
+	{
+		"fpga",
+		CONFIG_SYS_FPGA_CSPR,
+		CONFIG_SYS_FPGA_CSPR_EXT,
+		CONFIG_SYS_FPGA_AMASK,
+		CONFIG_SYS_FPGA_CSOR,
+		{
+			CONFIG_SYS_FPGA_FTIM0,
+			CONFIG_SYS_FPGA_FTIM1,
+			CONFIG_SYS_FPGA_FTIM2,
+			CONFIG_SYS_FPGA_FTIM3
+		},
+	}
+};
+
+struct ifc_regs ifc_cfg_nand_boot[CONFIG_SYS_FSL_IFC_BANK_COUNT] = {
+	{
+		"nand",
+		CONFIG_SYS_NAND_CSPR,
+		CONFIG_SYS_NAND_CSPR_EXT,
+		CONFIG_SYS_NAND_AMASK,
+		CONFIG_SYS_NAND_CSOR,
+		{
+			CONFIG_SYS_NAND_FTIM0,
+			CONFIG_SYS_NAND_FTIM1,
+			CONFIG_SYS_NAND_FTIM2,
+			CONFIG_SYS_NAND_FTIM3
+		},
+	},
+	{
+		"nor0",
+		CONFIG_SYS_NOR0_CSPR,
+		CONFIG_SYS_NOR0_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+	},
+	{
+		"nor1",
+		CONFIG_SYS_NOR1_CSPR,
+		CONFIG_SYS_NOR1_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+	},
+	{
+		"fpga",
+		CONFIG_SYS_FPGA_CSPR,
+		CONFIG_SYS_FPGA_CSPR_EXT,
+		CONFIG_SYS_FPGA_AMASK,
+		CONFIG_SYS_FPGA_CSOR,
+		{
+			CONFIG_SYS_FPGA_FTIM0,
+			CONFIG_SYS_FPGA_FTIM1,
+			CONFIG_SYS_FPGA_FTIM2,
+			CONFIG_SYS_FPGA_FTIM3
+		},
+	}
+};
+
+void ifc_cfg_boot_info(struct ifc_regs_info *regs_info)
+{
+	enum boot_src src = get_boot_src();
+
+	if (src == BOOT_SOURCE_IFC_NAND)
+		regs_info->regs = ifc_cfg_nand_boot;
+	else
+		regs_info->regs = ifc_cfg_nor_boot;
+	regs_info->cs_size = CONFIG_SYS_FSL_IFC_BANK_COUNT;
+}
+#endif
+
+int checkboard(void)
+{
+#ifdef CONFIG_TFABOOT
+	enum boot_src src = get_boot_src();
+#endif
+#ifndef CONFIG_SD_BOOT
+	u8 sw;
+#endif
+
+	puts("Board: LS1043AQDS, boot from ");
+
+#ifdef CONFIG_TFABOOT
+	if (src == BOOT_SOURCE_SD_MMC)
+		puts("SD\n");
+	else {
+#endif
+
+#ifdef CONFIG_SD_BOOT
+		puts("SD\n");
+#else
+		sw = QIXIS_READ(brdcfg[0]);
+		sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+		if (sw < 0x8)
+			printf("vBank: %d\n", sw);
+		else if (sw == 0x8)
+			puts("PromJet\n");
+		else if (sw == 0x9)
+			puts("NAND\n");
+		else if (sw == 0xF)
+			printf("QSPI\n");
+		else
+			printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+#endif
+
+#ifdef CONFIG_TFABOOT
+	}
+#endif
+
+	return 0;
+}
+
+bool if_board_diff_clk(void)
+{
+	u8 diff_conf = QIXIS_READ(brdcfg[11]);
+
+	return diff_conf & 0x40;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0f) {
+	case QIXIS_SYSCLK_64:
+		return 64000000;
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	if (if_board_diff_clk())
+		return get_board_sys_clk();
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+
+	return 66666666;
+}
+
+int dram_init(void)
+{
+	fsl_initdram();
+#if (!defined(CONFIG_SPL) && !defined(CONFIG_TFABOOT)) || \
+	defined(CONFIG_SPL_BUILD)
+	/* This will break-before-make MMU for DDR */
+	update_early_mmu_table();
+#endif
+
+	return 0;
+}
+
+void board_usb_cfg_reset(void)
+{
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+	u32 usb_pwrfault;
+
+	if(is_t40cw()) /* Senao LTE patch for T40-CW */
+	{
+		out_be32(&scfg->rcwpmuxcr0, 0x1111);
+		out_be32(&scfg->usbdrvvbus_selcr, SCFG_USBDRVVBUS_SELCR_USB1);
+		usb_pwrfault =
+			(SCFG_USBPWRFAULT_DEDICATED << SCFG_USBPWRFAULT_USB3_SHIFT) |
+			(SCFG_USBPWRFAULT_INACTIVE << SCFG_USBPWRFAULT_USB2_SHIFT)  |
+			(SCFG_USBPWRFAULT_SHARED << SCFG_USBPWRFAULT_USB1_SHIFT);
+		out_be32(&scfg->usbpwrfault_selcr, usb_pwrfault);
+		/* Senao LTE patch for T40-CW: reset IGT */
+		gpio_direction_output(403, 1);
+		udelay(120000);
+		gpio_direction_output(403, 0);
+		puts("T40-CW: USB configuration for LTE... OK\n");
+	}
+#endif
+}
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+	u32 usb_pwrfault;
+#endif
+#ifdef CONFIG_LPUART
+	u8 uart;
+#endif
+
+#ifdef CONFIG_SYS_I2C_EARLY_INIT
+	i2c_early_init_f();
+#endif
+	fsl_lsch2_early_init_f();
+
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+	out_be32(&scfg->rcwpmuxcr0, 0x3333);
+	out_be32(&scfg->usbdrvvbus_selcr, SCFG_USBDRVVBUS_SELCR_USB1);
+	usb_pwrfault =
+		(SCFG_USBPWRFAULT_DEDICATED << SCFG_USBPWRFAULT_USB3_SHIFT) |
+		(SCFG_USBPWRFAULT_DEDICATED << SCFG_USBPWRFAULT_USB2_SHIFT) |
+		(SCFG_USBPWRFAULT_SHARED << SCFG_USBPWRFAULT_USB1_SHIFT);
+	out_be32(&scfg->usbpwrfault_selcr, usb_pwrfault);
+#endif
+
+#ifdef CONFIG_HAS_GPIO4_12_13
+	out_be32(&scfg->rcwpmuxcr0, (in_be32(&scfg->rcwpmuxcr0) & 0xff00) | 0x11);
+#endif
+
+#ifdef CONFIG_LPUART
+	/* We use lpuart0 as system console */
+	uart = QIXIS_READ(brdcfg[14]);
+	uart &= ~CFG_UART_MUX_MASK;
+	uart |= CFG_LPUART_EN << CFG_UART_MUX_SHIFT;
+	QIXIS_WRITE(brdcfg[14], uart);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_DEEP_SLEEP
+/* determine if it is a warm boot */
+bool is_warm_boot(void)
+{
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+
+	if (in_be32(&gur->crstsr) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+#endif
+
+int config_board_mux(int ctrl_type)
+{
+	u8 reg14;
+
+	reg14 = QIXIS_READ(brdcfg[14]);
+
+	switch (ctrl_type) {
+	case MUX_TYPE_GPIO:
+		reg14 = (reg14 & (~0x30)) | 0x20;
+		break;
+	default:
+		puts("Unsupported mux interface type\n");
+		return -1;
+	}
+
+	QIXIS_WRITE(brdcfg[14], reg14);
+
+	return 0;
+}
+
+int config_serdes_mux(void)
+{
+	return 0;
+}
+
+
+#ifdef CONFIG_MISC_INIT_R
+int misc_init_r(void)
+{
+	if (hwconfig("gpio"))
+		config_board_mux(MUX_TYPE_GPIO);
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+#ifdef CONFIG_SYS_FSL_ERRATUM_A010315
+	erratum_a010315();
+#endif
+
+#ifdef CONFIG_SYS_FSL_SERDES
+	config_serdes_mux();
+#endif
+
+#ifdef CONFIG_FSL_LS_PPA
+	ppa_init();
+#endif
+
+	/* SENAO: init gpio */
+
+	gpio_direction_output(114, 1); /* Watchdog pulse output */
+	gpio_direction_output(123, 1); /* TPM_WakeupN */
+	gpio_direction_output(124, 1); /* RST_TPM_N */
+	gpio_direction_output(125, 1); /* TPM_Express */
+
+	gpio_direction_output(127, 1); /* LED_CLK */
+	gpio_direction_output(128, 1); /* LED_DATA */
+	gpio_direction_output(129, 1); /* RST_PCIE0_N reset QCA9880 */
+	gpio_direction_output(130, 1); /* POE_RST_N_33 */
+	gpio_direction_output(205, 1); /* LED_IC_RST_N_R_1V8 */
+	gpio_direction_output(206, 1); /* BLUETOOTH_RST_1V8 */
+	gpio_direction_output(211, 1); /* RST to VSC8514 */
+	gpio_direction_output(212, 1); /* RST to AR8035 */
+	gpio_direction_output(226, 1); /* QSPI_RST_N */
+	gpio_direction_output(315, 1);
+	gpio_direction_output(316, 1);
+	gpio_direction_output(326, 1); /* WatchDog enabl>> Active Low */
+	gpio_direction_output(413, 1);
+
+	/* Workaround for resetting QCA9880 */
+	gpio_direction_output(129, 0); /* RST_PCIE0_N reset QCA9880 */
+	udelay(10000); //keeping 10ms L
+	gpio_direction_output(129, 1); /* RST_PCIE0_N reset QCA9880 */
+
+	/* reset AR8035 */
+	gpio_direction_output(212, 1); /* RST to AR8035 */
+
+	/*
+	   Watchguard Wants to support both NEW (88E1545) and OLD (VSC8514) Boards.
+	   We will extend the udelay to 20 ms so that way it supports both PHYs
+	*/
+	/* reset 88E1545 or VSC8514 */
+	gpio_direction_output(211, 0); /* RST to 88E1545 or VSC8514 */
+	udelay(20000); //keeping 20ms L
+	gpio_direction_output(211, 1); /* RST to 88E1545 or VSC8514 */
+
+	/* Talor Lin: If model is T40-CW, then USB configuration should be changed for LTE */
+	board_usb_cfg_reset();
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	u64 base[CONFIG_NR_DRAM_BANKS];
+	u64 size[CONFIG_NR_DRAM_BANKS];
+	u8 reg;
+
+	/* fixup DT for the two DDR banks */
+	base[0] = gd->bd->bi_dram[0].start;
+	size[0] = gd->bd->bi_dram[0].size;
+	base[1] = gd->bd->bi_dram[1].start;
+	size[1] = gd->bd->bi_dram[1].size;
+
+	fdt_fixup_memory_banks(blob, base, size, 2);
+	ft_cpu_setup(blob, bd);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+#endif
+
+	fdt_fixup_icid(blob);
+
+	reg = QIXIS_READ(brdcfg[0]);
+	reg = (reg & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	/* Disable IFC if QSPI is enabled */
+	if (reg == 0xF)
+		do_fixup_by_compat(blob, "fsl,ifc",
+				   "status", "disabled", 8 + 1, 1);
+
+	return 0;
+}
+#endif
+
+u8 flash_read8(void *addr)
+{
+	return __raw_readb(addr + 1);
+}
+
+void flash_write16(u16 val, void *addr)
+{
+	u16 shftval = (((val >> 8) & 0xff) | ((val << 8) & 0xff00));
+
+	__raw_writew(shftval, addr);
+}
+
+u16 flash_read16(void *addr)
+{
+	u16 val = __raw_readw(addr);
+
+	return (((val) >> 8) & 0x00ff) | (((val) << 8) & 0xff00);
+}
+
+#ifdef CONFIG_TFABOOT
+void *env_sf_get_env_addr(void)
+{
+	return (void *)(CONFIG_SYS_FSL_QSPI_BASE + CONFIG_ENV_OFFSET);
+}
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t40/MAINTAINERS.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t40/MAINTAINERS	2022-05-09 14:11:35.908496013 -0700
@@ -0,0 +1,6 @@
+WatchGuard T40 build off the LS1043AQDS reference BOARD
+M:	Mukund Jampala <mukund.jampala@watchguard.com>
+S:	Maintained
+F:	board/freescale/ls1043aqds_t40/
+F:	include/configs/ls1043aqds_t40.h
+F:	configs/ls1043aqds_wg_t40_qspi_defconfig
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_pbi.cfg	2022-05-09 14:11:36.032490993 -0700
@@ -0,0 +1,22 @@
+#Configure Scratch register
+09570600 00000000
+09570604 10000000
+#Disable CCI barrier tranaction
+09570178 0000e010
+09180000 00000008
+#USB PHY frequency sel
+09570418 0000009e
+0957041c 0000009e
+09570420 0000009e
+#Serdes SATA
+09eb1300 80104e20
+09eb08dc 00502880
+#PEX gen3 link
+09570158 00000300
+89400890 01048000
+89500890 01048000
+89600890 01048000
+#Alt base register
+09570158 00001000
+#flush PBI data
+096100c0 000fffff
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ddr.c	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,323 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include "ddr.h"
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
+#include <asm/arch/clock.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 1) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	if (popts->registered_dimm_en)
+		pbsp = rdimms[0];
+	else
+		pbsp = udimms[0];
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for %lu MT/s\n",
+		       ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n",
+	      pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb);
+
+	popts->data_bus_width = 0;	/* 64-bit data bus */
+	popts->bstopre = 0;		/* enable auto precharge */
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_80ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_80ohm) |
+			  DDR_CDR2_VREF_TRAIN_EN | DDR_CDR2_VREF_RANGE_2;
+
+	/* optimize cpo for erratum A-009942 */
+    /*Albert.Ke.B*/
+#ifdef CONFIG_WG1008_VM1P
+	popts->cpo_sample = 0x4d;
+#else
+	popts->cpo_sample = 0x61;
+#endif
+    /*Albert.Ke.E*/
+
+}
+/*Albert.Ke:Add for fixed dram init*/
+#ifdef CONFIG_WG1008_VM1P
+/* DDR model number: MT40A512M8HX-093E */
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+/*
+	.rank_density = 2147483648u,
+	.capacity = 2147483648u,
+*/
+	.rank_density = 4294967296u,
+	.capacity = 4294967296u,
+
+/*
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+*/
+
+    .data_width = 72, //Albert.Ke
+	.primary_sdram_width = 64,
+
+	.ec_sdram_width = 8,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+    .device_width = 16, //Albert.Ke
+/*
+	.n_row_addr = 15,
+*/
+	.n_row_addr = 16,
+	.n_col_addr = 10,
+/*
+	.bank_addr_bits = 0,
+	.bank_group_bits = 2,
+*/
+	.bank_addr_bits = 2,
+	.bank_group_bits = 1,
+
+//	.edc_config = 0,
+	.edc_config = 2,
+
+	.burst_lengths_bitmask = 0x0c,
+
+/*Albert.Ke
+	.tckmin_x_ps = 938,
+	.tckmax_ps = 1500,
+*/
+	.tckmin_x_ps = 1250,
+	.tckmax_ps = 1500,
+
+	.caslat_x = 0x000DFA00,
+	.taa_ps = 13500,
+	.trcd_ps = 13500,
+	.trp_ps = 13500,
+/*Albert.Ke
+	.tras_ps = 33000,
+*/
+	.tras_ps = 35000,
+/*
+	.trc_ps = 46500,
+
+	.trfc1_ps = 260000,
+	.trfc2_ps = 160000,
+	.trfc4_ps = 110000,
+*/
+	.trc_ps = 48500,
+
+
+	.trfc1_ps = 350000,
+	.trfc2_ps = 260000,
+	.trfc4_ps = 160000,
+
+	.tfaw_ps = 35000,
+/*
+	.trrds_ps = 3700,
+	.trrdl_ps = 5300,
+	.tccdl_ps = 5355,
+*/
+	.trrds_ps = 6000,
+	.trrdl_ps = 7500,
+	.tccdl_ps = 6250,
+
+	.refresh_rate_ps = 7800000,
+	.dq_mapping[0] = 0x0,
+	.dq_mapping[1] = 0x0,
+	.dq_mapping[2] = 0x0,
+	.dq_mapping[3] = 0x0,
+	.dq_mapping[4] = 0x0,
+	.dq_mapping[5] = 0x0,
+	.dq_mapping[6] = 0x0,
+	.dq_mapping[7] = 0x0,
+	.dq_mapping[8] = 0x0,
+	.dq_mapping[9] = 0x0,
+	.dq_mapping[10] = 0x0,
+	.dq_mapping[11] = 0x0,
+	.dq_mapping[12] = 0x0,
+	.dq_mapping[13] = 0x0,
+	.dq_mapping[14] = 0x0,
+	.dq_mapping[15] = 0x0,
+	.dq_mapping[16] = 0x0,
+	.dq_mapping[17] = 0x0,
+	.dq_mapping_ors = 0,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+			    unsigned int controller_number,
+			    unsigned int dimm_number)
+{
+	static const char dimm_model[] = "Fixed DDR on board";
+
+	if (((controller_number == 0) && (dimm_number == 0)) ||
+	    ((controller_number == 1) && (dimm_number == 0))) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+#else
+
+phys_size_t fixed_sdram(void)
+{
+	int i;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	phys_size_t ddr_size;
+	ulong ddr_freq, ddr_freq_mhz;
+
+	ddr_freq = get_ddr_freq(0);
+	ddr_freq_mhz = ddr_freq / 1000000;
+
+	printf("Configuring DDR for %s MT/s data rate\n",
+	       strmhz(buf, ddr_freq));
+
+	for (i = 0; fixed_ddr_parm_0[i].max_freq > 0; i++) {
+		if ((ddr_freq_mhz > fixed_ddr_parm_0[i].min_freq) &&
+		    (ddr_freq_mhz <= fixed_ddr_parm_0[i].max_freq)) {
+			memcpy(&ddr_cfg_regs,
+			       fixed_ddr_parm_0[i].ddr_settings,
+			       sizeof(ddr_cfg_regs));
+			break;
+		}
+	}
+
+	if (fixed_ddr_parm_0[i].max_freq == 0)
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+		      strmhz(buf, ddr_freq));
+
+	ddr_size = (phys_size_t)4096 * 1024 * 1024;
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0, 0);
+
+	return ddr_size;
+}
+#endif
+#endif
+
+#ifdef CONFIG_TFABOOT
+int fsl_initdram(void)
+{
+	gd->ram_size = tfa_get_dram_size();
+
+	if (!gd->ram_size)
+		gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+}
+#else
+int fsl_initdram(void)
+{
+	phys_size_t dram_size;
+
+/*Albert.Ke.B*/
+#ifdef CONFIG_WG1008_VM1P
+
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL)
+	puts("Initializing DDR....\n");
+	dram_size = fsl_ddr_sdram();
+#else
+	dram_size =  fsl_ddr_sdram_size();
+#endif
+#else
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL)
+	puts("Initialzing DDR using fixed setting\n");
+	dram_size = fixed_sdram();
+#else
+	gd->ram_size = 0x80000000;
+
+	return 0;
+#endif
+#endif
+
+	//puts("Initialzing DDR using fixed setting\n");
+	//dram_size = fixed_sdram();
+
+#else
+
+#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
+	gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+#else
+	puts("Initializing DDR....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+#endif
+
+#endif
+/*Albert.Ke.E*/
+
+
+	erratum_a008850_post();
+
+	gd->ram_size = dram_size;
+
+	return 0;
+}
+#endif
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/MAINTAINERS.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/MAINTAINERS	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,30 @@
+WatchGuard T20 build off the LS1046ARDB reference BOARD
+M:	Mukund Jampala <mukund.jampala@watchguard.com>
+S:	Maintained
+F:	board/freescale/ls1046ardb_t80/
+F:	include/configs/ls1046ardb_t80.h
+F:	configs/ls1046ardb_wg_t80_qspi_defconfig
+F:	configs/ls1046ardb_wg_t80_qspi_SECURE_BOOT_defconfig
+
+LS1046A BOARD
+M:	Mingkai Hu <mingkai.hu@nxp.com>
+M:	Rajesh Bhagat <rajesh.bhagat@nxp.com>
+S:	Maintained
+F:	board/freescale/ls1046ardb/
+F:	board/freescale/ls1046ardb/ls1046ardb.c
+F:	include/configs/ls1046ardb.h
+F:	configs/ls1046ardb_qspi_defconfig
+F:	configs/ls1046ardb_qspi_spl_defconfig
+F:	configs/ls1046ardb_sdcard_defconfig
+F:	configs/ls1046ardb_emmc_defconfig
+F:	configs/ls1046ardb_tfa_defconfig
+
+LS1046A_SECURE_BOOT BOARD
+M:	Ruchika Gupta <ruchika.gupta@nxp.com>
+S:	Maintained
+F:	configs/ls1046ardb_SECURE_BOOT_defconfig
+F:	configs/ls1046ardb_sdcard_SECURE_BOOT_defconfig
+
+M:	Sumit Garg <sumit.garg@nxp.com>
+S:	Maintained
+F:	configs/ls1046ardb_qspi_SECURE_BOOT_defconfig
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/cpld.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/cpld.h	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2016 Freescale Semiconductor
+ */
+
+#ifndef __CPLD_H__
+#define __CPLD_H__
+
+/*
+ * CPLD register set of LS1046ARDB board-specific.
+ * CPLD Revision:  V2.1
+ */
+struct cpld_data {
+	u8 cpld_ver;		/* 0x0 - CPLD Major Revision Register */
+	u8 cpld_ver_sub;	/* 0x1 - CPLD Minor Revision Register */
+	u8 pcba_ver;		/* 0x2 - PCBA Revision Register */
+	u8 system_rst;		/* 0x3 - system reset register */
+	u8 soft_mux_on;		/* 0x4 - Switch Control Enable Register */
+	u8 cfg_rcw_src1;	/* 0x5 - RCW Source Location POR Regsiter 1 */
+	u8 cfg_rcw_src2;	/* 0x6 - RCW Source Location POR Regsiter 2 */
+	u8 vbank;		/* 0x7 - QSPI Flash Bank Setting Register */
+	u8 sysclk_sel;		/* 0x8 - System clock POR Register */
+	u8 uart_sel;		/* 0x9 - UART1 Connection Control Register */
+	u8 sd1refclk_sel;	/* 0xA - */
+	u8 rgmii_1588_sel;	/* 0xB - */
+	u8 reg_1588_clk_sel;	/* 0xC - */
+	u8 status_led;		/* 0xD - */
+	u8 global_rst;		/* 0xE - */
+	u8 sd_emmc;             /* 0xF - SD/EMMC Interface Control Regsiter */
+	u8 vdd_en;              /* 0x10 - VDD Voltage Control Enable Register */
+	u8 vdd_sel;             /* 0x11 - VDD Voltage Control Register */
+};
+
+u8 cpld_read(unsigned int reg);
+void cpld_write(unsigned int reg, u8 value);
+void cpld_rev_bit(unsigned char *value);
+void cpld_select_core_volt(bool en_0v9);
+
+#define CPLD_READ(reg) cpld_read(offsetof(struct cpld_data, reg))
+#define CPLD_WRITE(reg, value)  \
+	cpld_write(offsetof(struct cpld_data, reg), value)
+
+/* CPLD on IFC */
+#define CPLD_SW_MUX_BANK_SEL	0x40
+#define CPLD_BANK_SEL_MASK	0x07
+#define CPLD_BANK_SEL_ALTBANK	0x04
+#define CPLD_CFG_RCW_SRC_QSPI	0x044
+#define CPLD_CFG_RCW_SRC_SD	0x040
+#endif
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb.c	2022-05-09 14:11:35.972493422 -0700
@@ -0,0 +1,608 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <fdt_support.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/ppa.h>
+#include <asm/arch/soc.h>
+#include <asm/arch-fsl-layerscape/fsl_icid.h>
+#include <hwconfig.h>
+#include <ahci.h>
+#include <mmc.h>
+#include <scsi.h>
+#include <fm_eth.h>
+#include <fsl_csu.h>
+#include <fsl_esdhc.h>
+#include <power/mc34vr500_pmic.h>
+#include "cpld.h"
+#include <fsl_sec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_early_init_f(void)
+{
+	fsl_lsch2_early_init_f();
+
+	return 0;
+}
+
+#ifdef CONFIG_WG1008_VM1P
+//#define DBG_GPIO
+//#define ENDIAN_SWAP
+//#define BIT_SWAP
+#define ENDIAN_SWAP_AND_BIT_SWAP
+
+extern int switch_mv88e6190_port_led(u32 mode);
+
+GPIO_t wg1008_vm1p_gpio[] =
+{
+    {GPIO_BUS_RESET_IN                ,GPIO_SHIFT_RESET_IN                ,GPIO_DIR_RESET_IN                ,1},
+    {GPIO_BUS_ATT_LED                 ,GPIO_SHIFT_ATT_LED                 ,GPIO_DIR_ATT_LED                 ,1},
+    {GPIO_BUS_SW_STATUS_LED           ,GPIO_SHIFT_SW_STATUS_LED           ,GPIO_DIR_SW_STATUS_LED           ,1},
+    {GPIO_BUS_SW_MODE_LED             ,GPIO_SHIFT_SW_MODE_LED             ,GPIO_DIR_SW_MODE_LED             ,1},
+    {GPIO_BUS_FAILOVER_LED            ,GPIO_SHIFT_FAILOVER_LED            ,GPIO_DIR_FAILOVER_LED            ,1},
+    {GPIO_BUS_POWER_LED               ,GPIO_SHIFT_POWER_LED               ,GPIO_DIR_POWER_LED               ,0},
+    {GPIO_BUS_TMP_RESET               ,GPIO_SHIFT_TMP_RESET               ,GPIO_DIR_TMP_RESET               ,1},
+    {GPIO_BUS_MARVELL_SWITCH_RESET    ,GPIO_SHIFT_MARVELL_SWITCH_RESET    ,GPIO_DIR_MARVELL_SWITCH_RESET    ,1},
+    {GPIO_BUS_RST_MOD_RESET           ,GPIO_SHIFT_RST_MOD_RESET           ,GPIO_DIR_RST_MOD_RESET           ,1},
+    {GPIO_BUS_FAN_DRIVER_FON          ,GPIO_SHIFT_FAN_DRIVER_FON          ,GPIO_DIR_FAN_DRIVER_FON          ,1},
+    {GPIO_BUS_INT_ALL_ALM_7904D_CPU_N ,GPIO_SHIFT_INT_ALL_ALM_7904D_CPU_N ,GPIO_DIR_INT_ALL_ALM_7904D_CPU_N ,1},
+    {GPIO_BUS_MOD_BRD_TYPE_0          ,GPIO_SHIFT_MOD_BRD_TYPE_0          ,GPIO_DIR_MOD_BRD_TYPE_0          ,1},
+    {GPIO_BUS_MOD_BRD_TYPE_1          ,GPIO_SHIFT_MOD_BRD_TYPE_1          ,GPIO_DIR_MOD_BRD_TYPE_1          ,1},
+    {GPIO_BUS_INT_RTC_PHY_N           ,GPIO_SHIFT_INT_RTC_PHY_N           ,GPIO_DIR_INT_RTC_PHY_N           ,1},
+    {GPIO_BUS_MOD_BAY_PRESENT_N       ,GPIO_SHIFT_MOD_BAY_PRESENT_N       ,GPIO_DIR_MOD_BAY_PRESENT_N       ,1},
+    {GPIO_BUS_LED_CPU_MOD_1           ,GPIO_SHIFT_LED_CPU_MOD_1           ,GPIO_DIR_LED_CPU_MOD_1           ,1},
+    {GPIO_BUS_LED_CPU_MOD_2           ,GPIO_SHIFT_LED_CPU_MOD_2           ,GPIO_DIR_LED_CPU_MOD_2           ,1},
+    {GPIO_BUS_LED_CPU_MOD_3           ,GPIO_SHIFT_LED_CPU_MOD_3           ,GPIO_DIR_LED_CPU_MOD_3           ,1},
+    {GPIO_BUS_LED_CPU_MOD_4           ,GPIO_SHIFT_LED_CPU_MOD_4           ,GPIO_DIR_LED_CPU_MOD_4           ,1},
+};
+
+LED_t wg1008_vm1p_led[] =
+{
+    {GPIO_NUM_ATT_LED       ,"Attn"     ,0},
+    {GPIO_NUM_SW_STATUS_LED ,"Status"   ,0},
+    {GPIO_NUM_SW_MODE_LED   ,"Mode"     ,0},
+    {GPIO_NUM_FAILOVER_LED  ,"Failover" ,0},
+    {GPIO_NUM_POWER_LED     ,"Power"    ,0},
+    {GPIO_NUM_LED_CPU_MOD_1 ,"Module1"  ,0},
+    {GPIO_NUM_LED_CPU_MOD_2 ,"Module2"  ,0},
+    {GPIO_NUM_LED_CPU_MOD_3 ,"Module3"  ,0},
+    {GPIO_NUM_LED_CPU_MOD_4 ,"Module4"  ,0},
+    {0                      ,NULL       ,0},
+};
+
+u32 reverseEndian(u32 value)
+{
+    return (((value & 0x000000FF) << 24) |
+            ((value & 0x0000FF00) <<  8) |
+            ((value & 0x00FF0000) >>  8) |
+            ((value & 0xFF000000) >> 24));
+}
+
+u32 reverseBits8(u8 num)
+{
+    u8 count = sizeof(num) * 8 - 1;
+    u8 reverse_num = num;
+
+    num >>= 1;
+    while(num)
+    {
+       reverse_num <<= 1;
+       reverse_num |= num & 1;
+       num >>= 1;
+       count--;
+    }
+    reverse_num <<= count;
+//    printf("reverse_num  0x%02x\n", reverse_num);
+    return (u32)reverse_num;
+}
+
+u32 reverseBits32(u32 num)
+{
+    u32 count = sizeof(num) * 8 - 1;
+    u32 reverse_num = num;
+
+    num >>= 1;
+    while(num)
+    {
+       reverse_num <<= 1;
+       reverse_num |= num & 1;
+       num >>= 1;
+       count--;
+    }
+    reverse_num <<= count;
+//    printf("reverse_num  0x%02x\n", reverse_num);
+    return (u32)reverse_num;
+}
+
+
+u32 reverse32(u32 value) 
+{
+    u32 tmpVal = 0;
+#if defined(ENDIAN_SWAP)
+    tmpVal = reverseEndian(value);
+#elif defined(BIT_SWAP)
+    int idx = 0;
+    u32 tmpByte = 0;
+
+    tmpVal = value;
+    for(idx = 0; idx < 4; idx++)
+    {
+        tmpByte = (tmpVal & (0x000000FF<<(idx*8)))>>(idx*8);
+        tmpVal &= ~(0x000000FF<<(idx*8));
+        tmpVal |= (reverseBits8(tmpByte)<<(idx*8));
+    }
+#elif defined(ENDIAN_SWAP_AND_BIT_SWAP)
+    tmpVal = reverseEndian(value);
+    tmpVal = reverseBits32(tmpVal);
+#else
+    tmpVal = value;
+#endif
+
+    return tmpVal;
+}
+
+int regRead(volatile u32 *regAddr, volatile u32 *regVal)
+{
+    int ret = 0;
+
+#ifdef DBG_GPIO
+    printf("Before swap  0x%08x\n", *regAddr);
+#endif
+    *regVal = reverse32(*regAddr);
+#ifdef DBG_GPIO
+    printf("After swap  0x%08x\n", *regVal);
+#endif
+    return ret;
+}
+
+int regWrite(volatile u32 *regAddr, u32 regVal)
+{
+    u32 write_val = 0;
+    int ret = 0;
+
+#ifdef DBG_GPIO
+    printf("Before swap  0x%08x\n", regVal);
+#endif
+    write_val = reverse32(regVal);
+    *regAddr = write_val;
+#ifdef DBG_GPIO
+    printf("After swap  0x%08x\n", write_val);
+#endif
+
+    return ret;
+}
+
+int gpioWrite(u32 gpio_bus, u32 gpio_shift, u32 gpio_type, u32 val)
+{
+    u32 gpio_reg = NULL;
+    u32 read_val = 0;
+    int ret = 0;
+
+    if(GPIO_TYPE_DIR == gpio_type)
+    {
+        gpio_reg = LS1046A_GPIO1_DIR;
+    }
+    else if(GPIO_TYPE_DATA == gpio_type)
+    {
+        gpio_reg = LS1046A_GPIO1_DATA;
+    }
+    else
+    {
+        printf("Wrong gpio type %d!!!\n", gpio_type);
+        return -1;
+    }
+    gpio_reg += ((gpio_bus - 1)*0x10000);
+
+#ifdef DBG_GPIO
+    printf("\nGPIO%u_%02u REG 0x%08x\n", gpio_bus, gpio_shift, gpio_reg);
+#endif
+
+    ret = regRead(gpio_reg, &read_val);
+    if(ret)
+    {
+        printf("regRead failed!!!\n");
+        return -1;
+    }
+#ifdef DBG_GPIO
+    printf("Read value  0x%08x\n", read_val);
+#endif
+    if(val)
+    {
+        read_val |= (1<<gpio_shift);
+    }
+    else
+    {
+        read_val &= ~(1<<gpio_shift);
+    }
+    ret = regWrite(gpio_reg, read_val);
+    if(ret)
+    {
+        printf("regWrite failed!!!\n");
+        return -1;
+    }
+#ifdef DBG_GPIO
+    printf("Write value 0x%08x\n", read_val);
+#endif
+
+    return 0;
+}
+
+int gpioRead(u32 gpio_bus, u32 gpio_shift, u32 gpio_type, u32 *val)
+{
+    u32 gpio_reg = NULL;
+    u32 read_val = 0;
+    int ret = 0;
+
+    if(GPIO_TYPE_DIR == gpio_type)
+    {
+        gpio_reg = LS1046A_GPIO1_DIR;
+    }
+    else if(GPIO_TYPE_DATA == gpio_type)
+    {
+        gpio_reg = LS1046A_GPIO1_DATA;
+    }
+    else
+    {
+        printf("Wrong gpio type %d!!!\n", gpio_type);
+        return -1;
+    }
+    gpio_reg += ((gpio_bus - 1)*0x10000);
+#ifdef DBG_GPIO
+    printf("\nGPIO%u_%02u REG 0x%08x\n", gpio_bus, gpio_shift, gpio_reg);
+#endif
+
+    ret = regRead(gpio_reg, &read_val);
+    if(ret)
+    {
+        printf("regRead failed!!!\n");
+        return -1;
+    }
+
+#ifdef DBG_GPIO
+    printf("Read value  0x%08x\n", read_val);
+#endif
+    *val = (read_val & (1<<gpio_shift))?1:0;
+
+    return 0;
+}
+
+int getGpioNumByLedName(char *ledName, u32 *gpioNum, u32 *active_high)
+{
+    int ledLen = 0, idx =0;
+    if(!ledName || !gpioNum || !active_high)
+    {
+        printf("NULL arguments!!!\n");
+        return -1;
+    }
+
+    ledLen = sizeof(wg1008_vm1p_led)/sizeof(wg1008_vm1p_led[0]);
+    for(idx = 0; idx < ledLen; idx++)
+    {
+        if(!strncmp(ledName, wg1008_vm1p_led[idx].led_name, strlen(ledName)))
+        {
+            *gpioNum = wg1008_vm1p_led[idx].gpio_num;
+            *active_high = wg1008_vm1p_led[idx].active_high;
+            break;
+        }
+    }
+
+    if(idx == ledLen)
+    {
+        printf("Invalid LED name %s!!!\n", ledName);
+        printf("Supported LED names: ");
+        for(idx =0; idx < ledLen; idx++)
+        {
+            printf("%s ", wg1008_vm1p_led[idx].led_name);
+        }
+        printf("\n");
+        return -1;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+
+int setGpioLedAllOnOff(u32 mode)
+{
+    int ledLen = 0, idx =0;
+    u32 gpioNum = 0, active_high = 0, gpio_bus = 0, gpio_shift = 0, val = 0;
+
+    ledLen = sizeof(wg1008_vm1p_led)/sizeof(wg1008_vm1p_led[0]);
+    for(idx = 0; idx < ledLen; idx++)
+    {
+        gpioNum = wg1008_vm1p_led[idx].gpio_num;
+        active_high = wg1008_vm1p_led[idx].active_high;
+        if(mode == GPIO_LED_MODE_ON)
+        {
+            val = active_high?1:0;
+        }
+        else if(mode == GPIO_LED_MODE_OFF)
+        {
+            val = active_high?0:1;
+        }
+        else if(mode == GPIO_LED_MODE_NORMAL)
+        {
+            if(!strncmp("Power", wg1008_vm1p_led[idx].led_name, strlen("Power")))
+            {
+                val = active_high?1:0;
+            }
+            else
+            {
+                val = active_high?0:1;
+            }
+        }
+        else
+        {
+            break;
+        }
+        gpio_bus = wg1008_vm1p_gpio[gpioNum].gpio_bus;
+        gpio_shift = wg1008_vm1p_gpio[gpioNum].gpio_shift;
+        gpioWrite(gpio_bus, gpio_shift, GPIO_TYPE_DATA, val);
+    }
+
+    if(mode == GPIO_LED_MODE_ON)
+    {
+        switch_mv88e6190_port_led(PORT_LED_MODE_GREEN);
+        udelay(1000000);
+        switch_mv88e6190_port_led(PORT_LED_MODE_AMBER);
+        udelay(1000000);
+        switch_mv88e6190_port_led(PORT_LED_MODE_OFF);
+        udelay(1000000);
+        switch_mv88e6190_port_led(PORT_LED_MODE_ALLON);
+    }
+    else if(mode == GPIO_LED_MODE_OFF)
+    {
+        switch_mv88e6190_port_led(PORT_LED_MODE_OFF);
+    }
+    else if(mode == GPIO_LED_MODE_NORMAL)
+    {
+        switch_mv88e6190_port_led(PORT_LED_MODE_NORMAL);
+    }
+    else
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+int resetBtnPressed(void)
+{
+    u32 val = 0, gpioBus = 0, gpioShift = 0, gpioNum = 0, activeHigh = 0;
+
+    gpioBus = GPIO_BUS_RESET_IN;
+    gpioShift = GPIO_SHIFT_RESET_IN;
+    if(gpioRead(gpioBus, gpioShift, GPIO_TYPE_DATA, &val))
+    {
+        return 0;
+    }
+
+    if(getGpioNumByLedName("Status", &gpioNum, &activeHigh))
+    {
+        return -1;
+    }
+
+    gpioBus = wg1008_vm1p_gpio[gpioNum].gpio_bus;
+    gpioShift = wg1008_vm1p_gpio[gpioNum].gpio_shift;
+
+    if(!val) /* Pressed and light on Status LED */
+    {
+        gpioWrite(gpioBus, gpioShift, GPIO_TYPE_DATA, activeHigh?1:0);
+    }
+ 
+    return val?0:1; /* Active Low */
+}
+
+int wg1008_vm1p_gpio_init(void)
+{
+    int idx = 0, len = 0;
+    volatile u32 *gpio_dir_reg = NULL, *gpio_data_reg = NULL;
+    u32 gpio_bus = 0,default_val = 0, gpio_dir = 0, gpio_shift = 0;
+    int ret = 0;
+
+    printf("\nInitializing GPIO...");
+    len = sizeof(wg1008_vm1p_gpio)/sizeof(wg1008_vm1p_gpio[0]);
+
+    for(idx = 0; idx < len; idx++)
+    {
+        gpio_bus = wg1008_vm1p_gpio[idx].gpio_bus;
+        gpio_shift = wg1008_vm1p_gpio[idx].gpio_shift;
+        gpio_dir = wg1008_vm1p_gpio[idx].gpio_dir;
+        default_val = wg1008_vm1p_gpio[idx].gpio_default_val;
+#ifdef DBG_GPIO
+        printf("Initializing GPIO%u_%02u, direction : %s, default value : %u...", gpio_bus, gpio_shift, gpio_dir?"out":"in", default_val);
+#endif
+
+        ret = gpioWrite(gpio_bus, gpio_shift, GPIO_TYPE_DATA, default_val);
+        if(ret)
+        {
+            printf("\nFailed to set default value : %u!!!\n", default_val);
+            continue;
+        }
+        ret = gpioWrite(gpio_bus, gpio_shift, GPIO_TYPE_DIR, gpio_dir);
+        if(ret)
+        {
+            printf("\nFailed to set direction : %s!!!\n", gpio_dir?"out":"in");
+            continue;
+        }
+#ifdef DBG_GPIO
+        printf("done\n");
+#endif
+    }
+    printf("done\n");
+
+    return ret;
+}
+#endif
+
+#ifndef CONFIG_SPL_BUILD
+int checkboard(void)
+{
+	static const char *freq[2] = {"100.00MHZ", "156.25MHZ"};
+	u8 cfg_rcw_src1, cfg_rcw_src2;
+	u16 cfg_rcw_src;
+	u8 sd1refclk_sel;
+
+	puts("Board: LS1046ARDB, boot from ");
+
+	cfg_rcw_src1 = CPLD_READ(cfg_rcw_src1);
+	cfg_rcw_src2 = CPLD_READ(cfg_rcw_src2);
+	cpld_rev_bit(&cfg_rcw_src1);
+	cfg_rcw_src = cfg_rcw_src1;
+	cfg_rcw_src = (cfg_rcw_src << 1) | cfg_rcw_src2;
+
+	if (cfg_rcw_src == 0x44)
+		printf("QSPI vBank %d\n", CPLD_READ(vbank));
+	else if (cfg_rcw_src == 0x40)
+		puts("SD\n");
+#ifndef CONFIG_WG1008_VM1P
+	else
+		puts("Invalid setting of SW5\n");
+#endif
+
+	printf("CPLD:  V%x.%x\nPCBA:  V%x.0\n", CPLD_READ(cpld_ver),
+	       CPLD_READ(cpld_ver_sub), CPLD_READ(pcba_ver));
+
+	puts("SERDES Reference Clocks:\n");
+
+#ifdef CONFIG_WG1008_VM1P
+	sd1refclk_sel = 0;
+	printf("SD1_CLK1 = %s, SD1_CLK2 = %s\n", freq[sd1refclk_sel], freq[sd1refclk_sel^1]);
+#else
+	sd1refclk_sel = CPLD_READ(sd1refclk_sel);
+	printf("SD1_CLK1 = %s, SD1_CLK2 = %s\n", freq[sd1refclk_sel], freq[0]);
+#endif
+
+
+	return 0;
+}
+
+int board_init(void)
+{
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+
+#ifdef CONFIG_SECURE_BOOT
+	/*
+	 * In case of Secure Boot, the IBR configures the SMMU
+	 * to allow only Secure transactions.
+	 * SMMU must be reset in bypass mode.
+	 * Set the ClientPD bit and Clear the USFCFG Bit
+	 */
+	u32 val;
+	val = (in_le32(SMMU_SCR0) | SCR0_CLIENTPD_MASK) & ~(SCR0_USFCFG_MASK);
+	out_le32(SMMU_SCR0, val);
+	val = (in_le32(SMMU_NSCR0) | SCR0_CLIENTPD_MASK) & ~(SCR0_USFCFG_MASK);
+	out_le32(SMMU_NSCR0, val);
+#endif
+
+#ifdef CONFIG_FSL_CAAM
+	sec_init();
+#endif
+
+#ifdef CONFIG_FSL_LS_PPA
+	ppa_init();
+#endif
+
+	/* invert AQR105 IRQ pins polarity */
+	out_be32(&scfg->intpcr, AQR105_IRQ_MASK);
+
+	return 0;
+}
+
+int board_setup_core_volt(u32 vdd)
+{
+	bool en_0v9;
+
+	en_0v9 = (vdd == 900) ? true : false;
+	cpld_select_core_volt(en_0v9);
+
+	return 0;
+}
+
+int get_serdes_volt(void)
+{
+	return mc34vr500_get_sw_volt(SW4);
+}
+
+int set_serdes_volt(int svdd)
+{
+	return mc34vr500_set_sw_volt(SW4, svdd);
+}
+
+int power_init_board(void)
+{
+	int ret;
+
+#ifndef CONFIG_WG1008_VM1P /* NOT need. Chip volt are set by HW, Forest Tsao */
+	ret = power_mc34vr500_init(0);
+	if (ret)
+		return ret;
+
+	setup_chip_volt();
+#endif /* ifdef CONFIG_WG1008_VM1P */
+
+	return 0;
+}
+
+void config_board_mux(void)
+{
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+	u32 usb_pwrfault;
+
+	/* USB3 is not used, configure mux to IIC4_SCL/IIC4_SDA */
+	out_be32(&scfg->rcwpmuxcr0, 0x3300);
+	out_be32(&scfg->usbdrvvbus_selcr, SCFG_USBDRVVBUS_SELCR_USB1);
+	usb_pwrfault = (SCFG_USBPWRFAULT_DEDICATED <<
+			SCFG_USBPWRFAULT_USB3_SHIFT) |
+			(SCFG_USBPWRFAULT_DEDICATED <<
+			SCFG_USBPWRFAULT_USB2_SHIFT) |
+			(SCFG_USBPWRFAULT_SHARED <<
+			SCFG_USBPWRFAULT_USB1_SHIFT);
+	out_be32(&scfg->usbpwrfault_selcr, usb_pwrfault);
+#endif
+}
+
+#ifdef CONFIG_MISC_INIT_R
+int misc_init_r(void)
+{
+	config_board_mux();
+#ifdef CONFIG_WG1008_VM1P /* NOT need. Chip volt are set by HW, Forest Tsao */
+	env_save(); /* Save env */
+#endif
+    return 0;
+}
+#endif
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	u64 base[CONFIG_NR_DRAM_BANKS];
+	u64 size[CONFIG_NR_DRAM_BANKS];
+
+	/* fixup DT for the two DDR banks */
+	base[0] = gd->bd->bi_dram[0].start;
+	size[0] = gd->bd->bi_dram[0].size;
+	base[1] = gd->bd->bi_dram[1].start;
+	size[1] = gd->bd->bi_dram[1].size;
+
+	fdt_fixup_memory_banks(blob, base, size, 2);
+	ft_cpu_setup(blob, bd);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+#endif
+
+	fdt_fixup_icid(blob);
+
+	return 0;
+}
+#endif
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_rcw_emmc.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_rcw_emmc.cfg	2022-05-09 14:11:36.032490993 -0700
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# RCW
+0c150012 0e000000 00000000 00000000
+11335559 40000012 60040000 c1000000
+00000000 00000000 00000000 00238800
+20124000 00003000 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/Kconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/Kconfig	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,39 @@
+if TARGET_LS1046ARDB_WG_T80
+
+config WG1008_VM1P
+    default 1
+
+config SYS_BOARD
+	default "ls1046ardb_t80"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls1046ardb_t80"
+
+if FSL_LS_PPA
+#Albert.Ke.B
+#config SYS_LS_PPA_FW_ADDR
+#	hex "PPA Firmware Addr"
+#	default 0x40400000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+#	default 0x400000 if SYS_LS_PPA_FW_IN_MMC || SYS_LS_PPA_FW_IN_NAND
+config SYS_LS_PPA_FW_ADDR
+	hex "PPA Firmware Addr"
+	default 0x40240000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x240000 if SYS_LS_PPA_FW_IN_MMC || SYS_LS_PPA_FW_IN_NAND
+#Albert.Ke.E
+
+if CHAIN_OF_TRUST
+config SYS_LS_PPA_ESBC_ADDR
+	hex "PPA Firmware HDR Addr"
+	default 0x40680000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x680000 if SYS_LS_PPA_FW_IN_MMC || SYS_LS_PPA_FW_IN_NAND
+endif
+endif
+
+source "board/freescale/common/Kconfig"
+endif
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/Makefile	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright 2016 Freescale Semiconductor
+
+obj-y += ddr.o
+obj-y += ls1046ardb.o
+ifndef CONFIG_SPL_BUILD
+obj-$(CONFIG_NET) += eth.o
+obj-y += cpld.o
+endif
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ddr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ddr.h	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,146 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+
+void erratum_a008850_post(void);
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 8,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 8,     7, 0x08090A0C, 0x0D0F100B,},
+	{2,  1900, 0, 8,     7, 0x09090B0D, 0x0E10120B,},
+	{2,  2300, 0, 8,     9, 0x0A0B0C10, 0x1213140E,},
+#ifdef CONFIG_WG1008_VM1P
+/*Albert.Ke.B*/
+/*
+    {1,  1350, 0, 8,     6, 0x0708090B, 0x0C0D0E09,},
+    {1,  1666, 0, 8,     7, 0x08090A0C, 0x0D0F100B,},
+    {1,  1900, 0, 8,     7, 0x09090B0D, 0x0E10120B,},
+    {1,  2300, 0, 8,     9, 0x0A0B0C10, 0x1213140E,},
+*/
+    {1,  1350, 0, 9,     6, 0x06070709, 0x090A0A0C,},
+    {1,  1666, 0, 9,     6, 0x06070709, 0x090A0A0C,},
+    {1,  1900, 0, 9,     6, 0x06070709, 0x090A0A0C,},
+    {1,  2300, 0, 9,     6, 0x06070709, 0x090A0A0C,},
+/*Albert.Ke.E*/
+#endif /* ifdef CONFIG_WG1008_VM1P */
+    {}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+static const struct board_specific_parameters rdimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1666, 0, 0x8,     0x0D, 0x0C0B0A08, 0x0A0B0C08,},
+	{2,  1900, 0, 0x8,     0x0E, 0x0D0C0B09, 0x0B0C0D09,},
+	{2,  2300, 0, 0xa,     0x12, 0x100F0D0C, 0x0E0F100C,},
+	{1,  1666, 0, 0x8,     0x0D, 0x0C0B0A08, 0x0A0B0C08,},
+	{1,  1900, 0, 0x8,     0x0E, 0x0D0C0B09, 0x0B0C0D09,},
+	{1,  2300, 0, 0xa,     0x12, 0x100F0D0C, 0x0E0F100C,},
+	{}
+};
+
+static const struct board_specific_parameters *rdimms[] = {
+	rdimm0,
+};
+
+/*Albert.Ke.B*/
+#ifdef CONFIG_WG1008_VM1P
+fsl_ddr_cfg_regs_t ddr_cfg_regs_1600 = {
+	.cs[0].bnds = 0x0000007F,
+	.cs[1].bnds = 0,
+	.cs[2].bnds = 0,
+	.cs[3].bnds = 0,
+	.cs[0].config = 0x80040322,
+	.cs[0].config_2 = 0,
+	.cs[1].config = 0,
+	.cs[1].config_2 = 0,
+	.cs[2].config = 0,
+	.cs[3].config = 0,
+	.timing_cfg_3 = 0x010C1000,
+	.timing_cfg_0 = 0x91550018,
+	.timing_cfg_1 = 0xBBB48C42,
+	.timing_cfg_2 = 0x0048C111,
+	.ddr_sdram_cfg = 0xC50C0008,
+	.ddr_sdram_cfg_2 = 0x00401100,
+	.ddr_sdram_cfg_3 = 0,
+	.ddr_sdram_mode = 0x03010210,
+	.ddr_sdram_mode_2 = 0,
+	.ddr_sdram_mode_3 = 0x00010210,
+	.ddr_sdram_mode_4 = 0,
+	.ddr_sdram_mode_5 = 0x00010210,
+	.ddr_sdram_mode_6 = 0,
+	.ddr_sdram_mode_7 = 0x00010210,
+	.ddr_sdram_mode_8 = 0,
+	.ddr_sdram_mode_9 = 0x00000500,
+	.ddr_sdram_mode_10 = 0x04000000,
+	.ddr_sdram_mode_11 = 0x00000400,
+	.ddr_sdram_mode_12 = 0x04000000,
+	.ddr_sdram_mode_13 = 0x00000400,
+	.ddr_sdram_mode_14 = 0x04000000,
+	.ddr_sdram_mode_15 = 0x00000400,
+	.ddr_sdram_mode_16 = 0x04000000,
+	.ddr_sdram_interval = 0x18600618,
+	.ddr_data_init = 0xDEADBEEF,
+	.ddr_sdram_clk_cntl = 0x03000000,
+	.ddr_init_addr = 0,
+	.ddr_init_ext_addr = 0,
+	.timing_cfg_4 = 0x00000002,
+	.timing_cfg_5 = 0x03401400,
+	.timing_cfg_6 = 0,
+	.timing_cfg_7 = 0x13300000,
+	.timing_cfg_8 = 0x02115600,
+	.timing_cfg_9 = 0,
+	.ddr_zq_cntl = 0x8A090705,
+	.ddr_wrlvl_cntl = 0x8675F607,
+	.ddr_wrlvl_cntl_2 = 0x07090800,
+	.ddr_wrlvl_cntl_3 = 0,
+	.ddr_sr_cntr = 0,
+	.ddr_sdram_rcw_1 = 0,
+	.ddr_sdram_rcw_2 = 0,
+	.ddr_cdr1 = 0x80040000,
+	.ddr_cdr2 = 0x0000A181,
+	.dq_map_0 = 0,
+	.dq_map_1 = 0,
+	.dq_map_2 = 0,
+	.dq_map_3 = 0,
+	.debug[28] = 0x00700046,
+
+};
+
+fixed_ddr_parm_t fixed_ddr_parm_0[] = {
+	{1550, 1650, &ddr_cfg_regs_1600},
+	{0, 0, NULL}
+};
+#endif
+/*Albert.Ke.E*/
+#endif
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_rcw_sd.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_rcw_sd.cfg	2022-05-09 14:11:36.032490993 -0700
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# RCW
+0c150012 0e000000 00000000 00000000
+11335559 40005012 60040000 c1000000
+00000000 00000000 00000000 00238800
+20124000 00003101 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_rcw_qspi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_rcw_qspi.cfg	2022-05-09 14:11:36.032490993 -0700
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# RCW
+0c150010 0e000000 00000000 00000000
+11335559 40005012 40025000 c1000000
+00000000 00000000 00000000 00238800
+20124000 00003101 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_qspi_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/ls1046ardb_qspi_pbi.cfg	2022-05-09 14:11:36.032490993 -0700
@@ -0,0 +1,26 @@
+#QSPI clk
+0957015c 40100000
+#Configure Scratch register
+09570600 00000000
+09570604 10000000
+#Disable CCI barrier tranaction
+09570178 0000e010
+09180000 00000008
+#USB PHY frequency sel
+09570418 0000009e
+0957041c 0000009e
+09570420 0000009e
+#Serdes SATA
+09eb1300 80104e20
+09eb08dc 00502880
+#PEX gen3 link
+09570158 00000300
+89400890 01048000
+89500890 01048000
+89600890 01048000
+#Alt base register
+09570158 00001000
+#flush PBI data
+096100c0 000fffff
+#Change endianness
+09550000 000f400c
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/cpld.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/cpld.c	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,166 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016 Freescale Semiconductor
+ *
+ * Freescale LS1046ARDB board-specific CPLD controlling supports.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include "cpld.h"
+
+u8 cpld_read(unsigned int reg)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	return in_8(p + reg);
+}
+
+void cpld_write(unsigned int reg, u8 value)
+{
+	void *p = (void *)CONFIG_SYS_CPLD_BASE;
+
+	out_8(p + reg, value);
+}
+
+/* Set the boot bank to the alternate bank */
+void cpld_set_altbank(void)
+{
+	u16 reg = CPLD_CFG_RCW_SRC_QSPI;
+	u8 reg4 = CPLD_READ(soft_mux_on);
+	u8 reg5 = (u8)(reg >> 1);
+	u8 reg6 = (u8)(reg & 1);
+	u8 reg7 = CPLD_READ(vbank);
+
+	cpld_rev_bit(&reg5);
+
+	CPLD_WRITE(soft_mux_on, reg4 | CPLD_SW_MUX_BANK_SEL | 1);
+
+	CPLD_WRITE(cfg_rcw_src1, reg5);
+	CPLD_WRITE(cfg_rcw_src2, reg6);
+
+	reg7 = (reg7 & ~CPLD_BANK_SEL_MASK) | CPLD_BANK_SEL_ALTBANK;
+	CPLD_WRITE(vbank, reg7);
+
+	CPLD_WRITE(system_rst, 1);
+}
+
+/* Set the boot bank to the default bank */
+void cpld_set_defbank(void)
+{
+	u16 reg = CPLD_CFG_RCW_SRC_QSPI;
+	u8 reg4 = CPLD_READ(soft_mux_on);
+	u8 reg5 = (u8)(reg >> 1);
+	u8 reg6 = (u8)(reg & 1);
+
+	cpld_rev_bit(&reg5);
+
+	CPLD_WRITE(soft_mux_on, reg4 | CPLD_SW_MUX_BANK_SEL | 1);
+
+	CPLD_WRITE(cfg_rcw_src1, reg5);
+	CPLD_WRITE(cfg_rcw_src2, reg6);
+
+	CPLD_WRITE(vbank, 0);
+
+	CPLD_WRITE(system_rst, 1);
+}
+
+void cpld_set_sd(void)
+{
+	u16 reg = CPLD_CFG_RCW_SRC_SD;
+	u8 reg5 = (u8)(reg >> 1);
+	u8 reg6 = (u8)(reg & 1);
+
+	cpld_rev_bit(&reg5);
+
+	CPLD_WRITE(soft_mux_on, 1);
+
+	CPLD_WRITE(cfg_rcw_src1, reg5);
+	CPLD_WRITE(cfg_rcw_src2, reg6);
+
+	CPLD_WRITE(system_rst, 1);
+}
+
+void cpld_select_core_volt(bool en_0v9)
+{
+	u8 reg17 = en_0v9;
+
+	CPLD_WRITE(vdd_en, 1);
+	CPLD_WRITE(vdd_sel, reg17);
+}
+
+#ifdef DEBUG
+static void cpld_dump_regs(void)
+{
+	printf("cpld_ver	= %x\n", CPLD_READ(cpld_ver));
+	printf("cpld_ver_sub	= %x\n", CPLD_READ(cpld_ver_sub));
+	printf("pcba_ver	= %x\n", CPLD_READ(pcba_ver));
+	printf("soft_mux_on	= %x\n", CPLD_READ(soft_mux_on));
+	printf("cfg_rcw_src1	= %x\n", CPLD_READ(cfg_rcw_src1));
+	printf("cfg_rcw_src2	= %x\n", CPLD_READ(cfg_rcw_src2));
+	printf("vbank		= %x\n", CPLD_READ(vbank));
+	printf("sysclk_sel	= %x\n", CPLD_READ(sysclk_sel));
+	printf("uart_sel	= %x\n", CPLD_READ(uart_sel));
+	printf("sd1refclk_sel	= %x\n", CPLD_READ(sd1refclk_sel));
+	printf("rgmii_1588_sel	= %x\n", CPLD_READ(rgmii_1588_sel));
+	printf("1588_clk_sel	= %x\n", CPLD_READ(reg_1588_clk_sel));
+	printf("status_led	= %x\n", CPLD_READ(status_led));
+	printf("sd_emmc		= %x\n", CPLD_READ(sd_emmc));
+	printf("vdd_en		= %x\n", CPLD_READ(vdd_en));
+	printf("vdd_sel		= %x\n", CPLD_READ(vdd_sel));
+	putc('\n');
+}
+#endif
+
+void cpld_rev_bit(unsigned char *value)
+{
+	u8 rev_val, val;
+	int i;
+
+	val = *value;
+	rev_val = val & 1;
+	for (i = 1; i <= 7; i++) {
+		val >>= 1;
+		rev_val <<= 1;
+		rev_val |= val & 1;
+	}
+
+	*value = rev_val;
+}
+
+int do_cpld(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int rc = 0;
+
+	if (argc <= 1)
+		return cmd_usage(cmdtp);
+
+	if (strcmp(argv[1], "reset") == 0) {
+		if (strcmp(argv[2], "altbank") == 0)
+			cpld_set_altbank();
+		else if (strcmp(argv[2], "sd") == 0)
+			cpld_set_sd();
+		else
+			cpld_set_defbank();
+#ifdef DEBUG
+	} else if (strcmp(argv[1], "dump") == 0) {
+		cpld_dump_regs();
+#endif
+	} else {
+		rc = cmd_usage(cmdtp);
+	}
+
+	return rc;
+}
+
+U_BOOT_CMD(
+	cpld, CONFIG_SYS_MAXARGS, 1, do_cpld,
+	"Reset the board or alternate bank",
+	"reset: reset to default bank\n"
+	"cpld reset altbank: reset to alternate bank\n"
+	"cpld reset sd: reset to boot from SD card\n"
+#ifdef DEBUG
+	"cpld dump - display the CPLD registers\n"
+#endif
+);
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/README	2022-05-09 14:11:35.960493908 -0700
@@ -0,0 +1,76 @@
+Overview
+--------
+The LS1046A Reference Design Board (RDB) is a high-performance computing,
+evaluation, and development platform that supports the QorIQ LS1046A
+LayerScape Architecture processor. The LS1046ARDB provides SW development
+platform for the Freescale LS1046A processor series, with a complete
+debugging environment. The LS1046A RDB is lead-free and RoHS-compliant.
+
+LS1046A SoC Overview
+--------------------
+Please refer arch/arm/cpu/armv8/fsl-layerscape/doc/README.soc for LS1046A
+SoC overview.
+
+ LS1046ARDB board Overview
+ -----------------------
+ - SERDES1 Connections, 4 lanes supporting:
+      - Lane0: XFI with x1 RJ45 connector
+      - Lane1: XFI Cage
+      - Lane2: SGMII.5
+      - Lane3: SGMII.6
+ - SERDES2 Connections, 4 lanes supporting:
+      - Lane0: PCIe1 with miniPCIe slot
+      - Lane1: PCIe2 with PCIe x2 slot
+      - Lane2: PCIe3 with PCIe x4 slot
+      - Lane3: SATA
+ - DDR Controller
+     - 8GB 64bits DDR4 SDRAM. Support rates of up to 2133MT/s
+ -IFC/Local Bus
+    - One 512 MB NAND flash with ECC support
+    - CPLD connection
+ - USB 3.0
+    - one Type A port, one Micro-AB port
+ - SDHC: connects directly to a full SD/MMC slot
+ - DSPI: 64 MB high-speed flash Memory for boot code and storage (up to 108MHz)
+ - 4 I2C controllers
+ - UART
+   - Two 4-pin serial ports at up to 115.2 Kbit/s
+   - Two DB9 D-Type connectors supporting one Serial port each
+ - ARM JTAG support
+
+Memory map from core's view
+----------------------------
+Start Address	 End Address	 Description		Size
+0x00_0000_0000 - 0x00_000F_FFFF  Secure Boot ROM	1MB
+0x00_0100_0000 - 0x00_0FFF_FFFF  CCSRBAR		240MB
+0x00_1000_0000 - 0x00_1000_FFFF  OCRAM0 		64KB
+0x00_1001_0000 - 0x00_1001_FFFF  OCRAM1 		64KB
+0x00_2000_0000 - 0x00_20FF_FFFF  DCSR			16MB
+0x00_7E80_0000 - 0x00_7E80_FFFF  IFC - NAND Flash	64KB
+0x00_7FB0_0000 - 0x00_7FB0_0FFF  IFC - CPLD		4KB
+0x00_8000_0000 - 0x00_FFFF_FFFF  DRAM1			2GB
+0x05_0000_0000 - 0x05_07FF_FFFF  QMAN S/W Portal	128M
+0x05_0800_0000 - 0x05_0FFF_FFFF  BMAN S/W Portal	128M
+0x08_8000_0000 - 0x09_FFFF_FFFF  DRAM2			6GB
+0x40_0000_0000 - 0x47_FFFF_FFFF  PCI Express1		32G
+0x48_0000_0000 - 0x4F_FFFF_FFFF  PCI Express2		32G
+0x50_0000_0000 - 0x57_FFFF_FFFF  PCI Express3		32G
+
+QSPI flash map:
+Start Address    End Address     Description		Size
+0x00_4000_0000 - 0x00_400F_FFFF  RCW + PBI		1MB
+0x00_4010_0000 - 0x00_402F_FFFF  U-Boot 		2MB
+0x00_4030_0000 - 0x00_403F_FFFF  U-Boot Env		1MB
+0x00_4040_0000 - 0x00_405F_FFFF  PPA			2MB
+0x00_4060_0000 - 0x00_408F_FFFF  Secure boot header
+				 + bootscript		3MB
+0x00_4090_0000 - 0x00_4093_FFFF  FMan ucode		256KB
+0x00_4094_0000 - 0x00_4097_FFFF  QE/uQE firmware	256KB
+0x00_4098_0000 - 0x00_40FF_FFFF  Reserved		6MB
+0x00_4100_0000 - 0x00_43FF_FFFF  FIT Image		48MB
+
+Booting Options
+---------------
+a) QSPI boot
+b) SD boot
+c) eMMC boot
--- u-boot-2018.09/board/freescale/ls1046ardb_t80/eth.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1046ardb_t80/eth.c	2022-05-09 14:11:35.968493584 -0700
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2016 Freescale Semiconductor, Inc.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <netdev.h>
+#include <fm_eth.h>
+#include <fsl_dtsec.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+
+#include "../common/fman.h"
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	int i;
+	struct memac_mdio_info dtsec_mdio_info;
+	struct memac_mdio_info tgec_mdio_info;
+	struct mii_dev *dev;
+	u32 srds_s1;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+
+	srds_s1 = in_be32(&gur->rcwsr[4]) &
+			FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	dtsec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the 1G MDIO bus */
+	fm_memac_mdio_init(bis, &dtsec_mdio_info);
+
+	tgec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tgec_mdio_info);
+
+#ifndef CONFIG_WG1008_VM1P
+	/* Set the two on-board RGMII PHY address */
+	fm_info_set_phy_address(FM1_DTSEC3, RGMII_PHY1_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC4, RGMII_PHY2_ADDR);
+
+	/* Set the two on-board SGMII PHY address */
+	fm_info_set_phy_address(FM1_DTSEC5, SGMII_PHY1_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC6, SGMII_PHY2_ADDR);
+#endif
+
+	/* Set the two on-board SGMII PHY address */
+#ifdef CONFIG_WG1008_VM1P
+	fm_info_set_phy_address(FM1_DTSEC9, SGMII_PHY1_ADDR);
+	fm_info_set_phy_address(FM1_DTSEC10, SGMII_PHY2_ADDR);
+#endif
+
+#ifndef CONFIG_WG1008_VM1P
+	/* Set the on-board AQ PHY address */
+	fm_info_set_phy_address(FM1_10GEC1, FM1_10GEC1_PHY_ADDR);
+#endif
+
+	switch (srds_s1) {
+#ifdef CONFIG_WG1008_VM1P
+	case 0x2233:
+#else
+	case 0x1133:
+#endif
+		break;
+	default:
+		printf("Invalid SerDes protocol 0x%x for LS1046ARDB\n",
+		       srds_s1);
+		break;
+	}
+
+	dev = miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME);
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++)
+		fm_info_set_mdio(i, dev);
+
+	/* XFI on lane A, MAC 9 */
+#ifdef CONFIG_WG1008_VM1P
+	dev = miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME);
+	fm_info_set_mdio(FM1_DTSEC9, dev);
+	fm_info_set_mdio(FM1_DTSEC10, dev);
+#else
+	dev = miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME);
+	fm_info_set_mdio(FM1_10GEC1, dev);
+#endif
+	cpu_eth_init(bis);
+#endif
+
+#ifdef CONFIG_WG1008_VM1P /* Forest Tsao B */
+    marvell_nxp_sgmii_init();
+#endif /* Forest Tsao E */
+
+	return pci_eth_init(bis);
+}
+
+#ifdef CONFIG_FMAN_ENET
+int fdt_update_ethernet_dt(void *blob)
+{
+	u32 srds_s1;
+	int i, prop;
+	int offset, nodeoff;
+	const char *path;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+
+	srds_s1 = in_be32(&gur->rcwsr[4]) &
+			FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	/* Cycle through all aliases */
+	for (prop = 0; ; prop++) {
+		const char *name;
+
+		/* FDT might have been edited, recompute the offset */
+		offset = fdt_first_property_offset(blob,
+						   fdt_path_offset(blob,
+								   "/aliases")
+						   );
+		/* Select property number 'prop' */
+		for (i = 0; i < prop; i++)
+			offset = fdt_next_property_offset(blob, offset);
+
+		if (offset < 0)
+			break;
+
+		path = fdt_getprop_by_offset(blob, offset, &name, NULL);
+		nodeoff = fdt_path_offset(blob, path);
+
+		switch (srds_s1) {
+#ifdef CONFIG_WG1008_VM1P
+        case 0x2233:
+#else
+        case 0x1133:
+#endif
+			if (!strcmp(name, "ethernet0"))
+				fdt_status_disabled(blob, nodeoff);
+
+			if (!strcmp(name, "ethernet1"))
+				fdt_status_disabled(blob, nodeoff);
+		break;
+		default:
+			printf("%s: Invalid SerDes prtcl 0x%x for LS1046ARDB\n",
+			       __func__, srds_s1);
+		break;
+		}
+	}
+
+	return 0;
+}
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ddr.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ddr.h	2022-05-09 14:11:35.876497308 -0700
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+
+extern void erratum_a008850_post(void);
+
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+	u32 cpo_override;
+	u32 write_data_delay;
+	u32 force_2t;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl | cpo  |wrdata|2T
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3  |      |delay |
+	 */
+#ifdef CONFIG_SYS_FSL_DDR4
+	{2,  1666, 0,  8,     7, 0x0808090B, 0x0C0D0E0A,},
+	{2,  1900, 0,  8,     6, 0x08080A0C, 0x0D0E0F0A,},
+	{1,  1666, 0, 10,     7, 0x05080800, 0x00000000,},
+	{1,  1600, 0, 10,     7, 0x05080800, 0x00000000,},
+	{1,  1900, 0,  8,     9, 0x0A0B0C0B, 0x0D0E0F0D,},
+	{1,  2200, 0,  8,    10, 0x0B0C0D0C, 0x0E0F110E,},
+#elif defined(CONFIG_SYS_FSL_DDR3)
+	{1,  833,  1, 12,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{1,  1350, 1, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{1,  833,  2, 12,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{1,  1350, 2, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  833,  4, 12,     8, 0x06060607, 0x08080807,   0x1f,    2,  0},
+	{2,  1350, 4, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  1350, 0, 12,     8, 0x0708080A, 0x0A0B0C09,   0x1f,    2,  0},
+	{2,  1666, 4,  8,   0xa, 0x0B08090C, 0x0B0E0D0A,   0x1f,    2,  0},
+	{2,  1666, 0,  8,   0xa, 0x0B08090C, 0x0B0E0D0A,   0x1f,    2,  0},
+#else
+#error DDR type not defined
+#endif
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/sn74lv164a.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/sn74lv164a.c	2022-05-09 14:11:35.900496336 -0700
@@ -0,0 +1,102 @@
+#include <common.h>
+#include "sn74lv164a.h"
+
+#define SN74LV164A_CLR(v)	{ \
+	gpio_direction_output(SN74LV164A_CLR_GPIO, v); \
+}
+
+#define SN74LV164A_CLK(v)	{ \
+	gpio_direction_output(SN74LV164A_CLK_GPIO, v); \
+}
+
+#define SN74LV164A_INA(v)	{ \
+	gpio_direction_output(SN74LV164A_INA_GPIO, v); \
+}
+
+int SN74LV164A_OUT_VAL[SN74LV164A_OUT_NUM] = { SN74LV164A_OUT_LOW };
+
+void sn74lv164a_set(void) {
+	for(int i = 0; i < SN74LV164A_OUT_NUM; i++) {
+		SN74LV164A_INA(SN74LV164A_OUT_VAL[(SN74LV164A_OUT_NUM-(i+1))]);
+		SN74LV164A_CLK(1);
+		SN74LV164A_CLK(0);
+	}
+}
+
+void sn74lv164a_clear(void)
+{
+	SN74LV164A_CLR(1); \
+	SN74LV164A_CLR(0); \
+	SN74LV164A_CLR(1); \
+}
+
+void sn74lv164a_set_value(int pin, int val)
+{
+	SN74LV164A_OUT_VAL[pin] = val;
+	sn74lv164a_set();
+}
+
+void sn74lv164a_set_value_all_high(void)
+{
+	for(int i = 0; i < SN74LV164A_OUT_NUM; i++)
+		SN74LV164A_OUT_VAL[i] = SN74LV164A_OUT_HIGH;
+	sn74lv164a_set();
+}
+
+void sn74lv164a_set_value_all_low(void)
+{
+	for(int i = 0; i < SN74LV164A_OUT_NUM; i++)
+		SN74LV164A_OUT_VAL[i] = SN74LV164A_OUT_LOW;
+	sn74lv164a_set();
+}
+
+static int do_74lv164(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	int __maybe_unused pin, val;
+
+	if (argc == 2) {
+		if (!strcmp(argv[1], "clear")) {
+			sn74lv164a_clear();
+		} else if (!strcmp(argv[1], "high")) {
+			sn74lv164a_set_value_all_high();
+		} else if (!strcmp(argv[1], "low")) {
+			sn74lv164a_set_value_all_low();
+		} else {
+			return CMD_RET_USAGE;
+		}
+	} else if (argc == 3) {
+		if (!strcmp(argv[1], "qa")) {
+			pin = SN74LV164A_OUT_QA;
+		} else if (!strcmp(argv[1], "qb")) {
+			pin = SN74LV164A_OUT_QB;
+		} else if (!strcmp(argv[1], "qc")) {
+			pin = SN74LV164A_OUT_QC;
+		} else if (!strcmp(argv[1], "qd")) {
+			pin = SN74LV164A_OUT_QD;
+		} else if (!strcmp(argv[1], "qe")) {
+			pin = SN74LV164A_OUT_QE;
+		} else if (!strcmp(argv[1], "qf")) {
+			pin = SN74LV164A_OUT_QF;
+		} else if (!strcmp(argv[1], "qg")) {
+			pin = SN74LV164A_OUT_QG;
+		} else if (!strcmp(argv[1], "qh")) {
+			pin = SN74LV164A_OUT_QH;
+		} else {
+			return CMD_RET_USAGE;
+		}
+		val = simple_strtoul(argv[2], NULL, 10);
+		sn74lv164a_set_value(pin, val);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(74lv164, 3, 0, do_74lv164,
+	   "74lv164 control",
+	   "\n"
+	   "    clear/high/low\n"
+	   "    [<qa|qb|qc|qd|qe|qf|qg|qh>  <0|1>] \n"
+	   "\n"
+	   );
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/MAINTAINERS.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/MAINTAINERS	2022-05-09 14:11:35.860497956 -0700
@@ -0,0 +1,6 @@
+WatchGuard T20 build off the LS1043AQDS reference BOARD
+M:	Mukund Jampala <mukund.jampala@watchguard.com>
+S:	Maintained
+F:	board/freescale/ls1043aqds_t20/
+F:	include/configs/ls1043aqds_t20.h
+F:	configs/ls1043aqds_wg_t20_qspi_defconfig
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_rcw_sd_qspi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_rcw_sd_qspi.cfg	2022-05-09 14:11:35.900496336 -0700
@@ -0,0 +1,8 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# RCW
+# Enable QSPI; disable IFC
+08100010 0a000000 00000000 00000000
+14550002 80004012 60040000 c1002000
+00000000 00000000 00000000 00038800
+20124000 00001100 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_pbi.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_pbi.cfg	2022-05-09 14:11:35.896496499 -0700
@@ -0,0 +1,14 @@
+#Configure Scratch register
+09570600 00000000
+09570604 10000000
+#Alt base register
+09570158 00001000
+#Disable CCI barrier tranaction
+09570178 0000e010
+09180000 00000008
+#USB PHY frequency sel
+09570418 0000009e
+0957041c 0000009e
+09570420 0000009e
+#flush PBI data
+096100c0 000fffff
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/Makefile	2022-05-09 14:11:35.860497956 -0700
@@ -0,0 +1,14 @@
+#
+# Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += ddr.o
+obj-y += gpio.o
+obj-y += sn74lv164a.o
+obj-y += led.o
+ifndef CONFIG_SPL_BUILD
+obj-y += eth.o
+endif
+obj-y += ls1043aqds.o
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/eth.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/eth.c	2022-05-09 14:11:35.876497308 -0700
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <netdev.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <fsl_dtsec.h>
+#include <malloc.h>
+
+#include "../common/fman.h"
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	struct memac_mdio_info dtsec_mdio_info;
+	struct memac_mdio_info tgec_mdio_info;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	struct mii_dev *dev;
+	u32 srds_s1;
+
+	srds_s1 = in_be32(&gur->rcwsr[4]) &
+			FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	dtsec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+
+	dtsec_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the 1G MDIO bus */
+	fm_memac_mdio_init(bis, &dtsec_mdio_info);
+
+	tgec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tgec_mdio_info);
+
+	/* Set the on-board RGMII PHY address */
+	fm_info_set_phy_address(FM1_DTSEC3, RGMII_PHY1_ADDR);
+
+	switch (srds_s1) {
+	case 0x4558:
+		/* QSGMII on lane A, MAC 1/2/5/6 */
+		fm_info_set_phy_address(FM1_DTSEC1,
+					QSGMII_CARD_PORT1_PHY_ADDR_S1);
+		fm_info_set_phy_address(FM1_DTSEC2,
+					QSGMII_CARD_PORT2_PHY_ADDR_S1);
+		fm_info_set_phy_address(FM1_DTSEC5,
+					QSGMII_CARD_PORT3_PHY_ADDR_S1);
+		fm_info_set_phy_address(FM1_DTSEC6,
+					QSGMII_CARD_PORT4_PHY_ADDR_S1);
+		break;
+	default:
+		printf("Invalid SerDes protocol 0x%x for LS1043AQDS\n",
+		       srds_s1);
+		break;
+	}
+
+	dev = miiphy_get_dev_by_name(DEFAULT_FM_MDIO_NAME);
+	fm_info_set_mdio(FM1_DTSEC1, dev);
+	fm_info_set_mdio(FM1_DTSEC2, dev);
+	fm_info_set_mdio(FM1_DTSEC5, dev);
+	fm_info_set_mdio(FM1_DTSEC6, dev);
+
+	dev = miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME);
+	fm_info_set_mdio(FM1_DTSEC3, dev);
+
+	cpu_eth_init(bis);
+#endif /* CONFIG_FMAN_ENET */
+
+	return pci_eth_init(bis);
+}
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds.c	2022-05-09 14:11:35.896496499 -0700
@@ -0,0 +1,483 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <fdt_support.h>
+#include <fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/ppa.h>
+#include <asm/arch/fdt.h>
+#include <asm/arch/mmu.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+#include <asm/arch-fsl-layerscape/fsl_icid.h>
+#include <asm/gpio.h>
+#include <ahci.h>
+#include <hwconfig.h>
+#include <mmc.h>
+#include <scsi.h>
+#include <fm_eth.h>
+#include <fsl_esdhc.h>
+#include <fsl_ifc.h>
+#include <spl.h>
+
+#include "../common/qixis.h"
+#include "ls1043aqds_qixis.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+enum {
+	MUX_TYPE_GPIO,
+};
+
+/* LS1043AQDS serdes mux */
+#define CFG_SD_MUX1_SLOT2	0x0 /* SLOT2 TX/RX0 */
+#define CFG_SD_MUX1_SLOT1	0x1 /* SLOT1 TX/RX1 */
+#define CFG_SD_MUX2_SLOT3	0x0 /* SLOT3 TX/RX0 */
+#define CFG_SD_MUX2_SLOT1	0x1 /* SLOT1 TX/RX2 */
+#define CFG_SD_MUX3_SLOT4	0x0 /* SLOT4 TX/RX0 */
+#define CFG_SD_MUX3_MUX4	0x1 /* MUX4 */
+#define CFG_SD_MUX4_SLOT3	0x0 /* SLOT3 TX/RX1 */
+#define CFG_SD_MUX4_SLOT1	0x1 /* SLOT1 TX/RX3 */
+#define CFG_UART_MUX_MASK	0x6
+#define CFG_UART_MUX_SHIFT	1
+#define CFG_LPUART_EN		0x1
+
+#ifdef CONFIG_TFABOOT
+struct ifc_regs ifc_cfg_nor_boot[CONFIG_SYS_FSL_IFC_BANK_COUNT] = {
+	{
+		"nor0",
+		CONFIG_SYS_NOR0_CSPR,
+		CONFIG_SYS_NOR0_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+
+	},
+	{
+		"nor1",
+		CONFIG_SYS_NOR1_CSPR,
+		CONFIG_SYS_NOR1_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+	},
+	{
+		"nand",
+		CONFIG_SYS_NAND_CSPR,
+		CONFIG_SYS_NAND_CSPR_EXT,
+		CONFIG_SYS_NAND_AMASK,
+		CONFIG_SYS_NAND_CSOR,
+		{
+			CONFIG_SYS_NAND_FTIM0,
+			CONFIG_SYS_NAND_FTIM1,
+			CONFIG_SYS_NAND_FTIM2,
+			CONFIG_SYS_NAND_FTIM3
+		},
+	},
+	{
+		"fpga",
+		CONFIG_SYS_FPGA_CSPR,
+		CONFIG_SYS_FPGA_CSPR_EXT,
+		CONFIG_SYS_FPGA_AMASK,
+		CONFIG_SYS_FPGA_CSOR,
+		{
+			CONFIG_SYS_FPGA_FTIM0,
+			CONFIG_SYS_FPGA_FTIM1,
+			CONFIG_SYS_FPGA_FTIM2,
+			CONFIG_SYS_FPGA_FTIM3
+		},
+	}
+};
+
+struct ifc_regs ifc_cfg_nand_boot[CONFIG_SYS_FSL_IFC_BANK_COUNT] = {
+	{
+		"nand",
+		CONFIG_SYS_NAND_CSPR,
+		CONFIG_SYS_NAND_CSPR_EXT,
+		CONFIG_SYS_NAND_AMASK,
+		CONFIG_SYS_NAND_CSOR,
+		{
+			CONFIG_SYS_NAND_FTIM0,
+			CONFIG_SYS_NAND_FTIM1,
+			CONFIG_SYS_NAND_FTIM2,
+			CONFIG_SYS_NAND_FTIM3
+		},
+	},
+	{
+		"nor0",
+		CONFIG_SYS_NOR0_CSPR,
+		CONFIG_SYS_NOR0_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+	},
+	{
+		"nor1",
+		CONFIG_SYS_NOR1_CSPR,
+		CONFIG_SYS_NOR1_CSPR_EXT,
+		CONFIG_SYS_NOR_AMASK,
+		CONFIG_SYS_NOR_CSOR,
+		{
+			CONFIG_SYS_NOR_FTIM0,
+			CONFIG_SYS_NOR_FTIM1,
+			CONFIG_SYS_NOR_FTIM2,
+			CONFIG_SYS_NOR_FTIM3
+		},
+	},
+	{
+		"fpga",
+		CONFIG_SYS_FPGA_CSPR,
+		CONFIG_SYS_FPGA_CSPR_EXT,
+		CONFIG_SYS_FPGA_AMASK,
+		CONFIG_SYS_FPGA_CSOR,
+		{
+			CONFIG_SYS_FPGA_FTIM0,
+			CONFIG_SYS_FPGA_FTIM1,
+			CONFIG_SYS_FPGA_FTIM2,
+			CONFIG_SYS_FPGA_FTIM3
+		},
+	}
+};
+
+void ifc_cfg_boot_info(struct ifc_regs_info *regs_info)
+{
+	enum boot_src src = get_boot_src();
+
+	if (src == BOOT_SOURCE_IFC_NAND)
+		regs_info->regs = ifc_cfg_nand_boot;
+	else
+		regs_info->regs = ifc_cfg_nor_boot;
+	regs_info->cs_size = CONFIG_SYS_FSL_IFC_BANK_COUNT;
+}
+#endif
+
+int checkboard(void)
+{
+#ifdef CONFIG_TFABOOT
+	enum boot_src src = get_boot_src();
+#endif
+#ifndef CONFIG_SD_BOOT
+	u8 sw;
+#endif
+
+	puts("Board: LS1043AQDS, boot from ");
+
+#ifdef CONFIG_TFABOOT
+	if (src == BOOT_SOURCE_SD_MMC)
+		puts("SD\n");
+	else {
+#endif
+
+#ifdef CONFIG_SD_BOOT
+		puts("SD\n");
+#else
+		sw = QIXIS_READ(brdcfg[0]);
+		sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+		if (sw < 0x8)
+			printf("vBank: %d\n", sw);
+		else if (sw == 0x8)
+			puts("PromJet\n");
+		else if (sw == 0x9)
+			puts("NAND\n");
+		else if (sw == 0xF)
+			printf("QSPI\n");
+		else
+			printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+#endif
+
+#ifdef CONFIG_TFABOOT
+	}
+#endif
+
+	return 0;
+}
+
+bool if_board_diff_clk(void)
+{
+	u8 diff_conf = QIXIS_READ(brdcfg[11]);
+
+	return diff_conf & 0x40;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0f) {
+	case QIXIS_SYSCLK_64:
+		return 64000000;
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	if (if_board_diff_clk())
+		return get_board_sys_clk();
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+
+	return 66666666;
+}
+
+int dram_init(void)
+{
+	fsl_initdram();
+#if (!defined(CONFIG_SPL) && !defined(CONFIG_TFABOOT)) || \
+	defined(CONFIG_SPL_BUILD)
+	/* This will break-before-make MMU for DDR */
+	update_early_mmu_table();
+#endif
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+	struct ccsr_scfg *scfg = (struct ccsr_scfg *)CONFIG_SYS_FSL_SCFG_ADDR;
+	u32 usb_pwrfault;
+#endif
+#ifdef CONFIG_LPUART
+	u8 uart;
+#endif
+
+#ifdef CONFIG_SYS_I2C_EARLY_INIT
+	i2c_early_init_f();
+#endif
+	fsl_lsch2_early_init_f();
+
+#ifdef CONFIG_HAS_FSL_XHCI_USB
+	out_be32(&scfg->rcwpmuxcr0, 0x3333);
+	out_be32(&scfg->usbdrvvbus_selcr, SCFG_USBDRVVBUS_SELCR_USB1);
+	usb_pwrfault =
+		(SCFG_USBPWRFAULT_DEDICATED << SCFG_USBPWRFAULT_USB3_SHIFT) |
+		(SCFG_USBPWRFAULT_DEDICATED << SCFG_USBPWRFAULT_USB2_SHIFT) |
+		(SCFG_USBPWRFAULT_SHARED << SCFG_USBPWRFAULT_USB1_SHIFT);
+	out_be32(&scfg->usbpwrfault_selcr, usb_pwrfault);
+#endif
+
+#ifdef CONFIG_HAS_GPIO4_12_13
+	out_be32(&scfg->rcwpmuxcr0, (in_be32(&scfg->rcwpmuxcr0) & 0xff00) | 0x11);
+#endif
+
+#ifdef CONFIG_LPUART
+	/* We use lpuart0 as system console */
+	uart = QIXIS_READ(brdcfg[14]);
+	uart &= ~CFG_UART_MUX_MASK;
+	uart |= CFG_LPUART_EN << CFG_UART_MUX_SHIFT;
+	QIXIS_WRITE(brdcfg[14], uart);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_DEEP_SLEEP
+/* determine if it is a warm boot */
+bool is_warm_boot(void)
+{
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+
+	if (in_be32(&gur->crstsr) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+#endif
+
+int config_board_mux(int ctrl_type)
+{
+	u8 reg14;
+
+	reg14 = QIXIS_READ(brdcfg[14]);
+
+	switch (ctrl_type) {
+	case MUX_TYPE_GPIO:
+		reg14 = (reg14 & (~0x30)) | 0x20;
+		break;
+	default:
+		puts("Unsupported mux interface type\n");
+		return -1;
+	}
+
+	QIXIS_WRITE(brdcfg[14], reg14);
+
+	return 0;
+}
+
+int config_serdes_mux(void)
+{
+	return 0;
+}
+
+
+#ifdef CONFIG_MISC_INIT_R
+int misc_init_r(void)
+{
+	if (hwconfig("gpio"))
+		config_board_mux(MUX_TYPE_GPIO);
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+#ifdef CONFIG_SYS_FSL_ERRATUM_A010315
+	erratum_a010315();
+#endif
+
+#ifdef CONFIG_SYS_FSL_SERDES
+	config_serdes_mux();
+#endif
+
+#ifdef CONFIG_FSL_LS_PPA
+	ppa_init();
+#endif
+
+	/* SENAO: init gpio */
+
+	gpio_direction_output(114, 1); /* Watchdog pulse output */
+	gpio_direction_output(123, 1); /* TPM_WakeupN */
+	gpio_direction_output(124, 1); /* RST_TPM_N */
+	gpio_direction_output(125, 1); /* TPM_Express */
+
+	gpio_direction_output(127, 1); /* LED_CLK */
+	gpio_direction_output(128, 1); /* LED_DATA */
+	gpio_direction_output(129, 1); /* RST_PCIE0_N reset QCA9880 */
+	gpio_direction_output(130, 1); /* POE_RST_N_33 */
+	gpio_direction_output(205, 1); /* LED_IC_RST_N_R_1V8 */
+	gpio_direction_output(206, 1); /* BLUETOOTH_RST_1V8 */
+	gpio_direction_output(211, 1); /* RST to VSC8514 */
+	gpio_direction_output(212, 1); /* RST to AR8035 */
+	gpio_direction_output(226, 1); /* QSPI_RST_N */
+	gpio_direction_output(315, 1);
+	gpio_direction_output(316, 1);
+	gpio_direction_output(326, 1); /* WatchDog enabl>> Active Low */
+	gpio_direction_output(413, 1);
+
+	/* Workaround for resetting QCA9880 */
+	gpio_direction_output(129, 0); /* RST_PCIE0_N reset QCA9880 */
+	udelay(10000); //keeping 10ms L
+	gpio_direction_output(129, 1); /* RST_PCIE0_N reset QCA9880 */
+
+	/* reset AR8035 */
+	gpio_direction_output(212, 1); /* RST to AR8035 */
+
+	/*
+	   Watchguard Wants to support both NEW (88E1545) and OLD (VSC8514) Boards.
+	   We will extend the udelay to 20 ms so that way it supports both PHYs
+	*/
+	/* reset 88E1545 or VSC8514 */
+	gpio_direction_output(211, 0); /* RST to 88E1545 or VSC8514 */
+	udelay(20000); //keeping 20ms L
+	gpio_direction_output(211, 1); /* RST to 88E1545 or VSC8514 */
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	u64 base[CONFIG_NR_DRAM_BANKS];
+	u64 size[CONFIG_NR_DRAM_BANKS];
+	u8 reg;
+
+	/* fixup DT for the two DDR banks */
+	base[0] = gd->bd->bi_dram[0].start;
+	size[0] = gd->bd->bi_dram[0].size;
+	base[1] = gd->bd->bi_dram[1].start;
+	size[1] = gd->bd->bi_dram[1].size;
+
+	fdt_fixup_memory_banks(blob, base, size, 2);
+	ft_cpu_setup(blob, bd);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+#endif
+
+	fdt_fixup_icid(blob);
+
+	reg = QIXIS_READ(brdcfg[0]);
+	reg = (reg & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	/* Disable IFC if QSPI is enabled */
+	if (reg == 0xF)
+		do_fixup_by_compat(blob, "fsl,ifc",
+				   "status", "disabled", 8 + 1, 1);
+
+	return 0;
+}
+#endif
+
+u8 flash_read8(void *addr)
+{
+	return __raw_readb(addr + 1);
+}
+
+void flash_write16(u16 val, void *addr)
+{
+	u16 shftval = (((val >> 8) & 0xff) | ((val << 8) & 0xff00));
+
+	__raw_writew(shftval, addr);
+}
+
+u16 flash_read16(void *addr)
+{
+	u16 val = __raw_readw(addr);
+
+	return (((val) >> 8) & 0x00ff) | (((val) << 8) & 0xff00);
+}
+
+#ifdef CONFIG_TFABOOT
+void *env_sf_get_env_addr(void)
+{
+	return (void *)(CONFIG_SYS_FSL_QSPI_BASE + CONFIG_ENV_OFFSET);
+}
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_qixis.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_qixis.h	2022-05-09 14:11:35.896496499 -0700
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#ifndef __LS1043AQDS_QIXIS_H__
+#define __LS1043AQDS_QIXIS_H__
+
+/* Definitions of QIXIS Registers for LS1043AQDS */
+
+/* BRDCFG4[4:7] select EC1 and EC2 as a pair */
+#define BRDCFG4_EMISEL_MASK		0xe0
+#define BRDCFG4_EMISEL_SHIFT		5
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+#define QIXIS_SYSCLK_64			0x8
+
+/* DDRCLK */
+#define QIXIS_DDRCLK_66			0x0
+#define QIXIS_DDRCLK_100		0x1
+#define QIXIS_DDRCLK_125		0x2
+#define QIXIS_DDRCLK_133		0x3
+
+/* BRDCFG2 - SD clock*/
+#define QIXIS_SDCLK1_100		0x0
+#define QIXIS_SDCLK1_125		0x1
+#define QIXIS_SDCLK1_165		0x2
+#define QIXIS_SDCLK1_100_SP		0x3
+
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/README.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/README	2022-05-09 14:11:35.864497794 -0700
@@ -0,0 +1,64 @@
+Overview
+--------
+The LS1043A Development System (QDS) is a high-performance computing,
+evaluation, and development platform that supports the QorIQ LS1043A
+LayerScape Architecture processor. The LS1043AQDS provides SW development
+platform for the Freescale LS1043A processor series, with a complete
+debugging environment.
+
+LS1043A SoC Overview
+--------------------
+Please refer arch/arm/cpu/armv8/fsl-layerscape/doc/README.soc for LS1043A
+SoC overview.
+
+ LS1043AQDS board Overview
+ -----------------------
+ - SERDES Connections, 4 lanes supporting:
+      - PCI Express - 3.0
+      - SGMII, SGMII 2.5
+      - QSGMII
+      - SATA 3.0
+      - XFI
+ - DDR Controller
+     - 2GB 40bits (8-bits ECC) DDR4 SDRAM. Support rates of up to 1600MT/s
+ -IFC/Local Bus
+    - One in-socket 128 MB NOR flash 16-bit data bus
+    - One 512 MB NAND flash with ECC support
+    - PromJet Port
+    - FPGA connection
+ - USB 3.0
+    - Three high speed USB 3.0 ports
+    - First USB 3.0 port configured as Host with Type-A connector
+    - The other two USB 3.0 ports configured as OTG with micro-AB connector
+ - SDHC port connects directly to an adapter card slot, featuring:
+    - Optional clock feedback paths, and optional high-speed voltage translation assistance
+    - SD slots for SD, SDHC (1x, 4x, 8x), and/or MMC
+    - eMMC memory devices
+ - DSPI: Onboard support for three SPI flash memory devices
+ - 4 I2C controllers
+ - One SATA onboard connectors
+ - UART
+   - Two 4-pin serial ports at up to 115.2 Kbit/s
+   - Two DB9 D-Type connectors supporting one Serial port each
+ - ARM JTAG support
+
+Memory map from core's view
+----------------------------
+Start Address	End Address	Description		Size
+0x00_0000_0000	0x00_000F_FFFF	Secure Boot ROM		1MB
+0x00_0100_0000	0x00_0FFF_FFFF	CCSRBAR			240MB
+0x00_1000_0000	0x00_1000_FFFF	OCRAM0			64KB
+0x00_1001_0000	0x00_1001_FFFF	OCRAM1			64KB
+0x00_2000_0000	0x00_20FF_FFFF	DCSR			16MB
+0x00_6000_0000	0x00_67FF_FFFF	IFC - NOR Flash		128MB
+0x00_7E80_0000	0x00_7E80_FFFF	IFC - NAND Flash	64KB
+0x00_7FB0_0000	0x00_7FB0_0FFF	IFC - FPGA		4KB
+0x00_8000_0000	0x00_FFFF_FFFF	DRAM1			2GB
+
+Booting Options
+---------------
+a) Promjet Boot
+b) NOR boot
+c) NAND boot
+d) SD boot
+e) QSPI boot
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_rcw_sd_ifc.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_rcw_sd_ifc.cfg	2022-05-09 14:11:35.900496336 -0700
@@ -0,0 +1,8 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# RCW
+# Enable IFC; disable QSPI
+08100010 0a000000 00000000 00000000
+14550002 80004012 60040000 c1002000
+00000000 00000000 00000000 00038800
+00000000 00001100 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/led.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/led.c	2022-05-09 14:11:35.896496499 -0700
@@ -0,0 +1,61 @@
+#include <common.h>
+#include "sn74lv164a.h"
+
+enum {
+	LED_FAIL = SN74LV164A_OUT_QA,
+	LED_ATTN = SN74LV164A_OUT_QB,
+        LED_STAT = SN74LV164A_OUT_QC,
+        LED_MODE = SN74LV164A_OUT_QD,
+        LED_WAP0 = SN74LV164A_OUT_QE,
+        LED_WAP1 = SN74LV164A_OUT_QF,
+	LED_MAX = LED_WAP1,
+};
+
+#define LED_ON		0
+#define LED_OFF		1
+
+static int do_led(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	if (argc != 2)
+		return CMD_RET_USAGE;
+
+	if (!strcmp(argv[1],"on")) {
+		sn74lv164a_set_value_all_low();
+	} else if (!strcmp(argv[1],"off")) {
+		sn74lv164a_set_value_all_high();
+	} else if (!strcmp(argv[1],"reset")) {
+		sn74lv164a_clear();
+	} else if (!strcmp(argv[1],"fail")) {
+		sn74lv164a_set_value(LED_FAIL, LED_ON);
+	} else if (!strcmp(argv[1],"attn")) {
+		sn74lv164a_set_value(LED_ATTN, LED_ON);
+	} else if (!strcmp(argv[1],"stat")) {
+		sn74lv164a_set_value(LED_STAT, LED_ON);
+	} else if (!strcmp(argv[1],"mode")) {
+		sn74lv164a_set_value(LED_MODE, LED_ON);
+	} else if (!strcmp(argv[1],"2g")) {
+		sn74lv164a_set_value(LED_WAP1, LED_OFF);
+		sn74lv164a_set_value(LED_WAP0, LED_ON);
+	} else if (!strcmp(argv[1],"5g")) {
+		sn74lv164a_set_value(LED_WAP1, LED_ON);
+		sn74lv164a_set_value(LED_WAP0, LED_OFF);
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(led, 2, 0, do_led,
+	   "LED control",
+	   "\n"
+	   "\tled on    - Turn on all LEDs, except 2g/5g.\n"
+	   "\tled off   - Turn off all LEDs.\n"
+	   "\tled reset - Clear 74LV174A buffer\n"
+	   "\tled fail\n"
+	   "\tled attn \n"
+	   "\tled stat \n"
+	   "\tled mode \n"
+	   "\tled 2g \n"
+	   "\tled 5g \n"
+	   );
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/sn74lv164a.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/sn74lv164a.h	2022-05-09 14:11:35.900496336 -0700
@@ -0,0 +1,36 @@
+#ifndef _74LV164A_H_
+#define _74LV164A_H_
+#include <asm/gpio.h>
+
+#ifndef SN74LV164A_CLR_GPIO
+#error "GPIO pin for SN74LV164A_CLR_GPIO must be defined."
+#endif
+#ifndef SN74LV164A_CLK_GPIO
+#error "GPIO pin for SN74LV164A_CLK_GPIO must be defined."
+#endif
+#ifndef SN74LV164A_INA_GPIO
+#error "GPIO pin for SN74LV164A_INA_GPIO must be defined."
+#endif
+
+enum {
+	SN74LV164A_OUT_QA = 0,
+	SN74LV164A_OUT_QB,
+	SN74LV164A_OUT_QC,
+	SN74LV164A_OUT_QD,
+	SN74LV164A_OUT_QE,
+	SN74LV164A_OUT_QF,
+	SN74LV164A_OUT_QG,
+	SN74LV164A_OUT_QH,
+	SN74LV164A_OUT_NUM,
+	SN74LV164A_OUT_MAX = SN74LV164A_OUT_NUM,
+};
+
+#define SN74LV164A_OUT_HIGH	1
+#define SN74LV164A_OUT_LOW	0
+
+void sn74lv164a_clear(void);
+void sn74lv164a_set_value(int pin, int val);
+void sn74lv164a_set_value_all_high(void);
+void sn74lv164a_set_value_all_low(void);
+
+#endif /* _74LV164A_H_ */
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ddr.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ddr.c	2022-05-09 14:11:35.876497308 -0700
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#ifdef CONFIG_FSL_DEEP_SLEEP
+#include <fsl_sleep.h>
+#endif
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 3) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	pbsp = udimms[0];
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				popts->cpo_override = pbsp->cpo_override;
+				popts->write_data_delay =
+					pbsp->write_data_delay;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for %lu MT/s\n",
+		       ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n",
+	      pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb);
+
+	/* force DDR bus width to 32 bits */
+	popts->data_bus_width = 1;
+	popts->otf_burst_chop_en = 0;
+	popts->burst_length = DDR_BL8;
+	popts->bstopre = 0;		/* enable auto precharge */
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 1;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+#ifdef CONFIG_SYS_FSL_DDR4
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_80ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_80ohm) |
+			  DDR_CDR2_VREF_OVRD(70);	/* Vref = 70% */
+
+	/* optimize cpo for erratum A-009942 */
+	popts->cpo_sample = 0x59;
+#else
+	popts->cswl_override = DDR_CSWL_CS0;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+#endif
+	popts->cpo_sample = 0x41;
+}
+
+/* DDR model number: NT5AD1024M8A3-HR (1024Mb x 8) */
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 0x80000000,
+	.capacity = 0x80000000,
+	.primary_sdram_width = 32,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 15,					// P.1
+	.n_col_addr = 10,				        // P.1
+	.bank_addr_bits = 2,					// P.1
+	.bank_group_bits = 2,					// P.1
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tckmin_x_ps = 1250,					// P.242 P.273 P.249	
+	.tckmax_ps = 1500,					// P.242 P.273	
+	.caslat_x = 0x000DFA00,
+	.taa_ps = 13750,					// P.249 P.246 taa = tCK * CL 
+	.trcd_ps = 13750,					// P.249 11 nCK		
+	.trp_ps = 13750,					// P.249 11 nCK		
+	.tras_ps = 35000,					// P.249 28 nCK		
+	.trc_ps = 48750,					// P.249 39 nCK		
+	.trfc1_ps = 260000,					// P.278 260 ns
+	.trfc2_ps = 160000,					// P.278 260 ns
+	.trfc4_ps = 110000,					// P.278 260 ns
+	.tfaw_ps = 21000,					// P.274 20 nCK
+	.trrds_ps = 5000,					// P.274 4 nCK
+	.trrdl_ps = 6000,					// P.274 4 nCK			
+	.tccdl_ps = 6250,					// P.274 5 nCK			
+	.refresh_rate_ps = 3900000,				// P.1 Tc > 85 C
+	.dq_mapping[0] = 0x15,			
+	.dq_mapping[1] = 0x36,			
+	.dq_mapping[2] = 0x15,			
+	.dq_mapping[3] = 0x22,			
+	.dq_mapping[4] = 0x16,			
+	.dq_mapping[5] = 0x36,			
+	.dq_mapping[6] = 0x15,			
+	.dq_mapping[7] = 0x36,			
+	.dq_mapping[8] = 0x0,
+	.dq_mapping[9] = 0x0,
+	.dq_mapping[10] = 0x0,
+	.dq_mapping[11] = 0x0,
+	.dq_mapping[12] = 0x0,
+	.dq_mapping[13] = 0x0,
+	.dq_mapping[14] = 0x0,
+	.dq_mapping[15] = 0x0,
+	.dq_mapping[16] = 0x0,
+	.dq_mapping[17] = 0x0,
+	.dq_mapping_ors = 0,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR4 on board";
+
+	if (((controller_number == 0) && (dimm_number == 0)) ||
+		((controller_number == 1) && (dimm_number == 0))) {
+			memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+			memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+			memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_TFABOOT
+int fsl_initdram(void)
+{
+	gd->ram_size = tfa_get_dram_size();
+	if (!gd->ram_size)
+		gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+}
+#else
+int fsl_initdram(void)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
+	gd->ram_size = fsl_ddr_sdram_size();
+
+	return 0;
+#else
+#ifndef CONFIG_SYS_DDR_RAW_TIMING
+	puts("Initializing DDR....using SPD\n");
+#else
+	puts("Initializing DDR...\n");
+#endif
+
+	dram_size = fsl_ddr_sdram();
+#endif
+	erratum_a008850_post();
+
+#ifdef CONFIG_FSL_DEEP_SLEEP
+	fsl_dp_ddr_restore();
+#endif
+
+	gd->ram_size = dram_size;
+
+	return 0;
+}
+#endif
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_rcw_nand.cfg.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/ls1043aqds_rcw_nand.cfg	2022-05-09 14:11:35.900496336 -0700
@@ -0,0 +1,7 @@
+#PBL preamble and RCW header
+aa55aa55 01ee0100
+# serdes protocol
+08100010 0a000000 00000000 00000000
+14550002 80004012 e0106000 c1002000
+00000000 00000000 00000000 00038800
+00000000 00001100 00000096 00000001
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/gpio.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/gpio.c	2022-05-09 14:11:35.896496499 -0700
@@ -0,0 +1,171 @@
+#include <common.h>
+#include <mapmem.h>
+#include <asm/gpio.h>
+
+#define GPIO_BASE		0x2300000
+#define GPIO_DIRECTION		0x0
+#define GPIO_DATA               0x8
+
+#define GPIO1_BASE		(GPIO_BASE + 0x00000)
+#define GPIO1_DIRECTION         (GPIO1_BASE + GPIO_DIRECTION)
+#define GPIO1_DATA              (GPIO1_BASE + GPIO_DATA)
+
+#define GPIO2_BASE		(GPIO_BASE + 0x10000)
+#define GPIO2_DIRECTION         (GPIO2_BASE + GPIO_DIRECTION)
+#define GPIO2_DATA              (GPIO2_BASE + GPIO_DATA)
+
+#define GPIO3_BASE		(GPIO_BASE + 0x20000)
+#define GPIO3_DIRECTION         (GPIO3_BASE + GPIO_DIRECTION)
+#define GPIO3_DATA              (GPIO3_BASE + GPIO_DATA)
+
+#define GPIO4_BASE		(GPIO_BASE + 0x30000)
+#define GPIO4_DIRECTION         (GPIO4_BASE + GPIO_DIRECTION)
+#define GPIO4_DATA              (GPIO4_BASE + GPIO_DATA)
+
+#define BYTE_SWAP(x)		(((x / 8) * 16 + 7) - x)
+
+#ifndef GPIO1_SUPPORT
+#define GPIO1_SUPPORT		(0x0 << 0)
+#endif
+#ifndef GPIO2_SUPPORT
+#define GPIO2_SUPPORT		(0x0 << 0)
+#endif
+#ifndef GPIO3_SUPPORT
+#define GPIO3_SUPPORT		(0x0 << 0)
+#endif
+#ifndef GPIO4_SUPPORT
+#define GPIO4_SUPPORT		(0x0 << 0)
+#endif
+
+uint32_t gpio_direction[4] = {
+	GPIO1_DIRECTION,
+	GPIO2_DIRECTION,
+	GPIO3_DIRECTION,
+	GPIO4_DIRECTION,
+};
+
+uint32_t gpio_data[4] = {
+	GPIO1_DATA,
+	GPIO2_DATA,
+	GPIO3_DATA,
+	GPIO4_DATA,
+};
+
+uint32_t gpio_support[4] = {
+	GPIO1_SUPPORT,
+	GPIO2_SUPPORT,
+	GPIO3_SUPPORT,
+	GPIO4_SUPPORT,
+};
+
+static int is_support(unsigned gpio)
+{
+	int grp, pos, sup = 0;
+
+	grp = (gpio/100);
+	pos = (gpio%100);
+	sup = ((gpio_support[grp-1] >> pos) & 0x1);
+
+	return (!sup);
+}
+
+int gpio_request(unsigned gpio, const char *label)
+{
+	if (!is_support(gpio))
+		return 0;
+
+	return -1;
+}
+
+int gpio_free(unsigned gpio)
+{
+	return 0;
+}
+
+int gpio_direction_input(unsigned gpio)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_direction[grp-1]);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	val &= ~(1 << pos);
+	*(volatile uint32_t *)buf = val;
+	unmap_sysmem(buf);
+
+	return 0;
+}
+
+int gpio_direction_output(unsigned gpio, int value)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_direction[grp-1]);
+
+	gpio_set_value(gpio, value);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	val |= (1 << pos);
+	*(volatile uint32_t *)buf = (val);
+	unmap_sysmem(buf);
+
+	return 0;
+}
+
+int gpio_get_value(unsigned gpio)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_data[grp-1]);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	unmap_sysmem(buf);
+
+	return ((val >> pos) & 0x1);
+}
+
+int gpio_set_value(unsigned gpio, int value)
+{
+	if (is_support(gpio))
+		return -1;
+
+	ulong bytes;
+	uint32_t grp, pos, addr, val;
+
+	grp = (gpio/100);
+	pos = (BYTE_SWAP(gpio%100));
+	addr = (gpio_data[grp-1]);
+
+	const void *buf = map_sysmem(addr, bytes);
+	val = *(volatile uint32_t *)buf;
+	if (value)
+		val |= (1 << pos);
+	else
+		val &= ~(1 << pos);
+
+	*(volatile uint32_t *)buf = (val);
+	unmap_sysmem(buf);
+
+	return 0;
+}
--- u-boot-2018.09/board/freescale/ls1043aqds_t20/Kconfig.orig	1969-12-31 16:00:00.000000000 -0800
+++ u-boot-2018.09/board/freescale/ls1043aqds_t20/Kconfig	2022-05-09 14:11:35.860497956 -0700
@@ -0,0 +1,33 @@
+if TARGET_LS1043AQDS_WG_T20
+
+config SYS_BOARD
+	default "ls1043aqds_t20"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls1043aqds_t20"
+
+if FSL_LS_PPA
+config SYS_LS_PPA_FW_ADDR
+	hex "PPA Firmware Addr"
+	default 0x40400000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x60400000 if SYS_LS_PPA_FW_IN_XIP
+	default 0x400000 if SYS_LS_PPA_FW_IN_MMC || SYS_LS_PPA_FW_IN_NAND
+
+if CHAIN_OF_TRUST
+config SYS_LS_PPA_ESBC_ADDR
+	hex "PPA Firmware HDR Addr"
+	default 0x40680000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
+	default 0x60680000 if SYS_LS_PPA_FW_IN_XIP
+	default 0x680000 if SYS_LS_PPA_FW_IN_MMC || SYS_LS_PPA_FW_IN_NAND
+endif
+endif
+
+source "board/freescale/common/Kconfig"
+
+endif
