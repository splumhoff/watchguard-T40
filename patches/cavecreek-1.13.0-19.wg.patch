WatchGuard patches to sources for cavecreek-1.13.0-19 as of
Mon May  9 13:48:39 PDT 2022
The patches shown here have been applied to source .tar.gz 
files supplied with the WatchGuard Open Source Archive.

==========================================================================
--- cavecreek-1.13.0-19/quickassist/utilities/downloader/Target_CoreLibs/halAe/accelcomp/Makefile.orig	2022-05-09 13:48:33.256551455 -0700
+++ cavecreek-1.13.0-19/quickassist/utilities/downloader/Target_CoreLibs/halAe/accelcomp/Makefile	2022-05-09 13:48:33.648535544 -0700
@@ -87,7 +87,7 @@
          ../../uclo/uclo_exp.o ../../uclo/uclo.o ../../uclo/uclo_hw.o \
          ../../uclo/uclo_ivd.o ../../uclo/uclo_mof.o ../../uclo/uclo_overlay.o \
          ../../uclo/uclo_kern.o ../../uclo/uclo_helper.o  ../../uclo/uclo_suof.o
-         
+
 else
 
   PWD  := $(shell pwd)
@@ -99,12 +99,12 @@
   endif
 
 .PHONY : all
-      
+
 all:
 	cp -f $(ICP_OSAL_RELEASE_LINUX)/libosal.a $(PWD)
 	$(MAKE) -C $(KDIR) M=$(PWD)
-	
+
 clean:
-	$(RM) -r ../../uclo/*.o ../.*.cmd ../*.o .*.cmd libosal.a *.o *.mod.c *.ko .tmp_versions lib.a Module.symvers
-  
+	$(RM) -rf ../../uclo/*.o ../.*.cmd ../*.o .*.cmd libosal.a *.o *.mod.c *.ko .tmp_versions lib.a Module.symvers
+
 endif
--- cavecreek-1.13.0-19/quickassist/utilities/downloader/Target_CoreLibs/makDefs/coreLibs_kernel.mak.orig	2022-05-09 13:48:33.260551293 -0700
+++ cavecreek-1.13.0-19/quickassist/utilities/downloader/Target_CoreLibs/makDefs/coreLibs_kernel.mak	2022-05-09 13:48:33.656535219 -0700
@@ -81,4 +81,4 @@
 
 clean_libs :
 	@cd $(HALAETGT_DIR) $(CMD_CAT) $(MAKE) CCMODE=$(CCMODE) clean
-	$(RM) $(ALL_LIBS)
+	$(RM) -f $(ALL_LIBS)
--- cavecreek-1.13.0-19/quickassist/utilities/osal/src/linux/kernel_space/OsalUsrKrlProxy.c.orig	2022-05-09 13:48:33.280550481 -0700
+++ cavecreek-1.13.0-19/quickassist/utilities/osal/src/linux/kernel_space/OsalUsrKrlProxy.c	2022-05-09 13:48:33.672534570 -0700
@@ -48,7 +48,9 @@
 #include <asm/uaccess.h>
 #include <linux/string.h>
 #include <asm/io.h>
-
+#ifdef CONFIG_WG_PLATFORM	// WG:XD port to 4.14 kernel
+#include <linux/uaccess.h>
+#endif
 #define DEV_MEM_MAX_MINOR       1
 #define DEV_MEM_BASE_MINOR      0
 
--- cavecreek-1.13.0-19/quickassist/utilities/osal/src/linux/kernel_space/Makefile.orig	2022-05-09 13:48:33.276550643 -0700
+++ cavecreek-1.13.0-19/quickassist/utilities/osal/src/linux/kernel_space/Makefile	2022-05-09 13:48:33.672534570 -0700
@@ -49,7 +49,7 @@
 EXTRA_CFLAGS+=-DOSAL_ENSURE_ON
 
 ifndef CROSS_COMPILE
-MACHINE:=$(shell uname -m)
+MACHINE?=$(shell uname -m)
 else
 ifndef MACHINE
 $(error MACHINE is undefined)
@@ -102,15 +102,10 @@
 #include your $(ICP_OS)_$(ICP_OS_LEVEL).mk file
 include $(ICP_ENV_DIR)/$(ICP_OS)_$(ICP_OS_LEVEL).mk
 
+$(info MACHINE = $(MACHINE), ARCH = $(ARCH))
+
 ifneq ($(MACHINE), x86_64)
 ASM_SOURCES+= OsalAtomicAddSub.S
-else
-ifeq ($(ARCH), i386)
-ASM_SOURCES+= OsalAtomicAddSub.S
-endif
-ifeq ($(ARCH), i686)
-ASM_SOURCES+= OsalAtomicAddSub.S
-endif
 endif
 
 install: lib_static
--- cavecreek-1.13.0-19/quickassist/lookaside/access_layer/src/common/utils/lac_mem_pools.c.orig	2022-05-09 13:48:33.116557137 -0700
+++ cavecreek-1.13.0-19/quickassist/lookaside/access_layer/src/common/utils/lac_mem_pools.c	2022-05-09 13:48:33.500541551 -0700
@@ -230,6 +230,15 @@
         return CPA_STATUS_INVALID_PARAM; /*Error*/
     }
 
+#ifdef	CONFIG_WG_PLATFORM
+    {
+        extern int wg_colfax;
+        numElementsInPool <<= 1; // if (wg_colfax) numElementsInPool <<= 2;
+        printk("%s: Elements: %5d Size: %4d %s\n", __FUNCTION__,
+               numElementsInPool, blkSizeInBytes, poolName);
+    }
+#endif
+
     /* Allocate table for tracking memory blocks */
     if(CPA_TRUE == trackMemory)
     {
@@ -379,7 +388,16 @@
 #else
         LAC_SPINUNLOCK(&(pPoolID->headLock));
 #endif
+
+#ifdef CONFIG_WG_PLATFORM // WG:JB FBX-7483
+#ifdef __KERNEL__
+        return in_atomic() ? NULL : (void*)CPA_STATUS_RETRY;
+#else
+        return (void*)CPA_STATUS_RETRY;
+#endif
+#else
         return (void*)CPA_STATUS_RETRY;
+#endif
     }
     LAC_SPINUNLOCK(&(pPoolID->headLock));
     pMemBlkCurrent->isInUse = CPA_TRUE;
@@ -480,6 +498,28 @@
     return pPoolID->availBlks;
 }
 
+#ifdef	CONFIG_WG_PLATFORM
+int
+WG_pool_stats(char* cy, char* p, int n)
+{
+    int  j, z = 0;
+
+    for (j = 0; j < LAC_MEM_POOLS_NUM_SUPPORTED; j++)
+    if (lac_mem_pools[j] != NULL) {
+      char* q = &lac_mem_pools[j]->poolName[2];
+
+      if (strstr(q, cy) == q)
+          z += snprintf(p+z, n-z, "| Pool %-21s %6d used of %6d |\n",
+                        lac_mem_pools[j]->poolName,
+                        lac_mem_pools[j]->numElementsInPool -
+                        lac_mem_pools[j]->availBlks,
+                        lac_mem_pools[j]->numElementsInPool);
+    }
+
+    return z;
+}
+#endif
+
 void
 Lac_MemPoolStatsShow(void)
 {
--- cavecreek-1.13.0-19/quickassist/lookaside/access_layer/src/common/ctrl/sal_crypto.c.orig	2022-05-09 13:48:33.108557462 -0700
+++ cavecreek-1.13.0-19/quickassist/lookaside/access_layer/src/common/ctrl/sal_crypto.c	2022-05-09 13:48:33.488542038 -0700
@@ -500,6 +500,15 @@
                (long long unsigned int)symStats.numSymOpCompleted,
                (long long unsigned int)symStats.numSymOpCompletedErrors,
                (long long unsigned int)symStats.numSymOpVerifyFailures);
+#ifdef	CONFIG_WG_PLATFORM
+            {
+                extern int WG_pool_stats(char*, char*, int);
+
+                len += snprintf(data+len, size-len, SEPARATOR);
+                len += WG_pool_stats(&pCryptoService->debug_file->name[5],
+                                     data+len, size-len);
+            }
+#endif
             break;
         }
         case SAL_STATS_DSA:
--- cavecreek-1.13.0-19/quickassist/Makefile.orig	2022-05-09 13:48:32.984562495 -0700
+++ cavecreek-1.13.0-19/quickassist/Makefile	2022-05-09 13:48:33.392545935 -0700
@@ -95,12 +95,12 @@
 LAC_LIB_DIR=$(LAC_PATH)/build/libs
 export DRBG_POLL_AND_WAIT=1
 #Release Package build steps
-ALL_TARGETS =  clean lac_lib_dir libosal libosal_user hal adf adf_user lac lac_user qat-fw install_scripts
-ALL_TARGETS_CI =  lac_lib_dir lac_ci lac_user_ci qat-fw install_scripts
+ALL_TARGETS =  clean lac_lib_dir libosal libosal_user hal adf adf_user lac qat-fw install_scripts
+ALL_TARGETS_CI =  lac_lib_dir lac_ci qat-fw install_scripts
 ICP_ARCH_USER?=`uname -m`
 
 ifdef ICP_SRIOV
-ALL_TARGETS += libosalvf adfvf lacvf libosal_uservf
+ALL_TARGETS += libosalvf adfvf lacvf
 endif
 
 all: $(ALL_TARGETS)
--- cavecreek-1.13.0-19/quickassist/build_system/build_files/OS/linux_common_user_space_rules.mk.orig	2022-05-09 13:48:33.056559573 -0700
+++ cavecreek-1.13.0-19/quickassist/build_system/build_files/OS/linux_common_user_space_rules.mk	2022-05-09 13:48:33.428544474 -0700
@@ -60,6 +60,8 @@
 
 ifeq ($($(PROG_ACY)_OS_LEVEL), user_space)
 
+EXTRA_CFLAGS+=-I$(SYSTEM_INCLUDE)
+
 # Compile the object files with the CFLAGS
 $(OBJECTS): %.o: %.c
 	@echo 'Compiling $<' ;\
--- cavecreek-1.13.0-19/quickassist/adf/drivers/include/adf_chr_drv.h.orig	2022-05-09 13:48:33.024560872 -0700
+++ cavecreek-1.13.0-19/quickassist/adf/drivers/include/adf_chr_drv.h	2022-05-09 13:48:33.404545448 -0700
@@ -71,6 +71,11 @@
 #ifndef ADF_CHR_DEV_H
 #define ADF_CHR_DEV_H
 
+#ifdef CONFIG_WG_PLATFORM	// WG:XD port to 4.14 kernel
+#include <linux/uaccess.h>
+#include <linux/sched/signal.h>
+#endif
+
 typedef struct adf_chr_drv_info_s {
     struct module       *owner;
     unsigned            major;
--- cavecreek-1.13.0-19/quickassist/adf/drivers/common/linux/src/adf_proc_debug.c.orig	2022-05-09 13:48:33.008561521 -0700
+++ cavecreek-1.13.0-19/quickassist/adf/drivers/common/linux/src/adf_proc_debug.c	2022-05-09 13:48:33.404545448 -0700
@@ -137,11 +137,15 @@
                                    file_info->seq_read(file_info->private_data,
                                    file_info->page, PAGE_SIZE - 1,
                                    file_info->offset);
-                ret = seq_puts(sfile, (char*)file_info->page);
+#ifdef CONFIG_WG_PLATFORM	// WG:XD port to 4.14 kernel
+				seq_puts(sfile, (char*)file_info->page);
+#else
+				ret = seq_puts(sfile, (char*)file_info->page);
                 if (ret) {
                         /* run out of space - need to reprint */
                         file_info->offset = old_offset;
                 }
+#endif
         }
         return 0;
 }
--- cavecreek-1.13.0-19/quickassist/shims/netkey/versionfile.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/versionfile	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,11 @@
+PACKAGE_TYPE=icp_qat_netkey
+
+PACKAGE_OS=L
+
+PACKAGE_VERSION_MAJOR_NUMBER=0
+
+PACKAGE_VERSION_MINOR_NUMBER=3
+
+PACKAGE_VERSION_PATCH_NUMBER=0
+
+PACKAGE_VERSION_BUILD_NUMBER=18
--- cavecreek-1.13.0-19/quickassist/shims/netkey/filelist.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/filelist	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,10 @@
+LICENSE.GPL
+icp_netkey/Makefile
+icp_netkey/icp_netkey_shim_aes_sha1.c
+icp_netkey/icp_netkey_shim_linux.c
+icp_netkey/icp_netkey_shim_linux.h
+icp_netkey/test/Makefile
+icp_netkey/test/icp_aead_perf.c
+icp_netkey/test/icp_aead_perf.h
+icp_netkey/test/icp_aead_perf_module.c
+versionfile
--- cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/Makefile	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,48 @@
+#########################################################################
+# @par
+# GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#  version: icp_qat_netkey.L.0.3.0-18
+############################################################################
+
+#QA API  
+ICP_API_DIR=$(ICP_ROOT)/quickassist/include/
+KBUILD_EXTRA_SYMBOLS += $(ICP_ROOT)/quickassist/lookaside/access_layer/src/Module.symvers
+export KBUILD_EXTRA_SYMBOLS
+ICP_LAC_API_DIR=$(ICP_API_DIR)/lac/
+
+#include files
+EXTRA_CFLAGS += -I$(ICP_API_DIR) -I$(ICP_LAC_API_DIR)
+
+obj-m := icp_qat_netkey.o
+icp_qat_netkey-objs := icp_netkey_shim_linux.o
+default: clean 
+	make -C $(KERNEL_SOURCE_ROOT) M=$(PWD) modules
+
+clean:
+	/bin/rm -rf *.mod.c *.ko *.o *.a .*o.cmd modules.order .tmp_versions
+
+
+
+
+
--- cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/icp_aead_perf.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/icp_aead_perf.h	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,72 @@
+/***************************************************************************
+ *
+ * GPL LICENSE SUMMARY
+ * 
+ *   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+ * 
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ * 
+ *   This program is distributed in the hope that it will be useful, but 
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *   General Public License for more details.
+ * 
+ *   You should have received a copy of the GNU General Public License 
+ *   along with this program; if not, write to the Free Software 
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution 
+ *   in the file called LICENSE.GPL.
+ * 
+ *   Contact Information:
+ *   Intel Corporation
+ * 
+ *  version: icp_qat_netkey.L.0.3.0-18
+ *
+ ***************************************************************************/
+
+#define MAX_INFLIGHT_REQUESTS 200
+
+typedef struct _sa_context_s {
+	/* SA info */
+	struct crypto_aead *tfm;
+	u8 *pKey;
+	u8 *pTempBuf;		/* Used for decrypt testing to hold the known answer vector */
+	u32 keylen;
+
+	/* Per request */
+	struct aead_givcrypt_request *pReq[MAX_INFLIGHT_REQUESTS];
+	struct scatterlist sglData[MAX_INFLIGHT_REQUESTS];
+	struct scatterlist sglHdr[MAX_INFLIGHT_REQUESTS];
+	u8 *pIv[MAX_INFLIGHT_REQUESTS];
+	u8 *pBuff[MAX_INFLIGHT_REQUESTS];	/* Data buffer */
+	u32 buffLen;		/* Length of data buffer = dataLengthInBytes + hdr +iv + digest */
+	u32 dataLengthInBytes;
+
+	/* wait queue */
+	wait_queue_head_t tx_wait_queue;
+
+	/* Counters */
+	u64 totalRequestsSent;
+	u64 totalResponsesReceived;
+	u64 totalRetries;
+
+	/* Results */
+	u64 startCycleCount;
+	u64 endCycleCount;
+	u64 dummyCycles;
+
+} sa_context_t;
+
+typedef struct icp_aead_test_data_s {
+	u64 numReq;
+	u32 pktSize;
+	sa_context_t cs;	/* per thread session info */
+} icp_aead_test_data_t;
+
+/* Tests givencrypt function */
+int icp_aead_givencrypt(void *pData);
+
+/* Tests decrypt function */
+int icp_aead_decrypt(void *pData);
--- cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/Makefile	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,36 @@
+#########################################################################
+# @par
+# GPL LICENSE SUMMARY
+# 
+#   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+# 
+#   This program is free software; you can redistribute it and/or modify 
+#   it under the terms of version 2 of the GNU General Public License as
+#   published by the Free Software Foundation.
+# 
+#   This program is distributed in the hope that it will be useful, but 
+#   WITHOUT ANY WARRANTY; without even the implied warranty of 
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#   General Public License for more details.
+# 
+#   You should have received a copy of the GNU General Public License 
+#   along with this program; if not, write to the Free Software 
+#   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#   The full GNU General Public License is included in this distribution 
+#   in the file called LICENSE.GPL.
+# 
+#   Contact Information:
+#   Intel Corporation
+# 
+#  version: icp_qat_netkey.L.0.3.0-18
+############################################################################
+
+
+obj-m := icp_perf_aead.o
+icp_perf_aead-objs := icp_aead_perf.o icp_aead_perf_module.o
+default: clean
+	make -C $(KERNEL_SOURCE_ROOT) M=$(PWD) modules
+
+clean:
+	/bin/rm -rf *.mod.c *.ko *.o *.a
+
--- cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/icp_aead_perf.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/icp_aead_perf.c	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,459 @@
+/***************************************************************************
+ *
+ * GPL LICENSE SUMMARY
+ * 
+ *   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+ * 
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ * 
+ *   This program is distributed in the hope that it will be useful, but 
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *   General Public License for more details.
+ * 
+ *   You should have received a copy of the GNU General Public License 
+ *   along with this program; if not, write to the Free Software 
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution 
+ *   in the file called LICENSE.GPL.
+ * 
+ *   Contact Information:
+ *   Intel Corporation
+ * 
+ *  version: icp_qat_netkey.L.0.3.0-18
+ *
+ ***************************************************************************/
+
+#include <linux/random.h>
+#include <linux/crypto.h>
+#include <linux/wait.h>
+#include <linux/kthread.h>
+#include <linux/ktime.h>
+#include <crypto/aead.h>
+#include <crypto/authenc.h>
+#include <crypto/aes.h>
+#include <crypto/sha.h>
+#include <linux/scatterlist.h>
+#include <linux/rtnetlink.h>
+
+#include "icp_aead_perf.h"
+
+#define ICP_AEAD_PERF_HDR_LEN 8	/* header length in bytes */
+#define ICP_AEAD_PERF_AUTH_KEY_LEN 20	/* auth key length in bytes */
+
+#define RESPONSE_TIMEOUT_MS         5000
+#define RESPONSE_TIMEOUT_JIFFY      (RESPONSE_TIMEOUT_MS*HZ/100)
+
+extern unsigned int kp_numThreads;
+extern atomic_t arrived;
+extern atomic_t bGo;
+
+static int perf_aead_execute_tests(sa_context_t * cs, u32 dataLength,
+				   u64 totalReqs, int dir);
+static int perf_aead_performLoop(sa_context_t * cs, u64 totalReqsToSend,
+				 int dir);
+static int perf_aead_init_data(sa_context_t * cs, u32 dataLength, int dir);
+static int perf_aead_init_session(sa_context_t * cs, int dir);
+static int perf_aead_cleanup(sa_context_t * cs);
+
+/* Callback function */
+static void perf_op_done(struct crypto_async_request *pReq, int err)
+{
+	sa_context_t *cs = pReq->data;
+
+	if (err != 0) {
+		printk("\n Callback error!\n");
+	}
+
+	cs->totalResponsesReceived++;
+
+	wake_up_interruptible(&cs->tx_wait_queue);
+}
+
+int icp_aead_givencrypt(void *testData)
+{
+	icp_aead_test_data_t *data = (icp_aead_test_data_t *) testData;
+	u64 totalReqsToSend = data->numReq;
+	u32 pktSize = data->pktSize;
+
+	if (perf_aead_execute_tests(&data->cs, pktSize, totalReqsToSend, 0)) {
+		printk("\nFAILED: AEAD givencrypt performance test\n");
+		return -1;
+	}
+
+	return 0;
+
+}
+
+int icp_aead_decrypt(void *testData)
+{
+	icp_aead_test_data_t *data = (icp_aead_test_data_t *) testData;
+	u64 totalReqsToSend = data->numReq;
+	u32 pktSize = data->pktSize;
+
+	if (perf_aead_execute_tests(&data->cs, pktSize, totalReqsToSend, 1)) {
+		printk("\nFAILED: AEAD decrypt performance test\n");
+		return -1;
+	}
+
+	return 0;
+
+}
+
+int perf_aead_execute_tests(sa_context_t * cs, u32 dataLength, u64 totalReqs,
+			    int dir)
+{
+	int res = -1;		/* Non-zero is fail */
+
+	res = perf_aead_init_data(cs, dataLength, dir);
+	if (res != 0) {
+		return res;
+	}
+
+	res = perf_aead_init_session(cs, dir);
+	if (res != 0) {
+		/*clean up */
+		perf_aead_cleanup(cs);
+		return res;
+	}
+
+	res = perf_aead_performLoop(cs, totalReqs, dir);
+
+	perf_aead_cleanup(cs);
+
+	return res;
+
+}
+
+int perf_aead_performLoop(sa_context_t * cs, u64 totalReqsToSend, int dir)
+{
+	int ret;
+	u32 curr_offset = 0;
+
+
+	/* Wait are barrier for all threads */
+	atomic_inc(&arrived);
+	if (atomic_read(&arrived) < kp_numThreads) {
+		while (atomic_read(&bGo) == 0) {
+			yield();
+		}
+	} else {
+		atomic_inc(&bGo);
+	}
+
+	rdtscll(cs->startCycleCount);
+	/* Send all requests */
+	while (cs->totalRequestsSent < totalReqsToSend) {
+
+		ret = wait_event_interruptible_timeout(cs->tx_wait_queue,
+						       ((cs->totalRequestsSent -
+							 cs->
+							 totalResponsesReceived)
+							<
+							MAX_INFLIGHT_REQUESTS),
+						       RESPONSE_TIMEOUT_JIFFY);
+		if (ret < 0) {
+			printk("\n*** Wait for response interrupted\n");
+			return -1;
+		} else
+		    if (!
+			((cs->totalRequestsSent - cs->totalResponsesReceived) <
+			 MAX_INFLIGHT_REQUESTS)) {
+			printk("\n*** Failed to receive response from CPM\n");
+			return -1;
+		}
+		if (0 == dir) {
+			ret = crypto_aead_givencrypt(cs->pReq[curr_offset]);
+		} else {
+			memcpy(cs->pBuff[curr_offset], cs->pTempBuf,
+			       cs->dataLengthInBytes + 44);
+			ret =
+			    crypto_aead_decrypt(&(cs->pReq[curr_offset]->areq));
+		}
+		if (ret == -EBUSY) {
+			/* Retry (multiple threads using same instance) */
+			cs->totalRetries++;
+			yield();
+		} else {
+			if (ret == 0) {
+				/* Sync case - no callback */
+				cs->totalResponsesReceived++;
+			} else if (ret != -EINPROGRESS) {
+				printk("\n Result not as expected %d\n", ret);
+				return -1;
+			}
+			curr_offset = (curr_offset + 1) % MAX_INFLIGHT_REQUESTS;
+			cs->totalRequestsSent++;
+		}
+	}
+
+	/* Wait for inflights */
+	while (cs->totalResponsesReceived < totalReqsToSend) {
+		ret = wait_event_interruptible_timeout(cs->tx_wait_queue,
+						       (cs->
+							totalResponsesReceived
+							== totalReqsToSend),
+						       RESPONSE_TIMEOUT_JIFFY);
+		if (ret < 0) {
+			printk("\n*** Wait for response interrupted\n");
+			return -1;
+		} else if (cs->totalResponsesReceived != totalReqsToSend) {
+			printk("\n*** Failed to receive response from CPM\n");
+			return -1;
+		}
+	}
+
+	rdtscll(cs->endCycleCount);
+
+
+	return 0;
+}
+
+int perf_aead_init_data(sa_context_t * cs, u32 dataLength, int dir)
+{
+
+	u32 dataIndex = 0;
+	struct crypto_aead *tfm2;
+	struct aead_givcrypt_request *pReq;
+	u8 *pTemp = NULL;
+	u8 *pReqMem = NULL;
+	u8 *pIv = NULL;
+	struct rtattr *rta = NULL;
+	struct crypto_authenc_key_param *param;
+	u32 i = 0, j = 0;
+	u32 len = 0;
+	struct scatterlist sg[1];
+	struct scatterlist asg[1];
+
+	/* Clear structure */
+	memset(cs, 0, sizeof(sa_context_t));
+
+	/* SA Key */
+	cs->keylen = AES_KEYSIZE_128 + ICP_AEAD_PERF_AUTH_KEY_LEN
+	    + RTA_SPACE(sizeof(*param));
+	cs->pKey = kmalloc(cs->keylen, GFP_KERNEL);
+	if (NULL == cs->pKey) {
+		printk("Could not allocate key\n");
+		return -1;
+	}
+	pTemp = cs->pKey;
+	rta = (struct rtattr *)pTemp;
+	rta->rta_type = CRYPTO_AUTHENC_KEYA_PARAM;
+	rta->rta_len = RTA_LENGTH(sizeof(*param));
+	param = RTA_DATA(rta);
+	param->enckeylen = cpu_to_be32(AES_KEYSIZE_128);
+	pTemp += RTA_SPACE(sizeof(*param));
+	/* random key for this context */
+	get_random_bytes(pTemp, (AES_KEYSIZE_128 + ICP_AEAD_PERF_AUTH_KEY_LEN));
+
+	cs->pTempBuf = NULL;
+
+	cs->dataLengthInBytes = dataLength;
+
+	cs->buffLen = ICP_AEAD_PERF_HDR_LEN + AES_BLOCK_SIZE
+	    + dataLength + SHA1_DIGEST_SIZE;
+	if (1 == dir) {
+		/* decrypt direction - need to ensure digest
+		   verify passes */
+		/* For each context get a valid input */
+		cs->pTempBuf = kmalloc(cs->buffLen, GFP_KERNEL);
+		if (NULL == cs->pTempBuf) {
+			printk("Could not allocate pTempBuf\n");
+			kfree(cs->pKey);
+			return -1;
+		}
+		/* random input to encrypt */
+		get_random_bytes(cs->pTempBuf, cs->buffLen);
+
+		/* Use "authenc(hmac(sha1-generic),cbc-aes-aesni)" driver to generate valid
+		   decrypt input */
+		tfm2 =
+		    crypto_alloc_aead
+		    ("authenc(hmac(sha1-generic),cbc-aes-aesni)", 0, 0);
+		if (IS_ERR(tfm2)) {
+			/* "authenc(hmac(sha1-generic),cbc-aes-aesni)" driver not available try
+			   "authenc(hmac(sha1-generic),cbc(aes-asm))" driver */
+			tfm2 = crypto_alloc_aead
+			    ("authenc(hmac(sha1-generic),cbc(aes-asm))", 0, 0);
+			if (IS_ERR(tfm2)) {
+				printk
+				    ("authenc(hmac(sha1-generic),cbc-aes-aesni) and \
+                        authenc(hmac(sha1-generic),cbc(aes-asm)) drivers not available\n");
+				kfree(cs->pTempBuf);
+				kfree(cs->pKey);
+				return -1;
+			}
+		}
+		crypto_aead_setauthsize(tfm2, SHA1_DIGEST_SIZE);
+		crypto_aead_setkey(tfm2, cs->pKey, cs->keylen);
+
+		sg_init_one(&sg[0],
+			    (cs->pTempBuf + ICP_AEAD_PERF_HDR_LEN +
+			     AES_BLOCK_SIZE), dataLength + SHA1_DIGEST_SIZE);
+		sg_init_one(&asg[0], cs->pTempBuf, ICP_AEAD_PERF_HDR_LEN);
+		pIv = cs->pTempBuf + ICP_AEAD_PERF_HDR_LEN;
+
+		/* alloc givcrypt request */
+		len =
+		    sizeof(struct aead_givcrypt_request) +
+		    crypto_aead_reqsize(tfm2);
+		pReqMem = kmalloc(len, GFP_ATOMIC);
+		if (NULL == pReqMem) {
+			printk("Could not allocate pReqMem\n");
+			crypto_free_aead(tfm2);
+			kfree(cs->pTempBuf);
+			kfree(cs->pKey);
+			return -1;
+		}
+
+		pReq = (struct aead_givcrypt_request *)pReqMem;
+		aead_givcrypt_set_tfm(pReq, tfm2);
+
+		aead_givcrypt_set_callback(pReq, CRYPTO_TFM_REQ_MAY_BACKLOG, 0,
+					   0);
+		aead_givcrypt_set_crypt(pReq, sg, sg, dataLength, pIv);
+		aead_givcrypt_set_assoc(pReq, asg, ICP_AEAD_PERF_HDR_LEN);
+		aead_givcrypt_set_giv(pReq, pIv, 0);
+
+		if (0 != crypto_aead_givencrypt(pReq)) {
+			printk("Result not as expected\n");
+			kfree(pReqMem);
+			crypto_free_aead(tfm2);
+			kfree(cs->pTempBuf);
+			kfree(cs->pKey);
+			return -1;
+		}
+		crypto_free_aead(tfm2);
+		kfree(pReqMem);
+
+	}
+
+	for (i = 0; i < MAX_INFLIGHT_REQUESTS; i++) {
+		/* Allocate memory for Src/Dst */
+		cs->pBuff[i] = kmalloc(cs->buffLen, GFP_KERNEL);
+		if (NULL == cs->pBuff[i]) {
+			printk("Error allocating src buffer %d\n", i);
+			for (j = 0; j < i; j++) {
+				kfree(cs->pBuff[j]);
+			}
+			if (NULL != cs->pTempBuf) {
+				kfree(cs->pTempBuf);
+			}
+			kfree(cs->pKey);
+			return -1;
+		}
+
+		if (1 == dir) {
+			/* Fill buffer with result from givencrypt */
+			memcpy(cs->pBuff[i], cs->pTempBuf, cs->buffLen);
+		} else {
+			/* Fill buffer with stuff */
+			for (dataIndex = 0; dataIndex < cs->buffLen;
+			     dataIndex++) {
+				*((cs->pBuff[i]) + dataIndex) = (u8) dataIndex;
+			}
+		}
+
+		/* describe hdr as a sgl */
+		sg_init_one(&(cs->sglHdr[i]), cs->pBuff[i],
+			    ICP_AEAD_PERF_HDR_LEN);
+		/* describe data as a sgl */
+		sg_init_one(&(cs->sglData[i]),
+			    (cs->pBuff[i] + ICP_AEAD_PERF_HDR_LEN +
+			     AES_BLOCK_SIZE), dataLength + SHA1_DIGEST_SIZE);
+		/* Set where IV is */
+		cs->pIv[i] = (cs->pBuff[i] + ICP_AEAD_PERF_HDR_LEN);
+	}
+	return 0;
+
+}
+
+int perf_aead_init_session(sa_context_t * cs, int dir)
+{
+	u32 i = 0;
+
+	/* Crypto api - init SA */
+	cs->tfm = crypto_alloc_aead("authenc(hmac(sha1),cbc(aes))", 0, 0);
+	if (NULL == cs->tfm) {
+		printk("Error allocation tfm\n");
+		return -1;
+	}
+	crypto_aead_setauthsize(cs->tfm, SHA1_DIGEST_SIZE);
+	crypto_aead_setkey(cs->tfm, cs->pKey, cs->keylen);
+
+	/* Prep Crypto Requests */
+	for (i = 0; i < MAX_INFLIGHT_REQUESTS; i++) {
+		/* our implementation requires user to allocate crypto_aead_reqsize() */
+		cs->pReq[i] = kmalloc((sizeof(struct aead_givcrypt_request)
+				       + crypto_aead_reqsize(cs->tfm)),
+				      GFP_KERNEL);
+		if (NULL == cs->pReq[i]) {
+			printk("Error allocating request %d\n", i);
+			/* Calling function will free resources */
+			return -1;
+		}
+		if (0 == dir) {
+			aead_givcrypt_set_tfm(cs->pReq[i], cs->tfm);
+			aead_givcrypt_set_callback(cs->pReq[i], 0, perf_op_done,
+						   cs);
+			aead_givcrypt_set_crypt(cs->pReq[i], &cs->sglData[i],
+						&cs->sglData[i],
+						cs->dataLengthInBytes,
+						cs->pIv[i]);
+			aead_givcrypt_set_assoc(cs->pReq[i], &cs->sglHdr[i],
+						ICP_AEAD_PERF_HDR_LEN);
+			aead_givcrypt_set_giv(cs->pReq[i], cs->pIv[i], 0);
+		} else {
+			aead_request_set_tfm(&(cs->pReq[i]->areq), cs->tfm);
+			aead_request_set_callback(&(cs->pReq[i]->areq), 0,
+						  perf_op_done, cs);
+			aead_request_set_crypt(&(cs->pReq[i]->areq),
+					       &cs->sglData[i], &cs->sglData[i],
+					       cs->dataLengthInBytes +
+					       SHA1_DIGEST_SIZE, cs->pIv[i]);
+			aead_request_set_assoc(&(cs->pReq[i]->areq),
+					       &cs->sglHdr[i],
+					       ICP_AEAD_PERF_HDR_LEN);
+		}
+
+	}
+
+	/* Zero Counters */
+	cs->totalRequestsSent = 0;
+	cs->totalResponsesReceived = 0;
+
+	init_waitqueue_head(&cs->tx_wait_queue);
+
+	return 0;
+}
+
+int perf_aead_cleanup(sa_context_t * cs)
+{
+	u32 i = 0;
+
+	if (NULL != cs->tfm) {
+		crypto_free_aead(cs->tfm);
+	}
+
+	if (NULL != cs->pKey) {
+		kfree(cs->pKey);
+	}
+
+	if (NULL != cs->pTempBuf) {
+		kfree(cs->pTempBuf);
+	}
+	for (i = 0; i < MAX_INFLIGHT_REQUESTS; i++) {
+		if (NULL != cs->pBuff[i]) {
+			kfree(cs->pBuff[i]);
+		}
+		if (NULL != cs->pReq[i]) {
+			kfree(cs->pReq[i]);
+		}
+
+	}
+
+	return 0;
+
+}
--- cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/icp_aead_perf_module.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/test/icp_aead_perf_module.c	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,299 @@
+/***************************************************************************
+ *
+ * GPL LICENSE SUMMARY
+ * 
+ *   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+ * 
+ *   This program is free software; you can redistribute it and/or modify 
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ * 
+ *   This program is distributed in the hope that it will be useful, but 
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of 
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *   General Public License for more details.
+ * 
+ *   You should have received a copy of the GNU General Public License 
+ *   along with this program; if not, write to the Free Software 
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution 
+ *   in the file called LICENSE.GPL.
+ * 
+ *   Contact Information:
+ *   Intel Corporation
+ * 
+ *  version: icp_qat_netkey.L.0.3.0-18
+ *
+ ***************************************************************************/
+
+/*
+ * icp_aead_perf_module.c
+ *
+ * This module tests the performance at the lkcf api for AEAD algorithm 
+ * authenc(hmac(sha1),cbc(aes))
+ *
+ * The performace test runs when the module is insmod-ed. The following
+ * module parameters can be set:
+ *
+ * @param kp_numThreads   The number of threads. Each thread will be assigned to 
+ *                        the available cores on the system in a round robin 
+ *                        fashion.
+ * @param kp_pktSize      The packet size. This is the size in bytes of the plaintext.
+ *                        Similar to the IPSec use case this is the length to cipher
+ *                        The size of the data to auth is 24 bytes (8 for header and 
+ *                        16 for IV) greater than this.
+ * @param kp_numReqs      The number of packets to send per thread. Note at least
+ *                        1000 requests per thread should be sent to get reliable
+ *                        throughput numbers.
+ * @param kp_givenc       If set givencrypt function is tested.
+ * @param kp_dec          If set decrypt function is tested.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/crypto.h>
+#include <crypto/aes.h>
+#include <linux/kthread.h>
+#include <linux/scatterlist.h>
+#include <linux/cpufreq.h>
+
+#include "icp_aead_perf.h"
+
+MODULE_DESCRIPTION("ICP AEAD perf test module");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
+unsigned int kp_numThreads = 4;	/* Number of threads */
+static unsigned int kp_pktSize = 1024;	/* Pkt size */
+static unsigned int kp_numReqs = 5000000;	/* Number reqs to send per thread - needs to be
+						   greater than 1000 for accurate results */
+static unsigned int kp_givenc = 1;	/* If set, test givencrypt function */
+static unsigned int kp_dec = 1;	/* If set, test decrypt function */
+
+module_param(kp_numThreads, uint, 0);
+module_param(kp_pktSize, uint, 0);
+module_param(kp_numReqs, uint, 0);
+module_param(kp_givenc, uint, 0);
+module_param(kp_dec, uint, 0);
+
+atomic_t arrived;
+atomic_t bGo;
+
+static void icp_aead_output_res(icp_aead_test_data_t * pThreadData)
+{
+	u64 minStartCycles = 0, maxEndCycles = 0;
+	u64 totalCycles = 0;
+	u64 throughput = 0, time = 0;
+	int i = 0;
+	u64 cpu_freq = 0;
+	icp_aead_test_data_t *pTemp = pThreadData;
+
+	minStartCycles = pTemp->cs.startCycleCount;
+	maxEndCycles = pTemp->cs.endCycleCount;
+	pTemp++;
+
+	for (i = 1; i < kp_numThreads; i++) {
+		if (pTemp->cs.startCycleCount < minStartCycles) {
+			minStartCycles = pTemp->cs.startCycleCount;
+		}
+		if (pTemp->cs.endCycleCount > maxEndCycles) {
+			maxEndCycles = pTemp->cs.endCycleCount;
+		}
+		pTemp++;
+	}
+
+	totalCycles = maxEndCycles - minStartCycles;
+	cpu_freq = (u64) cpufreq_quick_get(0);
+	if (0 == cpu_freq) {
+		cpu_freq = (u64) cpu_khz;
+	}
+	do_div(cpu_freq, 1000);	/* in MHz */
+
+
+	/* Number of bits processed */
+	throughput =
+	    8 * pThreadData->cs.totalRequestsSent * kp_numThreads *
+	    pThreadData->cs.dataLengthInBytes;
+	/* Time taken */
+	time = totalCycles;
+
+	if (cpu_freq != 0) {
+		do_div(time, cpu_freq);
+	} else {
+		printk("Cpu frequency unknown, cannot calculate throughput\n");
+	}
+
+	/* divide by time taken */
+	if (time != 0) {
+		do_div(throughput, time);
+	} else {
+		printk("Time taken 0s, cannot calcualte throughput\n");
+	}
+
+	printk("-----------------------------------------------\n");
+	printk("Number threads:                            %d\n",
+	       kp_numThreads);
+	printk("Number of requests per thread:             %llu\n",
+	       pThreadData->cs.totalRequestsSent);
+	printk("Pkt Size:                                  %u\n",
+	       pThreadData->cs.dataLengthInBytes);
+	if (pThreadData->cs.totalRequestsSent > 1000) {
+		printk("Total number of Cycles:                    %llu\n",
+		       totalCycles);
+		if ((cpu_freq != 0) && (time != 0)) {
+			printk
+			    ("CPU frequency:                         %llu MHz\n",
+			     cpu_freq);
+			printk
+			    ("Throughput:                            %llu Mbps\n",
+			     throughput);
+		}
+	}
+	printk("-----------------------------------------------\n");
+
+}
+
+static int _icp_aead_perf_init(void)
+{
+	icp_aead_test_data_t *pThreadData = NULL;
+	icp_aead_test_data_t *pThreadDataTemp = NULL;
+	struct task_struct **pThread = NULL;
+	int i = 0;
+	u32 pktSize = kp_pktSize;
+	u32 numCpus = 0;
+
+	/* Param Checking */
+	if (kp_numThreads < 1) {
+		printk("kp_numThreads must be greater than or equal to 1\n");
+		return -1;
+	}
+
+	/* Round pktSize up to multiple of block size */
+	if (pktSize % AES_BLOCK_SIZE != 0) {
+		pktSize =
+		    kp_pktSize + (AES_BLOCK_SIZE -
+				  (kp_pktSize % AES_BLOCK_SIZE));
+		printk("Rounding pktSize up to multiple of block size\n");
+		printk("New pktSize %d\n", pktSize);
+	}
+
+	numCpus = num_online_cpus();
+
+	/* Initialise barrier */
+	atomic_set(&arrived, 0);
+	atomic_set(&bGo, 0);
+
+	pThread =
+	    kmalloc((kp_numThreads * sizeof(struct task_struct *)), GFP_KERNEL);
+	if (NULL == pThread) {
+		printk("Memory allocation failure (pThread)\n");
+		return -1;
+	}
+	pThreadData =
+	    kmalloc((kp_numThreads * sizeof(icp_aead_test_data_t)), GFP_KERNEL);
+	if (NULL == pThreadData) {
+		printk("Memory allocation failure (pThreadData)\n");
+		kfree(pThread);
+		return -1;
+	}
+
+	if (kp_givenc) {
+		printk
+		    ("\nAEAD givencrypt performance: alg authenc(hmac(sha1),cbc(aes))\n");
+
+		pThreadDataTemp = pThreadData;
+		/* Create and start threads */
+		for (i = 0; i < kp_numThreads; i++) {
+			pThreadDataTemp->numReq = kp_numReqs;
+			pThreadDataTemp->pktSize = pktSize;
+			pThread[i] =
+			    kthread_create(icp_aead_givencrypt,
+					   (void *)pThreadDataTemp, "GIVENC-%d",
+					   i);
+			if (IS_ERR(pThread[i])) {
+				printk("Failed to create thread GIVENC-%d\n",
+				       i);
+				kfree(pThreadData);
+				kfree(pThread);
+				return -1;
+			}
+			/* bind to a core */
+			kthread_bind(pThread[i], (i % numCpus));
+			wake_up_process(pThread[i]);
+
+			pThreadDataTemp++;
+		}
+
+		/* Wait to complete */
+		for (i = 0; i < kp_numThreads; i++) {
+			while (EXIT_DEAD != pThread[i]->exit_state) {
+				set_current_state((long)TASK_INTERRUPTIBLE);
+				schedule_timeout(10 * HZ);
+			}
+		}
+
+		/* Output results */
+		icp_aead_output_res(pThreadData);
+
+		/* Reset barrier */
+		atomic_set(&arrived, 0);
+		atomic_set(&bGo, 0);
+	}
+	if (kp_dec) {
+		printk
+		    ("\nAEAD decrypt performance: alg authenc(hmac(sha1),cbc(aes))\n");
+
+		pThreadDataTemp = pThreadData;
+		/* Create and start threads */
+		for (i = 0; i < kp_numThreads; i++) {
+			pThreadDataTemp->numReq = kp_numReqs;
+			pThreadDataTemp->pktSize = pktSize;
+			pThread[i] =
+			    kthread_create(icp_aead_decrypt,
+					   (void *)pThreadDataTemp, "DEC-%d",
+					   i);
+			if (IS_ERR(pThread[i])) {
+				printk("Failed to create thread GIVENC-%d\n",
+				       i);
+				kfree(pThreadData);
+				kfree(pThread);
+				return -1;
+			}
+			/* bind to a core */
+			kthread_bind(pThread[i], (i % numCpus));
+			wake_up_process(pThread[i]);
+
+			pThreadDataTemp++;
+		}
+
+		/* Wait to complete */
+		for (i = 0; i < kp_numThreads; i++) {
+			while (EXIT_DEAD != pThread[i]->exit_state) {
+				set_current_state((long)TASK_INTERRUPTIBLE);
+				schedule_timeout(10 * HZ);
+			}
+		}
+
+		/* Output results */
+		icp_aead_output_res(pThreadData);
+
+		/* Reset barrier */
+		atomic_set(&arrived, 0);
+		atomic_set(&bGo, 0);
+
+	}
+
+	kfree(pThread);
+	kfree(pThreadData);
+
+	return 0;
+}
+
+static void _icp_aead_perf_exit(void)
+{
+	/* Done */
+}
+
+module_init(_icp_aead_perf_init);
+module_exit(_icp_aead_perf_exit);
--- cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/icp_netkey_shim_linux.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/netkey/icp_netkey/icp_netkey_shim_linux.c	2022-05-09 13:48:33.636536031 -0700
@@ -0,0 +1,3650 @@
+/******************************************************************************
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *  version: icp_qat_netkey.L.0.3.0-17
+ *
+ *****************************************************************************/
+
+/*
+ * icp_netkey_shim_linux.c
+ *
+ * This is an implementation of Linux Kernel Crypto API shim that uses
+ * the Intel(R) Quick Assist API. The focus here is IPsec, (Netkey stack).
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <linux/scatterlist.h>
+#include <linux/rtnetlink.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <crypto/authenc.h>
+#include <crypto/aead.h>
+#include <crypto/hash.h>
+#include <crypto/internal/hash.h>
+#include <crypto/des.h>
+#include <crypto/aes.h>
+#include <crypto/md5.h>
+#include <crypto/sha.h>
+#include <crypto/algapi.h>
+#include <crypto/rng.h>
+/* Workaround for IXA00378497 - enc perf drop when append flag is set */
+#include <crypto/scatterwalk.h>
+#include <linux/sched.h>
+
+#ifdef	CONFIG_WG_KERNEL_4_14
+#include <crypto/skcipher.h>
+#include <crypto/aead.h>
+#include <crypto/internal/aead.h>
+#endif
+
+#include "cpa.h"
+#include "cpa_cy_im.h"
+#include "cpa_cy_sym.h"
+
+// #define	SAMPLE_TEST		perform
+
+#define	GCM_AAD_SIZE		(  8)
+#define	GCM_NONCE_SIZE		(  4)
+#define	GCM_ESP_IV_SIZE		(  8)
+#define	GCM_IV_SIZE		(4+8)
+#define	GCM_DIGEST_SIZE		( 16)
+
+#define	GCM_HW			on
+#define	DES_HW			on
+#define	MD5_HW			on
+#define	NULL_HW			on
+#define	ABLK_HW			on
+#define	AHASH_HW		on
+#define	SHASH_HW		on
+
+/* Define priority so that our algorithms take precedence over generic ones */
+#define	CRA_PRIORITY		8086
+
+#define	ICP_MAX_BLOCK_SIZE	AES_BLOCK_SIZE
+#define	ICP_MAX_DIGEST_SIZE	SHA512_DIGEST_SIZE
+#define	ICP_QAT_SRC_BUFF_ALIGN	8
+
+/* This shim supports up to 8 buffers in a buffer list */
+#define	ICP_MAX_NUM_BUFFERS	8
+
+/* This is the max number of times we try to remove the session */
+#define	ICP_RETRY_COUNT		10
+
+/* This is the amount of time we wait between remove session re-tries */
+#define	ICP_SESSION_REMOVE_TIME	2*HZ
+
+//#define	PrintK   printk
+#define	PrintK(...)
+
+//#define	PrintHex(a,b)
+#ifdef	CONFIG_WG_KERNEL_4_14
+#define	PrintHex(a,b)	wg_dump_hex(a,b,"")
+#else
+#define	PrintHex(a,b)   wg_dump_hex_3_12(a,b,"")
+static void inline      wg_dump_hex_3_12(const u8* buf, u32 len, const u8* tag)
+{
+  if (console_loglevel < 32) len = (len < 256) ? len : 256;
+
+  if (buf)
+  if (len > 0)
+  print_hex_dump(KERN_CONT, tag, DUMP_PREFIX_OFFSET,
+                 16, 1, buf, len, false);
+}
+#endif
+
+static inline void* __xchg_ptr(void* x, volatile void** ptr)
+{
+  __asm__ __volatile__("xchg %0,%1"
+                       :"=r" (x)
+                       :"m" (*ptr), "0" (x)
+                       :"memory");
+  return x;
+}
+
+#define xchg_ptr(v,p) __xchg_ptr((void*)v,(volatile void**)p)
+
+static int get_asize(const char* name)
+{
+  u8* type;
+
+  if ((type = strstr(name, "sha")) != NULL) {
+    u8  ch;
+    int value = INT_MIN;
+
+    type += 3;
+
+    while ((ch = *type++) != 0)
+    if ((ch >= '0') && (ch <= '9'))
+      value = (value * 10) + (ch - '0');
+    else
+      break;
+
+    if (value == 512) return SHA512_DIGEST_SIZE;
+    if (value == 384) return SHA384_DIGEST_SIZE;
+    if (value == 256) return SHA256_DIGEST_SIZE;
+    if (value == 224) return SHA224_DIGEST_SIZE;
+    if (value == 1)   return SHA1_DIGEST_SIZE;
+  }
+  else
+  if ((type = strstr(name, "md5")) != NULL)
+    return MD5_DIGEST_SIZE;
+
+  return 0;
+}
+
+static inline int get_atype(int auth_len)
+{
+  if (likely(auth_len >= SHA512_DIGEST_SIZE))
+    return CPA_CY_SYM_HASH_SHA512;
+  if (likely(auth_len >= SHA384_DIGEST_SIZE))
+    return CPA_CY_SYM_HASH_SHA384;
+  if (likely(auth_len >= SHA256_DIGEST_SIZE))
+    return CPA_CY_SYM_HASH_SHA256;
+  if (likely(auth_len >= SHA224_DIGEST_SIZE))
+    return CPA_CY_SYM_HASH_SHA224;
+  if (likely(auth_len >= SHA1_DIGEST_SIZE))
+    return CPA_CY_SYM_HASH_SHA1;
+  if (likely(auth_len >= MD5_DIGEST_SIZE))
+    return CPA_CY_SYM_HASH_MD5;
+
+  return 0;
+}
+
+static inline int get_etype(int key_len, int iv_len)
+{
+  if (likely(iv_len >= 16))
+    return CPA_CY_SYM_CIPHER_AES_CBC;
+
+  if (likely(iv_len >= 8)) {
+    if (likely(key_len >= 24))
+      return CPA_CY_SYM_CIPHER_3DES_CBC;
+    else
+      return CPA_CY_SYM_CIPHER_DES_CBC;
+  }
+
+  return 0;
+}
+
+/* Structure for context created per SA */
+struct icp_crypto_ctx {
+  CpaInstanceHandle  instance;    /* qat instance assigned to this ctx */
+  Cpa32U             authSize;    /* authentication  size */
+  Cpa32U             metaSize;    /* meta data size */
+  Cpa32U             sessionSize; /* session data size */
+  Cpa32U             requestSize; /* request data size */
+  struct mutex       mutexLock;   /* mutex lock on context */
+  volatile
+  CpaCySymSessionCtx encrypt_ctx; /* encrypt session */
+  atomic_t           encrypt_key; /* flag if encrypt setkey */
+  volatile
+  CpaCySymSessionCtx decrypt_ctx; /* decrypt session */
+  atomic_t           decrypt_key; /* flag if decrypt setkey */
+  u8 salt[ICP_MAX_BLOCK_SIZE];    /* salt for iv generation */
+  u32                gcm_mode;    /* flag  for GCM mode operations */
+  u32                gcm_nonce;   /* nonce for GCM mode operations */
+  atomic64_t         gcm_seqno;   /* seqno for GCM mode operations */
+};
+
+/* Structure for request ctx allocated per request */
+struct icp_crypto_req_ctx {
+  /* ptr to meta data memory required by src CpaBufferList */
+  u8 *pMetaData;
+  /* Src CpaBufferList */
+  CpaBufferList srcList __attribute__ ((aligned(ICP_QAT_SRC_BUFF_ALIGN)));
+  /* Flatbuffers to describe src data */
+  CpaFlatBuffer srcFlatBuffers[ICP_MAX_NUM_BUFFERS];
+  /* Workaround for IXA00378497 - enc performance drops if append flag set */
+  /* Used if digest is scattered over multiple buffers */
+  u8 digestBuffer[ICP_MAX_DIGEST_SIZE];
+  CpaCySymOpData sym_op_data; /* QA API request */
+  /* Workaround for IXA00378497 - enc performance drops if append flag set */
+  u8 digestCpy; /* if set digest must copy from digestBuffer in callback */
+  u8 *result;
+  u32 authSize; /* authSize required in callback if digestCpy is set */
+  u32 cryptlen;
+  u32 assoclen;
+  struct scatterlist *assoc;
+  struct scatterlist *src;
+  struct scatterlist *dst;
+  struct crypto_async_request *async_req;
+  u8  gcm_aad[AES_BLOCK_SIZE];
+  u8  gcm_iv[AES_BLOCK_SIZE];
+};
+
+/* Global memory containing iv=0 */
+static u8 pIvZero[ICP_MAX_BLOCK_SIZE] = { 0 }; /* iv=0 for geniv case */
+
+/* Structure for storing info on instances used by QAT */
+struct icp_qat_instances {
+  CpaInstanceHandle *instances;  /* Pointer to array of instance handles */
+  u32 ctr;   /* Used to allocate instances in a round robin fashion */
+  u32 total; /* Total number of instances available */
+};
+
+/* Global instance info - set at module init */
+struct icp_qat_instances qat_instances = { 0 };
+
+static DEFINE_SPINLOCK(qatInstLock); /* to make instance allocation thread safe */
+
+CpaInstanceHandle get_instance(void)
+{
+  CpaInstanceHandle cpaInst;
+
+  spin_lock(&qatInstLock);
+  cpaInst = qat_instances.instances[(qat_instances.ctr++) %
+                                    qat_instances.total];
+  spin_unlock(&qatInstLock);
+  return cpaInst;
+}
+
+/*  Callback function */
+static void symCallback(void *pCallback,
+                        CpaStatus status,
+                        const CpaCySymOp operationType,
+                        void *pOpData, CpaBufferList * pDstBuffer,
+                        CpaBoolean verifyResult)
+{
+  int                          res       = -EBADMSG;
+  struct icp_crypto_req_ctx   *req_ctx   = (struct icp_crypto_req_ctx *)pCallback;
+  struct crypto_async_request *async_req = req_ctx->async_req;
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: type %d status %d clen %d alen %d\n", __FUNCTION__,
+         operationType, status, req_ctx->cryptlen, req_ctx->authSize);
+
+  if (unlikely(CPA_STATUS_SUCCESS != status)) {
+    printk(KERN_ERR "%s: symCallback failed, status = (%d)\n", __FUNCTION__,
+           status);
+  } else {
+    static unsigned verifyFails = 0;
+
+    if (likely(CPA_TRUE == verifyResult))
+      /* set the result to success */
+      res = verifyFails = 0;
+    else
+    if (((++verifyFails) & 15) == 0)
+      printk(KERN_DEBUG "%s: verifyResult == CPA_FALSE (%d)\n", __FUNCTION__,
+             verifyResult);
+
+    /* Workaround for IXA00378497 - enc performance drops if append flag set */
+    if (unlikely(req_ctx->digestCpy)) {
+
+      scatterwalk_map_and_copy(req_ctx->digestBuffer,
+                               req_ctx->src, req_ctx->cryptlen,
+                               req_ctx->authSize, 1);
+    }
+
+    if (unlikely(console_loglevel & 16)) {
+      printk(KERN_DEBUG "%s: dst   %p %5d\n", __FUNCTION__,
+               sg_virt(req_ctx->src), req_ctx->cryptlen + req_ctx->authSize);
+      PrintHex(sg_virt(req_ctx->src), req_ctx->src->length);
+    }
+  }
+
+  async_req->complete(async_req, res);
+}
+
+/* Function used to convert scatterlist to bufferlist */
+static int sl_to_bl(CpaBufferList *pList,
+                    const struct scatterlist *const pSrc)
+{
+  struct scatterlist *pCurr = (struct scatterlist *)pSrc;
+
+  while (pCurr) {
+
+    if (unlikely(pList->numBuffers >= ICP_MAX_NUM_BUFFERS))
+      break;
+
+    pList->pBuffers[pList->numBuffers].pData = sg_virt(pCurr);
+    pList->pBuffers[pList->numBuffers].dataLenInBytes =  pCurr->length;
+    pList->numBuffers++;
+
+    pCurr = sg_next(pCurr);
+  }
+
+  if (likely(pList->numBuffers < ICP_MAX_NUM_BUFFERS))
+    return 0;
+
+  printk(KERN_ERR "%s: numBuffers in BufferList has exceeded max "
+         "value of %d\n", __FUNCTION__, ICP_MAX_NUM_BUFFERS);
+  return -ENOMEM;
+}
+
+/* Initialise CpaBufferList based on pAssoc, iv and pSrc value */
+static int icp_init_from_assoc_iv_src(struct icp_crypto_req_ctx *const opdata,
+                                      struct scatterlist *const pAssoc,
+                                      struct scatterlist *const pSrc,
+                                      const  Cpa8U        const *iv,
+                                      const  Cpa32U             iv_len)
+{
+  CpaBufferList *pBufflist    = &(opdata->srcList);
+
+  pBufflist->pPrivateMetaData = opdata->pMetaData;
+  pBufflist->pBuffers         = opdata->srcFlatBuffers;
+
+  /* If pAssoc, iv and pSrc are described in 1 contiguous section of
+     memory then we should create the CpaBufferList with 1 buffer to
+     ensure the optimized path is chosen */
+  /* iv is just after the assoc data */
+  if (likely(iv))
+  if (likely(pAssoc))
+  if (likely((sg_virt(pAssoc) + pAssoc->length) == iv))
+  if (likely((iv + iv_len) == sg_virt(pSrc))) /* src data is just after iv */
+  if (likely(NULL == sg_next(pSrc))) {        /* src data in 1 sg */
+
+    /* Can use optimized path for better performance */
+    pBufflist->numBuffers                  = 1;
+    pBufflist->pBuffers                    = opdata->srcFlatBuffers;
+    pBufflist->pBuffers[0].pData           = sg_virt(pAssoc);
+    pBufflist->pBuffers[0].dataLenInBytes  = pAssoc->length;
+    pBufflist->pBuffers[0].dataLenInBytes += (iv_len + pSrc->length);
+
+    return 0;
+  }
+
+  pBufflist->numBuffers = 0;
+
+  /* up to 2 buffers will be intialised before calling
+     sl_to_bl: pAssoc and pIV */
+
+  if (likely(pAssoc)) {
+    pBufflist->pBuffers[0].pData          = sg_virt(pAssoc);
+    pBufflist->pBuffers[0].dataLenInBytes = pAssoc->length;
+    pBufflist->numBuffers++;
+  }
+
+  if (likely(iv)) {
+    pBufflist->pBuffers[1].pData          = (Cpa8U *)iv;
+    pBufflist->pBuffers[1].dataLenInBytes = iv_len;
+    pBufflist->numBuffers++;
+  }
+
+  return sl_to_bl(pBufflist, pSrc);
+}
+
+/* Perform sym operation */
+static int perform_sym_op(struct crypto_async_request   *async_req,
+                          struct icp_crypto_ctx         *ctx,
+                          struct icp_crypto_req_ctx     *pReqCtx,
+                          Cpa8U  *iv, const Cpa32U       iv_len,
+                          const  CpaCySymCipherDirection cipherDirection,
+                          CpaBoolean                     geniv)
+{
+  CpaStatus          status;
+  Cpa32U             messageLen;
+  CpaCySymSessionCtx pSessionCtx;
+  struct scatterlist *pAssoc = pReqCtx->assoc;
+  struct scatterlist *pSrc   = pReqCtx->src;
+
+  if (unlikely(console_loglevel & 16)) if (0)
+  printk(KERN_DEBUG "%s: assoc %d ivlen %d cryptlen %d\n", __FUNCTION__,
+         pReqCtx->assoclen, iv_len, pReqCtx->cryptlen);
+
+  /* Workaround for IXA00378497 - enc performance drops if append flag set */
+
+  if (cipherDirection == CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT)
+    pSessionCtx = ctx->encrypt_ctx;
+  else
+    pSessionCtx = ctx->decrypt_ctx;
+
+  pReqCtx->async_req = async_req;
+
+  /* space for meta data after icp_crypto_req_ctx*/
+  pReqCtx->pMetaData = ((u8 *) pReqCtx) + sizeof(struct icp_crypto_req_ctx);
+
+  /* Describe input SGLs as one CpaBufferList */
+#ifdef	CONFIG_WG_KERNEL_4_14
+  pReqCtx->authSize  = ctx->authSize;
+  pReqCtx->cryptlen -= iv_len;
+
+  if (unlikely(wg_fips_iv))
+  if (unlikely(ctx->authSize == 0))
+  if (atomic_read(&ctx->encrypt_key) != 0) {
+    pReqCtx->assoclen -= iv_len;
+    pReqCtx->cryptlen += iv_len;
+  }
+
+  if (likely(!pAssoc))
+  if (likely(pReqCtx->assoclen > 0)) {
+    struct scatterlist assocTmp;
+    memcpy(pAssoc = &assocTmp, pSrc, sizeof(assocTmp));
+    sg_mark_end(pAssoc);	// WG:XD FBX-17246
+
+    if (CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT == cipherDirection) {
+      if (likely(!ctx->gcm_mode)) {
+        pReqCtx->assoclen -= iv_len;
+        memcpy(iv, sg_virt(pAssoc) + pReqCtx->assoclen,     iv_len);
+      }	// WG:XD FBX-17246
+      else 
+        memcpy(sg_virt(pAssoc) + pReqCtx->assoclen - iv_len, iv, iv_len);
+      pReqCtx->cryptlen += iv_len;
+    } else {
+      if (ctx->gcm_mode) {	// WG:XD FBX-17246
+        pReqCtx->cryptlen += iv_len;
+        memcpy(sg_virt(pAssoc) + pReqCtx->assoclen - iv_len, iv, iv_len);
+      } else
+      memcpy(    sg_virt(pAssoc) + pReqCtx->assoclen, iv, iv_len);
+    }
+    if (ctx->gcm_mode)	// WG:XD FBX-17246
+      iv = sg_virt(pAssoc) + pReqCtx->assoclen - iv_len;
+    else
+    iv         = sg_virt(pAssoc) + pReqCtx->assoclen;
+  }
+
+  if (likely(pAssoc)) {	// WG:XD FBX-17246
+    if (ctx->gcm_mode)
+      pAssoc->length = pReqCtx->assoclen - iv_len;
+    else
+      pAssoc->length = pReqCtx->assoclen;
+  }
+
+  if (ctx->gcm_mode) {	// WG:XD FBX-17246
+    pSrc->offset += pReqCtx->assoclen;
+    pSrc->length  -=  pReqCtx->assoclen;
+  }
+  else {
+  pSrc->offset += (pReqCtx->assoclen + iv_len);
+  pSrc->length  =  pReqCtx->cryptlen + ctx->authSize;
+  }
+
+  if (CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT == cipherDirection) geniv = iv_len;
+#endif
+
+  if (unlikely(icp_init_from_assoc_iv_src(pReqCtx, pAssoc, pSrc, iv, iv_len)))
+    return -ENOMEM;
+
+  /* Workaround for IXA00378497 - enc performance drops if append flag set */
+  pReqCtx->digestCpy = 0;
+
+  /* Setup CpaCySymOpData */
+  pReqCtx->sym_op_data.packetType                      = CPA_CY_SYM_PACKET_TYPE_FULL;
+  pReqCtx->sym_op_data.sessionCtx                      = pSessionCtx;
+
+  pReqCtx->authSize                                    = ctx->authSize;
+
+  if (!ctx->gcm_mode) {
+
+    pReqCtx->sym_op_data.ivLenInBytes                  = iv_len;
+    pReqCtx->sym_op_data.pAdditionalAuthData           = NULL;
+
+    pReqCtx->sym_op_data.hashStartSrcOffsetInBytes     = 0;
+    pReqCtx->sym_op_data.cryptoStartSrcOffsetInBytes   = pReqCtx->assoclen;
+    pReqCtx->sym_op_data.messageLenToHashInBytes       = pReqCtx->assoclen;
+
+  } else {
+
+    memcpy(&pReqCtx->gcm_iv[0], &ctx->gcm_nonce, GCM_NONCE_SIZE);
+    pReqCtx->sym_op_data.ivLenInBytes                  = GCM_IV_SIZE;
+    pReqCtx->sym_op_data.pIv                           = pReqCtx->gcm_iv;
+
+#ifdef CONFIG_WG_PLATFORM	// WG:XD FBX-17246
+    memcpy(pReqCtx->gcm_aad, sg_virt(pAssoc), pReqCtx->assoclen - iv_len);
+#else
+    memcpy(pReqCtx->gcm_aad, sg_virt(pAssoc), pReqCtx->assoclen);
+#endif
+    pReqCtx->sym_op_data.pAdditionalAuthData           = pReqCtx->gcm_aad;
+
+    pReqCtx->sym_op_data.hashStartSrcOffsetInBytes     = 0;
+#ifdef CONFIG_WG_PLATFORM	// WG:XD FBX-17246
+    pReqCtx->sym_op_data.cryptoStartSrcOffsetInBytes   = pReqCtx->assoclen;
+#else
+    pReqCtx->sym_op_data.cryptoStartSrcOffsetInBytes   = pReqCtx->assoclen + iv_len;
+#endif
+    pReqCtx->sym_op_data.messageLenToHashInBytes       = 0;
+    pReqCtx->sym_op_data.messageLenToCipherInBytes     = pReqCtx->cryptlen;
+  }
+
+  messageLen = pReqCtx->cryptlen;
+
+  if (CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT == cipherDirection) {
+
+    geniv = geniv ? iv_len : 0;
+
+    /* Generating IV - set iv=0 and encrypt an extra block */
+    if (!ctx->gcm_mode) {
+      pReqCtx->sym_op_data.pIv                       = geniv ? pIvZero : iv;
+      pReqCtx->sym_op_data.messageLenToCipherInBytes = (messageLen + geniv);
+      pReqCtx->sym_op_data.messageLenToHashInBytes  += (messageLen + geniv);
+    } else {
+      u64 seqno64  =  atomic64_inc_return(&ctx->gcm_seqno);
+      memcpy(iv,                         &seqno64, iv_len);
+      memcpy(&pReqCtx->gcm_iv[GCM_NONCE_SIZE], iv, iv_len);
+    }
+
+    if (unlikely(wg_fips_iv)) {
+      memcpy(iv,  wg_fips_iv, iv_len);
+
+      if (!ctx->gcm_mode) {
+        pReqCtx->sym_op_data.pIv                          = iv;
+        pReqCtx->sym_op_data.cryptoStartSrcOffsetInBytes += iv_len;
+        pReqCtx->sym_op_data.messageLenToCipherInBytes   -= iv_len;
+      } else
+        memcpy(&pReqCtx->gcm_iv[GCM_NONCE_SIZE], iv, iv_len);
+
+      wg_fips_iv = NULL;
+    }
+
+  } else
+
+  if (CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT == cipherDirection) {
+
+    messageLen -= ctx->authSize;
+
+    /* Use given iv */
+    if (!ctx->gcm_mode) {
+      pReqCtx->sym_op_data.pIv                          = iv;
+      pReqCtx->sym_op_data.cryptoStartSrcOffsetInBytes += iv_len;
+      pReqCtx->sym_op_data.messageLenToCipherInBytes    = messageLen;
+      pReqCtx->sym_op_data.messageLenToHashInBytes     += (iv_len + messageLen);
+    } else {
+      pReqCtx->sym_op_data.messageLenToCipherInBytes   -= ctx->authSize;
+      memcpy(&pReqCtx->gcm_iv[GCM_NONCE_SIZE], iv, iv_len);
+    }
+
+  }
+
+  if (unlikely(console_loglevel & 16)) {
+    printk(KERN_DEBUG "%s: coff %2d clen %2d hlen %2d assoc %2d giv %2d\n",
+	   __FUNCTION__,
+           pReqCtx->sym_op_data.cryptoStartSrcOffsetInBytes,
+           pReqCtx->sym_op_data.messageLenToCipherInBytes,
+           pReqCtx->sym_op_data.messageLenToHashInBytes,
+           pReqCtx->assoclen, geniv);
+
+    if (pAssoc) {
+      printk(KERN_DEBUG "%s: assoc %p %5d\n", __FUNCTION__,
+               sg_virt(pAssoc), pReqCtx->assoclen);
+      PrintHex(sg_virt(pAssoc), pReqCtx->assoclen);
+    }
+
+    if (iv) {
+      printk(KERN_DEBUG "%s: iv    %p %5d\n", __FUNCTION__,
+               iv, iv_len);
+      PrintHex(iv, iv_len);
+    }
+
+    if (ctx->gcm_mode) {
+      printk(KERN_DEBUG "%s: salt  %p %5d\n", __FUNCTION__,
+               pReqCtx->sym_op_data.pIv, GCM_IV_SIZE);
+      PrintHex(pReqCtx->sym_op_data.pIv, GCM_IV_SIZE);
+    }
+
+    {
+      printk(KERN_DEBUG "%s: src   %p %5d\n", __FUNCTION__,
+               sg_virt(pReqCtx->src), pReqCtx->sym_op_data.messageLenToCipherInBytes);
+      PrintHex(sg_virt(pReqCtx->src), pReqCtx->src->length);
+    }
+  }
+
+  /* Workaround for IXA00378497 - enc performance drops if append flag set */
+  /* The pDigestResult needs to be set even when digestIsAppended is true,
+   * otherwise the performance test will not complete IXA00373239 */
+  pReqCtx->sym_op_data.pDigestResult = pReqCtx->result;
+
+  /* Check for multiple buffers */
+  if (unlikely(pReqCtx->srcList.numBuffers > 1)) {
+    u32                 offset = 0;
+    struct scatterlist *pCurr  = pReqCtx->src;
+
+    /* Find digest location */
+    for (;;) {
+      if (!pCurr) {
+        printk(KERN_EMERG "%s: Null data len %d off %d num %d\n",
+               __FUNCTION__, messageLen, offset, pReqCtx->srcList.numBuffers);
+        return -EFAULT;
+      }
+      if (messageLen < offset + pCurr->length)
+        break;
+
+      offset += pCurr->length;
+      pCurr = sg_next(pCurr);
+    }
+
+    /* Ensure digest is in 1 buffer */
+    if (messageLen + ctx->authSize >
+        offset + pCurr->length) {
+
+      pReqCtx->sym_op_data.pDigestResult =  pReqCtx->digestBuffer;
+      if (CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT == cipherDirection) {
+        /* need to copy here */
+        scatterwalk_map_and_copy(pReqCtx->digestBuffer,
+                                 pReqCtx->src, messageLen,
+                                 ctx->authSize,
+                                 0);
+      } else {
+        pReqCtx->digestCpy = 1;
+        pReqCtx->authSize  = ctx->authSize;
+      }
+    } else {
+      pReqCtx->sym_op_data.pDigestResult  = sg_virt(pCurr);
+      pReqCtx->sym_op_data.pDigestResult += (messageLen - offset);
+    }
+
+  } else {
+    if (likely(!pReqCtx->sym_op_data.pDigestResult))
+      pReqCtx->sym_op_data.pDigestResult = sg_virt(pReqCtx->src) + messageLen;
+  }
+
+  if (unlikely(console_loglevel & 16)) {
+    printk(KERN_DEBUG "%s: flat  %p %5d\n", __FUNCTION__,
+             pReqCtx->srcList.pBuffers[0].pData, pReqCtx->srcList.pBuffers[0].dataLenInBytes);
+    PrintHex(pReqCtx->srcList.pBuffers[0].pData, pReqCtx->srcList.pBuffers[0].dataLenInBytes);
+  }
+
+  if (likely(pReqCtx->dst == pReqCtx->src)) {
+    status = cpaCySymPerformOp(ctx->instance, (void *)pReqCtx,
+                               &(pReqCtx->sym_op_data),
+                               &(pReqCtx->srcList),
+                               &(pReqCtx->srcList),
+                               NULL);
+    if (CPA_STATUS_RETRY == status) {
+      return -EBUSY;
+    }
+    if (CPA_STATUS_SUCCESS != status) {
+      printk(KERN_ERR "%s: cpaCySymPerformOp failed. (status = (%d))\n",
+             __FUNCTION__, status);
+      return -EINVAL;
+    }
+  } else {
+    printk(KERN_ERR "%s: Out of place processing not supported\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  return -EINPROGRESS;
+}
+
+/* This function is used to remove encrypt/decrypt session */
+static void icp_crypto_free(struct icp_crypto_ctx *ctx,
+                            volatile CpaCySymSessionCtx *pSession,
+                            atomic_t *pSetKey)
+{
+  int                count;
+  CpaStatus          status;
+  CpaCySymSessionCtx session;
+
+  session = xchg_ptr(NULL, pSession);
+
+  if (!session) return;
+
+  status = CPA_STATUS_SUCCESS;
+
+  /* Free session */
+
+  if (atomic_dec_return(pSetKey) < 0)
+    atomic_set(pSetKey, 0);
+  else
+  for (count = ICP_RETRY_COUNT;
+       (status = cpaCySymRemoveSession(ctx->instance, session))
+         == CPA_STATUS_RETRY;) {
+    /* Count exhausted? */
+    if (--count <= 0) break;
+
+    /* Wait a while before retry */
+    set_current_state((long)TASK_INTERRUPTIBLE);
+    schedule_timeout(ICP_SESSION_REMOVE_TIME);
+  }
+
+  if (CPA_STATUS_SUCCESS != status)
+    printk(KERN_ERR "%s: Failed to remove session\n", __FUNCTION__);
+
+  kfree(session);
+}
+
+/* This function is used to remove encrypt/decrypt session */
+static void icp_crypto_exit(struct crypto_tfm *tfm)
+{
+  struct icp_crypto_ctx *ctx = (struct icp_crypto_ctx *)crypto_tfm_ctx(tfm);
+
+  mutex_lock(&ctx->mutexLock);
+
+  icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+  icp_crypto_free(ctx, &ctx->decrypt_ctx, &ctx->decrypt_key);
+
+  mutex_unlock(&ctx->mutexLock);
+}
+
+/* This function is used to set up icp_crypto_ctx */
+static int icp_crypto_init(struct crypto_tfm *tfm, unsigned int *pReqSize)
+{
+  CpaStatus                status;
+  CpaCySymSessionSetupData Setup = { 0 };
+  struct icp_crypto_ctx   *ctx   = crypto_tfm_ctx(tfm);
+
+  /* Set up the mutex */
+  mutex_init(&ctx->mutexLock);
+
+  /* Clear setkey flags */
+  atomic_set(&ctx->encrypt_key, 0);
+  atomic_set(&ctx->decrypt_key, 0);
+
+  /* Get instance */
+  ctx->instance = get_instance();
+
+  /* get meta data size */
+  ctx->metaSize = 0;
+  status = cpaCyBufferListGetMetaSize(ctx->instance, ICP_MAX_NUM_BUFFERS,
+                                      &ctx->metaSize);
+  if (CPA_STATUS_SUCCESS != status) {
+    printk(KERN_ERR "%s: Failed to get meta size\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  ctx->requestSize = sizeof(struct icp_crypto_req_ctx) + ctx->metaSize;
+  if (pReqSize) *pReqSize = ctx->requestSize;
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: ctx %p size %d\n", __FUNCTION__,
+         ctx, ctx->requestSize);
+
+  /* alloc session memory */
+  /* Note: for current driver the session size does not depend on
+   *  the setup data */
+  ctx->sessionSize = 0;
+  status = cpaCySymSessionCtxGetSize(ctx->instance, &Setup,
+                                     &ctx->sessionSize);
+  if (CPA_STATUS_SUCCESS != status) {
+    printk(KERN_ERR "%s: Failed to get session size\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  return 0;
+}
+
+/* This function is used to set up icp_crypto_ctx */
+#ifdef	CONFIG_WG_KERNEL_4_14
+static void aead_exit_tfm(struct crypto_aead *tfm)
+{
+  return icp_crypto_exit(&tfm->base);
+}
+static int  aead_init_tfm(struct crypto_aead *tfm)
+{
+  return icp_crypto_init(&tfm->base, &tfm->reqsize);
+}
+#else
+static int  aead_init_tfm(struct crypto_tfm *tfm)
+{
+  return icp_crypto_init(tfm, &tfm->crt_aead.reqsize);
+}
+#endif
+
+/* This function initialises encrypt and decrypt sessions with the key */
+static int aead_setkey(struct crypto_aead *aead_tfm,
+                const Cpa8U * key, unsigned int keylen)
+{
+  int op    = 0;
+  int chain = 0;
+
+  struct rtattr                   *pRta   = (void *)key;
+  struct crypto_authenc_key_param *pParam = NULL;
+  struct icp_crypto_ctx           *ctx    = crypto_aead_ctx(aead_tfm);
+  struct crypto_tfm               *tfm    = crypto_aead_tfm(aead_tfm);
+  const  char                     *name   = crypto_tfm_alg_name(tfm);
+
+  unsigned int enckeylen  = 0;
+  unsigned int authkeylen = 0;
+  unsigned int iv_len     = crypto_aead_ivsize(aead_tfm);
+
+  CpaStatus                status;
+  CpaCySymCipherAlgorithm  cipherAlgorithm;
+  CpaCySymHashAlgorithm    hashAlgorithm;
+  CpaCySymSessionSetupData Setup = { 0 };
+
+  icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+  icp_crypto_free(ctx, &ctx->decrypt_ctx, &ctx->decrypt_key);
+
+  ctx->encrypt_ctx = kzalloc(ctx->sessionSize, GFP_KERNEL);
+  if (NULL == ctx->encrypt_ctx) {
+    printk(KERN_ERR "%s: Failed to alloc encrypt session\n", __FUNCTION__);
+    return -ENOMEM;
+  }
+
+  ctx->decrypt_ctx = kzalloc(ctx->sessionSize, GFP_KERNEL);
+  if (NULL == ctx->decrypt_ctx) {
+    printk(KERN_ERR "%s: Failed to alloc decrypt session\n", __FUNCTION__);
+    kfree(ctx->encrypt_ctx);
+    ctx->encrypt_ctx = NULL;
+    return -ENOMEM;
+  }
+
+  /* Check for GCM */
+  if ((ctx->gcm_mode = (strstr(name, "gcm") != NULL))) {
+
+    if ((enckeylen = keylen) < GCM_NONCE_SIZE)
+      return -EINVAL;
+
+    memcpy(&ctx->gcm_nonce, &key[enckeylen -= GCM_NONCE_SIZE], GCM_NONCE_SIZE);
+
+    cipherAlgorithm = CPA_CY_SYM_CIPHER_AES_GCM;
+    hashAlgorithm   = CPA_CY_SYM_HASH_AES_GCM;
+
+    ctx->authSize   = GCM_DIGEST_SIZE;
+
+    if (unlikely(console_loglevel & 16)) {
+      printk(KERN_DEBUG "%s: ctx %p authsize %d name %s\n",
+             __FUNCTION__, ctx, ctx->authSize, name);
+      printk(KERN_DEBUG "%s: ctx %p ivlen %2d key %p klen %2d nonce %d\n",
+             __FUNCTION__, ctx, iv_len, key, keylen, GCM_NONCE_SIZE);
+      PrintHex((u8*)&ctx->gcm_nonce, GCM_NONCE_SIZE);
+    }
+
+  }
+  else
+  {
+
+  /* The key we receive is the concatenation of:
+     - flags (length is RTA_ALIGN(pRta->rta_len))
+     - authentication key (length can be computed)
+     - cipher key (length is given by the flags)
+  */
+  if (!RTA_OK(pRta, keylen)) {
+    crypto_aead_set_flags(aead_tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+    printk(KERN_ERR "%s: Bad key\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  if (pRta->rta_type != CRYPTO_AUTHENC_KEYA_PARAM) {
+    crypto_aead_set_flags(aead_tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+    printk(KERN_ERR "%s: Bad key rta_type\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  if (RTA_PAYLOAD(pRta) < sizeof(*pParam)) {
+    crypto_aead_set_flags(aead_tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+    printk(KERN_ERR "%s: Bad key rta_payload\n", __FUNCTION__);
+    return -EINVAL;
+  }
+
+  pParam     = RTA_DATA(pRta);
+
+  enckeylen  = be32_to_cpu(pParam->enckeylen);
+  key       += RTA_ALIGN(pRta->rta_len);
+  keylen    -= RTA_ALIGN(pRta->rta_len);
+  authkeylen = keylen - enckeylen;
+
+  if (unlikely(console_loglevel & 16)) {
+  printk(KERN_DEBUG "%s: ctx %p authsize %d asize %d name %s\n",
+         __FUNCTION__, ctx, ctx->authSize, get_asize(name), name);
+  printk(KERN_DEBUG "%s: ctx %p ivlen %2d key %p elen %2d alen %2d\n",
+         __FUNCTION__, ctx, iv_len, key, enckeylen, authkeylen);
+  }
+
+  if (keylen < enckeylen) {
+    crypto_aead_set_flags(aead_tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+    printk(KERN_ERR "%s: Bad key, enckeylen is greater than keylen\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  cipherAlgorithm = get_etype(enckeylen, iv_len);
+  hashAlgorithm   = get_atype(get_asize(name));
+
+  }
+
+  if (likely((cipherAlgorithm > 0) && (hashAlgorithm > 0)))
+    op = CPA_CY_SYM_OP_ALGORITHM_CHAINING;
+  else
+  if (likely(cipherAlgorithm > 0))
+    op = CPA_CY_SYM_OP_CIPHER;
+  else
+  if (likely(hashAlgorithm > 0))
+    op = CPA_CY_SYM_OP_HASH;
+  else
+    return 0;
+
+  if (likely(op == CPA_CY_SYM_OP_ALGORITHM_CHAINING))
+    chain = -1;
+
+  if (unlikely(console_loglevel & 16)) {
+  printk(KERN_DEBUG "%s: ctx %p ealg %d aalg %d chain %d\n",
+         __FUNCTION__, ctx, cipherAlgorithm, hashAlgorithm, chain);
+  PrintHex(key,           authkeylen);
+  PrintHex(key+authkeylen, enckeylen);
+  }
+
+  /* Get salt */
+  if (iv_len > 0) {
+    int res = crypto_rng_get_bytes(crypto_default_rng, ctx->salt, iv_len);
+
+    if (res != 0) {
+      printk(KERN_ERR "%s: crypto_rng_get_bytes error\n", __FUNCTION__);
+      return res;
+    }
+
+    memcpy(&ctx->gcm_seqno, &ctx->salt, GCM_ESP_IV_SIZE);
+  }
+
+  /* Initialise sessions */
+
+  Setup.sessionPriority = CPA_CY_PRIORITY_HIGH;
+
+  Setup.symOperation = op;
+
+  if (likely(cipherAlgorithm > 0)) {
+    Setup.cipherSetupData.cipherAlgorithm = cipherAlgorithm;
+    Setup.cipherSetupData.pCipherKey = (Cpa8U *) key + authkeylen;
+    Setup.cipherSetupData.cipherKeyLenInBytes = enckeylen;
+  }
+
+  if (likely(hashAlgorithm > 0)) {
+    Setup.hashSetupData.hashAlgorithm = hashAlgorithm;
+    Setup.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+    if (hashAlgorithm == CPA_CY_SYM_HASH_AES_GCM) {
+    Setup.hashSetupData.authModeSetupData.aadLenInBytes = GCM_AAD_SIZE;
+    if (unlikely(wg_fips_aad_len)) {
+    Setup.hashSetupData.authModeSetupData.aadLenInBytes = wg_fips_aad_len;
+    wg_fips_aad_len = 0;
+    }
+    } else {
+    Setup.hashSetupData.authModeSetupData.authKey = (Cpa8U *)key;
+    Setup.hashSetupData.authModeSetupData.authKeyLenInBytes = authkeylen;
+    }
+    Setup.hashSetupData.digestResultLenInBytes = ctx->authSize;
+  }
+
+  /* encrypt first */
+  Setup.cipherSetupData.cipherDirection = CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+  Setup.algChainOrder = CPA_CY_SYM_ALG_CHAIN_ORDER_CIPHER_THEN_HASH & chain;
+
+/* Workaround for IXA00378497 - enc performance drop when append flag is set */
+/* Using the same append config for encrypt/decrypt */
+  Setup.digestIsAppended = CPA_FALSE;
+  Setup.verifyDigest     = CPA_FALSE;
+
+  /* Lock the context */
+  mutex_lock(&ctx->mutexLock);
+
+  /* Initialize the cipher enc session */
+  status = cpaCySymInitSession(ctx->instance, symCallback,
+                               &Setup, ctx->encrypt_ctx);
+  if (CPA_STATUS_SUCCESS != status) {
+    /* Unlock the context */
+    icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+    mutex_unlock(&ctx->mutexLock);
+
+    printk(KERN_ERR "%s: Failed to initialize encryption session\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  /* Set that encrypt key is set up */
+  atomic_set(&ctx->encrypt_key, 1);
+
+  /* now setup the decrypt session */
+  Setup.cipherSetupData.cipherDirection = CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+  Setup.algChainOrder = CPA_CY_SYM_ALG_CHAIN_ORDER_HASH_THEN_CIPHER & chain;
+
+  Setup.verifyDigest = CPA_TRUE;
+
+  /* Initialize the cipher decrypt session */
+  status = cpaCySymInitSession(ctx->instance, symCallback,
+                               &Setup, ctx->decrypt_ctx);
+  if (CPA_STATUS_SUCCESS != status) {
+    /* Unlock the context */
+    icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+    icp_crypto_free(ctx, &ctx->decrypt_ctx, &ctx->decrypt_key);
+    mutex_unlock(&ctx->mutexLock);
+
+    printk(KERN_ERR "%s: Failed to initialize decryption session\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  /* Set that decrypt key is set up */
+  atomic_set(&ctx->decrypt_key, 1);
+
+  /* Unlock the context */
+  mutex_unlock(&ctx->mutexLock);
+
+  return 0;
+}
+
+/* This function set the authsize */
+static int aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
+{
+  struct icp_crypto_ctx *ctx = (struct icp_crypto_ctx *)crypto_aead_ctx(tfm);
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: tfm %p ctx %p authsize %2d\n", __FUNCTION__,
+         tfm, ctx, authsize);
+
+  ctx->authSize = authsize;
+
+  return 0;
+}
+
+/* This function initiates encryption/decryption */
+static int aead_perform(struct aead_request *req, u8 *iv,
+                        int direction, int giv)
+{
+  struct crypto_aead        *aead_tfm = crypto_aead_reqtfm(req);
+  struct icp_crypto_ctx     *ctx      = crypto_aead_ctx(aead_tfm);
+  struct icp_crypto_req_ctx *req_ctx  = aead_request_ctx(req);
+
+  req_ctx->cryptlen = req->cryptlen;
+  req_ctx->assoclen = req->assoclen;
+#ifdef	CONFIG_WG_KERNEL_4_14
+  req_ctx->assoc    = NULL;
+#else
+  req_ctx->assoc    = req->assoc;
+#endif
+  req_ctx->src      = req->src;
+  req_ctx->dst      = req->dst;
+  req_ctx->result   = NULL;
+
+  return perform_sym_op(&req->base, ctx, req_ctx,
+                        iv, crypto_aead_ivsize(aead_tfm),
+                        direction, giv);
+}
+
+/* This function initiates decryption */
+static int aead_encrypt(struct aead_request *req)
+{
+  return aead_perform(req, req->iv,
+                      CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT, 0);
+}
+
+/* This function initiates decryption */
+static int aead_decrypt(struct aead_request *req)
+{
+  return aead_perform(req, req->iv,
+                      CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT, 0);
+}
+
+#ifndef	CONFIG_WG_KERNEL_4_14
+/* Generate IV encryption */
+static int aead_givencrypt(struct aead_givcrypt_request *giv_req)
+{
+  struct aead_request *req     = &(giv_req->areq);
+  struct crypto_aead *aead_tfm = crypto_aead_reqtfm(req);
+  struct icp_crypto_ctx *ctx   = crypto_aead_ctx(aead_tfm);
+  int iv_len                   = crypto_aead_ivsize(aead_tfm);
+  u64 seq                      = cpu_to_be64(giv_req->seq);
+
+  memcpy(giv_req->giv, ctx->salt, iv_len);
+  memcpy(giv_req->giv + iv_len - sizeof(seq), &seq, sizeof(seq));
+
+  return aead_perform(req, giv_req->giv,
+                      CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT, 1);
+}
+#endif
+
+#ifdef	CONFIG_WG_KERNEL_4_14
+static struct icp_aead {
+  struct aead_alg aead;
+} icp_aeads[] = {
+#ifdef	GCM_HW
+{
+  .aead = { .base = {
+    .cra_name		= "rfc4106(gcm(aes))",
+    .cra_driver_name	= "rfc4106_gcm_aes_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= GCM_ESP_IV_SIZE,
+    .maxauthsize	= GCM_DIGEST_SIZE,
+  },
+},
+#endif
+#ifdef	NULL_HW
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(digest_null,cbc(cipher_null))",
+    .cra_driver_name	= "authenc_digest_null_cbc_cipher_null_icp",
+    .cra_blocksize	= 1,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= 000*000,
+    .maxauthsize	= 000*000,
+  },
+},
+#endif
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha1),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= 000*000,
+    .maxauthsize	= SHA1_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha256),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= 000*000,
+    .maxauthsize	= SHA256_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha384),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= 000*000,
+    .maxauthsize	= SHA384_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha512),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= 000*000,
+    .maxauthsize	= SHA512_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(digest_null,cbc(des3_ede))",
+    .cra_driver_name	= "authenc_digest_null_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES3_EDE_BLOCK_SIZE,
+    .maxauthsize	= 000*000,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(digest_null,cbc(aes))",
+    .cra_driver_name	= "authenc_digest_null_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= AES_BLOCK_SIZE,
+    .maxauthsize	= 000*000,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha1),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES3_EDE_BLOCK_SIZE,
+    .maxauthsize	= SHA1_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha256),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES3_EDE_BLOCK_SIZE,
+    .maxauthsize	= SHA256_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha384),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES3_EDE_BLOCK_SIZE,
+    .maxauthsize	= SHA384_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha512),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES3_EDE_BLOCK_SIZE,
+    .maxauthsize	= SHA512_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha1),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= AES_BLOCK_SIZE,
+    .maxauthsize	= SHA1_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha256),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= AES_BLOCK_SIZE,
+    .maxauthsize	= SHA256_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha384),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= AES_BLOCK_SIZE,
+    .maxauthsize	= SHA384_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha512),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= AES_BLOCK_SIZE,
+    .maxauthsize	= SHA512_DIGEST_SIZE,
+  },
+},
+#ifdef	MD5_HW
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(md5),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= 000*000,
+    .maxauthsize	= MD5_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(md5),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES3_EDE_BLOCK_SIZE,
+    .maxauthsize	= MD5_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(md5),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= AES_BLOCK_SIZE,
+    .maxauthsize	= MD5_DIGEST_SIZE,
+  },
+},
+#endif
+#ifdef	DES_HW
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(digest_null,cbc(des))",
+    .cra_driver_name	= "authenc_digest_null_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES_BLOCK_SIZE,
+    .maxauthsize	= 000*000
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha1),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES_BLOCK_SIZE,
+    .maxauthsize	= SHA1_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha256),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES_BLOCK_SIZE,
+    .maxauthsize	= SHA256_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha384),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES_BLOCK_SIZE,
+    .maxauthsize	= SHA384_DIGEST_SIZE,
+  },
+},
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(sha512),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES_BLOCK_SIZE,
+    .maxauthsize	= SHA512_DIGEST_SIZE,
+  },
+},
+#ifdef	MD5_HW
+{
+  .aead = { .base = {
+    .cra_name		= "authenc(hmac(md5),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    },
+    .ivsize		= DES_BLOCK_SIZE,
+    .maxauthsize	= MD5_DIGEST_SIZE,
+  },
+},
+#endif
+#endif
+};
+#else
+static struct icp_aead {
+  struct crypto_alg crypto;
+} icp_aeads[] = {
+#ifdef	GCM_HW
+{
+  .crypto = {
+    .cra_name		= "rfc4106(gcm(aes))",
+    .cra_driver_name	= "rfc4106_gcm_aes_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= GCM_ESP_IV_SIZE,
+        .maxauthsize	= GCM_DIGEST_SIZE,
+      }
+    }
+  },
+},
+#endif
+#ifdef	NULL_HW
+{
+  .crypto = {
+    .cra_name		= "authenc(digest_null,cbc(cipher_null))",
+    .cra_driver_name	= "authenc_digest_null_cbc_cipher_null_icp",
+    .cra_blocksize	= 1,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= 000*000,
+        .maxauthsize	= 000*000,
+      }
+    }
+  },
+},
+#endif
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha1),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= 000*000,
+        .maxauthsize	= SHA1_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha256),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= 000*000,
+        .maxauthsize	= SHA256_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha384),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= 000*000,
+        .maxauthsize	= SHA384_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha512),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= 000*000,
+        .maxauthsize	= SHA512_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(digest_null,cbc(des3_ede))",
+    .cra_driver_name	= "authenc_digest_null_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES3_EDE_BLOCK_SIZE,
+        .maxauthsize	= 000*000,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(digest_null,cbc(aes))",
+    .cra_driver_name	= "authenc_digest_null_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= AES_BLOCK_SIZE,
+        .maxauthsize	= 000*000,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha1),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES3_EDE_BLOCK_SIZE,
+        .maxauthsize	= SHA1_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha256),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES3_EDE_BLOCK_SIZE,
+        .maxauthsize	= SHA256_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha384),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES3_EDE_BLOCK_SIZE,
+        .maxauthsize	= SHA384_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha512),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES3_EDE_BLOCK_SIZE,
+        .maxauthsize	= SHA512_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha1),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= AES_BLOCK_SIZE,
+        .maxauthsize	= SHA1_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha256),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= AES_BLOCK_SIZE,
+        .maxauthsize	= SHA256_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha384),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= AES_BLOCK_SIZE,
+        .maxauthsize	= SHA384_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha512),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= AES_BLOCK_SIZE,
+        .maxauthsize	= SHA512_DIGEST_SIZE,
+      }
+    }
+  },
+},
+#ifdef	MD5_HW
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(md5),cbc(cipher_null))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_cipher_null_icp",
+    .cra_blocksize	= 4,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= 000*000,
+        .maxauthsize	= MD5_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(md5),cbc(des3_ede))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES3_EDE_BLOCK_SIZE,
+        .maxauthsize	= MD5_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(md5),cbc(aes))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= AES_BLOCK_SIZE,
+        .maxauthsize	= MD5_DIGEST_SIZE,
+      }
+    }
+  },
+},
+#endif
+#ifdef	DES_HW
+{
+  .crypto = {
+    .cra_name		= "authenc(digest_null,cbc(des))",
+    .cra_driver_name	= "authenc_digest_null_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES_BLOCK_SIZE,
+        .maxauthsize	= 000*000
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha1),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha1_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES_BLOCK_SIZE,
+        .maxauthsize	= SHA1_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha256),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha256_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES_BLOCK_SIZE,
+        .maxauthsize	= SHA256_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha384),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha384_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES_BLOCK_SIZE,
+        .maxauthsize	= SHA384_DIGEST_SIZE,
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(sha512),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_sha512_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES_BLOCK_SIZE,
+        .maxauthsize	= SHA512_DIGEST_SIZE,
+      }
+    }
+  },
+},
+#ifdef	MD5_HW
+{
+  .crypto = {
+    .cra_name		= "authenc(hmac(md5),cbc(des))",
+    .cra_driver_name	= "authenc_hmac_md5_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_AEAD,
+    .cra_type		= &crypto_aead_type,
+    .cra_u		= { .aead = {
+        .ivsize		= DES_BLOCK_SIZE,
+        .maxauthsize	= MD5_DIGEST_SIZE,
+      }
+    }
+  },
+},
+#endif
+#endif
+};
+#endif
+
+#ifdef	ABLK_HW
+
+static int  ablk_setkey(struct crypto_ablkcipher *ablk_tfm,
+                        const Cpa8U * key, unsigned int keylen)
+{
+  CpaStatus                status;
+  CpaCySymCipherAlgorithm  cipherAlgorithm;
+  CpaCySymSessionSetupData Setup = { 0 };
+  struct icp_crypto_ctx   *ctx   = crypto_ablkcipher_ctx(ablk_tfm);
+
+  unsigned int iv_len = crypto_ablkcipher_ivsize(ablk_tfm);
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: ctx %p ivlen %2d key %p elen %2d\n",
+         __FUNCTION__, ctx, iv_len, key, keylen);
+
+  icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+  icp_crypto_free(ctx, &ctx->decrypt_ctx, &ctx->decrypt_key);
+
+  ctx->encrypt_ctx = kzalloc(ctx->sessionSize, GFP_KERNEL);
+  if (NULL == ctx->encrypt_ctx) {
+    printk(KERN_ERR "%s: Failed to alloc encrypt session\n", __FUNCTION__);
+    return -ENOMEM;
+  }
+
+  ctx->decrypt_ctx = kzalloc(ctx->sessionSize, GFP_KERNEL);
+  if (NULL == ctx->decrypt_ctx) {
+    printk(KERN_ERR "%s: Failed to alloc decrypt session\n", __FUNCTION__);
+    kfree(ctx->encrypt_ctx);
+    ctx->encrypt_ctx = NULL;
+    return -ENOMEM;
+  }
+
+  /* Get salt */
+  if (iv_len > 0) {
+    int res = crypto_rng_get_bytes(crypto_default_rng, ctx->salt, iv_len);
+
+    if (res != 0) {
+      printk(KERN_ERR "%s: crypto_rng_get_bytes error\n", __FUNCTION__);
+      return res;
+    }
+  }
+
+  cipherAlgorithm = get_etype(keylen, iv_len);
+
+  /* Initialise sessions */
+
+  Setup.sessionPriority                     = CPA_CY_PRIORITY_HIGH;
+  Setup.symOperation                        = CPA_CY_SYM_OP_CIPHER;
+  Setup.cipherSetupData.cipherAlgorithm     = cipherAlgorithm;
+  Setup.cipherSetupData.pCipherKey          = (Cpa8U *) key;
+  Setup.cipherSetupData.cipherKeyLenInBytes = keylen;
+
+  /* encrypt first */
+  Setup.cipherSetupData.cipherDirection = CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+
+/* Workaround for IXA00378497 - enc performance drop when append flag is set */
+/* Using the same append config for encrypt/decrypt */
+  Setup.digestIsAppended = CPA_FALSE;
+  Setup.verifyDigest     = CPA_FALSE;
+
+  /* Lock the context */
+  mutex_lock(&ctx->mutexLock);
+
+  /* Initialize the cipher enc session */
+  status = cpaCySymInitSession(ctx->instance, symCallback,
+                               &Setup, ctx->encrypt_ctx);
+  if (CPA_STATUS_SUCCESS != status) {
+    /* Unlock the context */
+    icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+    mutex_unlock(&ctx->mutexLock);
+
+    printk(KERN_ERR "%s: Failed to initialize encryption session\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  /* Set that encrypt key is set up */
+  atomic_set(&ctx->encrypt_key, 1);
+
+  /* now setup the decrypt session */
+  Setup.cipherSetupData.cipherDirection = CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+
+  /* Initialize the cipher decrypt session */
+  status = cpaCySymInitSession(ctx->instance, symCallback,
+                               &Setup, ctx->decrypt_ctx);
+  if (CPA_STATUS_SUCCESS != status) {
+    /* Unlock the context */
+    icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+    icp_crypto_free(ctx, &ctx->decrypt_ctx, &ctx->decrypt_key);
+    mutex_unlock(&ctx->mutexLock);
+
+    printk(KERN_ERR "%s: Failed to initialize decryption session\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  /* Set that decrypt key is set up */
+  atomic_set(&ctx->decrypt_key, 1);
+
+  /* Unlock the context */
+  mutex_unlock(&ctx->mutexLock);
+
+  return 0;
+}
+
+static int ablk_init_tfm(struct crypto_tfm *tfm)
+{
+  return icp_crypto_init(tfm, &tfm->crt_ablkcipher.reqsize);
+}
+
+static int ablk_perform(struct ablkcipher_request *req, int direction)
+{
+  struct crypto_ablkcipher  *tfm     = crypto_ablkcipher_reqtfm(req);
+  struct icp_crypto_ctx     *ctx     = crypto_ablkcipher_ctx(tfm);
+  struct icp_crypto_req_ctx *req_ctx = ablkcipher_request_ctx(req);
+
+  req_ctx->cryptlen = req->nbytes;
+  req_ctx->assoclen = 0;
+  req_ctx->assoc    = NULL;
+  req_ctx->src      = req->src;
+  req_ctx->dst      = req->dst;
+  req_ctx->result   = NULL;
+
+  return perform_sym_op(&req->base, ctx, req_ctx, NULL,
+                        crypto_ablkcipher_ivsize(tfm),
+                        direction, 0);
+}
+
+static int ablk_encrypt(struct ablkcipher_request *req)
+{
+  return ablk_perform(req, CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT);
+}
+
+static int ablk_decrypt(struct ablkcipher_request *req)
+{
+  return ablk_perform(req, CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT);
+}
+
+static struct icp_ablk {
+  struct crypto_alg crypto;
+} icp_ablks[] = {
+{
+  .crypto = {
+    .cra_name		= "ablk(cbc(des3_ede))",
+    .cra_driver_name	= "ablk_cbc_des3_ede_icp",
+    .cra_blocksize	= DES3_EDE_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER,
+    .cra_type		= &crypto_ablkcipher_type,
+    .cra_u		= { .ablkcipher = {
+        .min_keysize	= DES3_EDE_KEY_SIZE,
+        .max_keysize	= DES3_EDE_KEY_SIZE,
+        .ivsize		= DES3_EDE_BLOCK_SIZE,
+        .geniv		= "eseqiv",
+      }
+    }
+  },
+},
+{
+  .crypto = {
+    .cra_name		= "ablk(cbc(aes))",
+    .cra_driver_name	= "ablk_cbc_aes_icp",
+    .cra_blocksize	= AES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER,
+    .cra_type		= &crypto_ablkcipher_type,
+    .cra_u		= { .ablkcipher = {
+        .min_keysize	= AES_MIN_KEY_SIZE,
+        .max_keysize	= AES_MAX_KEY_SIZE,
+        .ivsize		= AES_BLOCK_SIZE,
+        .geniv		= "eseqiv",
+      }
+    }
+  },
+},
+#ifdef	DES_HW
+{
+  .crypto = {
+    .cra_name		= "ablk(cbc(des))",
+    .cra_driver_name	= "ablk_cbc_des_icp",
+    .cra_blocksize	= DES_BLOCK_SIZE,
+    .cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER,
+    .cra_type		= &crypto_ablkcipher_type,
+    .cra_u		= { .ablkcipher = {
+        .min_keysize	= DES_KEY_SIZE,
+        .max_keysize	= DES_KEY_SIZE,
+        .ivsize		= DES_BLOCK_SIZE,
+  .geniv		= "eseqiv",
+      }
+    }
+  },
+},
+#endif
+};
+
+#endif
+
+#ifdef	AHASH_HW
+
+static void ahash_dump(const char* func, struct ahash_request* areq)
+{
+  if (likely(areq)) {
+    PrintK(KERN_DEBUG "%s: areq %p base %p nbytes %d result %p\n", func,
+           areq, &areq->base, areq->nbytes, areq->result);
+    PrintK(KERN_DEBUG "%s: complete %p data %p\n", func,
+           areq->base.complete, areq->base.data);
+  }
+  else
+    printk(KERN_EMERG "%s: areq %p\n", func, areq);
+}
+
+static int  ahash_init_tfm(struct crypto_tfm *tfm)
+{
+  return icp_crypto_init(tfm, NULL);
+}
+
+static int  ahash_setkey(struct crypto_ahash *ahash_tfm, const u8 *key,
+                         unsigned int keylen)
+{
+  CpaStatus                status;
+  CpaCySymHashAlgorithm    hashAlgorithm;
+  CpaCySymSessionSetupData Setup = { 0 };
+  struct icp_crypto_ctx   *ctx   = crypto_ahash_ctx(ahash_tfm);
+  struct crypto_tfm       *tfm   = crypto_ahash_tfm(ahash_tfm);
+  const  char             *name  = crypto_tfm_alg_name(tfm);
+
+  /* Set request size */
+  ahash_tfm->reqsize    = ctx->requestSize;
+
+  /* Set authsize */
+  ctx->authSize         = get_asize(name);
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: ctx %p key %p len %2d auth %2d req %2d '%s'\n",
+         __FUNCTION__, ctx, key, keylen,
+         ctx->authSize, ctx->requestSize, name);
+
+  hashAlgorithm         = get_atype(ctx->authSize);
+
+  Setup.sessionPriority = CPA_CY_PRIORITY_HIGH;
+  Setup.symOperation    = CPA_CY_SYM_OP_HASH;
+
+  Setup.hashSetupData.digestResultLenInBytes = ctx->authSize;
+  Setup.hashSetupData.hashAlgorithm          = hashAlgorithm;
+  Setup.hashSetupData.authModeSetupData.authKeyLenInBytes = keylen;
+
+  if (likely(keylen > 0)) {
+    Setup.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+    Setup.hashSetupData.authModeSetupData.authKey = (Cpa8U *)key;
+  } else {
+    Setup.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_PLAIN;
+    Setup.hashSetupData.authModeSetupData.authKey = (Cpa8U *)"";
+  }
+
+/* Workaround for IXA00378497 - enc performance drop when append flag is set */
+/* Using the same append config for encrypt/decrypt */
+  Setup.digestIsAppended = CPA_FALSE;
+  Setup.verifyDigest     = CPA_FALSE;
+
+  icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+
+  ctx->encrypt_ctx = kzalloc(ctx->sessionSize, GFP_KERNEL);
+  if (NULL == ctx->encrypt_ctx) {
+    printk(KERN_ERR "%s: Failed to alloc encrypt session\n", __FUNCTION__);
+    return -ENOMEM;
+  }
+
+  /* Lock the context */
+  mutex_lock(&ctx->mutexLock);
+
+  /* Initialize the cipher enc session */
+  status = cpaCySymInitSession(ctx->instance, symCallback,
+                               &Setup, ctx->encrypt_ctx);
+  if (CPA_STATUS_SUCCESS != status) {
+    /* Unlock the context */
+    icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+    mutex_unlock(&ctx->mutexLock);
+
+    printk(KERN_ERR "%s: Failed to initialize encryption session\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  /* Set that encrypt key is set up */
+  atomic_set(&ctx->encrypt_key, 1);
+
+  /* Unlock the context */
+  mutex_unlock(&ctx->mutexLock);
+
+  return 0;
+}
+
+static int ahash_init(struct ahash_request *areq)
+{
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: areq %p\n", __FUNCTION__, areq);
+
+  ahash_dump(__FUNCTION__, areq);
+
+  return 0;
+}
+
+static int ahash_process_req(struct ahash_request *areq, unsigned int nbytes)
+{
+  struct crypto_ahash       *tfm     = crypto_ahash_reqtfm(areq);
+  struct icp_crypto_ctx     *ctx     = crypto_ahash_ctx(tfm);
+  struct icp_crypto_req_ctx *req_ctx = ahash_request_ctx(areq);
+
+  if (unlikely(console_loglevel & 16))
+    printk(KERN_DEBUG "%s: ctx %p len %d\n", __FUNCTION__, ctx, nbytes);
+
+  req_ctx->cryptlen = nbytes;
+  req_ctx->assoclen = 0;
+  req_ctx->assoc    = NULL;
+  req_ctx->src      = areq->src;
+  req_ctx->dst      = areq->src;
+  req_ctx->result   = areq->result;
+
+  return perform_sym_op(&areq->base, ctx, req_ctx, NULL, 0,
+                        CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT, 0);
+}
+
+static int ahash_digest(struct ahash_request *areq)
+{
+  ahash_dump(__FUNCTION__, areq);
+
+  return ahash_process_req(areq, areq->nbytes);
+}
+
+static int ahash_update(struct ahash_request *areq)
+{
+  ahash_dump(__FUNCTION__, areq);
+
+  return ahash_process_req(areq, areq->nbytes);
+}
+
+static int ahash_final(struct ahash_request *areq)
+{
+  ahash_dump(__FUNCTION__, areq);
+
+  return ahash_process_req(areq, 0);
+}
+
+static int ahash_finup(struct ahash_request *areq)
+{
+  ahash_dump(__FUNCTION__, areq);
+
+  return ahash_process_req(areq, areq->nbytes);
+}
+
+static struct icp_ahash {
+  struct ahash_alg ahash;
+} icp_ahashs[] = {
+{
+  .ahash = {
+    .init		= ahash_init,
+    .update		= ahash_update,
+    .final		= ahash_final,
+    .finup		= ahash_finup,
+    .digest		= ahash_digest,
+    .setkey		= ahash_setkey,
+    .halg.digestsize    = SHA1_DIGEST_SIZE,
+    .halg.statesize     = SHA1_BLOCK_SIZE*2,
+    .halg.base = {
+      .cra_name		= "auth(sha1)",
+      .cra_driver_name	= "auth_sha1_icp",
+      .cra_blocksize	= SHA1_BLOCK_SIZE,
+      .cra_flags	= CRYPTO_ALG_TYPE_AHASH,
+      .cra_type		= &crypto_ahash_type,
+    }
+  }
+},
+{
+  .ahash = {
+    .init		= ahash_init,
+    .update		= ahash_update,
+    .final		= ahash_final,
+    .finup		= ahash_finup,
+    .digest		= ahash_digest,
+    .setkey		= ahash_setkey,
+    .halg.digestsize    = SHA256_DIGEST_SIZE,
+    .halg.statesize     = SHA256_BLOCK_SIZE*2,
+    .halg.base = {
+      .cra_name		= "auth(sha256)",
+      .cra_driver_name	= "auth_sha256_icp",
+      .cra_blocksize	= SHA256_BLOCK_SIZE,
+      .cra_flags	= CRYPTO_ALG_TYPE_AHASH,
+      .cra_type		= &crypto_ahash_type,
+    }
+  }
+},
+{
+  .ahash = {
+    .init		= ahash_init,
+    .update		= ahash_update,
+    .final		= ahash_final,
+    .finup		= ahash_finup,
+    .digest		= ahash_digest,
+    .setkey		= ahash_setkey,
+    .halg.digestsize    = SHA384_DIGEST_SIZE,
+    .halg.statesize     = SHA384_BLOCK_SIZE*2,
+    .halg.base = {
+      .cra_name		= "auth(sha384)",
+      .cra_driver_name	= "auth_sha384_icp",
+      .cra_blocksize	= SHA384_BLOCK_SIZE,
+      .cra_flags	= CRYPTO_ALG_TYPE_AHASH,
+      .cra_type		= &crypto_ahash_type,
+    }
+  }
+},
+{
+  .ahash = {
+    .init		= ahash_init,
+    .update		= ahash_update,
+    .final		= ahash_final,
+    .finup		= ahash_finup,
+    .digest		= ahash_digest,
+    .setkey		= ahash_setkey,
+    .halg.digestsize    = SHA512_DIGEST_SIZE,
+    .halg.statesize     = SHA512_BLOCK_SIZE*2,
+    .halg.base = {
+      .cra_name		= "auth(sha512)",
+      .cra_driver_name	= "auth_sha512_icp",
+      .cra_blocksize	= SHA512_BLOCK_SIZE,
+      .cra_flags	= CRYPTO_ALG_TYPE_AHASH,
+      .cra_type		= &crypto_ahash_type,
+    }
+  }
+}
+};
+
+#endif
+
+#ifdef	SHASH_HW
+
+static int  sha_hw_init_tfm(struct crypto_tfm *tfm)
+{
+  return icp_crypto_init(tfm, NULL);
+}
+
+static int sha_hw_setkey(struct crypto_shash *shash_tfm, const u8 *key,
+                          unsigned int keylen)
+{
+  CpaStatus                status;
+  CpaCySymSessionSetupData Setup = { 0 };
+  struct icp_crypto_ctx   *ctx   = crypto_shash_ctx(shash_tfm);
+
+  /* Set request size */
+  shash_tfm->descsize   = ctx->requestSize;
+
+  /* Set authsize */
+  ctx->authSize         = SHA1_DIGEST_SIZE;
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: ctx %p key %p len %2d auth %2d req %2d\n",
+         __FUNCTION__, ctx, key, keylen, ctx->authSize, ctx->requestSize);
+
+  Setup.sessionPriority = CPA_CY_PRIORITY_HIGH;
+  Setup.symOperation    = CPA_CY_SYM_OP_HASH;
+
+  Setup.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA1;
+  Setup.hashSetupData.hashMode      = CPA_CY_SYM_HASH_MODE_PLAIN;
+
+  Setup.hashSetupData.digestResultLenInBytes = ctx->authSize;
+
+  Setup.hashSetupData.authModeSetupData.authKey           = (Cpa8U *)"";
+  Setup.hashSetupData.authModeSetupData.authKeyLenInBytes = 0;
+
+/* Workaround for IXA00378497 - enc performance drop when append flag is set */
+/* Using the same append config for encrypt/decrypt */
+  Setup.digestIsAppended = CPA_FALSE;
+  Setup.verifyDigest     = CPA_FALSE;
+
+  icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+
+  ctx->encrypt_ctx = kzalloc(ctx->sessionSize, GFP_KERNEL);
+  if (NULL == ctx->encrypt_ctx) {
+    printk(KERN_ERR "%s: Failed to alloc encrypt session\n", __FUNCTION__);
+    return -ENOMEM;
+  }
+
+  /* Lock the context */
+  mutex_lock(&ctx->mutexLock);
+
+  /* Initialize the cipher enc session */
+  status = cpaCySymInitSession(ctx->instance, symCallback,
+                               &Setup, ctx->encrypt_ctx);
+  if (CPA_STATUS_SUCCESS != status) {
+    /* Unlock the context */
+    icp_crypto_free(ctx, &ctx->encrypt_ctx, &ctx->encrypt_key);
+    mutex_unlock(&ctx->mutexLock);
+
+    printk(KERN_ERR "%s: Failed to initialize encryption session\n",
+           __FUNCTION__);
+    return -EINVAL;
+  }
+
+  /* Set that encrypt key is set up */
+  atomic_set(&ctx->encrypt_key, 1);
+
+  /* Unlock the context */
+  mutex_unlock(&ctx->mutexLock);
+
+  return 0;
+}
+
+static int sha_hw_init(struct shash_desc *desc)
+{
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: desc %p\n", __FUNCTION__, desc);
+
+  return 0;
+}
+
+static void sha_hw_cb(struct crypto_async_request *async_req, int status)
+{
+  async_req->flags |= 1;
+}
+
+static int sha_hw_update(struct shash_desc *desc, const u8 *data,
+        unsigned int len)
+{
+  int    err;
+  struct crypto_shash        *shash_tfm = desc->tfm;
+  struct icp_crypto_ctx      *ctx       = crypto_shash_ctx(shash_tfm);
+  struct icp_crypto_req_ctx  *req_ctx   = shash_desc_ctx(desc);
+  struct crypto_async_request async_req = { .complete = sha_hw_cb, };
+  struct scatterlist          sg;
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: desc %p len %d\n", __FUNCTION__, desc, len);
+
+  sg_init_one(&sg, data, len + SHA1_DIGEST_SIZE);
+
+  async_req.tfm     = &shash_tfm->base;
+  async_req.flags   = 0;
+
+  req_ctx->cryptlen = len;
+  req_ctx->assoclen = 0;
+  req_ctx->assoc    = NULL;
+  req_ctx->src      = &sg;
+  req_ctx->dst      = &sg;
+  req_ctx->result   = NULL;
+
+  err = perform_sym_op(&async_req, ctx, req_ctx, NULL, 0,
+                       CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT, 0);
+
+  if (!err) while (async_req.flags == 0) udelay(1);
+
+  return err;
+}
+
+static int sha_hw_final(struct shash_desc *desc, u8 *out)
+{
+  int    err = 0;
+  struct icp_crypto_req_ctx *req_ctx = shash_desc_ctx(desc);
+
+  /* Check for zero length hash buffer */
+  if (unlikely(req_ctx->cryptlen == 0)) err = sha_hw_update(desc, out, 0);
+
+  memcpy(out, req_ctx->digestBuffer, SHA1_DIGEST_SIZE);
+
+  /* Wipe context */
+  memset(req_ctx->digestBuffer, 0, SHA1_DIGEST_SIZE);
+
+  return err;
+}
+
+#ifdef	EXPORT_IMPORT
+
+static int sha_hw_export(struct shash_desc *desc, void *out)
+{
+  struct sha1_state *sctx = shash_desc_ctx(desc);
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: desc %p\n", __FUNCTION__, desc);
+
+  memcpy(out, sctx, sizeof(*sctx));
+  return 0;
+}
+
+static int sha_hw_import(struct shash_desc *desc, const void *in)
+{
+  struct sha1_state *sctx = shash_desc_ctx(desc);
+
+  if (unlikely(console_loglevel & 16))
+  printk(KERN_DEBUG "%s: desc %p\n", __FUNCTION__, desc);
+
+  memcpy(sctx, in, sizeof(*sctx));
+  return 0;
+}
+
+#endif
+
+struct icp_shash {
+  struct shash_alg shash;
+} icp_shashs[] = {
+{
+  .shash = {
+    .init		= sha_hw_init,
+    .update		= sha_hw_update,
+    .final		= sha_hw_final,
+#ifdef	EXPORT_IMPORT
+    .export		= sha_hw_export,
+    .import		= sha_hw_import,
+#endif
+    .setkey		= sha_hw_setkey,
+    .statesize		= sizeof(struct sha1_state),
+    .digestsize		= SHA1_DIGEST_SIZE,
+    .base = {
+      .cra_name		= "hash(sha1)",
+      .cra_driver_name	= "hash_sha1_icp",
+      .cra_blocksize	= SHA1_BLOCK_SIZE,
+      .cra_flags	= CRYPTO_ALG_TYPE_SHASH,
+    }
+  }
+}
+};
+
+#endif
+
+int __init icp_algos_init(void)
+{
+  int j, err;
+
+  printk(KERN_INFO "\n%s: Built " __DATE__ " " __TIME__ "\n\n", __FUNCTION__);
+
+#ifdef	SHASH_HW
+  for (j = 0; j < ARRAY_SIZE(icp_shashs); j++) {
+    struct crypto_alg *cra = &icp_shashs[j].shash.base;
+
+    //shash
+    cra->cra_flags    |= CRYPTO_ALG_ASYNC;
+    cra->cra_ctxsize   = sizeof(struct icp_crypto_ctx);
+    cra->cra_module    = THIS_MODULE;
+    cra->cra_alignmask = 0;
+    cra->cra_priority  = CRA_PRIORITY;
+    cra->cra_init      = sha_hw_init_tfm;
+    cra->cra_exit      = icp_crypto_exit;
+
+    INIT_LIST_HEAD(&cra->cra_list);
+
+    printk(KERN_INFO "%s: Insert shash '%s'\n", __FUNCTION__, cra->cra_name);
+    if ((err = crypto_register_shash(&icp_shashs[j].shash)) != 0) {
+    printk(KERN_EMERG "%s: Error %4d registering '%s'\n",
+           __FUNCTION__, err, cra->cra_name);
+    cra->cra_priority  = 0;
+    }
+  }
+#endif
+
+#ifdef	AHASH_HW
+
+  for (j = 0; j < ARRAY_SIZE(icp_ahashs); j++) {
+    struct crypto_alg *cra = &icp_ahashs[j].ahash.halg.base;
+
+    //ahash
+    cra->cra_flags    |= CRYPTO_ALG_ASYNC;
+    cra->cra_ctxsize   = sizeof(struct icp_crypto_ctx);
+    cra->cra_module    = THIS_MODULE;
+    cra->cra_alignmask = 0;
+    cra->cra_priority  = CRA_PRIORITY;
+    cra->cra_init      = ahash_init_tfm;
+    cra->cra_exit      = icp_crypto_exit;
+
+    INIT_LIST_HEAD(&cra->cra_list);
+
+    printk(KERN_INFO "%s: Insert ahash '%s'\n", __FUNCTION__, cra->cra_name);
+    if ((err = crypto_register_ahash(&icp_ahashs[j].ahash)) != 0) {
+    printk(KERN_EMERG "%s: Error %4d registering '%s'\n",
+           __FUNCTION__, err, cra->cra_name);
+    cra->cra_priority  = 0;
+    }
+  }
+#endif
+
+#ifdef	ABLK_HW
+  for (j = 0; j < ARRAY_SIZE(icp_ablks); j++) {
+    struct crypto_alg* cra = &icp_ablks[j].crypto;
+
+    cra->cra_flags    |= CRYPTO_ALG_ASYNC;
+    cra->cra_ctxsize   = sizeof(struct icp_crypto_ctx);
+    cra->cra_module    = THIS_MODULE;
+    cra->cra_alignmask = 0;
+    cra->cra_init      = ablk_init_tfm;
+    cra->cra_exit      = icp_crypto_exit;
+    cra->cra_priority  = CRA_PRIORITY;
+
+    INIT_LIST_HEAD(&cra->cra_list);
+
+    //ablk
+    cra->cra_ablkcipher.setkey  = ablk_setkey;
+    cra->cra_ablkcipher.encrypt = ablk_encrypt;
+    cra->cra_ablkcipher.decrypt = ablk_decrypt;
+
+    printk(KERN_INFO "%s: Insert ablk  '%s'\n", __FUNCTION__, cra->cra_name);
+    if ((err = crypto_register_alg(&icp_ablks[j].crypto)) != 0) {
+    printk(KERN_EMERG "%s: Error %4d registering '%s'\n",
+           __FUNCTION__, err, cra->cra_name);
+    cra->cra_priority  = 0;
+    }
+  }
+#endif
+
+  for (j = 0; j < ARRAY_SIZE(icp_aeads); j++) {
+#ifdef	CONFIG_WG_KERNEL_4_14
+    struct aead_alg*  aead = &icp_aeads[j].aead;
+    struct crypto_alg* cra = &aead->base;
+
+    cra->cra_flags    |= CRYPTO_ALG_ASYNC;
+    cra->cra_ctxsize   = sizeof(struct icp_crypto_ctx);
+    cra->cra_module    = THIS_MODULE;
+    cra->cra_alignmask = 0;
+    cra->cra_priority  = CRA_PRIORITY;
+
+    INIT_LIST_HEAD(&cra->cra_list);
+
+    //aead
+    aead->setkey                = aead_setkey;
+    aead->setauthsize           = aead_setauthsize;
+    aead->encrypt               = aead_encrypt;
+    aead->decrypt               = aead_decrypt;
+    aead->init                  = aead_init_tfm;
+    aead->exit                  = aead_exit_tfm;
+
+    printk(KERN_INFO "%s: Insert aead  '%s'\n", __FUNCTION__, cra->cra_name);
+
+    if ((err = crypto_register_aead(&icp_aeads[j].aead)) != 0) {
+    printk(KERN_EMERG "%s: Error %4d registering '%s'\n",
+           __FUNCTION__, err, cra->cra_name);
+    cra->cra_priority  = 0;
+    }
+#else
+    struct crypto_alg* cra = &icp_aeads[j].crypto;
+
+    cra->cra_flags    |= CRYPTO_ALG_ASYNC;
+    cra->cra_ctxsize   = sizeof(struct icp_crypto_ctx);
+    cra->cra_module    = THIS_MODULE;
+    cra->cra_alignmask = 0;
+    cra->cra_init      = aead_init_tfm;
+    cra->cra_exit      = icp_crypto_exit;
+    cra->cra_priority  = CRA_PRIORITY;
+
+    INIT_LIST_HEAD(&cra->cra_list);
+
+    //aead
+    cra->cra_aead.setkey	= aead_setkey;
+    cra->cra_aead.setauthsize   = aead_setauthsize;
+    cra->cra_aead.encrypt       = aead_encrypt;
+    cra->cra_aead.decrypt       = aead_decrypt;
+    cra->cra_aead.givencrypt    = aead_givencrypt;
+
+    printk(KERN_INFO "%s: Insert aead  '%s'\n", __FUNCTION__, cra->cra_name);
+
+    if ((err = crypto_register_alg(&icp_aeads[j].crypto)) != 0) {
+    printk(KERN_EMERG "%s: Error %4d registering '%s'\n",
+           __FUNCTION__, err, cra->cra_name);
+    cra->cra_priority  = 0;
+    }
+#endif
+  }
+
+  return 0;
+}
+
+void __exit icp_algos_exit(void)
+{
+  int j;
+
+  printk(KERN_INFO "\n%s: Built " __DATE__ " " __TIME__ "\n\n", __FUNCTION__);
+
+  for (j = 0; j < ARRAY_SIZE(icp_aeads); j++)
+#ifdef	CONFIG_WG_KERNEL_4_14
+  if (icp_aeads[j].aead.base.cra_priority > 0) {
+    struct aead_alg*  aead = &icp_aeads[j].aead;
+    struct crypto_alg* cra = &aead->base;
+    printk(KERN_INFO "%s: Remove aead  '%s'\n", __FUNCTION__, cra->cra_name);
+    crypto_unregister_aead(&icp_aeads[j].aead);
+#else
+  if (icp_aeads[j].crypto.cra_priority > 0) {
+    struct crypto_alg* cra = &icp_aeads[j].crypto;
+    printk(KERN_INFO "%s: Remove aead  '%s'\n", __FUNCTION__, cra->cra_name);
+    crypto_unregister_alg(&icp_aeads[j].crypto);
+#endif
+  }
+#ifdef	ABLK_HW
+  for (j = 0; j < ARRAY_SIZE(icp_ablks); j++)
+  if (icp_ablks[j].crypto.cra_priority > 0) {
+    struct crypto_alg* cra = &icp_ablks[j].crypto;
+    printk(KERN_INFO "%s: Remove ablk  '%s'\n", __FUNCTION__, cra->cra_name);
+    crypto_unregister_alg(&icp_ablks[j].crypto);
+  }
+#endif
+
+#ifdef	AHASH_HW
+  for (j = 0; j < ARRAY_SIZE(icp_ahashs); j++)
+  if (icp_ahashs[j].ahash.halg.base.cra_priority > 0) {
+    struct crypto_alg *cra = &icp_ahashs[j].ahash.halg.base;
+    printk(KERN_INFO "%s: Remove ahash '%s'\n", __FUNCTION__, cra->cra_name);
+    crypto_unregister_ahash(&icp_ahashs[j].ahash);
+  }
+#endif
+
+#ifdef	SHASH_HW
+  for (j = 0; j < ARRAY_SIZE(icp_shashs); j++)
+  if (icp_shashs[j].shash.base.cra_priority > 0) {
+    struct crypto_alg *cra = &icp_shashs[j].shash.base;
+    printk(KERN_INFO "%s: Remove shash '%s'\n", __FUNCTION__, cra->cra_name);
+    crypto_unregister_shash(&icp_shashs[j].shash);
+  }
+#endif
+}
+
+/* This function gets the QA instances and registers our module with LKCF */
+static int __init icp_netkey_init(void)
+{
+  int       j;
+  int       retval;
+  int       startCtr;
+  Cpa16U    num    = 0;
+  CpaStatus status = CPA_STATUS_SUCCESS;
+
+  /* QA API crypto instances are found at module init and are assumed to
+     stay static while this module is active. */
+  if (cpaCyGetNumInstances(&num) != CPA_STATUS_SUCCESS) {
+    printk(KERN_ERR "%s: Could not get number of Quick Assist"
+           "crypto instances\n", __FUNCTION__);
+    retval = -EINVAL;
+    goto out;
+  }
+
+  /* Allocate memory to store global array of QA instances */
+  qat_instances.instances = kmalloc(sizeof(CpaInstanceHandle) * num,
+                                    GFP_KERNEL);
+  if (NULL == qat_instances.instances) {
+    printk(KERN_ERR "%s: Failed to alloc instance memory\n", __FUNCTION__);
+    retval = -ENOMEM;
+    goto out;
+  }
+
+  if (cpaCyGetInstances(num, qat_instances.instances) != CPA_STATUS_SUCCESS) {
+    printk(KERN_ERR "%s: Could not get Quick Assist crypto instance\n",
+           __FUNCTION__);
+    retval = -EINVAL;
+    goto free_instances;
+  }
+
+  qat_instances.ctr   = 0;
+  qat_instances.total = num;
+
+  /* Start all instances */
+  for (startCtr = 0; startCtr < num; startCtr++) {
+    status = cpaCyStartInstance(qat_instances.instances[startCtr]);
+    if (CPA_STATUS_SUCCESS != status) {
+      printk(KERN_ERR "%s: Failed to start instance %d\n", __FUNCTION__,
+             startCtr);
+      retval = -EINVAL;
+      goto stop_instances;
+    }
+
+    printk(KERN_INFO "%s: Instance %3d [%p] started\n",
+           __FUNCTION__, startCtr, qat_instances.instances[startCtr]);
+  }
+
+#ifdef	SAMPLE_TEST
+  {
+    CpaStatus
+    SampleTest(void);
+    SampleTest();
+  }
+#endif
+
+  /* Get default rng */
+  retval = crypto_get_default_rng();
+  if (retval != 0) {
+    printk(KERN_ERR "%s: Failed to get default rng\n", __FUNCTION__);
+    goto stop_instances;
+  }
+
+  /* Initialize algorithm drivers */
+  return icp_algos_init();
+
+ stop_instances:
+  for (j = 0; j < startCtr; j++)
+    cpaCyStopInstance(qat_instances.instances[j]);
+
+ free_instances:
+  kfree(qat_instances.instances);
+
+ out:
+  return retval;
+}
+
+/* This function calls driver_exit functions and frees instance memory */
+static void __exit icp_netkey_exit(void)
+{
+  int j;
+
+  /* Un-register algos */
+  icp_algos_exit();
+
+  /* Free default rng */
+  crypto_put_default_rng();
+
+  /* Stop all instances */
+  for (j = 0; j < qat_instances.total; j++)
+    cpaCyStopInstance(qat_instances.instances[j]);
+
+  /* Free resources */
+  kfree(qat_instances.instances);
+}
+
+module_init(icp_netkey_init);
+module_exit(icp_netkey_exit);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LCKF Driver for Intel Quick Assist crypto acceleration");
+MODULE_AUTHOR("Intel Corporation");
+
+
+// SAMPLE TEST CODE FOME INTEL
+
+
+#ifdef	SAMPLE_TEST
+
+/*
+ * Attach the code below to the end of this module and call SampleTest from
+ * the module's init code to run a simple start up test of the algo whose
+ * test code is included below.
+ */
+
+/* Kernel space utils */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <asm/io.h>
+
+#ifdef __x86_64__
+#define SAMPLE_ADDR_LEN uint64_t
+#else
+#define SAMPLE_ADDR_LEN uint32_t
+#endif
+
+/* Threads */
+typedef struct task_struct *sampleThread;
+
+/* Printing */
+/**< Prints the name of the function and the arguments only if gDebugParam is 
+ * TRUE.
+ */
+#define PRINT_DBG(args...)              \
+    do {                                \
+        if (TRUE == gDebugParam) {      \
+            printk("%s(): ", __func__); \
+            printk(args);               \
+        }                               \
+    } while (0)
+
+/**< Prints the name of the function and the arguments */
+    #define PRINT_ERR(args...)          \
+    do {                                \
+            printk("%s(): ", __func__); \
+            printk(args);               \
+    } while (0)
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      Completion definitions
+ *
+ ******************************************************************************/
+#define COMPLETION_STRUCT completion
+
+#define COMPLETION_INIT(c) init_completion(c)
+
+#define COMPLETION_WAIT(c, timeout)                         \
+    wait_for_completion_interruptible_timeout(c, timeout)
+
+#define COMPLETE(c) complete(c)
+
+#define COMPLETION_DESTROY(s)
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      This function and associated macro sleeps for ms milliseconds 
+ *
+ * @param[in] ms    sleep time in ms 
+ *
+ * @retval none 
+ *
+ ******************************************************************************/
+static __inline CpaStatus 
+sampleCodeSleep(Cpa32U ms)
+{
+    if(ms != 0)
+    {
+        set_current_state((long) TASK_INTERRUPTIBLE);
+        schedule_timeout((ms * HZ)/ 1000);
+    }
+    else
+    {
+       schedule();
+    }
+
+    return CPA_STATUS_SUCCESS;
+}
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      Macro from the sampleCodeSleep function
+ *
+ ******************************************************************************/
+#define OS_SLEEP(ms) \
+    sampleCodeSleep((ms))
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      This function and associated macro allocates the memory for the given
+ *      size and stores the address of the memory allocated in the pointer.
+ *      Memory allocated by this function is NOT gauranteed to be physically
+ *      contiguous. 
+ *
+ * @param[out] ppMemAddr    address of pointer where address will be stored
+ * @param[in] sizeBytes     the size of the memory to be allocated
+ *
+ * @retval CPA_STATUS_RESOURCE  Macro failed to allocate Memory
+ * @retval CPA_STATUS_SUCCESS   Macro executed successfully
+ *
+ ******************************************************************************/
+static __inline CpaStatus
+Mem_OsMemAlloc(void **ppMemAddr,
+                  Cpa32U sizeBytes)
+{
+    *ppMemAddr = kmalloc(sizeBytes, GFP_KERNEL);
+    if (NULL == *ppMemAddr)
+    {
+        return CPA_STATUS_RESOURCE;
+    }
+    return CPA_STATUS_SUCCESS;
+}
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      This function and associated macro allocates the memory for the given
+ *      size for the given alignment and stores the address of the memory 
+ *      allocated in the pointer. Memory allocated by this function is
+ *      gauranteed to be physically contiguous.
+ *
+ * @param[out] ppMemAddr    address of pointer where address will be stored
+ * @param[in] sizeBytes     the size of the memory to be allocated
+ * @param[in] alignement    the alignment of the memory to be allocated (non-zero)
+ *
+ * @retval CPA_STATUS_RESOURCE  Macro failed to allocate Memory
+ * @retval CPA_STATUS_SUCCESS   Macro executed successfully
+ *
+ ******************************************************************************/
+static __inline CpaStatus
+Mem_Alloc_Contig(void **ppMemAddr,
+                  Cpa32U sizeBytes, Cpa32U alignment)
+{
+    void * pAlloc = NULL;
+    uint32_t align = 0; 
+
+    pAlloc = kmalloc_node((sizeBytes+alignment+sizeof(void*)), GFP_KERNEL, 0);
+    if (NULL == pAlloc)
+    {
+        return CPA_STATUS_RESOURCE;
+    }
+
+    *ppMemAddr = pAlloc + sizeof(void*);
+
+    align = ((SAMPLE_ADDR_LEN)(*ppMemAddr))%alignment;
+
+    *ppMemAddr += (alignment-align);
+    *(SAMPLE_ADDR_LEN *)(*ppMemAddr - sizeof(void*)) = (SAMPLE_ADDR_LEN)pAlloc; 
+
+    return CPA_STATUS_SUCCESS;
+}
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      Macro from the Mem_OsMemAlloc function
+ *
+ ******************************************************************************/
+#define OS_MALLOC(ppMemAddr, sizeBytes) \
+    Mem_OsMemAlloc((void *)(ppMemAddr), (sizeBytes))
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      Macro from the Mem_Alloc_Contig function
+ *
+ ******************************************************************************/
+#define PHYS_CONTIG_ALLOC(ppMemAddr, sizeBytes) \
+    Mem_Alloc_Contig((void *)(ppMemAddr), (sizeBytes), 1)
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *     Algined version of PHYS_CONTIG_ALLOC() macro 
+ *
+ ******************************************************************************/
+#define PHYS_CONTIG_ALLOC_ALIGNED(ppMemAddr, sizeBytes, alignment) \
+    Mem_Alloc_Contig((void *)(ppMemAddr), (sizeBytes), (alignment))
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      This function and associated macro frees the memory at the given address
+ *      and resets the pointer to NULL. The memory must have been allocated by 
+ *      the function Mem_OsMemAlloc()
+ *
+ * @param[out] ppMemAddr    address of pointer where mem address is stored.
+ *                          If pointer is NULL, the function will exit silently
+ *
+ * @retval void
+ *
+ ******************************************************************************/
+static __inline void
+Mem_OsMemFree(void **ppMemAddr)
+{
+    if (NULL != *ppMemAddr)
+    {
+       kfree(*ppMemAddr);
+       *ppMemAddr = NULL;
+    }
+}
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      This function and associated macro frees the memory at the given address
+ *      and resets the pointer to NULL. The memory must have been allocated by 
+ *      the function Mem_Alloc_Contig().
+ *
+ * @param[out] ppMemAddr    address of pointer where mem address is stored.
+ *                          If pointer is NULL, the function will exit silently
+ *
+ * @retval void
+ *
+ ******************************************************************************/
+static __inline void
+Mem_Free_Contig(void **ppMemAddr)
+{
+    void * pAlloc = NULL;
+    if (NULL != *ppMemAddr)
+    {
+       pAlloc = (void *)(*((SAMPLE_ADDR_LEN *)(*ppMemAddr - sizeof(void*))));
+       kfree(pAlloc);
+       *ppMemAddr = NULL;
+    }
+}
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      Macro from the Mem_OsMemFree function
+ *
+ ******************************************************************************/
+#define OS_FREE(pMemAddr) \
+    Mem_OsMemFree((void *)&pMemAddr)
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      Macro from the Mem_Free_Contig function
+ *
+ ******************************************************************************/
+#define PHYS_CONTIG_FREE(pMemAddr) \
+    Mem_Free_Contig((void *)&pMemAddr)
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      This function returns the physical address for a given virtual address.
+ *      In case of error 0 is returned.
+ *
+ * @param[in] virtAddr     Virtual address 
+ *
+ * @retval CpaPhysicalAddr Physical address or 0 in case of error 
+ *
+ ******************************************************************************/
+
+static __inline CpaPhysicalAddr
+sampleVirtToPhys(void * virtAddr)
+{
+    return (CpaPhysicalAddr) virt_to_phys(virtAddr);
+}
+
+/**
+ *******************************************************************************
+ * @ingroup sampleUtils
+ *      This function creates a thread 
+ *
+ ******************************************************************************/
+
+static __inline CpaStatus
+sampleThreadCreate(sampleThread * thread, void* funct, void* args)
+{
+   *thread = kthread_create(funct, args, "SAMPLE_THREAD");
+   return CPA_STATUS_SUCCESS;
+}
+
+static __inline void 
+sampleThreadExit(void)
+{
+}
+
+void
+sampleCyGetInstance(CpaInstanceHandle* pCyInstHandle);
+
+void
+sampleCyStartPolling(CpaInstanceHandle cyInstHandle);
+
+void
+sampleCyStopPolling(void);
+
+void
+sampleDcGetInstance(CpaInstanceHandle* pDcInstHandle);
+
+void
+sampleDcStartPolling(CpaInstanceHandle dcInstHandle);
+
+void
+sampleDcStopPolling(void);
+
+// SAMPLE COMMON CODE
+
+/*
+ * Maximum number of instances to query from the API
+ */
+#define MAX_INSTANCES 1
+
+static sampleThread gPollingThread;
+static int gPollingCy = 0;
+static int gDebugParam = TRUE;
+
+/*
+ * This function returns a handle to an instance of the cryptographic
+ */
+
+void
+sampleCyGetInstance(CpaInstanceHandle* pCyInstHandle)
+{
+    CpaInstanceHandle cyInstHandles[MAX_INSTANCES];
+    Cpa16U numInstances = 0;
+    CpaStatus status = CPA_STATUS_SUCCESS;
+
+    *pCyInstHandle = NULL;
+
+    status = cpaCyGetNumInstances(&numInstances);
+    if ((status == CPA_STATUS_SUCCESS) && (numInstances > 0))
+    {
+        status = cpaCyGetInstances(MAX_INSTANCES, cyInstHandles);
+        if (status == CPA_STATUS_SUCCESS)
+        {
+            *pCyInstHandle = cyInstHandles[0];
+        }
+    }
+}
+
+/* 
+ * This function polls a crypto instance.
+ *
+ */
+static void
+sal_polling(CpaInstanceHandle cyInstHandle)
+{
+   gPollingCy = 1;
+   while(gPollingCy)
+   {
+       void icp_sal_CyPollInstance(CpaInstanceHandle, int);    
+       icp_sal_CyPollInstance(cyInstHandle, 0);
+       OS_SLEEP(10);
+   }
+
+   sampleThreadExit();
+}
+
+/*
+ * This function checks the instance info. If the instance is
+ * required to be polled then it starts a polling thread.
+ */
+void
+sampleCyStartPolling(CpaInstanceHandle cyInstHandle)
+{
+   CpaInstanceInfo2 info2 = {0};
+   CpaStatus status = CPA_STATUS_SUCCESS;
+
+   status = cpaCyInstanceGetInfo2(cyInstHandle, &info2);
+   if((status == CPA_STATUS_SUCCESS) && (info2.isPolled == CPA_TRUE))
+   {
+      /* Start thread to poll instance */
+      sampleThreadCreate(&gPollingThread, sal_polling, cyInstHandle);
+   }
+
+}
+
+/*
+ * This function stops the polling of a crypto instance. 
+ */
+void
+sampleCyStopPolling(void)
+{
+   gPollingCy = 0;
+}
+
+// SAMPLE GCM CODE
+
+#if	0
+
+static Cpa8U sampleKey[] = {
+        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
+        0x99, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
+        0x77, 0x88, 0x99, 0x00, 0x11, 0x22, 0x33, 0x44,
+        0x55, 0x66, 0x77, 0x88, 0x99, 0x00, 0x11, 0x22
+};
+
+static Cpa8U sampleIv[] = {
+        0xca, 0xfe, 0xca, 0xfe, 0xca, 0xfe, 0xca, 0xfe,
+        0xca, 0xfe, 0xca, 0xfe
+};
+
+static Cpa8U sampleAddAuthData[] = {
+        0xde, 0xad, 0xde, 0xad, 0xde, 0xad, 0xde, 0xad,
+        0xde, 0xad, 0xde, 0xad, 0xde, 0xad, 0xde, 0xad,
+        0xde, 0xad, 0xde, 0xad
+};
+
+static Cpa8U samplePayload[] = {
+        0x79, 0x84, 0x86, 0x44, 0x68, 0x45, 0x15, 0x61,
+        0x86, 0x54, 0x66, 0x56, 0x54, 0x54, 0x31, 0x54,
+        0x64, 0x64, 0x68, 0x45, 0x15, 0x15, 0x61, 0x61,
+        0x51, 0x51, 0x51, 0x51, 0x51, 0x56, 0x14, 0x11,
+        0x72, 0x13, 0x51, 0x82, 0x84, 0x56, 0x74, 0x53,
+        0x45, 0x34, 0x65, 0x15, 0x46, 0x14, 0x67, 0x55,
+        0x16, 0x14, 0x67, 0x54, 0x65, 0x47, 0x14, 0x67,
+        0x46, 0x74, 0x65, 0x46
+};
+
+static Cpa8U expectedOutput[] = {
+        0x59, 0x85, 0x02, 0x97, 0xE0, 0x4D, 0xFC, 0x5C,
+        0x03, 0xCC, 0x83, 0x64, 0xCE, 0x28, 0x0B, 0x95,
+        0x78, 0xEC, 0x93, 0x40, 0xA1, 0x8D, 0x21, 0xC5,
+        0x48, 0x6A, 0x39, 0xBA, 0x4F, 0x4B, 0x8C, 0x95,
+        0x6F, 0x8C, 0xF6, 0x9C, 0xD0, 0xA5, 0x8D, 0x67,
+        0xA1, 0x32, 0x11, 0xE7, 0x2E, 0xF6, 0x63, 0xAF,
+        0xDE, 0xD4, 0x7D, 0xEC, 0x15, 0x01, 0x58, 0xCB,
+        0xE3, 0x7B, 0xC6, 0x94,
+
+        /* Tag */
+
+        0x5D, 0x10, 0x3F, 0xC7, 0x22, 0xC7, 0x21, 0x29,
+        0x95, 0x10, 0xF9, 0x9E, 0x81, 0xE7, 0x8A, 0x07
+};
+
+#else
+
+static Cpa8U sampleKey[] = {
+        0x47, 0x43, 0x4D, 0x31, 0x36, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0X00, 0x00, 0x00, 0x00
+};
+
+static Cpa8U sampleIv[] = {
+        0x4E, 0x4F, 0x4E, 0x45, 0x93, 0x2F, 0xA9, 0x4F,
+        0x4A, 0xF6, 0xDB, 0xB6
+};
+
+static Cpa8U sampleAddAuthData[] = {
+        0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x01
+};
+
+static Cpa8U samplePayload[] = {
+        0x45, 0x00, 0x00, 0x54, 0x92, 0x43, 0x40, 0x00,
+        0x40, 0x01, 0x30, 0x10, 0xc0, 0xa8, 0xfb, 0x01,
+
+        0xc0, 0xa8, 0xfc, 0x02, 0x08, 0x00, 0x57, 0xD4,
+        0xDE, 0x0D, 0x00, 0x01, 0x7A, 0x04, 0x8F, 0x5A,
+
+        0x00, 0x00, 0x00, 0x00, 0xF7, 0xEA, 0x02, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13,
+
+        0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
+        0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
+
+        0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
+        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33,
+
+        0x34, 0x35, 0x36, 0x37, 0x01, 0x02, 0x02, 0x04
+};
+
+static Cpa8U expectedOutput[] = {
+        0xb3, 0x13, 0xfe, 0x1e, 0xcf, 0x0b, 0xba, 0x74,
+        0xb3, 0xeb, 0x28, 0xc5, 0x20, 0xd2, 0x3e, 0xca,
+
+        0x6b, 0xdc, 0x48, 0x61, 0x05, 0x8c, 0xc5, 0x2f,
+        0x9f, 0xaa, 0xd0, 0x10, 0xa4, 0xeb, 0xc8, 0xfd,
+
+        0xe3, 0x85, 0x7b, 0x68, 0x5b, 0x18, 0xe0, 0x43,
+        0x00, 0x21, 0x06, 0xcc, 0xa3, 0x7e, 0xbc, 0xc6,
+
+        0x7d, 0x2f, 0xbe, 0xda, 0x0c, 0x50, 0x73, 0xd0,
+        0xf6, 0x86, 0x8b, 0xcf, 0xe1, 0x26, 0xa6, 0xb2,
+
+        0x46, 0x61, 0x54, 0xcc, 0xc9, 0x84, 0xd3, 0xec,
+        0xbf, 0x3d, 0xae, 0x35, 0x97, 0xeb, 0x32, 0xe5,
+
+        0x30, 0x04, 0xd9, 0xcc, 0x2e, 0x78, 0x02, 0xc9,
+
+        /* Tag */
+
+        0x58, 0xbd, 0x2a, 0x75, 0x04, 0x01, 0xbc, 0xfd,
+        0x08, 0x30, 0x98, 0x93, 0x14, 0x94, 0x9f, 0x30
+};
+
+#endif
+
+#define TAG_LENGTH	(sizeof(expectedOutput) - sizeof(samplePayload))
+
+/*
+ * Callback function
+ *
+ * This function is "called back" (invoked by the implementation of
+ * the API) when the asynchronous operation has completed.  The
+ * context in which it is invoked depends on the implementation, but
+ * as described in the API it should not sleep (since it may be called
+ * in a context which does not permit sleeping, e.g. a Linux bottom
+ * half).
+ *
+ * This function can perform whatever processing is appropriate to the
+ * application.  For example, it may free memory, continue processing
+ * of a decrypted packet, etc.  In this example, the function checks
+ * verifyResult returned and sets the complete variable to indicate
+ * it has been called.
+ */
+
+static void
+symcCallbackGCM(void *pCallbackTag,
+        CpaStatus status,
+        const CpaCySymOp operationType,
+        void *pOpData,
+        CpaBufferList *pDstBuffer,
+        CpaBoolean verifyResult)
+{
+    PRINT_DBG("Callback called with status = %d.\n", status);
+
+    if(CPA_FALSE == verifyResult)
+    {
+       PRINT_ERR("Error verifyResult failed\n");
+    }
+
+    if (NULL != pCallbackTag)
+    {
+        /** indicate that the function has been called */
+        COMPLETE((struct COMPLETION_STRUCT *)pCallbackTag);
+    }
+}
+
+/*
+ * Perform a simple GCM test
+ */
+
+static CpaStatus
+PerformOpGCM(CpaInstanceHandle cyInstHandle, CpaCySymSessionCtx sessionCtx, int dir)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    Cpa8U  *pBufferMeta = NULL;
+    Cpa32U bufferMetaSize = 0;
+    CpaBufferList *pBufferList = NULL;
+    CpaFlatBuffer *pFlatBuffer = NULL;
+    CpaCySymOpData *pOpData = NULL;
+    Cpa32U bufferSize = sizeof(samplePayload) + TAG_LENGTH;
+    Cpa32U aadBuffSize = 0;
+    Cpa32U numBuffers = 1;  /* only using 1 buffer in this case */
+    /* allocate memory for bufferlist and array of flat buffers in a contiguous
+     * area and carve it up to reduce number of memory allocations required. */
+    Cpa32U bufferListMemSize = sizeof(CpaBufferList) +
+        (numBuffers * sizeof(CpaFlatBuffer));
+    Cpa8U  *pSrcBuffer = NULL;
+    Cpa8U  *pIvBuffer = NULL;
+    Cpa8U  *pAadBuffer = NULL;
+
+    /* The following variables are allocated on the stack because we block
+     * until the callback comes back. If a non-blocking approach was to be
+     * used then these variables should be dynamically allocated */
+    struct COMPLETION_STRUCT complete;
+
+    /* get meta information size */
+    PRINT_DBG("cpaCyBufferListGetMetaSize\n");
+    status = cpaCyBufferListGetMetaSize( cyInstHandle,
+                numBuffers, &bufferMetaSize);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pBufferMeta, bufferMetaSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = OS_MALLOC(&pBufferList, bufferListMemSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        status = PHYS_CONTIG_ALLOC(&pSrcBuffer, bufferSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* increment by sizeof(CpaBufferList) to get at the
+         * array of flatbuffers */
+        pFlatBuffer = (CpaFlatBuffer *) (pBufferList + 1);
+
+        pBufferList->pBuffers = pFlatBuffer;
+        pBufferList->numBuffers = 1;
+        pBufferList->pPrivateMetaData = pBufferMeta;
+
+        pFlatBuffer->dataLenInBytes = bufferSize;
+        pFlatBuffer->pData = pSrcBuffer;
+
+        /* copy source into buffer */
+        if(CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT == dir)
+        {
+           memcpy(pSrcBuffer, samplePayload, sizeof(samplePayload));
+        }
+        else
+        {
+           memcpy(pSrcBuffer, expectedOutput, sizeof(expectedOutput));
+        }
+        /* Allocate memory to store IV. For GCM this is the block J0
+         * (size equal to AES block size). If iv is 12 bytes the
+         * implementation will construct the J0 block given the iv.
+         * If iv is not 12 bytes then the user must contruct the J0
+         * block and give this as the iv. In both cases space for J0
+         * must be allocated. */
+        status = PHYS_CONTIG_ALLOC(&pIvBuffer, AES_BLOCK_SIZE);
+    }
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Allocate memory for AAD. For GCM this memory will hold the
+         * additional authentication data and any padding to ensure total
+         * size is a multiple of the AES block size
+         */
+        aadBuffSize = sizeof(sampleAddAuthData);
+        if(aadBuffSize%AES_BLOCK_SIZE)
+        {
+           aadBuffSize += AES_BLOCK_SIZE-(aadBuffSize%AES_BLOCK_SIZE);
+        }
+        status = PHYS_CONTIG_ALLOC(&pAadBuffer, aadBuffSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        memcpy(pAadBuffer, sampleAddAuthData, sizeof(sampleAddAuthData));
+        status = OS_MALLOC(&pOpData, sizeof(CpaCySymOpData));
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        if(12 == sizeof(sampleIv))
+        {
+           pOpData->sessionCtx = sessionCtx;
+           pOpData->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+           pOpData->pIv = pIvBuffer;
+           /* In this example iv is 12 bytes. The implementation
+            * will use the iv to generation the J0 block
+            */
+           memcpy(pIvBuffer, sampleIv, sizeof(sampleIv));
+           pOpData->ivLenInBytes = sizeof(sampleIv);
+           pOpData->cryptoStartSrcOffsetInBytes = 0;
+           pOpData->messageLenToCipherInBytes = sizeof(samplePayload);
+           /* For GCM hash offset and length are not required */
+           pOpData->pAdditionalAuthData = pAadBuffer;
+        }
+        else
+        {
+           /* Need to generate J0 block see SP800-38D */
+        }
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /** initialisation for callback; the "complete" variable is used by the
+         * callback function to indicate it has been called*/
+        COMPLETION_INIT(&complete);
+
+        PRINT_DBG("cpaCySymPerformOp\n");
+
+        /** Perform symmetric operation */
+        status = cpaCySymPerformOp(cyInstHandle,
+                (void *)&complete, /* data sent as is to the callback function*/
+                pOpData,           /* operational data struct */
+                pBufferList,       /* source buffer list */
+                pBufferList,       /* same src & dst for an in-place operation*/
+                NULL);             /* pVerifyResult not required in async mode */
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymPerformOp failed. (status = %d)\n", status);
+        }
+
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            /** wait until the completion of the operation*/
+            if (!COMPLETION_WAIT(&complete, 5000))
+            {
+                PRINT_ERR("timeout or interruption in cpaCySymPerformOp\n");
+                status = CPA_STATUS_FAIL;
+            }
+        }
+
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            if(CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT == dir)
+            {
+               if (0 == memcmp(pSrcBuffer, expectedOutput, bufferSize))
+               {
+                   PRINT_DBG("Output matches expected output GCM encrypt\n");
+               }
+               else
+               {
+                   PRINT_ERR("Output does not match expected output GCM encrypt\n");
+                   PrintHex(pSrcBuffer, bufferSize);
+                   status = CPA_STATUS_FAIL;
+               }
+            }
+            else
+            {
+               if (0 == memcmp(pSrcBuffer, samplePayload, sizeof(samplePayload)))
+               {
+                   PRINT_DBG("Output matches expected output GCM decrypt\n");
+               }
+               else
+               {
+                   PRINT_ERR("Output does not match expected output GCM decrypt\n");
+                   PrintHex(pSrcBuffer, sizeof(samplePayload));
+                   status = CPA_STATUS_FAIL;
+               }
+            }
+        }
+    }
+
+
+
+
+    /* at this stage, the callback function has returned, so it is sure that
+     * the structures won't be needed any more*/
+    PHYS_CONTIG_FREE(pSrcBuffer);
+    PHYS_CONTIG_FREE(pIvBuffer);
+    PHYS_CONTIG_FREE(pAadBuffer);
+    OS_FREE(pBufferList);
+    PHYS_CONTIG_FREE(pBufferMeta);
+    OS_FREE(pOpData);
+
+    COMPLETION_DESTROY(&complete);
+
+    return status;
+}
+
+/*
+ * Set up a simple GCM test
+ */
+
+CpaStatus
+SampleTestGCM(void)
+{
+    CpaStatus status = CPA_STATUS_FAIL;
+    CpaCySymSessionCtx sessionCtx = NULL;
+    Cpa32U sessionCtxSize = 0;
+    CpaInstanceHandle cyInstHandle = NULL;
+    CpaCySymSessionSetupData sessionSetupData = {0};
+    CpaCySymStats64 symStats = {0};
+
+    printk("\n\n");
+
+    /*
+     * In this simplified version of instance discovery, we discover
+     * exactly one instance of a crypto service.
+     */
+    sampleCyGetInstance(&cyInstHandle);
+    if (cyInstHandle == NULL)
+    {
+        return CPA_STATUS_FAIL;
+    }
+
+    /* Start Cryptographic component */
+    PRINT_DBG("cpaCyStartInstance\n");
+    status = cpaCyStartInstance(cyInstHandle);
+
+    if(CPA_STATUS_SUCCESS == status)
+    {
+       /*
+        * Set the address translation function for the instance
+        */
+        status = cpaCySetAddressTranslation(cyInstHandle, sampleVirtToPhys);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+       /*
+        * If the instance is polled start the polling thread. Note that
+        * how the polling is done is implementation-dependant.
+        */
+        sampleCyStartPolling(cyInstHandle);
+
+        PRINT_DBG("Authenticated Encryption\n");
+
+        /* populate symmetric session data structure */
+        sessionSetupData.sessionPriority =  CPA_CY_PRIORITY_NORMAL;
+        sessionSetupData.symOperation = CPA_CY_SYM_OP_ALGORITHM_CHAINING;
+        sessionSetupData.algChainOrder =
+                                    CPA_CY_SYM_ALG_CHAIN_ORDER_CIPHER_THEN_HASH;
+
+        sessionSetupData.cipherSetupData.cipherAlgorithm =
+                                    CPA_CY_SYM_CIPHER_AES_GCM;
+        sessionSetupData.cipherSetupData.pCipherKey = sampleKey;
+        sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                                    sizeof(sampleKey);
+        sessionSetupData.cipherSetupData.cipherDirection =
+                                    CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+
+        sessionSetupData.hashSetupData.hashAlgorithm =  CPA_CY_SYM_HASH_AES_GCM;
+        sessionSetupData.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+        sessionSetupData.hashSetupData.digestResultLenInBytes = TAG_LENGTH;
+        /* For GCM authKey and authKeyLen are not required this information
+           is provided by the cipherKey in cipherSetupData */
+        sessionSetupData.hashSetupData.authModeSetupData.aadLenInBytes =
+                                                 sizeof(sampleAddAuthData);
+        /* Tag follows immediately after the region to hash */
+        sessionSetupData.digestIsAppended = CPA_TRUE;
+        /* digestVerify is not required to be set. For GCM authenticated
+           encryption this value is understood to be CPA_FALSE */
+
+        /* Determine size of session context to allocate */
+        PRINT_DBG("cpaCySymSessionCtxGetSize GCM encrypt\n");
+        status = cpaCySymSessionCtxGetSize(cyInstHandle,
+                    &sessionSetupData, &sessionCtxSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Allocate session context */
+        status = PHYS_CONTIG_ALLOC(&sessionCtx, sessionCtxSize);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Initialize the session */
+        PRINT_DBG("cpaCySymInitSession GCM encrypt\n");
+        status = cpaCySymInitSession(cyInstHandle,
+                    symcCallbackGCM, &sessionSetupData, sessionCtx);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        CpaStatus sessionStatus = CPA_STATUS_SUCCESS;
+
+        /* Perform algchaining operation */
+        status = PerformOpGCM(cyInstHandle, sessionCtx,
+                              CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT);
+
+        /* Remove the session - session init has already succeeded */
+        PRINT_DBG("cpaCySymRemoveSession GCM encrypt\n");
+        sessionStatus = cpaCySymRemoveSession(
+                            cyInstHandle, sessionCtx);
+
+        /* maintain status of remove session only when status of all operations
+         * before it are successful. */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            status = sessionStatus;
+        }
+    }
+
+    if(CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("Authenticated Decryption\n");
+
+        /* populate symmetric session data structure */
+        sessionSetupData.sessionPriority =  CPA_CY_PRIORITY_NORMAL;
+        sessionSetupData.symOperation = CPA_CY_SYM_OP_ALGORITHM_CHAINING;
+        sessionSetupData.algChainOrder =
+                                    CPA_CY_SYM_ALG_CHAIN_ORDER_HASH_THEN_CIPHER;
+
+        sessionSetupData.cipherSetupData.cipherAlgorithm =
+                                    CPA_CY_SYM_CIPHER_AES_GCM;
+        sessionSetupData.cipherSetupData.pCipherKey = sampleKey;
+        sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                                    sizeof(sampleKey);
+        sessionSetupData.cipherSetupData.cipherDirection =
+                                    CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+
+        sessionSetupData.hashSetupData.hashAlgorithm =  CPA_CY_SYM_HASH_AES_GCM;
+        sessionSetupData.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+        sessionSetupData.hashSetupData.digestResultLenInBytes = TAG_LENGTH;
+
+        /* For GCM authKey and authKeyLen are not required this information
+           is provided by the cipherKey in cipherSetupData */
+        sessionSetupData.hashSetupData.authModeSetupData.aadLenInBytes =
+                                                 sizeof(sampleAddAuthData);
+        /* Tag follows immediately after the region to hash */
+        sessionSetupData.digestIsAppended = CPA_TRUE;
+        /* digestVerify is not required to be set. For GCM authenticated
+           decryption this value is understood to be CPA_TRUE */
+
+    }
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Initialize the session */
+        PRINT_DBG("cpaCySymInitSession GCM Decrypt\n");
+        status = cpaCySymInitSession(cyInstHandle,
+                    symcCallbackGCM, &sessionSetupData, sessionCtx);
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        CpaStatus sessionStatus = CPA_STATUS_SUCCESS;
+
+        /* Perform algchaining operation */
+        status = PerformOpGCM(cyInstHandle, sessionCtx,
+                              CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT);
+
+        /* Remove the session - session init has already succeeded */
+        PRINT_DBG("cpaCySymRemoveSession GCM decrypt\n");
+        sessionStatus = cpaCySymRemoveSession(
+                            cyInstHandle, sessionCtx);
+
+        /* maintain status of remove session only when status of all operations
+         * before it are successful. */
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            status = sessionStatus;
+        }
+    }
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        /* Query symmetric statistics */
+        status = cpaCySymQueryStats64(cyInstHandle, &symStats);
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            PRINT_ERR("cpaCySymQueryStats failed, status = %d\n", status);
+        }
+        else
+        {
+            PRINT_DBG("Number of symmetric operation completed: %llu\n",
+                    (unsigned long long)symStats.numSymOpCompleted);
+        }
+    }
+
+    /* Clean up */
+
+    /* Free session Context */
+    PHYS_CONTIG_FREE(sessionCtx);
+
+    /* Stop the polling thread */
+    sampleCyStopPolling();
+
+
+    PRINT_DBG("cpaCyStopInstance\n");
+    cpaCyStopInstance(cyInstHandle);
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        PRINT_DBG("Sample code ran successfully\n");
+    }
+    else
+    {
+        PRINT_DBG("Sample code failed with status of %d\n", status);
+    }
+
+    return status;
+}
+
+/*
+ * Generic test wrapper, change to call specific test as needed.
+ */
+
+CpaStatus
+SampleTest(void)
+{
+  return SampleTestGCM();
+}
+
+#endif	// SAMPLE_TEST
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qae_mem_utils.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qae_mem_utils.h	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,148 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qae_mem_utils.h
+ *
+ * This file provides linux kernel memory allocation for quick assist API
+ *
+ *****************************************************************************/
+
+#ifndef __QAE_MEM_UTILS_H
+#define __QAE_MEM_UTILS_H
+
+#include "cpa.h"
+
+/*define types which need to vary between 32 and 64 bit*/
+#ifdef __x86_64__
+#define QAE_UINT  Cpa64U
+#define QAE_INT   Cpa64S
+#else
+#define QAE_UINT  Cpa32U
+#define QAE_INT  Cpa32S
+#endif
+
+#define qaePinnedMemAlloc(m) qaeMemAlloc(m,__FILE__,__LINE__)
+#define qaePinnedMemRealloc(m,s) qaeMemAlloc(m,s,__FILE__,__LINE__)
+
+/*****************************************************************************
+ * function:
+ *         qaeMemAlloc(size_t memsize);
+ *
+ * @description
+ *      allocates memsize bytes of memory
+ *
+ * @param[in] memsize, the amount of memory in bytes to be allocated
+ *
+ * @retval pointer to the allocated memory
+ *
+ *****************************************************************************/
+void *qaeMemAlloc(size_t memsize, const char *file, int line);
+
+/*****************************************************************************
+ * function:
+ *         qaeMemRealloc(void *ptr, size_t memsize)
+ *
+ * @description
+ *      re-allocates memsize bytes of memory
+ *
+ * @param[in] pointer to existing memory
+ * @param[in] memsize, the amount of memory in bytes to be allocated
+ *
+ * @retval pointer to the allocated memory
+ *
+ *****************************************************************************/
+void *qaeMemRealloc(void *ptr, size_t memsize, const char *file, int line);
+
+/*****************************************************************************
+ * function:
+ *         qaeMemFree(void *ptr)
+ *
+ * @description
+ *      frees memory allocated by the qaeMemAlloc function
+ *
+ *
+ * @param[in] pointer to the memory to be freed
+ *
+ * @retval none
+ *
+ *****************************************************************************/
+void qaeMemFree(void *ptr);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeMemV2P(void *v)
+ *
+ * @description
+ * 	find the physical address of a block of memory referred to by virtual
+ * 	address v in the current process's address map
+ *
+ *
+ * @param[in] ptr, virtual pointer to the memory
+ *
+ * @retval the physical address of the memory referred to by ptr
+ *
+ *****************************************************************************/
+CpaPhysicalAddr qaeMemV2P (void *v);
+
+/******************************************************************************
+* function:
+*         setMyVirtualToPhysical(CpaVirtualToPhysical fp)
+*
+* @param CpaVirtualToPhysical [IN] - Function pointer to translation function
+*
+* description:
+*   External API to allow users to specify their own virtual to physical
+*   address translation function.
+*
+******************************************************************************/
+void setMyVirtualToPhysical(CpaVirtualToPhysical fp);
+
+#endif
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/Makefile	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,34 @@
+#
+# Makefile to build the qat_engine outside of the openssl source tree
+#
+# Requires:
+#     ICP_ROOT to point to the top of the ICP source tree
+#
+#     ICP_BUILD_OUTPUT to point to the directory where the userspace
+#     icp libraries live.
+#
+#     SYSTEM_INCLUDE needs to have the path to the openssl headers
+#     if they are not in the default include path.
+#
+INCLUDES = -Iqat_mem -I$(SYSTEM_INCLUDE)
+CFLAGS = $(INCLUDES) -g -fPIC -Wall -O2 
+
+# Include path for Intel QAT API
+INCLUDES += -I${ICP_ROOT}/quickassist/include
+INCLUDES += -I${ICP_ROOT}/quickassist/include/lac
+INCLUDES += -I$(ICP_ROOT)/quickassist/lookaside/access_layer/include
+
+LIBICP = -Wl,$(ICP_BUILD_OUTPUT)/icp_qa_al_s.so
+
+LIBQAT_SRC = e_qat.c qae_mem_utils.c 
+
+LIBQAT_OBJ = $(LIBQAT_SRC:%.c=%.o)
+
+all: libqat.so
+
+libqat.so: $(LIBQAT_OBJ) Makefile
+	$(CC) -shared -o libqat.so $(LIBQAT_OBJ) $(LIBICP) -lrt 
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff *.so *.sl *.dll
+
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/e_qat.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/e_qat.h	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,53 @@
+#ifndef E_QAT_H
+#define E_QAT_H
+
+#include <openssl/sha.h>
+
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_sym.h"
+
+typedef struct qat_chained_ctx_t
+{
+    /*While decryption is done in SW the first elements
+     *of this structure need to be the elements present
+     *in EVP_AES_HMAC_SHA1 defined in 
+     * crypto/evp/e_aes_cbc_hmac_sha1.c
+     */
+    AES_KEY             ks;
+    SHA_CTX             head,tail,md;
+    size_t              payload_length; /* AAD length in decrypt case */
+    union {
+        unsigned int    tls_ver;
+        unsigned char   tls_aad[16];    /* 13 used */
+    } aux;
+
+    /* QAT Session Params */
+    CpaInstanceHandle instanceHandle;
+    CpaCySymSessionSetupData* session_data;
+    CpaCySymSessionCtx qat_ctx;
+    int initParamsSet;
+    int initHmacKeySet;
+
+    /* QAT Op Params */
+    CpaCySymOpData    OpData;
+    CpaBufferList     srcBufferList;
+    CpaBufferList     dstBufferList;
+    CpaFlatBuffer     srcFlatBuffer[2];
+    CpaFlatBuffer     dstFlatBuffer[2];
+
+    /* Crypto */
+    unsigned char *hmac_key; //Why do we need this it should be in the context
+    Cpa8U*   pIv;
+    SHA_CTX  key_wrap;
+
+    /* TLS SSL proto */
+    /*  Reintroduce when QAT decryption added size_t       
+     * payload_length;
+     */
+    Cpa8U*	 tls_virt_hdr;
+    unsigned int tls_version;
+
+} qat_chained_ctx;
+
+#endif //E_QAT_H
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes_cbc_hmac_sha1.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes_cbc_hmac_sha1.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,419 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+#define AES_BLOCKSIZE 16
+
+/******************************************************************************
+* function:
+*         run_aes_cbc_hmac_sha1(int count,
+*                     ENGINE *e
+*                     int print_output
+*                     int verify
+*                     int len)
+*
+* @param count [IN] - number of iterations
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+* @param len [IN] - the length of input message
+*
+* description:
+*   The function is designed to test AES_128_hmac_sha1 alg chaining for encryption
+*   and decryption using QAT engine.
+*   
+*   The higher level EVP interface function EVP_EncryptInit_ex(), EVP_EncryptUpdate()
+*   and EVP_EncryptFinal_ex() are called for encryption routines inside of test application.
+*   EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
+*   corresponding EVP decryption routines.
+*   
+*   The Ctrl functions EVP_CIPHER_CTX_ctrl are called after the Init to set up the 
+*   TLS headers and the HMAC keys.
+*
+******************************************************************************/
+static void
+run_aes_cbc_hmac_sha1(int count, ENGINE * e, int print_output, int verify, int len , int keySize)
+{
+    int i = 0;
+    int ret = 0;
+
+    int cipherLen = 0;
+    int update_len = 0;
+    int DoutLen = 0;
+    int DinLen = 0;
+    EVP_CIPHER_CTX *ctx = NULL;
+
+    EVP_CIPHER_CTX *dctx = NULL;
+
+    /* 32 bytes key */
+    const unsigned char key_32[] = {
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00
+    };
+
+    /* 16 bytes key */
+    const unsigned char key[] = {
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00
+    };
+
+    /* 16 bytes initial vector */
+     unsigned char ivec[] = {
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42
+    };
+
+    static unsigned char hmac_key[] =
+    {
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
+        0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b
+
+    };
+
+    /* obtain the length in two bytes */
+    unsigned char lengthByte1 = len >> 8 ;
+    unsigned char lengthByte2 = len|16 >> 8 ; 
+
+    /*  Create the TLS virtual header:
+        TLS seq = first 8 bytes
+        0x16 = TLS handshake protocl 
+        0x03, 0x01 = major minor version number
+        The last two bytes are the payload length */
+    
+     unsigned char tls_virt_hdr[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x16, 0x03, 0x01, lengthByte1, lengthByte2 
+    };
+
+
+    /* initialise ctx for encryption */
+    ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for ctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+
+    EVP_CIPHER_CTX_init(ctx);
+
+    DEBUG("\n----- Encrypt AES_128_cbc-hmac-sha1 ----- \n\n");
+
+    if (keySize == TEST_AES128_CBC_HMAC_SHA1)
+    {
+    	ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_aes_128_cbc_hmac_sha1(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    }
+    else if (keySize == TEST_AES256_CBC_HMAC_SHA1)
+    {
+        ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_aes_256_cbc_hmac_sha1(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key_32,   /* Key */
+                             ivec   /* initial vector */
+        );
+
+    }
+    else 
+    {
+        printf("\n Incorrect KeySize\n");
+        exit(EXIT_FAILURE);
+
+    }
+    
+    
+
+    if (ret != 1)
+    {
+        
+        printf("[%s] --- EVP_EncryptInit_ex() ret = %d!\n", __func__, ret);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        exit(EXIT_FAILURE);
+    }
+
+    /* call the EVP API to set up the HMAC key */
+    EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY , 16 ,hmac_key);
+
+    /* get the TLS record padding size */
+    int  pad = EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_TLS1_AAD, sizeof(tls_virt_hdr), (void*)tls_virt_hdr);
+
+    unsigned char *input = OPENSSL_malloc(len); 
+
+    /* setup input message values */
+    for (i = 0; i < (len); i++)
+        input[i] = i % 16;
+
+
+
+
+    if (print_output)
+        tests_hexdump("AES128-CBC-HMAC-SHA1 - INPUT  :", input, len);
+
+   /* create the buffers */
+    unsigned char *outcipher = OPENSSL_malloc(len + pad);
+    unsigned char *Doutput = OPENSSL_malloc(len + pad);
+    unsigned char *incipher = outcipher;
+
+
+    /*add padding and diggest to message */
+    int completeMsgLen =  len + pad;
+    
+    /* do cipher for every count - specified by the user -c option */
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_EncryptUpdate(ctx,    /* EVP_CIPHER_CTX */
+                                outcipher,  /* output cipher pointer */
+                                &cipherLen, /* output cipher length pointer */
+                                input,  /* input text */
+                                completeMsgLen  /* input text length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_EncryptUpdate, ret = %d!\n", __func__,ret);
+                   
+            goto err;
+        }
+    }
+
+
+    DEBUG("outLen now is %d \n", cipherLen);
+
+    DEBUG("Calling EVP_CipherFinal! \n");
+
+    if (print_output)
+        tests_hexdump("AES128-CBC-HMAC-SHA1 :", outcipher, cipherLen);
+
+    EVP_CIPHER_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+    ctx = NULL;
+
+/*----------------------- Decryption ------------------------ */
+
+/* initialise ctx for decryption */
+    dctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (dctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for dctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(dctx);
+
+    /* set back the update_len value for decryption */
+    update_len = 0;
+    /* input length should same as output cipher length from encryption */
+    DinLen =  cipherLen;
+
+    if (keySize == TEST_AES128_CBC_HMAC_SHA1)
+    {
+        ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_aes_128_cbc_hmac_sha1(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    }
+    else if (keySize == TEST_AES256_CBC_HMAC_SHA1)
+    {
+        ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_aes_256_cbc_hmac_sha1(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key_32,   /* Key */
+                             ivec   /* initial vector */
+        );
+    }
+ 
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+   /* call the EVP API to set up the HMAC key */
+    EVP_CIPHER_CTX_ctrl(dctx, EVP_CTRL_AEAD_SET_MAC_KEY , 16 ,hmac_key);
+
+    /* get the TLS record padding size */
+    int  dec_pad = EVP_CIPHER_CTX_ctrl(dctx, EVP_CTRL_AEAD_TLS1_AAD, sizeof(tls_virt_hdr), (void*)tls_virt_hdr);
+
+
+    for (i = 0; i < count; i++)
+    {
+        ret = EVP_DecryptUpdate(dctx,   /* EVP_CIPHER_CTX */
+                                Doutput,    /* output text pointer */
+                                &DoutLen,   /* output text length pointer */
+                                incipher,   /* input cipher for decryption */
+                                DinLen  /* input cipher length */
+            );
+    }
+
+   if (print_output)
+        tests_hexdump("AES128-CBC-HMAC-SHA1 Decrypted msg:", Doutput, (DoutLen+dec_pad));
+
+    /* Compare and verify the decrypt and encrypt message. */
+    if (verify )
+    {
+  
+        if (keySize == TEST_AES128_CBC_HMAC_SHA1)
+        {     
+            if (memcmp(Doutput, input, (len) ))
+            {
+               printf("# FAIL verify for AES128-CBC-HMAC-SHA1");
+
+                tests_hexdump("AES128-CBC-HMAC-SHA1 actual  :", Doutput, len);
+                tests_hexdump("AES128-CBC-HMAC-SHA1 expected:", input, len);
+
+            }
+            else
+            {
+                printf("# PASS verify for AES128-CBC-HMAC-SHA1\n");
+            }
+
+        }
+        else if (keySize == TEST_AES256_CBC_HMAC_SHA1)
+        {
+            if (memcmp(Doutput, input, (len) ))
+            {
+               printf("# FAIL verify for AES256-CBC-HMAC-SHA1");
+
+                tests_hexdump("AES256-CBC-HMAC-SHA1 actual  :", Doutput, len);
+                tests_hexdump("AES256-CBC-HMAC-SHA1 expected:", input, len);
+
+            }
+            else
+            {
+                printf("# PASS verify for AES256-CBC-HMAC-SHA1\n");
+            }
+
+         }
+    }
+
+
+    EVP_CIPHER_CTX_cleanup(dctx);
+    OPENSSL_free(dctx);
+    dctx = NULL;
+
+    if (input)
+        OPENSSL_free(input);
+    if (outcipher)
+        OPENSSL_free(outcipher);
+    if (Doutput)
+        OPENSSL_free(Doutput);
+    return;
+
+  err:
+    if (ctx != NULL)
+    {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        OPENSSL_free(ctx);
+    }
+    if (dctx != NULL) ;
+    {
+        EVP_CIPHER_CTX_cleanup(dctx);
+        OPENSSL_free(dctx);
+    }
+    exit(EXIT_FAILURE);
+
+
+}
+
+/******************************************************************************
+* function:
+*   tests_run_aes_cbc_hmac_sha1 (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_aes_cbc_hmac_sha1(int count, int size, ENGINE * e, int print_output, int verify, int keySize)
+{
+    run_aes_cbc_hmac_sha1(count, e, print_output, verify, size, keySize);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/main.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/main.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,972 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+/* macros defined to allow use of the cpu get and set affinity functions */
+#define _GNU_SOURCE
+#define __USE_GNU
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <sched.h>
+#include <sys/time.h>
+#include <unistd.h>
+
+#include <openssl/engine.h>
+#include <openssl/evp.h>
+
+#include "cpa.h"
+#include "tests.h"
+#include "qae_mem_utils.h"
+
+/* test_count specify the number of workers that each thread  */
+static pthread_cond_t ready_cond;
+static pthread_cond_t start_cond;
+static pthread_cond_t stop_cond;
+static pthread_mutex_t mutex;
+static int cleared_to_start;
+static int active_thread_count;
+static int ready_thread_count;
+static pthread_mutex_t *open_ssl_mutex_list;
+static long *openssl_mutex_count;
+
+/* thread_count control number of threads create */
+static int thread_count = 1;
+
+/* define the initial test values */
+static int core_count = 1;
+static int enable_engine = 1;
+static int test_count = 1;
+static int test_size = 1024;
+static int cpu_affinity = 0;
+static int test_type = 0;
+static int print_output = 0;
+static int verify = 0;
+static int zero_copy = 0;
+static int cpu_core_info = 0;
+extern int qatPerformOpRetries;
+/* default engine declaration */
+static ENGINE *engine = NULL;
+
+/* Thread_info structure declaration */
+typedef struct
+{
+    pthread_t th;
+    int id;
+    int count;
+}
+THREAD_INFO;
+
+#define MAX_STAT 10
+#define MAX_CORE 32
+typedef union
+{
+    struct 
+    {
+        int user;
+        int nice;
+        int sys;
+        int idle;
+        int io;
+        int irq;
+        int softirq;
+        int context;
+    };
+    int d[MAX_STAT];
+}
+cpu_time_t;
+
+static cpu_time_t cpu_time[MAX_CORE];
+static cpu_time_t cpu_time_total;
+static cpu_time_t cpu_context;
+
+#define MAX_THREAD 1024
+
+THREAD_INFO tinfo[MAX_THREAD];
+
+/******************************************************************************
+* function:
+*	 cpu_time_add (cpu_time_t *t1, cpu_time_t *t2, int subtract)
+*   
+* @param t1 [IN] - cpu time 
+* @param t2 [IN] - cpu time 
+* @param substract [IN] - subtract flag
+*
+* description:
+*   CPU timing calculation functions.
+******************************************************************************/
+static void cpu_time_add (cpu_time_t *t1, cpu_time_t *t2, int subtract)
+{
+    int i;
+
+    for (i = 0; i < MAX_STAT; i++)
+    {
+        if (subtract)
+            t1->d[i] -= t2->d[i];
+        else
+            t1->d[i] += t2->d[i];
+    }
+}
+
+/******************************************************************************
+* function:
+*	read_stat (int init)
+*   
+* @param init [IN] - op flag  
+*
+* description:
+*  read in CPU status from proc/stat file 
+******************************************************************************/
+static void read_stat (int init)
+{
+    char line[1024];
+    char tag[10];
+    FILE *fp;
+    int index = 0;
+    int i;
+    cpu_time_t tmp;
+
+    if ((fp = fopen ("/proc/stat", "r")) == NULL)
+    {
+        fprintf (stderr, "Can't open proc stat\n");
+        exit (1);
+    }
+
+    while (!feof (fp))
+    {
+        if (fgets (line, sizeof line - 1, fp) == NULL)
+            break;
+
+        if (!strncmp (line, "ctxt", 4))
+        {
+            if (sscanf (line, "%*s %d", &tmp.context) < 1)
+                goto parse_fail;
+
+            cpu_time_add (&cpu_context, &tmp, init);
+            continue;
+        }
+
+        if (strncmp (line, "cpu", 3))
+            continue;
+
+        if (sscanf (line, "%s %d %d %d %d %d %d %d",
+                tag, 
+                &tmp.user,
+                &tmp.nice,
+                &tmp.sys,
+                &tmp.idle,
+                &tmp.io,
+                &tmp.irq,
+                &tmp.softirq) < 8)
+        {
+            goto parse_fail;
+        }
+
+        if (!strcmp (tag, "cpu"))
+            cpu_time_add (&cpu_time_total, &tmp, init);
+        else if (!strncmp (tag, "cpu", 3))
+        {
+            index = atoi (&tag[3]);
+            cpu_time_add (&cpu_time[index], &tmp, init);
+        }
+    }
+
+    if (!init && cpu_core_info)
+    {
+        printf ("      %10s %10s %10s %10s %10s %10s %10s\n", 
+                "user", "nice", "sys", "idle", "io", "irq", "sirq");
+        for (i = 0; i < MAX_CORE + 1; i++)
+        {
+            cpu_time_t *t;
+
+            if (i == MAX_CORE)
+            {
+                printf ("total ");
+                t = &cpu_time_total;
+            }
+            else
+            {
+                printf ("cpu%d  ", i);
+                t = &cpu_time[i];
+            }
+
+            printf (" %10d %10d %10d %10d %10d %10d %10d\n", 
+                    t->user,
+                    t->nice,
+                    t->sys,
+                    t->idle,
+                    t->io,
+                    t->irq,
+                    t->softirq);
+        }
+
+        printf ("Context switches: %d\n", cpu_context.context);
+    }
+
+    fclose (fp);
+    return;
+
+parse_fail:
+    fprintf (stderr, "Failed to parse %s\n", line);
+    exit (1);
+}
+
+/******************************************************************************
+* function:
+*   rdtsc (void)
+*
+* description:
+*   Timetamp Counter for measuring clock cycles in performance testing.
+******************************************************************************/
+static __inline__ unsigned long long rdtsc(void)
+{
+    unsigned long a, d;
+
+    asm volatile ("rdtsc":"=a" (a), "=d"(d));
+
+    return (((unsigned long long)a) | (((unsigned long long)d) << 32));
+}
+
+/******************************************************************************
+* function:
+*           *test_name(int test)
+*
+* @param test [IN] - test case
+*
+* description:
+*   test_name selection list
+******************************************************************************/
+static char *test_name(int test)
+{
+    switch (test)
+    {
+        case TEST_SHA512:
+            return "SHA512";
+            break;
+        case TEST_SHA256:
+            return "SHA256";
+            break;
+        case TEST_SHA1:
+            return "SHA1";
+            break;
+        case TEST_AES256:
+            return "AES256";
+            break;
+        case TEST_AES192:
+            return "AES192";
+            break;
+        case TEST_AES128:
+            return "AES128";
+            break;
+        case TEST_RC4:
+            return "RC4";
+            break;
+        case TEST_DES3:
+            return "DES3";
+            break;
+        case TEST_DES3_ENCRYPT:
+            return "DES3 encrypt";
+            break;
+        case TEST_DES3_DECRYPT:
+            return "DES3 decrypt";
+            break;
+        case TEST_DES:
+            return "DES";
+            break;
+        case TEST_DSA_SIGN:
+            return "DSA sign";
+            break;
+        case TEST_DSA_VERIFY:
+            return "DSA verify";
+            break;
+        case TEST_RSA_SIGN:
+            return "RSA sign";
+            break;
+        case TEST_RSA_VERIFY:
+            return "RSA verify";
+            break;
+        case TEST_RSA_ENCRYPT:
+            return "RSA encrypt";
+            break;
+        case TEST_RSA_DECRYPT:
+            return "RSA decrypt";
+            break;
+        case TEST_HMAC:
+            return "HMAC";
+            break;
+        case TEST_MD5:
+            return "MD5";
+            break;
+        case TEST_DH:
+            return "DH";
+            break;
+        case TEST_AES128_CBC_HMAC_SHA1:
+            return "AES128 CBC HMAC SHA1";
+            break;
+        case TEST_AES256_CBC_HMAC_SHA1:
+            return "AES256 CBC HMAC SHA1";
+            break;
+	case 0:
+            return "all tests";
+            break;
+    }
+    return "*unknown*";
+}
+
+/******************************************************************************
+* function:
+*           usage(char *program)
+*
+*
+* @param program [IN] - input argument
+*
+* description:
+*   test application usage help
+******************************************************************************/
+static void usage(char *program)
+{
+    int i;
+
+    printf("\nUsage:\n");
+    printf("\t%s [-t <type>] [-c <count>] [-s <size>] "
+           "[-n <count>] [-nc <count>] [-af] [-d]\n", program);
+    printf("Where:\n");
+    printf("\t-t  specifies the test type to run (see below)\n");
+    printf("\t-c  specifies the test iteration count\n");
+    printf("\t-s  specifies the test message size (default 1024)\n");
+    printf("\t-n  specifies the number of threads to run\n");
+    printf("\t-nc specifies the number of CPU cores\n");
+    printf("\t-af enables core affinity\n");
+    printf("\t-d  disables use of the QAT engine\n");
+    printf("\t-p  print the test output\n");
+    printf("\t-i  icp config section name\n");
+    printf("\t-v  verify the output\n");
+    printf("\t-u  display cpu usage per core\n");
+    printf("\t-z  enable zero copy mode\n");
+    printf("\t-h  print this usage\n");
+    printf("\nand where the -t test type is:\n\n");
+
+    for (i = 1; i <= TEST_TYPE_MAX; i++)
+        printf("\t%-2d = %s\n", i, test_name(i));
+   
+    printf("\nIf test type is not specified, one iteration "
+           "of each test type is executed and verified.\n");
+
+    /* In order to measure the maximum throughput from QAT, the iteration 
+     * test will repeat actual operation to keep QAT busy without reset 
+     * input variables such as initial vector. Thus, the iteration count should 
+     * limited to one for verification propose. 
+     */ 	
+    printf("The test iteration count will set to 1 if the verify flag raised.\n\n");
+    
+    exit(EXIT_SUCCESS);
+}
+
+/******************************************************************************
+* function:
+* parse_option(int *index,
+*                        int argc,
+*                       char *argv[],
+*                        int *value)
+*
+* @param index [IN] - index pointer
+* @param argc [IN] - input argument count
+* @param argv [IN] - argument buffer
+* @param value [IN] - input value pointer
+*
+* description:
+*   user input arguments check
+******************************************************************************/
+static void parse_option(int *index, int argc, char *argv[], int *value)
+{
+    if (*index + 1 >= argc)
+    {
+        fprintf(stderr, "\nParameter expected\n");
+        usage(argv[0]);
+        exit(EXIT_FAILURE);
+    }
+
+    (*index)++;
+
+    *value = atoi(argv[*index]);
+
+}
+
+/******************************************************************************
+* function:
+*           handle_option(int argc,
+*                         char *argv[],
+*                         int *index)
+*
+* @param argc [IN] - input argument count
+* @param argv [IN] - argument buffer
+* @param index [IN] - index pointer
+*
+* description:
+*   input operation handler
+******************************************************************************/
+static void handle_option(int argc, char *argv[], int *index)
+{
+    char *option = argv[*index];
+
+    if (!strcmp(option, "-n"))
+        parse_option(index, argc, argv, &thread_count);
+    else if (!strcmp(option, "-t"))
+        parse_option(index, argc, argv, &test_type);
+    else if (!strcmp(option, "-c"))
+        parse_option(index, argc, argv, &test_count);
+    else if (!strcmp(option, "-af"))
+        cpu_affinity = 1;
+    else if (!strcmp(option, "-nc"))
+        parse_option(index, argc, argv, &core_count);
+    else if (!strcmp(option, "-s"))
+        parse_option(index, argc, argv, &test_size);
+    else if (!strcmp(option, "-i"))
+    {
+        if (*index + 1 >= argc)
+        {
+            fprintf(stderr, "\nParameter expected\n");
+            usage(argv[0]);
+            exit(EXIT_FAILURE);
+        }
+
+        (*index)++;
+
+        extern char *ICPConfigSectionName_start;
+
+        ICPConfigSectionName_start = argv[*index];
+    }
+    else if (!strcmp(option, "-d"))
+    {
+	enable_engine = 0;
+	printf("QAT Engine disabled ! \n");
+    }
+    else if (!strcmp(option, "-p"))
+        print_output = 1;
+    else if (!strcmp(option, "-v"))
+        verify = 1;
+    else if (!strcmp(option, "-z"))
+        zero_copy = 1;
+    else if (!strcmp(option, "-u"))
+        cpu_core_info = 1;
+    else if (!strcmp(option, "-h"))
+        usage(argv[0]);
+    else
+    {
+        fprintf(stderr, "\nInvalid option '%s'\n", option);
+        usage(argv[0]);
+        exit(EXIT_FAILURE);
+    }
+    
+    if(verify)
+    {
+	test_count = 1;
+	core_count = 1;
+	thread_count = 1;
+    }
+}
+
+/******************************************************************************
+* function:
+*	pthreads_locking_callback(int mode, int type, const char *file,
+*                                      int line)
+*
+* @param mode [IN] - mutex lock mode  
+* @param type [IN] - mutex ID 
+* @param file [IN] - file pointer 
+* @param line [IN] - line number
+*
+* description:
+*   unlock mutes if not CRYTO_LOCK
+******************************************************************************/
+static void pthreads_locking_callback(int mode, int type, const char *file,
+                                      int line)
+{
+    if (mode & CRYPTO_LOCK)
+    {
+        pthread_mutex_lock(&(open_ssl_mutex_list[type]));
+        openssl_mutex_count[type]++;
+    }
+    else
+    {
+        pthread_mutex_unlock(&(open_ssl_mutex_list[type]));
+    }
+}
+
+/******************************************************************************
+* function:
+*	pthreads_thread_id(void)
+*
+* description:
+*   return pthreads ID.
+******************************************************************************/
+static unsigned long pthreads_thread_id(void)
+{
+    return (unsigned long)pthread_self();
+}
+
+/******************************************************************************
+* function:
+*           *thread_worker(void *arg)
+*
+* @param arg [IN] - thread structure info
+*
+* description:
+*   thread worker setups. the threads will lunch at the same time after
+*   all of them in ready condition.
+******************************************************************************/
+static void *thread_worker(void *arg)
+{
+    extern void qat_set_instance_for_thread(int);
+
+    THREAD_INFO *info = (THREAD_INFO *) arg;
+    int rc;
+    int performance = 1;
+
+    if (enable_engine)
+        qat_set_instance_for_thread(info->id);
+
+    /* mutex lock for thread count */
+    rc = pthread_mutex_lock(&mutex);
+    ready_thread_count++;
+    pthread_cond_broadcast(&ready_cond);
+    rc = pthread_mutex_unlock(&mutex);
+
+    /* waiting for thread clearance */
+    rc = pthread_mutex_lock(&mutex);
+
+    while (!cleared_to_start)
+        pthread_cond_wait(&start_cond, &mutex);
+
+    rc = pthread_mutex_unlock(&mutex);
+
+    tests_run(&info->count,     /* Interation count */
+              test_type,        /* Test type */
+              test_size,        /* Test message size */
+              engine,           /* Engine indicator */
+              info->id,         /* Thread ID */
+              print_output,     /* Print out results flag */
+              verify,           /* Verify flag */
+              performance       /* Performance or functional */
+        );
+
+    /* update active threads */
+    rc = pthread_mutex_lock(&mutex);
+    active_thread_count--;
+    pthread_cond_broadcast(&stop_cond);
+    rc = pthread_mutex_unlock(&mutex);
+
+    return NULL;
+}
+
+/******************************************************************************
+* function:
+*           performance_test(void)
+*
+* description:
+*   performers test application running on user definition .
+******************************************************************************/
+static void performance_test(void)
+{
+    int i;
+    int coreID = 0;
+    int rc = 0;
+    int sts = 1;
+    cpu_set_t cpuset;
+    struct timeval start_time;
+    struct timeval stop_time;
+    int elapsed = 0;
+    unsigned long long rdtsc_start = 0;
+    unsigned long long rdtsc_end = 0;
+    int bytes_to_bits = 8;
+    int crypto_ops_per_test = 1;
+    float throughput = 0.0;
+    char name[20];
+
+    open_ssl_mutex_list =
+        OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));
+    if (!open_ssl_mutex_list)
+        printf("%s: open_ssl_mutex_list malloc failed.\n", __func__);
+
+    openssl_mutex_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
+    if (!openssl_mutex_count)
+        printf("%s: openssl_mutex_count malloc failed.\n", __func__);
+
+    for (i = 0; i < CRYPTO_num_locks(); i++)
+    {
+        openssl_mutex_count[i] = 0;
+        pthread_mutex_init(&(open_ssl_mutex_list[i]), NULL);
+    }
+
+    CRYPTO_set_id_callback(pthreads_thread_id);
+    CRYPTO_set_locking_callback(pthreads_locking_callback);
+
+    pthread_mutex_init(&mutex, NULL);
+    pthread_cond_init(&ready_cond, NULL);
+    pthread_cond_init(&start_cond, NULL);
+    pthread_cond_init(&stop_cond, NULL);
+
+    for (i = 0; i < thread_count; i++)
+    {
+        THREAD_INFO *info = &tinfo[i];
+
+        info->id = i;
+        info->count = test_count / thread_count;
+
+        pthread_create(&info->th, NULL, thread_worker, (void *)info);
+        sprintf(name, "worker-%d", i);
+
+        /* cpu affinity setup */
+        if (cpu_affinity == 1)
+        {
+            CPU_ZERO(&cpuset);
+
+            /* assigning thread to different cores */
+            coreID = (i % core_count);
+            CPU_SET(coreID, &cpuset);
+
+            sts = pthread_setaffinity_np(info->th, sizeof(cpu_set_t), &cpuset);
+            if (sts != 0)
+            {
+                printf("pthread_setaffinity_np error, status = %d \n", sts);
+                exit(EXIT_FAILURE);
+            }
+           sts = pthread_getaffinity_np(info->th, sizeof(cpu_set_t), &cpuset);
+            if (sts != 0)
+            {
+                printf("pthread_getaffinity_np error, status = %d \n", sts);
+                exit(EXIT_FAILURE);
+            }
+
+            if (CPU_ISSET(coreID, &cpuset))
+                printf("Thread %d assigned on CPU core %d\n", i, coreID);
+        }
+    }
+
+    /* set all threads to ready condition */
+    rc = pthread_mutex_lock(&mutex);
+
+    while (ready_thread_count < thread_count)
+    {
+        pthread_cond_wait(&ready_cond, &mutex);
+    }
+
+    rc = pthread_mutex_unlock(&mutex);
+
+    printf("Beginning test ....\n");
+    /* all threads start at the same time */
+    read_stat (1);
+    gettimeofday(&start_time, NULL);
+    rdtsc_start = rdtsc();
+    rc = pthread_mutex_lock(&mutex);
+    cleared_to_start = 1;
+    pthread_cond_broadcast(&start_cond);
+    pthread_mutex_unlock(&mutex);
+
+    /* wait for other threads stop */
+    rc = pthread_mutex_lock(&mutex);
+
+    while (active_thread_count > 0)
+        pthread_cond_wait(&stop_cond, &mutex);
+
+    rc = pthread_mutex_unlock(&mutex);
+
+    for (i = 0; i < thread_count; i++)
+    {
+        if (pthread_join(tinfo[i].th, NULL))
+            printf("Could not join thread id - %d !\n", i);
+    }
+
+    CRYPTO_set_locking_callback(NULL);
+
+    for (i = 0; i < CRYPTO_num_locks(); i++)
+    {
+        pthread_mutex_destroy(&(open_ssl_mutex_list[i]));
+    }
+
+    OPENSSL_free(open_ssl_mutex_list);
+    OPENSSL_free(openssl_mutex_count);
+
+    rdtsc_end = rdtsc();
+    gettimeofday(&stop_time, NULL);
+    read_stat (0);
+    printf("All threads complete\n\n");
+
+    if (!test_count)
+    {
+        for (i = 0; i < thread_count; i++)
+        {
+            test_count -= tinfo[i].count;
+        }
+    }
+
+    /* generate report */
+    elapsed = (stop_time.tv_sec - start_time.tv_sec) * 1000000 +
+        (stop_time.tv_usec - start_time.tv_usec);
+
+    /* Cipher tests, except for DES3_ENCRYPT and DES3_DECRYPT, contain 2
+       performOp calls. */
+    if (test_type <= MAX_CIPHER_TEST_TYPE && test_type != TEST_DES3_ENCRYPT
+        && test_type != TEST_DES3_DECRYPT)
+        crypto_ops_per_test = 2;
+
+    /* Cast test_size * test_count to avoid int overflow */
+    throughput = ((float)test_size * (float)test_count *
+                  (bytes_to_bits * crypto_ops_per_test) / (float)elapsed);
+
+    printf("Elapsed time   = %.3f msec\n", (float)elapsed / 1000);
+    printf("Operations     = %d\n", test_count);
+
+    printf("Time per op    = %.3f usec (%d ops/sec)\n",
+           (float)elapsed / test_count,
+           (int)((float)test_count * 1000000.0 / (float)elapsed));
+
+    printf("Elapsed cycles = %llu\n", rdtsc_end - rdtsc_start);
+
+    printf("Throughput     = %.2f (Mbps)\n", throughput);
+
+    printf("Retries        = %d\n", qatPerformOpRetries);
+
+    printf("\nCSV summary:\n");
+
+    printf("Algorithm,"
+           "Test_type,"
+           "Using_engine,"
+           "Core_affinity,"
+           "Elapsed_usec," 
+           "Cores," 
+           "Threads," 
+           "Count," 
+           "Data_size," 
+           "Mbps,"
+           "CPU_time,"
+           "User_time,"
+           "Kernel_time\n");
+
+    int cpu_time = 0;
+    int cpu_user = 0;
+    int cpu_kernel = 0;
+
+    cpu_time = (cpu_time_total.user + 
+                cpu_time_total.nice + 
+                cpu_time_total.sys + 
+                cpu_time_total.io + 
+                cpu_time_total.irq + 
+                cpu_time_total.softirq) * 10000 / core_count;
+    cpu_user = cpu_time_total.user * 10000 / core_count;
+    cpu_kernel = cpu_time_total.sys * 10000 / core_count;
+
+    printf("csv,%s,%d,%s,%s,%d,%d,%d,%d,%d,%.2f,%d,%d,%d\n",
+           test_name(test_type),
+           test_type,
+           (enable_engine) ? "Yes" : "No",
+           cpu_affinity ? "Yes" : "No",
+           elapsed,
+           core_count, thread_count, test_count, test_size, throughput,
+           cpu_time * 100 / elapsed,
+            cpu_user * 100 / elapsed,
+            cpu_kernel * 100 / elapsed);
+}
+
+/******************************************************************************
+* function:
+*           functional_test(void)
+*
+* description:
+*    Default testing application, a single thread test running through all the
+*    test cases with testing function definition values
+******************************************************************************/
+static void functional_test(void)
+{
+    int i;
+    int id = 0;
+    int verify = 1;
+    int count = 1;
+    int size = 1024;
+    int performance = 0;
+
+    printf("\nResults for functional test cases:\n");
+
+    for (i = 1; i <= TEST_TYPE_MAX; i++)
+    {
+        if (zero_copy &&
+            (i == TEST_SHA1 || 
+             i == TEST_SHA256 ||
+             i == TEST_SHA512 || 
+             i == TEST_MD5 || 
+             i == TEST_DSA_SIGN || 
+             i == TEST_DSA_VERIFY || 
+             i == TEST_DH || 
+             i == TEST_HMAC))
+        {
+            printf ("skipping %s in zero copy mode\n",
+                    test_name(i));
+            continue;
+        }
+
+        tests_run(&count, i, size, engine, id, print_output, verify,
+                  performance);
+    }
+}
+
+/******************************************************************************
+* function:
+*           main(int argc,
+*                char *argv[])
+*
+* @param argc [IN] - input argument count
+* @param argv [IN] - argument buffer
+*
+* description:
+*    main function is used to setups QAT engine setups and define the testing type.
+******************************************************************************/
+int main(int argc, char *argv[])
+{
+    int i = 0;
+
+    for (i = 1; i < argc; i++)
+    {
+        if (argv[i][0] != '-')
+            break;
+
+        handle_option(argc, argv, &i);
+    }
+
+    /* The thread count should not be great than the test cout */ 
+    if (thread_count > test_count )
+    {
+	thread_count = test_count;
+
+ 	printf("\nWARNING - Thread Count cannot aceed the Test Count");
+        printf("\nThread Count adjusted to: %d\n\n", thread_count);
+    } 
+
+
+
+    if (zero_copy)
+    {
+        if (access(QAT_DEV, F_OK) == 0)
+        {
+            if (CRYPTO_set_mem_ex_functions(qaeMemAlloc, qaeMemRealloc, qaeMemFree))
+            {
+                DEBUG("%s: CRYPTO_set_mem_functions succeeded\n", __func__);
+            }
+
+            setMyVirtualToPhysical (qaeMemV2P);
+        }
+        else
+        {
+            perror(QAT_DEV);
+        }
+    }
+
+    if (i < argc)
+    {
+        fprintf(stderr,
+                "This program does not take arguments, please use -h for usage.\n");
+        exit(EXIT_FAILURE);
+    }
+
+    active_thread_count = thread_count;
+    ready_thread_count = 0;
+
+    /* Load qat engine for workers */
+    if (enable_engine)
+    {
+        ENGINE_load_builtin_engines();
+        engine = tests_initialise_engine();
+
+        if (!engine)
+        {
+            fprintf(stderr, "ENGINE load error, exit! \n");
+            exit(EXIT_FAILURE);
+        }
+    }
+    else
+	printf("QAT Engine disabled ! \n");
+    
+    printf("\nQAT openssl engine test application\n");
+    printf("\n\tCopyright (C) 2010 Intel Corporation\n");
+    printf("\nTest parameters:\n\n");
+    printf("\tTest type:           %d (%s)\n", test_type, test_name(test_type));
+    printf("\tTest count:          %d\n", test_count);
+    printf("\tThread count:        %d\n", thread_count);
+    printf("\tMessage size:        %d\n", test_size);
+    printf("\tPrint output:        %s\n", print_output ? "Yes" : "No");
+    printf("\tCPU core affinity:   %s\n", cpu_affinity ? "Yes" : "No");
+    printf("\tNumber of cores:     %d\n", core_count);
+    printf("\tQAT Engine enabled:  %s\n", (enable_engine) ? "Yes" : "No");
+
+    printf("\n");
+
+    if (test_type == 0)
+        functional_test();
+    else
+        performance_test();
+
+    if (engine)
+        tests_cleanup_engine(engine);
+    ENGINE_cleanup();
+
+    return 0;
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes128.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes128.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,340 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+#define AES128_BLOCKSIZE 16
+
+/******************************************************************************
+* function:
+*         run_aes128 (int count,
+*                     ENGINE *e
+*                     int print_output
+*                     int verify
+*                     int len)
+*
+* @param count [IN] - number of iterations
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+* @param len [IN] - the length of input message
+*
+* description:
+*   The function is design to test AES_128 cipher encryption and decryption using QAT engine.
+*   The higher level EVP interface function EVP_EncryptInit_ex(), EVP_EncryptUpdate()
+*   and EVP_EncryptFinal_ex() are called for encryption routines inside of test application.
+*   EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
+*   corresponding EVP decryption routines.
+*
+******************************************************************************/
+static void
+run_aes128(int count, ENGINE * e, int print_output, int verify, int len)
+{
+    int i = 0;
+    int ret = 0;
+
+    unsigned char *input = OPENSSL_malloc(len);
+
+    /* adding extra four black size memory space for large input data */
+    unsigned char *outcipher = OPENSSL_malloc(len + AES128_BLOCKSIZE*4);
+    unsigned char *Doutput = OPENSSL_malloc(len + AES128_BLOCKSIZE*4);
+    unsigned char *incipher = outcipher;
+    int cipherLen = 0;
+    int update_len = 0;
+    int DoutLen = 0;
+    int DinLen = 0;
+    EVP_CIPHER_CTX *ctx = NULL;
+    EVP_CIPHER_CTX *dctx = NULL;
+
+    /* 16 bytes key */
+    const unsigned char key[] = {
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00
+    };
+
+    /* 16 bytes initial vector */
+    const unsigned char ivec[] = {
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42
+    };
+
+    if (input == NULL || outcipher == NULL || Doutput == NULL)
+    {
+        printf("[%s] --- Initial parameters malloc failed ! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* setup input message values */
+    for (i = 0; i < len; i++)
+        input[i] = i % 16;
+
+    /* initialise ctx for encryption */
+    ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for ctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(ctx);
+
+    DEBUG("\n----- Encrypt AES_128_cbc cipher ----- \n\n");
+
+    if (print_output)
+        tests_hexdump("AES128 input msg:", input, len);
+
+    ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_aes_128_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- EVP_EncryptInit_ex() ret = %d!\n", __func__, ret);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        exit(EXIT_FAILURE);
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_EncryptUpdate(ctx,    /* EVP_CIPHER_CTX */
+                                outcipher,  /* output cipher pointer */
+                                &cipherLen, /* output cipher length pointer */
+                                input,  /* input text */
+                                len /* input text length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_EncryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    DEBUG("outLen now is %d \n", cipherLen);
+
+    DEBUG("Calling EVP_CipherFinal! \n");
+
+    ret = EVP_EncryptFinal_ex(ctx,  /* EVP_CIPHER_CTX */
+                              outcipher + cipherLen,    /* output buffer,
+                                                           update from the last 
+                                                           padding block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in evp_EncryptFinal, ret = %d\n", __func__, ret);
+        goto err;
+    }
+
+    /* update the outLen of output */
+    cipherLen += update_len;
+
+    if (print_output)
+        tests_hexdump("AES128 Cipher:", outcipher, cipherLen);
+
+    EVP_CIPHER_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+    ctx = NULL;
+
+        /*---------- Decryption ----------*/
+
+    /* initialise ctx for decryption */
+    dctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (dctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for dctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(dctx);
+
+    /* set back the update_len value for decryption */
+    update_len = 0;
+    /* input length should same as output cipher length from encryption */
+    DinLen = cipherLen;
+
+    ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_aes_128_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        ret = EVP_DecryptUpdate(dctx,   /* EVP_CIPHER_CTX */
+                                Doutput,    /* output text pointer */
+                                &DoutLen,   /* output text length pointer */
+                                incipher,   /* input cipher for decryption */
+                                DinLen  /* input cipher length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_DecryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    ret = EVP_DecryptFinal_ex(dctx, /* EVP_CIPHER_CTX */
+                              Doutput + DoutLen,    /* output buffer, update
+                                                       from the last padding
+                                                       block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptFinal, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    /* decrypt outlen update */
+    DoutLen += update_len;
+
+    if (print_output)
+        tests_hexdump("AES128 Decrypted msg:", Doutput, DoutLen);
+
+    /* Compare and verify the decrypt and encrypt message. */
+    if (verify)
+    {
+        if (memcmp(Doutput, input, len))
+        {
+            printf("# FAIL verify for AES128.\n");
+
+            tests_hexdump("AES128 actual  :", Doutput, DoutLen);
+            tests_hexdump("AES128 expected:", input, len);
+
+        }
+        else
+        {
+            printf("# PASS verify for AES128.\n");
+        }
+    }
+
+    EVP_CIPHER_CTX_cleanup(dctx);
+    OPENSSL_free(dctx);
+    dctx = NULL;
+
+    if (input)
+        OPENSSL_free(input);
+    if (outcipher)
+        OPENSSL_free(outcipher);
+    if (Doutput)
+        OPENSSL_free(Doutput);
+    return;
+
+  err:
+    if (ctx != NULL)
+    {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        OPENSSL_free(ctx);
+    }
+    if (dctx != NULL) ;
+    {
+        EVP_CIPHER_CTX_cleanup(dctx);
+        OPENSSL_free(dctx);
+    }
+    exit(EXIT_FAILURE);
+}
+
+/******************************************************************************
+* function:
+*   tests_run_aes128 (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_aes128(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_aes128(count, e, print_output, verify, size);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_md5.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_md5.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,159 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/md5.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+/******************************************************************************
+* function:
+*   tests_run_md5_msg (int count,
+*                      int size,
+*                      ENGINE *e
+*                      int print_output,
+*                      int verify)
+*
+* @param count        [IN] - number of iterations
+* @param size         [IN] - input data size
+* @param e            [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify       [IN] - verify flag
+*
+* Description:
+*   This function is designed to test the QAT engine with variable message sizes
+*   using the MD5 algorithm. The higher level EVP interface function EVP_Digest()
+*   is used inside of test application.
+*   This is a boundary test, the application should return the expected digest hash value.
+******************************************************************************/
+
+void tests_run_md5_msg(int count, int size, ENGINE * e, int print_output,
+                       int verify)
+{
+    int i = 0;
+    int inLen = size;
+    int ret = 0;
+
+    /* Use default input size in verify mode. */
+    if (verify)
+        size = 1024;
+
+    unsigned char md[MD5_DIGEST_LENGTH];
+    unsigned char *inData = OPENSSL_malloc(inLen);
+
+    unsigned char expected[] = {
+        0xC5, 0x99, 0x59, 0x4B, 0x3E, 0xAF, 0xAB, 0x99,
+        0x0E, 0x1B, 0x1B, 0x41, 0x57, 0x1F, 0x2D, 0xE2,
+    };
+
+    if (inData == NULL)
+    {
+        printf("[%s] --- inData malloc failed! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* Setup the input and output data. */
+    memset(inData, 0xaa, inLen);
+    memset(md, 0x00, MD5_DIGEST_LENGTH);
+
+    for (i = 0; i < count; i++)
+    {
+        DEBUG("\n----- MD5 digest msg ----- \n\n");
+
+        ret = EVP_Digest(inData,    /* Input data pointer.  */
+                         inLen, /* Input data length.  */
+                         md,    /* Ouput hash pointer.  */
+                         NULL, EVP_md5(),   /* Hash algorithm indicator. */
+                         e      /* Engine indicator.  */
+            );
+
+        if (ret != 1 || verify)
+        {
+            /* Compare the digested result with the expected result */
+            if (memcmp(md, expected, MD5_DIGEST_LENGTH))
+            {
+                printf("# FAIL verify for MD5\n");
+
+                tests_hexdump("MD5 actual  :", md, MD5_DIGEST_LENGTH);
+                tests_hexdump("MD5 expected:", expected, MD5_DIGEST_LENGTH);
+            }
+            else
+            {
+                printf("# PASS verify for MD5.\n");
+            }
+        }
+
+        if (print_output)
+            tests_hexdump("MD5 digest text:", md, MD5_DIGEST_LENGTH);
+    }
+
+    if (inData)
+        OPENSSL_free(inData);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_sha256.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_sha256.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,162 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+/******************************************************************************
+* function:
+*   tests_run_sha256__msg (int count,
+*                          int size, 
+*                          ENGINE *e
+*                          int print_output,
+*                          int verify)
+*
+* @param count        [IN] - number of iterations
+* @param size         [IN] - input data size 
+* @param e            [IN] - OpenSSL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify       [IN] - verify flag
+*
+* description:
+*   This function is designed to test the QAT engine with variable message sizes
+*   using the SHA256 algorithm. The higher level EVP interface function EVP_Digest()
+*   is used inside of test application.
+*   This is a boundary test, the application should return the expected digest hash value.
+*   In verify mode a input size of 1024 bytes is used to generate a comparison digest.
+******************************************************************************/
+void tests_run_sha256_msg(int count, int size, ENGINE * e, int print_output,
+                          int verify)
+{
+    int i = 0;
+    int inLen = size;
+    int ret = 0;
+
+    /* Use default input size in verify mode. */
+    if (verify)
+        inLen = 1024;
+
+    unsigned char md[SHA256_DIGEST_LENGTH];
+    unsigned char *inData = OPENSSL_malloc(inLen);
+
+    unsigned char expected[] = {
+        0x0E, 0xC7, 0x76, 0x47, 0xB0, 0x18, 0x96, 0x7B,
+        0x6E, 0x56, 0x57, 0x55, 0x35, 0xA7, 0x8E, 0x12,
+        0xC4, 0x8D, 0x35, 0xD2, 0x75, 0x50, 0xA8, 0xA8,
+        0x9E, 0x1D, 0x39, 0xA7, 0xBE, 0xA8, 0x97, 0x88,
+    };
+
+    if (inData == NULL)
+    {
+        printf("*** [%s] --- inData malloc failed! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* Setup the input and output data. */
+    memset(inData, 0xaa, inLen);
+    memset(md, 0x00, SHA256_DIGEST_LENGTH);
+
+    for (i = 0; i < count; i++)
+    {
+        DEBUG("\n----- SHA256 digest msg ----- \n\n");
+
+        ret = EVP_Digest(inData,    /* Input data pointer.  */
+                         inLen, /* Input data length.  */
+                         md,    /* Output hash pointer.  */
+                         NULL, EVP_sha256(),    /* Hash algorithm indicator */
+                         e      /* Engine indicator.  */
+            );
+
+        if (ret != 1 || verify)
+        {
+            /* Compare the digested results with the expected results */
+            if (memcmp(md, expected, SHA256_DIGEST_LENGTH))
+            {
+                printf("# FAIL verify for SHA256.\n");
+
+                tests_hexdump("SHA256 actual  :", md, SHA256_DIGEST_LENGTH);
+                tests_hexdump("SHA256 expected:", expected,
+                              SHA256_DIGEST_LENGTH);
+            }
+            else
+            {
+                printf("# PASS verify for SHA256.\n");
+            }
+        }
+
+        if (print_output)
+            tests_hexdump("SHA256 digest text:", md, SHA256_DIGEST_LENGTH);
+    }
+
+    if (inData)
+        OPENSSL_free(inData);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/Makefile	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,57 @@
+CFLAGS+=-g -I${OPENSSL_ROOT}/include \
+-I${OPENSSL_ROOT}/crypto \
+-I${OPENSSL_ROOT} \
+-I$(ICP_ROOT)/quickassist/lookaside/access_layer/include \
+-I$(ICP_ROOT)/quickassist/include \
+-I$(OPENSSL_ROOT)/engines/qat_engine
+
+
+CC=gcc
+#COVERAGE=-fprofile-arcs -ftest-coverage -O3
+#COVERAGE=-finstrument-functions -ggdb3 -rdynamic
+COVERAGE=-ggdb3 -pg
+# COVERAGE=-O3
+CFLAGS+=$(COVERAGE) -Wall
+SRCS=\
+main.c \
+tests.c \
+tests_md5.c \
+tests_sha1.c \
+tests_sha256.c \
+tests_sha512.c \
+tests_des3.c \
+tests_des.c \
+tests_aes256.c \
+tests_aes192.c \
+tests_aes128.c \
+tests_rc4.c \
+tests_rsa.c \
+tests_dsa.c \
+tests_hmac.c \
+tests_dh.c \
+tests_aes_cbc_hmac_sha1.c
+
+OBJS = $(SRCS:%.c=%.o)
+#COVERAGE_OBJS = $(SRCS:%.c=%.gcno) $(SRCS:%.c=%.gcda)
+COVERAGE_OBJS =
+
+LIBQAT=$(ICP_ROOT)/build/icp_qa_al.a -L$(ICP_ROOT)/build -ladf_proxy -losal -lcrypto
+
+testapp: $(OBJS) tests.h ${OPENSSL_ROOT}/libcrypto.a 
+	$(CC) -o testapp $(OBJS) $(COVERAGE) -L${OPENSSL_ROOT}/ \
+	-lcrypto -lssl -ldl -lrt \
+	-lpthread \
+	$(LIBQAT)
+#	fiber.o vxthread.o \
+
+fiber.o: fiber.c
+	$(CC) -c $(CFLAGS) fiber.c
+
+vxthread.o: vxthread.c
+	$(CC)  -c $(CFLAGS) vxthread.c
+
+timeswap: timeswap.o
+	gcc -o timeswap timeswap.o -lpthread
+
+clean: $(OBJS)
+	rm $(OBJS) $(COVERAGE_OBJS) testapp
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_des3.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_des3.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,397 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+#define DES_BLOCKSIZE 8
+
+/******************************************************************************
+* function:
+*         run_des3 (int count,
+*                   ENGINE *e
+*                   int print_output
+*                   int verify
+*                   int len)
+*
+* @param count [IN] - number of iterations
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+* @param len [IN] - the length of input message
+*
+* description:
+*   The function is design to test  DES_EDE3_CBC cipher encryption and decryption using QAT engine.
+*   The higher level EVP interface function EVP_EncryptInit_ex(), EVP_EncryptUpdate()
+*   and EVP_EncryptFinal_ex() are called for encryption routines inside of test application.
+*   EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
+*   corresponding EVP decryption routines.
+*
+******************************************************************************/
+
+void run_des3(int count, ENGINE * e, int print_output, int verify, int len,
+	      int encrypt_only, int decrypt_only)
+{
+    int i = 0;
+    int ret = 0;
+
+    unsigned char *input = OPENSSL_malloc(len);
+
+    /* extra one black size memory space needed for padding */
+    unsigned char *outcipher = OPENSSL_malloc(len + DES_BLOCKSIZE*4);
+    unsigned char *Doutput = OPENSSL_malloc(len + DES_BLOCKSIZE*4);
+    unsigned char *incipher = outcipher;
+    int cipherLen = 0;
+    int update_len = 0;
+    int DoutLen = 0;
+    int DinLen = 0;
+    int timer = 0;
+    int timer_mode = 0;
+    int loops;
+    EVP_CIPHER_CTX *ctx = NULL;
+    EVP_CIPHER_CTX *dctx = NULL;
+
+    /* 24 bytes key */
+    const unsigned char key[] = {
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88
+    };
+
+    /* 8 bytes initial vector */
+    const unsigned char ivec[] = {
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
+    };
+
+    if (input == NULL || outcipher == NULL || Doutput == NULL)
+    {
+        printf("[%s] --- Initial parameters malloc failed ! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    if (count == 0)
+    {
+	printf ("*** TIMER mode\n");
+        timer_mode = 1;
+	timer = (int) time(NULL) + 20;
+    }
+
+    /* setup input message values */
+    for (i = 0; i < len; i++)
+        input[i] = i % 16;
+
+    /* initialise ctx for encryption */
+    ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for ctx\n", __func__);
+        goto err;
+    }
+    EVP_CIPHER_CTX_init(ctx);
+
+    DEBUG("\n----- Encrypt DES_EDE3_CBC cipher ----- \n\n");
+
+    if (print_output)
+        tests_hexdump("DES3 input msg:", input, len);
+
+    ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_des_ede3_cbc(),    /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- EVP_EncryptInit_ex() ret = %d!\n", __func__, ret);
+        goto err;
+    }
+
+    do
+    {
+	/*  If timer mode, do 1000 ops at a time and update
+	 *  count each time.  Otherwise just do whatever
+	 *  value count is set to.
+	 */
+	if (timer_mode)
+	    loops = 1000;
+        else 
+	    loops = count;
+
+	/* Even for decrypt_only, we have to run one encrypt so that padding
+	 * is correct when decryption comes around. */
+	for (i = 0; i < (decrypt_only ? 1 : loops); i++)
+	{
+
+	    ret = EVP_EncryptUpdate(ctx,    /* EVP_CIPHER_CTX */
+				    outcipher,  /* output cipher pointer */
+				    &cipherLen, /* output cipher length pointer */
+				    input,  /* input text */
+				    len /* input text length */
+		);
+	    if (ret != 1)
+	    {
+		printf("[%s] --- Error in EVP_EncryptUpdate!, ret = %d\n", __func__,
+		       ret);
+		goto err;
+	    }
+	}
+
+	if (timer_mode)
+	    count -= loops;
+    }
+    while (!decrypt_only && timer_mode && timer > (int) time (NULL));
+
+    ret = EVP_EncryptFinal_ex(ctx,  /* EVP_CIPHER_CTX */
+                              outcipher + cipherLen,    /* output buffer,
+                                                           update from the last 
+                                                           padding block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in evp_EncryptFinal, ret = %d\n", __func__, ret);
+        goto err;
+    }
+
+    /* update the outLen of output */
+    cipherLen += update_len;
+
+    if (print_output)
+        tests_hexdump("DES3 Cipher:", outcipher, cipherLen);
+
+    EVP_CIPHER_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+    ctx = NULL;
+
+    if (!encrypt_only)
+    {
+
+        /*------------ Decrypt ----------*/
+
+    dctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (dctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for dctx\n", __func__);
+        goto err;
+    }
+    EVP_CIPHER_CTX_init(dctx);
+
+    /* set back the update_len value for decryption */
+    update_len = 0;
+    /* input length should same as output cipher length from encryption */
+    DinLen = cipherLen;
+
+    ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_des_ede3_cbc(),    /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    do
+    {
+	/*  If timer mode, do 1000 ops at a time and update
+	 *  count each time.  Otherwise just do whatever
+	 *  value count is set to.
+	 */
+	if (timer_mode)
+	    loops = 1000;
+        else 
+	    loops = count;
+
+	for (i = 0; i < loops; i++)
+	{
+
+	    ret = EVP_DecryptUpdate(dctx,   /* EVP_CIPHER_CTX */
+				    Doutput,    /* output text pointer */
+				    &DoutLen,   /* output text length pointer */
+				    incipher,   /* input cipher for decryption */
+				    DinLen  /* input cipher length */
+		);
+	    if (ret != 1)
+	    {
+		printf("[%s] --- Error in EVP_DecryptUpdate, ret = %d!\n", __func__,
+		       ret);
+		goto err;
+	    }
+	}
+
+	if (timer_mode)
+	    count -= loops;
+    }
+    while (timer_mode && timer > (int) time (NULL));
+
+    ret = EVP_DecryptFinal_ex(dctx, /* EVP_CIPHER_CTX */
+                              Doutput + DoutLen,    /* output buffer, update
+                                                       from the last padding
+                                                       block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptFinal_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    /* decrypt outlen update */
+    DoutLen += update_len;
+
+    if (print_output)
+        tests_hexdump("DES3 Decrpyted msg:", Doutput, DoutLen);
+
+    /* Compare and verify the decrypt and encrypt message. */
+    if (verify)
+    {
+        if (memcmp(Doutput, input, len))
+        {
+            printf("# FAIL verify for DES3.\n");
+
+            tests_hexdump("DES3 actual  :", Doutput, DoutLen);
+            tests_hexdump("DES3 expected:", input, len);
+
+        }
+        else
+        {
+            printf("# PASS verify for DES3.\n");
+        }
+    }
+
+    EVP_CIPHER_CTX_cleanup(dctx);
+    OPENSSL_free(dctx);
+    dctx = NULL;
+
+    }	/* !encrypt_only */
+
+    if (input)
+        OPENSSL_free(input);
+    if (outcipher)
+        OPENSSL_free(outcipher);
+    if (Doutput)
+        OPENSSL_free(Doutput);
+    return;
+
+  err:
+    if (ctx != NULL)
+    {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        OPENSSL_free(ctx);
+    }
+    if (dctx != NULL) ;
+    {
+        EVP_CIPHER_CTX_cleanup(dctx);
+        OPENSSL_free(dctx);
+    }
+    exit(EXIT_FAILURE);
+}
+
+/******************************************************************************
+* function:
+*     tests_run_des3 (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_des3(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_des3(count, e, print_output, verify, size, 0, 0);
+}
+
+void
+tests_run_des3_encrypt(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_des3(count, e, print_output, verify, size, 1, 0);
+}
+
+void
+tests_run_des3_decrypt(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_des3(count, e, print_output, verify, size, 0, 1);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_sha1.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_sha1.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,161 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+/******************************************************************************
+* function:
+*   tests_run_sha1_msg (int count,
+*                       int size,
+*                       ENGINE *e
+*                       int print_output,
+*                       int verify)
+*
+* @param count        [IN] - number of iterations
+* @param size         [IN] - input data size 
+* @param e            [IN] - OpenSSL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify       [IN] - verify flag
+*
+* Description:
+*   This function is designed to test the QAT engine with variable message sizes
+*   using the SHA1 algorithm. The higher level EVP interface function EVP_Digest()
+*   is used inside of test application.
+*   This is a boundary test, the application should return the expected digest hash value.
+*   In verify mode a input size of 1024 bytes is used to generate a comparison digest.
+******************************************************************************/
+
+void tests_run_sha1_msg(int count, int size, ENGINE * e, int print_output,
+                        int verify)
+{
+    int i = 0;
+    int inLen = size;
+    int ret = 0;
+
+    /* Use default input size in verify mode. */
+    if (verify)
+        inLen = 1024;
+
+    unsigned char md[SHA_DIGEST_LENGTH];
+    unsigned char *inData = OPENSSL_malloc(inLen);
+
+    unsigned char expected[] = {
+        0xDE, 0xB2, 0x38, 0x07, 0xD4, 0xFE, 0x02, 0x5E,
+        0x90, 0x0F, 0xE9, 0xA9, 0xC7, 0xD8, 0x41, 0x0C,
+        0x3D, 0xDE, 0x96, 0x71,
+    };
+
+    if (inData == NULL)
+    {
+        printf("*** [%s] --- inData malloc failed! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* Setup the input and output data. */
+    memset(inData, 0xaa, inLen);
+    memset(md, 0x00, SHA_DIGEST_LENGTH);
+
+    for (i = 0; i < count; i++)
+    {
+        DEBUG("\n----- SHA1 digest msg ----- \n\n");
+
+        ret = EVP_Digest(inData,    /* Input data pointer.  */
+                         inLen, /* Input data length.  */
+                         md,    /* Output hash pointer.  */
+                         NULL, EVP_sha1(),  /* Hash algorithm indicator. */
+                         e      /* Engine indicator.  */
+            );
+
+        if (ret != 1 || verify)
+        {
+            /* Compare the digest results with the expected results. */
+            if (memcmp(md, expected, SHA_DIGEST_LENGTH))
+            {
+                printf("# FAIL verify for SHA1.\n");
+
+                tests_hexdump("SHA1 actual  :", md, SHA_DIGEST_LENGTH);
+                tests_hexdump("SHA1 expected:", expected, SHA_DIGEST_LENGTH);
+            }
+            else
+            {
+                printf("# PASS verify for SHA1.\n");
+            }
+        }
+
+        if (print_output)
+            tests_hexdump("SHA1 digest text:", md, SHA_DIGEST_LENGTH);
+    }
+
+    if (inData)
+        OPENSSL_free(inData);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests.h	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,189 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#ifndef __TESTS_H
+#define __TESTS_H
+
+ENGINE * tests_initialise_engine(void);
+void tests_run (int *count, int size, int type, ENGINE *e, int id, int print_output, int verify, int performance);
+void tests_cleanup_engine (ENGINE *e);
+void tests_hexdump (const char *title, const unsigned char *s,int l);
+
+void tests_run_md5_msg (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_hmac_sha256 (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_sha1_msg   (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_sha256_msg (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_sha512_msg (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_aes256 (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_aes192 (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_aes128cbc_hmac_sha1 (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_aes128 (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_rc4 (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_des3 (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_des3_encrypt (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_des3_decrypt (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_des (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_rsa (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_rsa_sign (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_rsa_verify (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_dsa (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_dsa_sign_only (int count, int size, ENGINE *e, int print_output, int verify);
+void tests_run_dsa_sign_verify (int count, int size, ENGINE *e, int print_output, int verify);
+
+void tests_run_dh (int count, int size, ENGINE *e, int print_output, int verify);
+
+#define TEST_DES		1
+#define TEST_DES3		2
+#define TEST_DES3_ENCRYPT	3
+#define TEST_DES3_DECRYPT	4
+#define TEST_AES128		5
+#define TEST_AES192		6
+#define TEST_AES256		7
+#define TEST_RC4		8
+
+/* Note, throughput test in main uses MAX_CIPHER_TEST_TYPE to determine if */
+/* test id is a cipher or digest/PKE. Add ciphers above and digests below. */
+#define MAX_CIPHER_TEST_TYPE    TEST_RC4
+
+#define TEST_SHA1               9
+#define TEST_SHA256             10
+#define TEST_SHA512             11
+#define TEST_MD5                12
+#define TEST_RSA_SIGN           13
+#define TEST_RSA_VERIFY         14
+#define TEST_RSA_ENCRYPT        15
+#define TEST_RSA_DECRYPT        16
+#define TEST_DSA_SIGN           17
+#define TEST_DSA_VERIFY         18
+#define TEST_DH        			19
+#define TEST_HMAC        		20
+#define TEST_AES128_CBC_HMAC_SHA1 21
+#define TEST_AES256_CBC_HMAC_SHA1 22
+
+#define TEST_TYPE_MAX 22	 
+
+
+#define DEBUG(...) 
+
+#define QAT_DEV "/dev/qat_mem"
+
+#endif
+
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_dsa.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_dsa.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,281 @@
+
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <openssl/crypto.h>
+#include <openssl/rand.h>
+#include <openssl/bio.h>
+#include <openssl/err.h>
+#include <openssl/bn.h>
+#include <openssl/dsa.h>
+
+#include "tests.h"
+
+
+static unsigned char BN_p[] =
+{ 
+        0xD7, 0x57, 0x26, 0x2C, 0x45, 0x84, 0xC4, 0x4C,
+        0x21, 0x1F, 0x18, 0xBD, 0x96, 0xE5, 0xF0, 0x61,
+        0xC4, 0xF0, 0xA4, 0x23, 0xF7, 0xFE, 0x6B, 0x6B,
+        0x85, 0xB3, 0x4C, 0xEF, 0x72, 0xCE, 0x14, 0xA0,
+        0xD3, 0xA5, 0x22, 0x2F, 0xE0, 0x8C, 0xEC, 0xE6,
+        0x5B, 0xE6, 0xC2, 0x65, 0x85, 0x48, 0x89, 0xDC,
+        0x1E, 0xDB, 0xD1, 0x3E, 0xC8, 0xB2, 0x74, 0xDA,
+        0x9F, 0x75, 0xBA, 0x26, 0xCC, 0xB9, 0x87, 0x72,
+        0x36, 0x02, 0x78, 0x7E, 0x92, 0x2B, 0xA8, 0x44,
+        0x21, 0xF2, 0x2C, 0x3C, 0x89, 0xCB, 0x9B, 0x06,
+        0xFD, 0x60, 0xFE, 0x01, 0x94, 0x1D, 0xDD, 0x77,
+        0xFE, 0x6B, 0x12, 0x89, 0x3D, 0xA7, 0x6E, 0xEB,
+        0xC1, 0xD1, 0x28, 0xD9, 0x7F, 0x06, 0x78, 0xD7,
+        0x72, 0x2B, 0x53, 0x41, 0xC8, 0x50, 0x6F, 0x35,
+        0x82, 0x14, 0xB1, 0x6A, 0x2F, 0xAC, 0x4B, 0x36,
+        0x89, 0x50, 0x38, 0x78, 0x11, 0xC7, 0xDA, 0x33,
+};
+
+static unsigned char BN_q[] =
+{ 
+        0xC7, 0x73, 0x21, 0x8C, 0x73, 0x7E, 0xC8, 0xEE,
+        0x99, 0x3B, 0x4F, 0x2D, 0xED, 0x30, 0xF4, 0x8E,
+        0xDA, 0xCE, 0x91, 0x5F,
+
+};
+
+static unsigned char BN_g[] =
+{ 
+        0x82, 0x26, 0x90, 0x09, 0xE1, 0x4E, 0xC4, 0x74,
+        0xBA, 0xF2, 0x93, 0x2E, 0x69, 0xD3, 0xB1, 0xF1,
+        0x85, 0x17, 0xAD, 0x95, 0x94, 0x18, 0x4C, 0xCD,
+        0xFC, 0xEA, 0xE9, 0x6E, 0xC4, 0xD5, 0xEF, 0x93,
+        0x13, 0x3E, 0x84, 0xB4, 0x70, 0x93, 0xC5, 0x2B,
+        0x20, 0xCD, 0x35, 0xD0, 0x24, 0x92, 0xB3, 0x95,
+        0x9E, 0xC6, 0x49, 0x96, 0x25, 0xBC, 0x4F, 0xA5,
+        0x08, 0x2E, 0x22, 0xC5, 0xB3, 0x74, 0xE1, 0x6D,
+        0xD0, 0x01, 0x32, 0xCE, 0x71, 0xB0, 0x20, 0x21,
+        0x70, 0x91, 0xAC, 0x71, 0x7B, 0x61, 0x23, 0x91,
+        0xC7, 0x6C, 0x1F, 0xB2, 0xE8, 0x83, 0x17, 0xC1,
+        0xBD, 0x81, 0x71, 0xD4, 0x1E, 0xCB, 0x83, 0xE2,
+        0x10, 0xC0, 0x3C, 0xC9, 0xB3, 0x2E, 0x81, 0x05,
+        0x61, 0xC2, 0x16, 0x21, 0xC7, 0x3D, 0x6D, 0xAA,
+        0xC0, 0x28, 0xF4, 0xB1, 0x58, 0x5D, 0xA7, 0xF4,
+        0x25, 0x19, 0x71, 0x8C, 0xC9, 0xB0, 0x9E, 0xEF,
+};
+
+
+static unsigned char Pub_key[] = 
+{
+        0x52, 0x3C, 0x3E, 0x53, 0x41, 0xC3, 0xC8, 0xDF,
+        0x22, 0x4E, 0x07, 0x0C, 0x99, 0x76, 0xFC, 0x7D,
+        0xF1, 0x95, 0xD3, 0xC5, 0x1D, 0x67, 0x1A, 0xF2,
+        0xC9, 0x68, 0xA2, 0xA1, 0x41, 0x35, 0x1F, 0xFC,
+        0x64, 0x47, 0x65, 0xAD, 0xEB, 0xC4, 0x71, 0xD5,
+        0x1B, 0xC2, 0xEF, 0x76, 0x21, 0xE9, 0xED, 0x6A,
+        0xA6, 0xD9, 0xDB, 0x5B, 0xBB, 0x81, 0x43, 0x8F,
+        0xC0, 0x1E, 0xE6, 0x49, 0x2A, 0xB7, 0xEA, 0x8F,
+        0xCB, 0x6B, 0x93, 0x1E, 0x94, 0x8C, 0x24, 0x48,
+        0xE3, 0x80, 0xD3, 0x9B, 0x4F, 0xDC, 0xBF, 0x45,
+        0xE3, 0xC0, 0xFC, 0xDA, 0x1C, 0x06, 0x74, 0xF9,
+        0x02, 0x2A, 0x5A, 0xAA, 0x18, 0x58, 0x1D, 0x12,
+        0x4D, 0x07, 0x0F, 0x00, 0xB4, 0x5E, 0xA3, 0x62,
+        0xB1, 0xFA, 0xEE, 0x05, 0x04, 0x89, 0x27, 0x5A,
+        0x68, 0xBF, 0x8B, 0x19, 0x90, 0x84, 0x21, 0xB8,
+        0xFB, 0x3B, 0x37, 0x04, 0x4D, 0x6B, 0xB6, 0xD2,
+
+};
+
+static unsigned char Priv_key[] = 
+{ 
+        0x6E, 0xB5, 0x08, 0x61, 0xE5, 0x25, 0xD7, 0xEF,
+        0x6C, 0x53, 0xBD, 0x77, 0x72, 0x0F, 0x98, 0xE1,
+        0x60, 0x3D, 0x67, 0x67,
+
+};
+
+/******************************************************************************
+* function:
+*           run_dsa(int count,
+*                   ENGINE *e
+*                   int print_output
+*                   int verify)
+*
+* @param count [IN] - number of iterations
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*   The function is design to test DSA sign and verify using qat engine. 
+*
+*******************************************************************************/
+void run_dsa(int count, ENGINE * e, int print_output, int verify, int len)
+{
+    DSA *dsa = NULL;
+    int i = 0;
+    int ret = 0;
+    unsigned char sig[256] = {0,};
+    unsigned int siglen = 0;
+    
+    unsigned char *DgstData = OPENSSL_malloc(len);
+
+    if (DgstData == NULL)
+    {
+        printf("DgstData Initial malloc failed ! \n");
+        exit(EXIT_FAILURE);
+    }
+
+    /* setup input hash message */
+    for (i = 0; i < len; i++)
+        DgstData[i] = i % 16;
+   
+    if ((dsa = DSA_new()) == NULL)
+        goto end;
+
+    /* iteration count to find h, in this case 105 is expect */
+    dsa->q = BN_bin2bn(BN_q, sizeof(BN_q), dsa->q);
+    dsa->p = BN_bin2bn(BN_p, sizeof(BN_p), dsa->p);
+    dsa->g = BN_bin2bn(BN_g, sizeof(BN_g), dsa->g);
+    dsa->pub_key = BN_bin2bn(Pub_key, sizeof(Pub_key), dsa->pub_key);
+    dsa->priv_key = BN_bin2bn(Priv_key, sizeof(Priv_key), dsa->priv_key);
+    
+    for (i = 0; i < count; i++)
+    {
+
+        /* DSA_sign() computes a digital signature on the len byte message
+           digest dgst using the private key dsa and places its ASN.1 DER
+           encoding at sig. The length of the signature is placed in *siglen.
+           sig must point to DSA_size(dsa) bytes of memory. */
+        DEBUG("%s starting DSA sign \n", __func__);
+        ret = DSA_sign(0, DgstData, len, sig, &siglen, dsa);
+        if (print_output)
+
+        {
+            tests_hexdump(" DSA Signature:", sig, siglen);
+        }
+        if (verify)
+
+        {
+
+            /* DSA_verify() verifies that the signature sig of size siglen
+               matches a given message digest dgst of size len. dsa is the
+               signer's public key. Returns * 1: correct signature * 0:
+               incorrect signature * -1: error */
+            DEBUG("%s starting DSA verify! \n", __func__);
+            ret = DSA_verify(0, DgstData, len, sig, siglen, dsa);
+            if (!ret)
+                printf("# DSA signature verify failed! \n");
+        }
+
+        /* the built-in DSA implementation uses constant time modular
+           exponentiation for secret exponents by default. The
+           DSA_FLAG_NO_EXP_CONSTTIME flag use the faster variable sliding
+           window method to be used for all exponents. */
+    }
+    if (ret)
+        printf("# PASS verify for DSA.\n");
+
+    else
+        printf("# FAIL verify for DSA.\n");
+end:
+    DEBUG("%s start to clean up! \n", __func__);
+    OPENSSL_free(DgstData);
+    
+    if (dsa != NULL)
+        DSA_free(dsa);
+}
+
+/******************************************************************************
+* function:
+*     tests_run_dsa  (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_dsa(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_dsa(count, e, print_output, verify, size);
+} 
+
+void
+tests_run_dsa_sign_only(int count, int size, ENGINE * e, int print_output,
+                        int verify)
+{
+    run_dsa(count, e, print_output, 0, size);
+} 
+
+void
+tests_run_dsa_sign_verify(int count, int size, ENGINE * e, int print_output,
+                          int verify)
+{
+    run_dsa(count, e, print_output, 1, size);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_dh.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_dh.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,373 @@
+
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/crypto.h>
+#include <openssl/bio.h>
+#include <openssl/bn.h>
+#include <openssl/rand.h>
+#include <openssl/err.h>
+#include <openssl/dh.h>
+
+#include "tests.h"
+
+static const unsigned char BNp_1024[] = {
+        0xC1, 0xF1, 0x54, 0x26, 0x9C, 0x53, 0xC7, 0x22,
+        0x29, 0xBC, 0x03, 0x29, 0x00, 0x73, 0x61, 0xA7,
+        0x20, 0x7A, 0x1E, 0x75, 0x6C, 0x01, 0xCA, 0x8D,
+        0xE8, 0x9B, 0x4E, 0x1C, 0xC7, 0x59, 0x14, 0x35,
+        0x63, 0x29, 0x56, 0x09, 0x57, 0xD8, 0x01, 0x2F,
+        0xAD, 0x8F, 0x16, 0x78, 0x78, 0x9D, 0xA1, 0x03,
+        0x74, 0x5F, 0xAC, 0x7A, 0x37, 0x76, 0x12, 0x50,
+        0xF4, 0xBB, 0x4C, 0xCE, 0xD8, 0xF7, 0x87, 0x31,
+        0xD9, 0x45, 0xFC, 0xB6, 0xBF, 0xD5, 0x08, 0xFB,
+        0xA9, 0xBC, 0xA4, 0xA8, 0x65, 0x77, 0x69, 0xA4,
+        0x89, 0xD4, 0xB4, 0x40, 0x58, 0xCC, 0xF8, 0x62,
+        0x1A, 0x3E, 0x7B, 0x7A, 0x0E, 0x01, 0xA5, 0x8B,
+        0x1D, 0x5B, 0xED, 0xB1, 0x0D, 0x4A, 0x44, 0x70,
+        0x3B, 0xE7, 0x93, 0x4A, 0xC8, 0xFB, 0xAE, 0x81,
+        0x77, 0xC0, 0x23, 0x7D, 0xBB, 0x96, 0x72, 0xF7,
+        0x42, 0xFF, 0x80, 0xD6, 0x87, 0xE5, 0x97, 0xCB};
+
+static const unsigned char BNp_2048[]= {
+        0xFC, 0x90, 0x16, 0xE9, 0x4B, 0xE4, 0x28, 0x49,
+        0xC2, 0xDF, 0x6E, 0xFC, 0xF4, 0xB1, 0xC5, 0xBC,
+        0x48, 0xD1, 0xEC, 0x3C, 0xE6, 0xEA, 0xDC, 0x8E,
+        0x5B, 0x51, 0x8A, 0x48, 0xCF, 0xC9, 0xB1, 0xAC,
+        0x29, 0x30, 0x45, 0x22, 0x07, 0x71, 0x6C, 0x05,
+        0x2D, 0xE8, 0xEE, 0x46, 0x16, 0xC3, 0x8B, 0xFE,
+        0x65, 0xF5, 0xDA, 0x68, 0x76, 0x4F, 0x0D, 0x05,
+        0x15, 0x9B, 0x21, 0xF6, 0x1C, 0x92, 0xCD, 0xFE,
+        0xBE, 0x2F, 0xD0, 0x79, 0xA5, 0x6C, 0x23, 0xC6,
+        0x00, 0xC9, 0xBB, 0xD1, 0x63, 0xCD, 0x06, 0x21,
+        0xD1, 0xD3, 0x55, 0x2F, 0x1E, 0x38, 0x5A, 0xCC,
+        0x49, 0x85, 0x13, 0xFE, 0xA0, 0x55, 0x1F, 0x51,
+        0xE3, 0xE3, 0xA2, 0x3F, 0x00, 0x04, 0xAB, 0xB4,
+        0xF3, 0x5A, 0x53, 0x82, 0xD0, 0xD5, 0xD7, 0x5A,
+        0x11, 0xE5, 0xE3, 0xDB, 0x57, 0xA8, 0xB3, 0xB8,
+        0x70, 0xF8, 0x6E, 0xEC, 0xC0, 0x46, 0x82, 0xEC,
+        0x98, 0xBD, 0xE0, 0xD2, 0xB2, 0x5E, 0x44, 0x51,
+        0x41, 0x18, 0x66, 0x93, 0xF1, 0xA5, 0xF3, 0x86,
+        0xC9, 0x9D, 0xEC, 0x80, 0x78, 0x0B, 0x7E, 0x13,
+        0xF9, 0xDF, 0x78, 0x0E, 0x0D, 0x23, 0xBB, 0x6A,
+        0xF2, 0x9C, 0xBF, 0x2F, 0xD3, 0xF1, 0xFA, 0xC4,
+        0xA1, 0xEB, 0xF3, 0x53, 0xBD, 0x4C, 0xDF, 0x8C,
+        0xBB, 0x4A, 0x41, 0x90, 0x54, 0x72, 0x8B, 0x8D,
+        0xAA, 0xAF, 0x3B, 0x2C, 0x52, 0x6F, 0x27, 0x0E,
+        0xDD, 0x82, 0xF8, 0xC8, 0x72, 0xDB, 0xE1, 0x6A,
+        0x81, 0x5D, 0xA4, 0xE2, 0x45, 0xA6, 0xA6, 0x7D,
+        0x7B, 0x82, 0x08, 0x8B, 0x03, 0xD2, 0x70, 0xD3,
+        0x9B, 0x9B, 0x05, 0x6D, 0x63, 0x1F, 0x37, 0x32,
+        0xCF, 0xAE, 0xA9, 0x4B, 0xAD, 0x50, 0xB0, 0xF1,
+        0xA1, 0x75, 0x4B, 0xF9, 0xEF, 0x38, 0x18, 0x94,
+        0x2C, 0x30, 0x26, 0x0D, 0x63, 0x70, 0x24, 0xED,
+        0x7D, 0x2F, 0xDD, 0x96, 0xD2, 0x7E, 0xD1, 0xD7};
+
+
+static const unsigned char BNp_4096[]= {
+        0xBF, 0x01, 0x78, 0x3A, 0x05, 0xC6, 0x8E, 0xFA,
+        0x4E, 0x42, 0x93, 0xFC, 0x2F, 0x80, 0x26, 0x09,
+        0xC5, 0x59, 0x7A, 0xC6, 0x5E, 0x15, 0xD8, 0xBF,
+        0x46, 0x0F, 0xAB, 0x10, 0xD9, 0x01, 0x3A, 0x76,
+        0x32, 0xCE, 0xB6, 0x8D, 0x7D, 0x10, 0x7E, 0xA3,
+        0xE1, 0x12, 0x9F, 0xCF, 0x64, 0x54, 0xB9, 0x38,
+        0x96, 0x0D, 0x2B, 0xDC, 0xE8, 0x1D, 0x6E, 0x34,
+        0x45, 0xAE, 0x4E, 0x49, 0x36, 0x5C, 0x33, 0x1E,
+        0x1E, 0xE4, 0xB5, 0x76, 0x87, 0x19, 0x82, 0x4B,
+        0xDA, 0xC6, 0x0F, 0x5B, 0x28, 0x8A, 0x82, 0xB7,
+        0x2D, 0x3A, 0xDC, 0x0C, 0x68, 0x0B, 0xA5, 0xE6,
+        0x69, 0xCC, 0x9F, 0x87, 0x19, 0xFE, 0x65, 0xDE,
+        0xFE, 0x6A, 0xDD, 0xE2, 0x68, 0x08, 0x2B, 0x79,
+        0x4D, 0xA7, 0x23, 0x7C, 0x96, 0x92, 0x8B, 0x3A,
+        0x6E, 0x36, 0x64, 0xD0, 0x91, 0x01, 0xDC, 0x7B,
+        0x7B, 0x44, 0x2A, 0xAD, 0xA2, 0x26, 0x6D, 0x3A,
+        0xD5, 0xF6, 0xEA, 0x56, 0x58, 0x4D, 0xA7, 0x4E,
+        0xC7, 0x8C, 0x4B, 0x61, 0x9C, 0x9F, 0x1F, 0xFD,
+        0x65, 0xC2, 0xA8, 0xAC, 0x94, 0x8A, 0xF8, 0x65,
+        0x73, 0x08, 0x5A, 0x27, 0x6E, 0x0B, 0xE3, 0xAF,
+        0xB5, 0x19, 0xEA, 0x22, 0xFA, 0x91, 0x5A, 0x65,
+        0xD1, 0x5A, 0x28, 0x4C, 0xF3, 0x06, 0xAA, 0x37,
+        0xDD, 0xB7, 0x19, 0x38, 0xCD, 0x5B, 0xED, 0x0D,
+        0x9C, 0x59, 0xED, 0x02, 0x44, 0x3C, 0x02, 0xC2,
+        0xEC, 0xAF, 0xCF, 0x62, 0xC8, 0xD4, 0x36, 0x78,
+        0x68, 0x43, 0x86, 0x6F, 0x3F, 0xFD, 0x58, 0x4D,
+        0x15, 0x86, 0xCB, 0xF3, 0x3E, 0xE0, 0xEF, 0x2F,
+        0xD5, 0x5E, 0x3A, 0x81, 0xAB, 0x6D, 0x85, 0xD2,
+        0x8E, 0x6D, 0x84, 0x35, 0xC8, 0xFD, 0x42, 0x3A,
+        0xCB, 0x9A, 0x5C, 0x25, 0xC6, 0x92, 0x60, 0xAB,
+        0xED, 0xC3, 0x04, 0x6E, 0xDE, 0x7F, 0xD4, 0x68,
+        0xC9, 0xAE, 0xB6, 0xC1, 0xF7, 0xCE, 0x28, 0x2C,
+        0xE7, 0x66, 0xA1, 0xF9, 0x62, 0x50, 0x3C, 0x20,
+        0x57, 0x1E, 0x7F, 0x74, 0xB8, 0x52, 0x42, 0xB8,
+        0x70, 0xFF, 0x32, 0x46, 0x8C, 0x34, 0xC5, 0x6A,
+        0x11, 0x62, 0x1E, 0x03, 0xFB, 0x79, 0x1F, 0x9B,
+        0xAC, 0xAF, 0xED, 0x9E, 0x98, 0xC8, 0xF9, 0x4F,
+        0x68, 0x85, 0xD3, 0x3C, 0x07, 0xE9, 0xBB, 0x41,
+        0x67, 0x0C, 0x79, 0x28, 0x3F, 0xF5, 0x8B, 0x8E,
+        0xAC, 0xB5, 0x80, 0x40, 0x0C, 0x90, 0x33, 0x68,
+        0xE3, 0x4F, 0x97, 0xE7, 0x94, 0x22, 0x20, 0x80,
+        0x01, 0x1A, 0x9F, 0x1F, 0x6F, 0x22, 0x06, 0x05,
+        0xC7, 0x86, 0x85, 0x1B, 0xF8, 0x7A, 0xB0, 0xF6,
+        0xFB, 0xA5, 0x59, 0xF8, 0xA5, 0xFB, 0xC1, 0x88,
+        0xF9, 0x33, 0xF0, 0x38, 0xBB, 0xF0, 0x14, 0x1C,
+        0xFE, 0xAF, 0x14, 0x9A, 0xCF, 0xBE, 0xF4, 0xF6,
+        0x9C, 0x73, 0xE4, 0xF4, 0x81, 0x41, 0x30, 0x8C,
+        0x53, 0xA9, 0x17, 0xA2, 0x8C, 0xF9, 0xA4, 0x0C,
+        0xFD, 0x29, 0x26, 0x49, 0x70, 0x20, 0xFB, 0xB5,
+        0x34, 0x5C, 0x04, 0x86, 0x49, 0x4C, 0xFF, 0x8D,
+        0x45, 0x25, 0xFB, 0x80, 0x37, 0x54, 0xCC, 0x74,
+        0xCC, 0xBF, 0x39, 0x3B, 0x9A, 0x43, 0xF6, 0x44,
+        0xEB, 0x0B, 0x88, 0xE8, 0xFF, 0x9F, 0x82, 0xCE,
+        0x6F, 0x0A, 0x16, 0x7E, 0x5A, 0x50, 0x34, 0x8A,
+        0x8A, 0x39, 0x19, 0x4D, 0x1B, 0x1F, 0x4E, 0x1D,
+        0x7A, 0x12, 0x9A, 0x5B, 0x29, 0xD0, 0x3D, 0xAA,
+        0x2D, 0x4B, 0x59, 0xCA, 0x29, 0xC3, 0x7F, 0xF9,
+        0xD7, 0x36, 0x74, 0xE7, 0x86, 0x11, 0x83, 0x7C,
+        0xDD, 0x45, 0xC8, 0x27, 0x39, 0xC1, 0x9D, 0x2A,
+        0xDB, 0x57, 0xA4, 0x5B, 0x8F, 0x50, 0x4A, 0x3D,
+        0xFD, 0x98, 0x45, 0xE6, 0x33, 0x50, 0xA1, 0xF4,
+        0xF7, 0x4D, 0xB7, 0x99, 0x7E, 0x04, 0x3E, 0xC7,
+        0x9E, 0xF0, 0x4C, 0xA9, 0xB3, 0x25, 0x88, 0xE3,
+        0x25, 0xCA, 0x2A, 0x6F, 0xDD, 0xD3, 0xE3, 0xBF};
+
+static const unsigned char BNg[] ={0x05};
+
+
+/******************************************************************************
+* function:
+*           run_dh (int count,
+*                   ENGINE *e
+*                   int print_output
+*                   int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - prime number exponent size 
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*   The function is design to test DH key generation and verify using qat engine. 
+*   If the verify flag raised, two DH public keys are generate separately 
+*   with and without DH_FLAG_NO_EXP_CONSTTIME flag. And the verification compares 
+*   the outputs of each DH_compute_key() after exchange two public keys.  
+*
+********************************************************************************/
+void run_dh(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    DH *dh_a = NULL;
+    DH *dh_b = NULL;
+    char buf[12] = { 0, };
+    unsigned char *abuf = NULL, *bbuf = NULL;
+    int i = 0, alen = 0, blen = 0, aout = 0, bout = 0, ret = 0;
+
+    BIO *out = NULL;
+
+    out = BIO_new(BIO_s_file());
+    if (out == NULL)
+        goto err;
+    BIO_set_fp(out, stdout, BIO_NOCLOSE);
+
+    /* callback function cannot be NULL */
+
+    if ((dh_a = DH_new()) == NULL)
+        goto err;
+    
+    if(size <= 1024)
+	dh_a->p = BN_bin2bn(BNp_1024, sizeof(BNp_1024), dh_a->p);
+    if(size > 1024 && size <= 2048)
+	dh_a->p = BN_bin2bn(BNp_2048, sizeof(BNp_2048), dh_a->p);
+    if(size > 2048)
+	dh_a->p = BN_bin2bn(BNp_4096, sizeof(BNp_4096), dh_a->p);
+    
+    dh_a->g = BN_bin2bn(BNg, sizeof(BNg), dh_a->g);
+    dh_b = DH_new();
+    if (dh_b == NULL)
+        goto err;
+
+    /* we copy over prime and generator values from dh_a, just save time to
+       generate and validate values */
+    dh_b->p = BN_dup(dh_a->p);
+    dh_b->g = BN_dup(dh_a->g);
+    if ((dh_b->p == NULL) || (dh_b->g == NULL))
+        goto err;
+
+    /* Set dh_a to run with normal modexp and dh_b to use constant time The
+       build-in DH implementation now uses constant time modular
+       exponentiation for secret exponents by default. DH_FLAG_NO_EXP_CONTTIME
+       flag causes the faster variable sliding window method to be used for
+       all exponents */
+    dh_b->flags &= ~DH_FLAG_NO_EXP_CONSTTIME;
+    dh_a->flags |= DH_FLAG_NO_EXP_CONSTTIME;
+  
+        if (!DH_generate_key(dh_a))
+            goto err;
+
+        if (print_output)
+        {
+            BIO_puts(out, "pri 1=");
+            BN_print(out, dh_a->priv_key);
+            BIO_puts(out, "\npub 1=");
+            BN_print(out, dh_a->pub_key);
+            BIO_puts(out, "\n");
+        }
+  
+        if (!DH_generate_key(dh_b))
+            goto err;
+
+        if (print_output)
+        {
+            BIO_puts(out, "pri 2=");
+            BN_print(out, dh_b->priv_key);
+            BIO_puts(out, "\npub 2=");
+            BN_print(out, dh_b->pub_key);
+            BIO_puts(out, "\n");
+        }
+
+        alen = DH_size(dh_a);
+        abuf = (unsigned char *)OPENSSL_malloc(alen);
+        if (abuf == NULL)
+        {
+            printf("abuf malloc failed ! \n");
+            goto err;
+        }
+
+    for (i = 0; i < count; i++)
+    {
+        aout = DH_compute_key(abuf, dh_b->pub_key, dh_a);
+    
+
+        if (print_output)
+        {
+            BIO_puts(out, "key1 =");
+            for (i = 0; i < aout; i++)
+            {
+                sprintf(buf, "%02X", abuf[i]);
+                BIO_puts(out, buf);
+            }
+            BIO_puts(out, "\n");
+        }
+    } 
+    if(verify){ 
+        blen = DH_size(dh_b);
+        bbuf = (unsigned char *)OPENSSL_malloc(blen);
+        if (bbuf == NULL)
+        {
+            printf("bbuf malloc failed ! \n");
+            goto err;
+        }
+
+        bout = DH_compute_key(bbuf, dh_a->pub_key, dh_b);
+        if (print_output)
+        {
+            BIO_puts(out, "key2 =");
+            for (i = 0; i < bout; i++)
+            {
+                sprintf(buf, "%02X", bbuf[i]);
+                BIO_puts(out, buf);
+            }
+            BIO_puts(out, "\n");
+        }
+
+        if ((aout < 4) || (bout != aout) || (memcmp(abuf, bbuf, aout) != 0))
+        {
+            ret = 1;
+            printf("# FAIL verify for DH.\n");
+        }
+    }
+    if (!ret)
+        printf("# PASS verify for DH. \n");
+  err:
+    ERR_print_errors_fp(stderr);
+    if (abuf != NULL)
+        OPENSSL_free(abuf);
+    if (bbuf != NULL)
+        OPENSSL_free(bbuf);
+    if (dh_b != NULL)
+        DH_free(dh_b);
+    if (dh_a != NULL)
+        DH_free(dh_a);
+    BIO_free(out);
+
+}
+
+/******************************************************************************
+* function:
+*       tests_run_dh (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void tests_run_dh(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_dh(count, size, e, print_output, verify);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes256.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes256.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,343 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+#define AES256_BLOCKSIZE 16
+
+/******************************************************************************
+* function:
+*   	  run_aes256 (int count,
+*                  ENGINE *e
+*                     int print_output
+*                     int verify
+*                     int len)
+*
+* @param count [IN] - number of iterations
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+* @param len [IN] - the length of input message
+*
+* description:
+*   The function is design to test AES_256 cipher encryption and decryption using QAT engine.
+*   The higher level EVP interface function EVP_EncryptInit_ex(), EVP_EncryptUpdate()
+*   and EVP_EncryptFinal_ex() are called for encryption routines inside of test application.
+*   EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
+*   corresponding EVP decryption routines.
+*
+******************************************************************************/
+static void
+run_aes256(int count, ENGINE * e, int print_output, int verify, int len)
+{
+    int i = 0;
+    int ret = 0;
+
+    unsigned char *input = OPENSSL_malloc(len);
+
+    /* extra one black size memory space needed for padding */
+    unsigned char *outcipher = OPENSSL_malloc(len + AES256_BLOCKSIZE*4);
+    unsigned char *Doutput = OPENSSL_malloc(len + AES256_BLOCKSIZE*4);
+    unsigned char *incipher = outcipher;
+    int cipherLen = 0;
+    int update_len = 0;
+    int DoutLen = 0;
+    int DinLen = 0;
+    EVP_CIPHER_CTX *ctx = NULL;
+    EVP_CIPHER_CTX *dctx = NULL;
+
+    /* 32 bytes key */
+    const unsigned char key[] = {
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00
+    };
+
+    /* 16 bytes initial vector */
+    const unsigned char ivec[] = {
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42
+    };
+
+    if (input == NULL || outcipher == NULL || Doutput == NULL)
+    {
+        printf("[%s] --- Initial parameters malloc failed ! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* setup input message values */
+    for (i = 0; i < len; i++)
+        input[i] = i % 16;
+
+    /* initialise ctx for encryption */
+    ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for ctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(ctx);
+
+    DEBUG("\n----- Encrypt AES_256_cbc cipher ----- \n\n");
+
+    if (print_output)
+        tests_hexdump("AES256 input msg", input, len);
+
+    ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_aes_256_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_EncryptInit_ex() ret = %d!\n", __func__,
+               ret);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        exit(EXIT_FAILURE);
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_EncryptUpdate(ctx,    /* EVP_CIPHER_CTX */
+                                outcipher,  /* output cipher pointer */
+                                &cipherLen, /* output cipher length pointer */
+                                input,  /* input text */
+                                len /* input text length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_EncryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    DEBUG("outLen now is %d \n", cipherLen);
+
+    DEBUG("Calling EVP_EncryptFinal_ex! \n");
+
+    ret = EVP_EncryptFinal_ex(ctx,  /* EVP_CIPHER_CTX */
+                              outcipher + cipherLen,    /* output buffer,
+                                                           update from the last 
+                                                           padding block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_EncryptFinal_ex, ret = %d\n", __func__,
+               ret);
+        goto err;
+    }
+
+    /* update the outLen of output */
+    cipherLen += update_len;
+
+    if (print_output)
+        tests_hexdump("AES256 Cipher", outcipher, cipherLen);
+
+    EVP_CIPHER_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+    ctx = NULL;
+
+        /*---------- Decryption ----------*/
+
+    /* initialise ctx for decryption */
+    dctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (dctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for dctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(dctx);
+
+    /* set back the update_len value for decryption */
+    update_len = 0;
+    /* input length should same as output cipher length from encryption */
+    DinLen = cipherLen;
+
+    ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_aes_256_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_DecryptUpdate(dctx,   /* EVP_CIPHER_CTX */
+                                Doutput,    /* output text pointer */
+                                &DoutLen,   /* output text length pointer */
+                                incipher,   /* input cipher for decryption */
+                                DinLen  /* input cipher length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_DecryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    ret = EVP_DecryptFinal_ex(dctx, /* EVP_CIPHER_CTX */
+                              Doutput + DoutLen,    /* output buffer, update
+                                                       from the last padding
+                                                       block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptFinal_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    /* decrypt outlen update */
+    DoutLen += update_len;
+
+    if (print_output)
+        tests_hexdump("AES256 Decrpyted msg", Doutput, DoutLen);
+
+    /* Compare and verify the decrypt and encrypt message. */
+    if (verify)
+    {
+        if (memcmp(Doutput, input, len))
+        {
+            printf("# FAIL verify for AES256.\n");
+
+            tests_hexdump("AES256 actual  :", Doutput, DoutLen);
+            tests_hexdump("AES256 expected:", input, len);
+
+        }
+        else
+        {
+            printf("# PASS verify for AES256.\n");
+        }
+    }
+
+    EVP_CIPHER_CTX_cleanup(dctx);
+    OPENSSL_free(dctx);
+
+    if (input)
+        OPENSSL_free(input);
+    if (outcipher)
+        OPENSSL_free(outcipher);
+    if (Doutput)
+        OPENSSL_free(Doutput);
+    return;
+
+  err:
+    if (ctx != NULL)
+    {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        OPENSSL_free(ctx);
+    }
+    if (dctx != NULL) ;
+    {
+        EVP_CIPHER_CTX_cleanup(dctx);
+        OPENSSL_free(dctx);
+    }
+    exit(EXIT_FAILURE);
+}
+
+/******************************************************************************
+* function:
+*   tests_run_aes256 (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void tests_run_aes256(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_aes256(count, e, print_output, verify, size);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_rsa.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_rsa.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,1030 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+/* Maximum RSA size supported */
+#define RSA_SIZE 512
+#define HASH_DATA_SIZE 100
+
+
+static const unsigned char rsaCrtCoefQInv_1024_KeyPair[] = {
+    0x4f, 0x45, 0x6c, 0x50, 0x24, 0x93, 0xbd, 0xc0,
+    0xed, 0x2a, 0xb7, 0x56, 0xa3, 0xa6, 0xed, 0x4d,
+    0x67, 0x35, 0x2a, 0x69, 0x7d, 0x42, 0x16, 0xe9,
+    0x32, 0x12, 0xb1, 0x27, 0xa6, 0x3d, 0x54, 0x11,
+    0xce, 0x6f, 0xa9, 0x8d, 0x5d, 0xbe, 0xfd, 0x73,
+    0x26, 0x3e, 0x37, 0x28, 0x14, 0x27, 0x43, 0x81,
+    0x81, 0x66, 0xed, 0x7d, 0xd6, 0x36, 0x87, 0xdd,
+    0x2a, 0x8c, 0xa1, 0xd2, 0xf4, 0xfb, 0xd8, 0xe1
+};
+
+static const unsigned char rsaCrtCoefQInv_2048_KeyPair[] = {
+    0x6f, 0x38, 0x52, 0x6b, 0x39, 0x25, 0x08, 0x55,
+    0x34, 0xef, 0x3e, 0x41, 0x5a, 0x83, 0x6e, 0xde,
+    0x8b, 0x86, 0x15, 0x8a, 0x2c, 0x7c, 0xbf, 0xec,
+    0xcb, 0x0b, 0xd8, 0x34, 0x30, 0x4f, 0xec, 0x68,
+    0x3b, 0xa8, 0xd4, 0xf4, 0x79, 0xc4, 0x33, 0xd4,
+    0x34, 0x16, 0xe6, 0x32, 0x69, 0x62, 0x3c, 0xea,
+    0x10, 0x07, 0x76, 0xd8, 0x5a, 0xff, 0x40, 0x1d,
+    0x3f, 0xff, 0x61, 0x0e, 0xe6, 0x54, 0x11, 0xce,
+    0x3b, 0x13, 0x63, 0xd6, 0x3a, 0x97, 0x09, 0xee,
+    0xde, 0x42, 0x64, 0x7c, 0xea, 0x56, 0x14, 0x93,
+    0xd5, 0x45, 0x70, 0xa8, 0x79, 0xc1, 0x86, 0x82,
+    0xcd, 0x97, 0x71, 0x0b, 0x96, 0x20, 0x5e, 0xc3,
+    0x11, 0x17, 0xd7, 0x3b, 0x5f, 0x36, 0x22, 0x3f,
+    0xad, 0xd6, 0xe8, 0xba, 0x90, 0xdd, 0x7c, 0x0e,
+    0xe6, 0x1d, 0x44, 0xe1, 0x63, 0x25, 0x1e, 0x20,
+    0xc7, 0xf6, 0x6e, 0xb3, 0x05, 0x11, 0x7c, 0xb8};
+
+static const unsigned char rsaCrtCoefQInv_4096_KeyPair[] = {
+	        0x94, 0x13, 0xB8, 0x44, 0x05, 0x22, 0xCD, 0xC8, 
+        0x71, 0xFB, 0x20, 0xC0, 0x39, 0x90, 0xD6, 0xA7, 
+        0x82, 0x7F, 0x93, 0xE2, 0x5A, 0x8C, 0x96, 0x7D, 
+        0x4D, 0xDC, 0xFE, 0xDD, 0x89, 0x5B, 0x95, 0x3D, 
+        0xF9, 0xF3, 0xE6, 0xE4, 0x50, 0xE4, 0xF0, 0xE6, 
+        0xD3, 0xDB, 0x1E, 0x85, 0xC7, 0xCA, 0xCE, 0x6B, 
+        0xC6, 0x6E, 0x21, 0x3B, 0x61, 0x83, 0xC9, 0x31, 
+        0x8A, 0xB9, 0x9C, 0x0F, 0x87, 0x1A, 0xD7, 0x78, 
+        0xC8, 0xCD, 0x53, 0xCA, 0x0F, 0xA4, 0x2B, 0xFE, 
+        0x35, 0x44, 0x8B, 0x59, 0x1E, 0xE7, 0x5A, 0x04, 
+        0xCB, 0xFD, 0xC2, 0xD0, 0x95, 0x4F, 0x43, 0x58, 
+        0x7F, 0x00, 0x06, 0x20, 0x54, 0xD9, 0x9D, 0x49, 
+        0x4D, 0xDA, 0x19, 0xEE, 0xD5, 0x49, 0xA4, 0xAA, 
+        0xD1, 0xE1, 0xBA, 0xCF, 0x18, 0x58, 0x21, 0xB5, 
+        0x96, 0x06, 0x5E, 0x27, 0x82, 0x79, 0x0E, 0x6D, 
+        0x33, 0xD4, 0xE3, 0x58, 0xB9, 0xD5, 0x73, 0x20, 
+        0x7E, 0x21, 0x23, 0x97, 0x12, 0x84, 0x54, 0xBB, 
+        0x9B, 0xBB, 0xC1, 0xBE, 0x6F, 0xF1, 0xF3, 0x12, 
+        0xBA, 0x20, 0xD7, 0x51, 0xAA, 0x46, 0x96, 0x87, 
+        0x85, 0xAA, 0x50, 0xDB, 0x3C, 0x4D, 0xA1, 0x6E, 
+        0xAD, 0xF6, 0xB6, 0xB6, 0x73, 0xD2, 0xAE, 0x5C, 
+        0x96, 0x83, 0x25, 0x4E, 0x32, 0x9F, 0x3A, 0x89, 
+        0xB6, 0x1A, 0x28, 0x4C, 0xFE, 0x9E, 0x89, 0x4B, 
+        0x64, 0xB7, 0x89, 0xE2, 0xEE, 0xF9, 0x38, 0x5D, 
+        0x65, 0x9C, 0x66, 0x15, 0x74, 0x00, 0xA8, 0xBE, 
+        0xD2, 0x30, 0xA2, 0x25, 0xB4, 0x33, 0xDA, 0xD2, 
+        0xBD, 0x6C, 0xB3, 0xE0, 0x2C, 0x54, 0xE6, 0xF6, 
+        0x90, 0xA9, 0x0C, 0x44, 0xCC, 0xE9, 0x2A, 0x50, 
+        0xC7, 0x80, 0x5D, 0x40, 0xF3, 0x2D, 0x83, 0x60, 
+        0x27, 0x95, 0x57, 0x79, 0xBF, 0x0E, 0xC0, 0x23, 
+        0x75, 0x21, 0xA5, 0x78, 0xBC, 0xA2, 0x5E, 0x63, 
+        0xAF, 0x9D, 0xBC, 0x29, 0x10, 0x81, 0x4D, 0xFD};
+	
+
+static const unsigned char rsaCrtExpDq_1024_KeyPair[] = {
+
+    0x95, 0x29, 0x7b, 0x0f, 0x95, 0xa2, 0xfa, 0x67,
+    0xd0, 0x07, 0x07, 0xd6, 0x09, 0xdf, 0xd4, 0xfc,
+    0x05, 0xc8, 0x9d, 0xaf, 0xc2, 0xef, 0x6d, 0x6e,
+    0xa5, 0x5b, 0xec, 0x77, 0x1e, 0xa3, 0x33, 0x73,
+    0x4d, 0x92, 0x51, 0xe7, 0x90, 0x82, 0xec, 0xda,
+    0x86, 0x6e, 0xfe, 0xf1, 0x3c, 0x45, 0x9e, 0x1a,
+    0x63, 0x13, 0x86, 0xb7, 0xe3, 0x54, 0xc8, 0x99,
+    0xf5, 0xf1, 0x12, 0xca, 0x85, 0xd7, 0x15, 0x83
+};
+
+static const unsigned char rsaCrtExpDq_2048_KeyPair[] = {
+    0x26, 0x58, 0xb3, 0x7f, 0x6d, 0xf9, 0xc1, 0x03,
+    0x0b, 0xe1, 0xdb, 0x68, 0x11, 0x7f, 0xa9, 0xd8,
+    0x7e, 0x39, 0xea, 0x2b, 0x69, 0x3b, 0x7e, 0x6d,
+    0x3a, 0x2f, 0x70, 0x94, 0x74, 0x13, 0xee, 0xc6,
+    0x14, 0x2e, 0x18, 0xfb, 0x8d, 0xfc, 0xb6, 0xac,
+    0x54, 0x5d, 0x7c, 0x86, 0xa0, 0xad, 0x48, 0xf8,
+    0x45, 0x71, 0x70, 0xf0, 0xef, 0xb2, 0x6b, 0xc4,
+    0x81, 0x26, 0xc5, 0x3e, 0xfd, 0x1d, 0x16, 0x92,
+    0x01, 0x98, 0xdc, 0x2a, 0x11, 0x07, 0xdc, 0x28,
+    0x2d, 0xb6, 0xa8, 0x0c, 0xd3, 0x06, 0x23, 0x60,
+    0xba, 0x3f, 0xa1, 0x3f, 0x70, 0xe4, 0x31, 0x2f,
+    0xf1, 0xa6, 0xcd, 0x6b, 0x8f, 0xc4, 0xcd, 0x9c,
+    0x5c, 0x3d, 0xb1, 0x7c, 0x6d, 0x6a, 0x57, 0x21,
+    0x2f, 0x73, 0xae, 0x29, 0xf6, 0x19, 0x32, 0x7b,
+    0xad, 0x59, 0xb1, 0x53, 0x85, 0x85, 0x85, 0xba,
+    0x4e, 0x28, 0xb6, 0x0a, 0x62, 0xa4, 0x5e, 0x49};
+
+static const unsigned char rsaCrtExpDq_4096_KeyPair[] = {
+        0x2A, 0x38, 0xD4, 0x7A, 0x18, 0x8D, 0xCE, 0xFA, 
+        0x18, 0xD4, 0x6D, 0x2A, 0x8A, 0xD7, 0xD7, 0xA7, 
+        0x94, 0x54, 0x4C, 0x09, 0x2E, 0x57, 0xD0, 0x01, 
+        0x7E, 0x59, 0xE2, 0x18, 0xD7, 0xAE, 0xB5, 0x14, 
+        0x00, 0xAA, 0x6E, 0xDA, 0x3A, 0x35, 0x39, 0x05, 
+        0xC7, 0x31, 0xA0, 0xCA, 0xBB, 0x05, 0x34, 0x48, 
+        0x18, 0xCF, 0x3A, 0xDC, 0x66, 0xA4, 0xBE, 0xB0, 
+        0x6B, 0x13, 0x0E, 0x7F, 0x26, 0x60, 0xF8, 0xC3, 
+        0x5A, 0x6A, 0x20, 0xB4, 0x45, 0x47, 0xCC, 0x10, 
+        0x8A, 0x2C, 0xFD, 0x23, 0xC2, 0x77, 0x1E, 0x78, 
+        0xCC, 0xAF, 0x46, 0x89, 0x7E, 0xFE, 0xE7, 0x4F, 
+        0x6F, 0x3C, 0xA4, 0xE9, 0xE0, 0xBA, 0xBA, 0x88, 
+        0xE1, 0x81, 0x59, 0x60, 0xE8, 0xDE, 0x0A, 0xE7, 
+        0xB7, 0xB3, 0x4C, 0xCD, 0x7A, 0x35, 0x54, 0x8A, 
+        0x23, 0x70, 0x8F, 0x0A, 0xED, 0x46, 0x3A, 0x83, 
+        0x3C, 0x33, 0x98, 0xDA, 0x80, 0x71, 0x21, 0x6F, 
+        0xE4, 0x8D, 0x6C, 0x60, 0x50, 0x7B, 0x97, 0xF7, 
+        0x7C, 0x8E, 0x18, 0x24, 0x69, 0xB2, 0x2B, 0x76, 
+        0x95, 0x89, 0xD1, 0xD3, 0x93, 0x5E, 0x78, 0xB0, 
+        0xA0, 0x1C, 0x9D, 0x64, 0xD4, 0xEE, 0xD4, 0xF6, 
+        0x17, 0x3A, 0x84, 0x0F, 0x87, 0xEA, 0x85, 0x2A, 
+        0xDC, 0x77, 0x24, 0x53, 0x13, 0xAC, 0x97, 0xCD, 
+        0xC3, 0x2D, 0xDF, 0x1A, 0x1E, 0x3D, 0xC3, 0x3D, 
+        0x75, 0xDF, 0x08, 0xA8, 0xD4, 0x91, 0xF2, 0x8C, 
+        0x09, 0x4C, 0x43, 0xF7, 0xC1, 0xB3, 0xAE, 0xC4, 
+        0xC8, 0x6F, 0x80, 0x0C, 0x60, 0xB6, 0x3D, 0xFF, 
+        0x84, 0xAA, 0xDA, 0x33, 0x2C, 0x59, 0x54, 0xE7, 
+        0x07, 0x1B, 0x72, 0x74, 0x73, 0x13, 0x5E, 0x2D, 
+        0x6B, 0x35, 0xCB, 0x56, 0xE0, 0x03, 0xA6, 0xBF, 
+        0xA5, 0xB0, 0xC6, 0x53, 0x0E, 0x27, 0x12, 0x6D, 
+        0xED, 0x24, 0x17, 0x9F, 0x11, 0x18, 0x1C, 0xB8, 
+        0xE2, 0x73, 0x20, 0xEE, 0x63, 0x4D, 0x68, 0x4F};
+
+static const unsigned char rsaCrtExpDp_1024_KeyPair[] = {
+
+    0x0e, 0x12, 0xbf, 0x17, 0x18, 0xe9, 0xce, 0xf5,
+    0x59, 0x9b, 0xa1, 0xc3, 0x88, 0x2f, 0xe8, 0x04,
+    0x6a, 0x90, 0x87, 0x4e, 0xef, 0xce, 0x8f, 0x2c,
+    0xcc, 0x20, 0xe4, 0xf2, 0x74, 0x1f, 0xb0, 0xa3,
+    0x3a, 0x38, 0x48, 0xae, 0xc9, 0xc9, 0x30, 0x5f,
+    0xbe, 0xcb, 0xd2, 0xd7, 0x68, 0x19, 0x96, 0x7d,
+    0x46, 0x71, 0xac, 0xc6, 0x43, 0x1e, 0x40, 0x37,
+    0x96, 0x8d, 0xb3, 0x78, 0x78, 0xe6, 0x95, 0xc1
+};
+
+
+static const unsigned char rsaCrtExpDp_2048_KeyPair[] = {
+    0xc7, 0x35, 0x64, 0x57, 0x1d, 0x00, 0xfb, 0x15,
+    0xd0, 0x8a, 0x3d, 0xe9, 0x95, 0x7a, 0x50, 0x91,
+    0x5d, 0x71, 0x26, 0xe9, 0x44, 0x2d, 0xac, 0xf4,
+    0x2b, 0xc8, 0x2e, 0x86, 0x2e, 0x56, 0x73, 0xff,
+    0x6a, 0x00, 0x8e, 0xd4, 0xd2, 0xe3, 0x74, 0x61,
+    0x7d, 0xf8, 0x9f, 0x17, 0xa1, 0x60, 0xb4, 0x3b,
+    0x7f, 0xda, 0x9c, 0xb6, 0xb6, 0xb7, 0x42, 0x18,
+    0x60, 0x98, 0x15, 0xf7, 0xd4, 0x5c, 0xa2, 0x63,
+    0xc1, 0x59, 0xaa, 0x32, 0xd2, 0x72, 0xd1, 0x27,
+    0xfa, 0xf4, 0xbc, 0x8c, 0xa2, 0xd7, 0x73, 0x78,
+    0xe8, 0xae, 0xb1, 0x9b, 0x0a, 0xd7, 0xda, 0x3c,
+    0xb3, 0xde, 0x0a, 0xe7, 0x31, 0x49, 0x80, 0xf6,
+    0x2b, 0x6d, 0x4b, 0x0a, 0x87, 0x5d, 0x1d, 0xf0,
+    0x3c, 0x1b, 0xae, 0x39, 0xcc, 0xd8, 0x33, 0xef,
+    0x6c, 0xd7, 0xe2, 0xd9, 0x52, 0x8b, 0xf0, 0x84,
+    0xd1, 0xf9, 0x69, 0xe7, 0x94, 0xe9, 0xf6, 0xc1};
+
+	static const unsigned char rsaCrtExpDp_4096_KeyPair[] = {
+        0x64, 0x73, 0xFE, 0xD9, 0x52, 0xBA, 0x7B, 0xA6, 
+        0xF6, 0xB9, 0xAA, 0xB0, 0x74, 0xDA, 0x36, 0x78, 
+        0x76, 0x47, 0xE9, 0xC5, 0x12, 0xBD, 0xEF, 0xA9, 
+        0x29, 0xF0, 0x2B, 0x70, 0xDA, 0xA8, 0x23, 0x18, 
+        0x92, 0x18, 0x98, 0x9B, 0xE6, 0x2E, 0x14, 0x03, 
+        0x77, 0x0E, 0x61, 0x8F, 0x1E, 0x9B, 0x7B, 0xCB, 
+        0x23, 0xE8, 0xF4, 0x5D, 0xCB, 0x42, 0xD6, 0x2A, 
+        0x58, 0x37, 0xFA, 0x58, 0x46, 0x5A, 0x07, 0xF3, 
+        0x26, 0x29, 0x3C, 0xFE, 0x73, 0xD2, 0x0B, 0x66, 
+        0x3D, 0x66, 0x56, 0x1B, 0xEC, 0x8D, 0xD0, 0xED, 
+        0xE2, 0x38, 0x49, 0x3C, 0x4A, 0x62, 0xC2, 0xFC, 
+        0xCE, 0xDB, 0xAC, 0xAA, 0xC2, 0xB8, 0xCC, 0x2D, 
+        0x99, 0xC3, 0xCC, 0x00, 0x42, 0x31, 0x87, 0xB9, 
+        0xB1, 0x3A, 0xA3, 0x78, 0x04, 0x38, 0xF0, 0x16, 
+        0x01, 0xFC, 0x23, 0x05, 0x1E, 0x1F, 0xC3, 0xC1, 
+        0xAF, 0x5A, 0x19, 0x13, 0x8B, 0xB9, 0x64, 0x48, 
+        0x04, 0x6A, 0xA0, 0x25, 0xA6, 0xE5, 0xE8, 0x29, 
+        0x20, 0xA0, 0xFF, 0x0F, 0xAE, 0x06, 0xF7, 0x4C, 
+        0xAC, 0x64, 0x09, 0x24, 0x47, 0xA7, 0x00, 0x46, 
+        0x6E, 0xA9, 0x70, 0xBD, 0x6B, 0xAF, 0x70, 0xD7, 
+        0x63, 0xC2, 0x57, 0xFA, 0x68, 0xE0, 0x75, 0x66, 
+        0x43, 0x03, 0x2C, 0x61, 0xF5, 0x61, 0xC3, 0x92, 
+        0x04, 0x13, 0xD2, 0xC4, 0x9F, 0xF4, 0xA4, 0xA0, 
+        0x3D, 0xF6, 0x25, 0xB8, 0xDE, 0xCE, 0x5C, 0x53, 
+        0x91, 0x61, 0xDB, 0x60, 0x34, 0xE0, 0x5E, 0x3E, 
+        0xF4, 0x73, 0xB2, 0x45, 0xE5, 0xE3, 0x71, 0xFF, 
+        0x1C, 0xA9, 0xE6, 0x9F, 0xE4, 0xB9, 0xB4, 0xD7, 
+        0xE5, 0x60, 0xD7, 0xAC, 0x31, 0xFB, 0x19, 0xD6, 
+        0x2D, 0x11, 0x29, 0x55, 0x79, 0x8A, 0xF4, 0x99, 
+        0x0E, 0x69, 0x2A, 0xED, 0x5F, 0xC1, 0x59, 0xAE, 
+        0xAE, 0xC6, 0x66, 0x40, 0x23, 0xED, 0xED, 0x94, 
+        0x62, 0x78, 0x9C, 0xEB, 0x48, 0x04, 0x17, 0x85};
+
+static const unsigned char rsaPrimeQ_1024_KeyPair[] = {
+
+    0xcc, 0x88, 0x53, 0xd1, 0xd5, 0x4d, 0xa6, 0x30,
+    0xfa, 0xc0, 0x04, 0xf4, 0x71, 0xf2, 0x81, 0xc7,
+    0xb8, 0x98, 0x2d, 0x82, 0x24, 0xa4, 0x90, 0xed,
+    0xbe, 0xb3, 0x3d, 0x3e, 0x3d, 0x5c, 0xc9, 0x3c,
+    0x47, 0x65, 0x70, 0x3d, 0x1d, 0xd7, 0x91, 0x64,
+    0x2f, 0x1f, 0x11, 0x6a, 0x0d, 0xd8, 0x52, 0xbe,
+    0x24, 0x19, 0xb2, 0xaf, 0x72, 0xbf, 0xe9, 0xa0,
+    0x30, 0xe8, 0x60, 0xb0, 0x28, 0x8b, 0x5d, 0x77
+};
+
+static const unsigned char rsaPrimeQ_2048_KeyPair[] = {
+    0xbc, 0x46, 0xc4, 0x64, 0xfc, 0x6a, 0xc4, 0xca,
+    0x78, 0x3b, 0x0e, 0xb0, 0x8a, 0x3c, 0x84, 0x1b,
+    0x77, 0x2f, 0x7e, 0x9b, 0x2f, 0x28, 0xba, 0xbd,
+    0x58, 0x8a, 0xe8, 0x85, 0xe1, 0xa0, 0xc6, 0x1e,
+    0x48, 0x58, 0xa0, 0xfb, 0x25, 0xac, 0x29, 0x99,
+    0x90, 0xf3, 0x5b, 0xe8, 0x51, 0x64, 0xc2, 0x59,
+    0xba, 0x11, 0x75, 0xcd, 0xd7, 0x19, 0x27, 0x07,
+    0x13, 0x51, 0x84, 0x99, 0x2b, 0x6c, 0x29, 0xb7,
+    0x46, 0xdd, 0x0d, 0x2c, 0xab, 0xe1, 0x42, 0x83,
+    0x5f, 0x7d, 0x14, 0x8c, 0xc1, 0x61, 0x52, 0x4b,
+    0x4a, 0x09, 0x94, 0x6d, 0x48, 0xb8, 0x28, 0x47,
+    0x3f, 0x1c, 0xe7, 0x6b, 0x6c, 0xb6, 0x88, 0x6c,
+    0x34, 0x5c, 0x03, 0xe0, 0x5f, 0x41, 0xd5, 0x1b,
+    0x5c, 0x3a, 0x90, 0xa3, 0xf2, 0x40, 0x73, 0xc7,
+    0xd7, 0x4a, 0x4f, 0xe2, 0x5d, 0x9c, 0xf2, 0x1c,
+    0x75, 0x96, 0x0f, 0x3f, 0xc3, 0x86, 0x31, 0x83};
+
+	static const unsigned char rsaPrimeQ_4096_KeyPair[] = {
+        0xD0, 0xB2, 0x39, 0x17, 0x5C, 0xE3, 0x20, 0x42, 
+        0xE0, 0xC0, 0x43, 0xF1, 0x67, 0x52, 0x96, 0xA0, 
+        0x85, 0xFE, 0x1D, 0x6A, 0x2E, 0x16, 0x53, 0x8C, 
+        0xD1, 0x48, 0x64, 0x9B, 0x58, 0x52, 0xE2, 0x11, 
+        0x4B, 0x71, 0x80, 0x14, 0x90, 0x55, 0x53, 0x2D, 
+        0x65, 0x7D, 0x21, 0xEE, 0x31, 0xD9, 0xDF, 0x8C, 
+        0xB7, 0x41, 0x4F, 0xB6, 0xD0, 0x81, 0x8A, 0x97, 
+        0xE8, 0x6F, 0x3E, 0x0A, 0x18, 0x72, 0x21, 0x54, 
+        0xCD, 0x76, 0x3E, 0x06, 0x19, 0xD5, 0xBE, 0x03, 
+        0x53, 0x57, 0x8C, 0x03, 0x9F, 0x49, 0x22, 0xD9, 
+        0x45, 0x9B, 0x01, 0x8A, 0x4A, 0xA6, 0xAB, 0x61, 
+        0x92, 0x73, 0x31, 0x39, 0xAA, 0x3F, 0x46, 0xB7, 
+        0x62, 0x7E, 0x22, 0x73, 0x27, 0xCF, 0xB9, 0xFC, 
+        0x61, 0xC1, 0x42, 0x87, 0xA2, 0xEA, 0x05, 0xE5, 
+        0xDB, 0x67, 0xFB, 0x1F, 0xE2, 0x0E, 0x8D, 0xC8, 
+        0xF2, 0xCA, 0x53, 0x69, 0x31, 0x98, 0x1F, 0x60, 
+        0x18, 0x0B, 0x4B, 0x28, 0xDA, 0x2C, 0xAF, 0xC2, 
+        0x4D, 0x88, 0x09, 0x29, 0x5F, 0x86, 0xB1, 0x73, 
+        0xA7, 0x1D, 0x8C, 0x38, 0x3F, 0x36, 0xD0, 0xC6, 
+        0x7F, 0x7E, 0x34, 0x5A, 0x04, 0xBE, 0x41, 0x64, 
+        0xBB, 0x4B, 0xBA, 0xEB, 0x0C, 0xFE, 0xBA, 0x30, 
+        0xE1, 0x3E, 0x34, 0x85, 0x60, 0x8D, 0x17, 0x14, 
+        0x59, 0x94, 0x93, 0xE5, 0x75, 0x68, 0x4F, 0x25, 
+        0x75, 0x7F, 0x1C, 0xC8, 0xFA, 0x47, 0xD8, 0x92, 
+        0xCF, 0xF2, 0xF8, 0xF4, 0x00, 0xEA, 0x7B, 0x27, 
+        0x32, 0xCD, 0xCA, 0x48, 0xA6, 0x67, 0xBB, 0xFE, 
+        0x6D, 0xFB, 0xC4, 0xE1, 0x68, 0x71, 0xDC, 0xAC, 
+        0x88, 0x83, 0xA1, 0x8B, 0x86, 0xF9, 0xE7, 0x57, 
+        0x0B, 0xDB, 0xE7, 0xC3, 0x35, 0x02, 0x77, 0x80, 
+        0x31, 0x20, 0x74, 0xD8, 0xB7, 0xD9, 0x8C, 0xE8, 
+        0x39, 0x58, 0x13, 0xAD, 0x74, 0x50, 0x0B, 0xC2, 
+        0x1F, 0x51, 0x37, 0x1D, 0x2D, 0xA8, 0x9B, 0x2B};
+	
+	
+	
+	
+
+static const unsigned char rsaPrimeP_1024_KeyPair[] = {
+
+    0xd3, 0x27, 0x37, 0xe7, 0x26, 0x7f, 0xfe, 0x13,
+    0x41, 0xb2, 0xd5, 0xc0, 0xd1, 0x50, 0xa8, 0x1b,
+    0x58, 0x6f, 0xb3, 0x13, 0x2b, 0xed, 0x2f, 0x8d,
+    0x52, 0x62, 0x86, 0x4a, 0x9c, 0xb9, 0xf3, 0x0a,
+    0xf3, 0x8b, 0xe4, 0x48, 0x59, 0x8d, 0x41, 0x3a,
+    0x17, 0x2e, 0xfb, 0x80, 0x2c, 0x21, 0xac, 0xf1,
+    0xc1, 0x1c, 0x52, 0x0c, 0x2f, 0x26, 0xa4, 0x71,
+    0xdc, 0xad, 0x21, 0x2e, 0xac, 0x7c, 0xa3, 0x9d
+};
+
+
+static const unsigned char rsaPrimeP_2048_KeyPair[] = {
+    0xec, 0xf5, 0xae, 0xcd, 0x1e, 0x55, 0x15, 0xff,
+    0xfa, 0xcb, 0xd7, 0x5a, 0x28, 0x16, 0xc6, 0xeb,
+    0xf4, 0x90, 0x18, 0xcd, 0xfb, 0x46, 0x38, 0xe1,
+    0x85, 0xd6, 0x6a, 0x73, 0x96, 0xb6, 0xf8, 0x09,
+    0x0f, 0x80, 0x18, 0xc7, 0xfd, 0x95, 0xcc, 0x34,
+    0xb8, 0x57, 0xdc, 0x17, 0xf0, 0xcc, 0x65, 0x16,
+    0xbb, 0x13, 0x46, 0xab, 0x4d, 0x58, 0x2c, 0xad,
+    0xad, 0x7b, 0x41, 0x03, 0x35, 0x23, 0x87, 0xb7,
+    0x03, 0x38, 0xd0, 0x84, 0x04, 0x7c, 0x9d, 0x95,
+    0x39, 0xb6, 0x49, 0x62, 0x04, 0xb3, 0xdd, 0x6e,
+    0xa4, 0x42, 0x49, 0x92, 0x07, 0xbe, 0xc0, 0x1f,
+    0x96, 0x42, 0x87, 0xff, 0x63, 0x36, 0xc3, 0x98,
+    0x46, 0x58, 0x33, 0x68, 0x46, 0xf5, 0x6e, 0x46,
+    0x86, 0x18, 0x81, 0xc1, 0x02, 0x33, 0xd2, 0x17,
+    0x6b, 0xf1, 0x5a, 0x5e, 0x96, 0xdd, 0xc7, 0x80,
+    0xbc, 0x86, 0x8a, 0xa7, 0x7d, 0x3c, 0xe7, 0x69};
+
+static const unsigned char rsaPrimeP_4096_KeyPair[] = {
+	        0xD9, 0x33, 0xBC, 0x12, 0x30, 0x71, 0xE8, 0x20, 
+        0x73, 0xF3, 0xEA, 0xCD, 0x2A, 0xF2, 0x06, 0x45, 
+        0xCD, 0xF7, 0xFE, 0x5A, 0x57, 0xE5, 0xF0, 0x59, 
+        0xAD, 0x46, 0x10, 0x30, 0xF8, 0x97, 0xBD, 0x62, 
+        0x2B, 0x8E, 0xC7, 0x32, 0x2D, 0x1E, 0x5F, 0xA7, 
+        0xFB, 0xF6, 0x23, 0xE4, 0x3B, 0x13, 0xAA, 0x72, 
+        0x5B, 0x6B, 0xC1, 0xD3, 0x92, 0x12, 0x4A, 0x10, 
+        0xA4, 0x58, 0x9A, 0x99, 0x48, 0xF1, 0x57, 0x16, 
+        0xBC, 0xDB, 0x6B, 0xE3, 0x27, 0xB7, 0xB1, 0xF5, 
+        0xF9, 0x0B, 0x99, 0xC9, 0xBB, 0x32, 0x3B, 0x97, 
+        0xC4, 0xBA, 0x1C, 0xDB, 0x4A, 0x4C, 0xE7, 0x8D, 
+        0xB0, 0x93, 0xCD, 0x4F, 0x78, 0xE4, 0xA4, 0x72, 
+        0xB6, 0xC0, 0x2D, 0xFB, 0x16, 0x06, 0x89, 0x5C, 
+        0x30, 0x36, 0x7F, 0xF6, 0x9A, 0xF9, 0xF0, 0x36, 
+        0xBF, 0x79, 0x2C, 0xF5, 0xE4, 0x2B, 0x53, 0xC7, 
+        0xBD, 0xE1, 0xE6, 0xE0, 0xDF, 0xE5, 0x60, 0xC9, 
+        0x6D, 0x6E, 0xBB, 0x89, 0xE1, 0xDC, 0x59, 0x85, 
+        0x22, 0x28, 0x2A, 0xB5, 0x7F, 0x81, 0xD3, 0xBD, 
+        0x57, 0x52, 0x42, 0xB9, 0xFD, 0x27, 0xF3, 0x01, 
+        0x53, 0x53, 0xE5, 0xE8, 0xB1, 0x45, 0xEB, 0xC0, 
+        0xDC, 0xC2, 0xC3, 0x8C, 0xAA, 0xF8, 0xF1, 0x01, 
+        0x81, 0xC2, 0xAD, 0x30, 0x01, 0x61, 0xFF, 0xCB, 
+        0xA1, 0xA7, 0xFB, 0x7A, 0x08, 0xE5, 0x5D, 0xB5, 
+        0x41, 0xE1, 0xED, 0xEA, 0xC9, 0xB8, 0x19, 0x8E, 
+        0xA2, 0x72, 0x55, 0x0D, 0x65, 0xC7, 0xA3, 0xF7, 
+        0x4E, 0x73, 0xD5, 0xD9, 0xCA, 0x99, 0x35, 0xE3, 
+        0xFB, 0x47, 0x5C, 0xF8, 0xF3, 0x53, 0xD9, 0x4B, 
+        0xFB, 0x8B, 0xF5, 0xC5, 0xAB, 0x29, 0x6F, 0x50, 
+        0x1C, 0x2B, 0xA2, 0xBE, 0x77, 0x4B, 0xB6, 0x2E, 
+        0x7A, 0x8D, 0xDF, 0x0C, 0x4D, 0xA0, 0x19, 0x45, 
+        0x58, 0x93, 0x12, 0x48, 0x25, 0xD2, 0x70, 0x14, 
+        0xF2, 0x57, 0xBB, 0x84, 0xBA, 0xAF, 0xB5, 0x37};
+	
+	
+	
+static const unsigned char rsaPrivateExponentD_1024[] = {
+
+    0x53, 0x33, 0x9c, 0xfd, 0xb7, 0x9f, 0xc8, 0x46,
+    0x6a, 0x65, 0x5c, 0x73, 0x16, 0xac, 0xa8, 0x5c,
+    0x55, 0xfd, 0x8f, 0x6d, 0xd8, 0x98, 0xfd, 0xaf,
+    0x11, 0x95, 0x17, 0xef, 0x4f, 0x52, 0xe8, 0xfd,
+    0x8e, 0x25, 0x8d, 0xf9, 0x3f, 0xee, 0x18, 0x0f,
+    0xa0, 0xe4, 0xab, 0x29, 0x69, 0x3c, 0xd8, 0x3b,
+    0x15, 0x2a, 0x55, 0x3d, 0x4a, 0xc4, 0xd1, 0x81,
+    0x2b, 0x8b, 0x9f, 0xa5, 0xaf, 0x0e, 0x7f, 0x55,
+    0xfe, 0x73, 0x04, 0xdf, 0x41, 0x57, 0x09, 0x26,
+    0xf3, 0x31, 0x1f, 0x15, 0xc4, 0xd6, 0x5a, 0x73,
+    0x2c, 0x48, 0x31, 0x16, 0xee, 0x3d, 0x3d, 0x2d,
+    0x0a, 0xf3, 0x54, 0x9a, 0xd9, 0xbf, 0x7c, 0xbf,
+    0xb7, 0x8a, 0xd8, 0x84, 0xf8, 0x4d, 0x5b, 0xeb,
+    0x04, 0x72, 0x4d, 0xc7, 0x36, 0x9b, 0x31, 0xde,
+    0xf3, 0x7d, 0x0c, 0xf5, 0x39, 0xe9, 0xcf, 0xcd,
+    0xd3, 0xde, 0x65, 0x37, 0x29, 0xea, 0xd5, 0xd1
+};
+
+
+static const unsigned char rsaPrivateExponentD_2048[] = {
+    0x05, 0x6b, 0x04, 0x21, 0x6f, 0xe5, 0xf3, 0x54,
+    0xac, 0x77, 0x25, 0x0a, 0x4b, 0x6b, 0x0c, 0x85,
+    0x25, 0xa8, 0x5c, 0x59, 0xb0, 0xbd, 0x80, 0xc5,
+    0x64, 0x50, 0xa2, 0x2d, 0x5f, 0x43, 0x8e, 0x59,
+    0x6a, 0x33, 0x3a, 0xa8, 0x75, 0xe2, 0x91, 0xdd,
+    0x43, 0xf4, 0x8c, 0xb8, 0x8b, 0x9d, 0x5f, 0xc0,
+    0xd4, 0x99, 0xf9, 0xfc, 0xd1, 0xc3, 0x97, 0xf9,
+    0xaf, 0xc0, 0x70, 0xcd, 0x9e, 0x39, 0x8c, 0x8d,
+    0x19, 0xe6, 0x1d, 0xb7, 0xc7, 0x41, 0x0a, 0x6b,
+    0x26, 0x75, 0xdf, 0xbf, 0x5d, 0x34, 0x5b, 0x80,
+    0x4d, 0x20, 0x1a, 0xdd, 0x50, 0x2d, 0x5c, 0xe2,
+    0xdf, 0xcb, 0x09, 0x1c, 0xe9, 0x99, 0x7b, 0xbe,
+    0xbe, 0x57, 0x30, 0x6f, 0x38, 0x3e, 0x4d, 0x58,
+    0x81, 0x03, 0xf0, 0x36, 0xf7, 0xe8, 0x5d, 0x19,
+    0x34, 0xd1, 0x52, 0xa3, 0x23, 0xe4, 0xa8, 0xdb,
+    0x45, 0x1d, 0x6f, 0x4a, 0x5b, 0x1b, 0x0f, 0x10,
+    0x2c, 0xc1, 0x50, 0xe0, 0x2f, 0xee, 0xe2, 0xb8,
+    0x8d, 0xea, 0x4a, 0xd4, 0xc1, 0xba, 0xcc, 0xb2,
+    0x4d, 0x84, 0x07, 0x2d, 0x14, 0xe1, 0xd2, 0x4a,
+    0x67, 0x71, 0xf7, 0x40, 0x8e, 0xe3, 0x05, 0x64,
+    0xfb, 0x86, 0xd4, 0x39, 0x3a, 0x34, 0xbc, 0xf0,
+    0xb7, 0x88, 0x50, 0x1d, 0x19, 0x33, 0x03, 0xf1,
+    0x3a, 0x22, 0x84, 0xb0, 0x01, 0xf0, 0xf6, 0x49,
+    0xea, 0xf7, 0x93, 0x28, 0xd4, 0xac, 0x5c, 0x43,
+    0x0a, 0xb4, 0x41, 0x49, 0x20, 0xa9, 0x46, 0x0e,
+    0xd1, 0xb7, 0xbc, 0x40, 0xec, 0x65, 0x3e, 0x87,
+    0x6d, 0x09, 0xab, 0xc5, 0x09, 0xae, 0x45, 0xb5,
+    0x25, 0x19, 0x01, 0x16, 0xa0, 0xc2, 0x61, 0x01,
+    0x84, 0x82, 0x98, 0x50, 0x9c, 0x1c, 0x3b, 0xf3,
+    0xa4, 0x83, 0xe7, 0x27, 0x40, 0x54, 0xe1, 0x5e,
+    0x97, 0x07, 0x50, 0x36, 0xe9, 0x89, 0xf6, 0x09,
+    0x32, 0x80, 0x7b, 0x52, 0x57, 0x75, 0x1e, 0x79};
+
+static const unsigned char rsaPrivateExponentD_4096[] = {	
+	        0x9D, 0x0E, 0xD2, 0x47, 0x6D, 0x75, 0x03, 0x44, 
+        0x57, 0xC1, 0x31, 0x0A, 0x81, 0xC4, 0xBA, 0xB9, 
+        0xF5, 0x22, 0x96, 0xAD, 0xF8, 0x64, 0x88, 0xB2, 
+        0x89, 0x82, 0x93, 0x34, 0xB5, 0x70, 0x03, 0x06, 
+        0x21, 0x99, 0xAD, 0xAF, 0x16, 0x24, 0x84, 0x3A, 
+        0x43, 0x1E, 0x18, 0x8F, 0x31, 0x24, 0x39, 0xC8, 
+        0x93, 0x4C, 0x40, 0x29, 0x14, 0xB5, 0xD3, 0xB8, 
+        0x94, 0x42, 0x10, 0x5C, 0x80, 0x81, 0xDE, 0xAE, 
+        0x90, 0x95, 0x33, 0xF9, 0x79, 0x62, 0x40, 0x64, 
+        0x7B, 0x1F, 0x5C, 0xA4, 0xF9, 0x44, 0x29, 0x75, 
+        0xC4, 0xF6, 0xDC, 0x4E, 0x91, 0xC2, 0x38, 0x62, 
+        0x40, 0x73, 0x99, 0x17, 0x54, 0x0C, 0x4E, 0xC2, 
+        0x13, 0x15, 0xA0, 0x06, 0x79, 0x04, 0x9C, 0x12, 
+        0xD9, 0x60, 0xA3, 0x88, 0x52, 0xA4, 0x41, 0x61, 
+        0xC3, 0xA3, 0x0E, 0x84, 0x8F, 0x7D, 0x2E, 0xD9, 
+        0x5D, 0xB4, 0xDF, 0x35, 0x06, 0xC1, 0x11, 0x0C, 
+        0x64, 0xBC, 0x40, 0xA2, 0xC8, 0x4A, 0x61, 0xC3, 
+        0xAF, 0x1E, 0x20, 0x81, 0xC9, 0x1D, 0xD2, 0xD9, 
+        0x0D, 0x8B, 0xA4, 0xA0, 0xA8, 0x35, 0xB1, 0x15, 
+        0x5F, 0xAD, 0x71, 0x91, 0x0A, 0x9F, 0xE4, 0x77, 
+        0x13, 0x35, 0x6D, 0xFB, 0x83, 0xF3, 0x4C, 0xA5, 
+        0xB2, 0xC2, 0x54, 0x82, 0xAA, 0x79, 0x1A, 0x11, 
+        0xA1, 0x7D, 0xE1, 0x8E, 0x84, 0xD6, 0x4E, 0xD8, 
+        0x50, 0x35, 0x72, 0x84, 0x57, 0x26, 0xC6, 0xA9, 
+        0xEB, 0xDE, 0x00, 0x71, 0x09, 0x21, 0xD9, 0x90, 
+        0x77, 0x44, 0xF3, 0x7A, 0x92, 0xCD, 0x06, 0xE0, 
+        0xC7, 0xE4, 0x50, 0x6D, 0x69, 0xB5, 0xBE, 0x63, 
+        0xC8, 0x80, 0x7A, 0x2A, 0xD4, 0x4D, 0x1D, 0x9A, 
+        0x30, 0xB4, 0xA7, 0xFC, 0x32, 0x6E, 0x94, 0xCA, 
+        0x72, 0x0B, 0x66, 0x5F, 0xAA, 0x1B, 0xE4, 0x1F, 
+        0x9F, 0xB6, 0xA5, 0x00, 0x97, 0x60, 0x7C, 0xCB, 
+        0x6D, 0xD1, 0x9D, 0x40, 0x0C, 0x7B, 0x5B, 0xF7, 
+        0xF1, 0xE0, 0x12, 0x21, 0x2F, 0x7D, 0x9A, 0x04, 
+        0x9A, 0x8B, 0x7E, 0x5E, 0x25, 0x5B, 0xB6, 0xE8, 
+        0x9C, 0x45, 0x49, 0x17, 0x94, 0x1D, 0x73, 0x30, 
+        0x0D, 0xF0, 0xED, 0x80, 0xCD, 0x7A, 0xEE, 0x7E, 
+        0x48, 0xD8, 0x89, 0x6A, 0xCB, 0x8D, 0xAE, 0xE1, 
+        0x0A, 0x80, 0xED, 0x90, 0x9B, 0x47, 0xAE, 0xF9, 
+        0x4C, 0xC5, 0x7E, 0x1B, 0xC7, 0xF3, 0x8B, 0x76, 
+        0xAF, 0xF4, 0xA6, 0x7C, 0x8B, 0x5D, 0xE5, 0xCF, 
+        0xA4, 0x5E, 0x76, 0x98, 0x1C, 0x41, 0xC6, 0x00, 
+        0x28, 0x72, 0x53, 0xBA, 0x7A, 0x29, 0x84, 0xB6, 
+        0xCA, 0x36, 0xA5, 0xFB, 0xE1, 0x8A, 0xDB, 0xC8, 
+        0x3B, 0xD6, 0xDF, 0x1B, 0x32, 0x3D, 0x5F, 0xAE, 
+        0x78, 0xD8, 0xE1, 0x72, 0x92, 0x26, 0xA4, 0x09, 
+        0xDF, 0x3C, 0x34, 0x01, 0x4A, 0x3A, 0x9E, 0x69, 
+        0xEF, 0x7C, 0x57, 0x18, 0x97, 0xDC, 0xBF, 0x5E, 
+        0xF3, 0xDC, 0xBA, 0x54, 0x73, 0x4D, 0x33, 0xD0, 
+        0xBD, 0xD4, 0x9E, 0xAA, 0x49, 0x29, 0x54, 0xF0, 
+        0x99, 0xB9, 0x89, 0x85, 0x71, 0x04, 0xEF, 0xF2, 
+        0x09, 0xCF, 0xAD, 0xB6, 0x74, 0x81, 0xB7, 0x76, 
+        0x29, 0x20, 0x90, 0x59, 0x7C, 0x54, 0xF6, 0xA4, 
+        0xAC, 0x37, 0x16, 0xF4, 0x58, 0xE0, 0x21, 0x00, 
+        0xDD, 0x77, 0xAD, 0x5D, 0xAC, 0x96, 0xD0, 0x66, 
+        0xC0, 0xE0, 0xE4, 0x6F, 0x12, 0x7A, 0x46, 0xE4, 
+        0xE2, 0x74, 0x35, 0x76, 0xD6, 0x41, 0xB1, 0xEB, 
+        0x3F, 0x07, 0xA6, 0x0F, 0x7B, 0xB2, 0x71, 0x76, 
+        0xE9, 0x00, 0x22, 0xDF, 0xA4, 0xE8, 0xB0, 0x4C, 
+        0x86, 0xC8, 0x80, 0x64, 0x53, 0xD6, 0x41, 0x8D, 
+        0x03, 0x75, 0xB7, 0x91, 0x53, 0x55, 0x78, 0xA9, 
+        0x39, 0xE6, 0x19, 0x81, 0xC0, 0x56, 0xF6, 0xA8, 
+        0x38, 0x9D, 0x0B, 0x17, 0x80, 0x9A, 0xD6, 0x4A, 
+        0x34, 0x89, 0x2A, 0x0E, 0x83, 0x3A, 0xCD, 0x25, 
+        0x94, 0x45, 0x7C, 0x71, 0xDF, 0xDB, 0x28, 0x55};
+	
+	
+
+static const unsigned char rsaPublicExponentE_1024[] = {
+
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01
+};
+
+
+static const unsigned char rsaPublicExponentE_2048[] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01};
+
+	
+static const unsigned char rsaPublicExponentE_4096[] = {	
+	        0x01, 0x00, 0x01};
+
+static const unsigned char rsaModulusN_1024[] = {
+
+    0xa8, 0xb3, 0xb2, 0x84, 0xaf, 0x8e, 0xb5, 0x0b,
+    0x38, 0x70, 0x34, 0xa8, 0x60, 0xf1, 0x46, 0xc4,
+    0x91, 0x9f, 0x31, 0x87, 0x63, 0xcd, 0x6c, 0x55,
+    0x98, 0xc8, 0xae, 0x48, 0x11, 0xa1, 0xe0, 0xab,
+    0xc4, 0xc7, 0xe0, 0xb0, 0x82, 0xd6, 0x93, 0xa5,
+    0xe7, 0xfc, 0xed, 0x67, 0x5c, 0xf4, 0x66, 0x85,
+    0x12, 0x77, 0x2c, 0x0c, 0xbc, 0x64, 0xa7, 0x42,
+    0xc6, 0xc6, 0x30, 0xf5, 0x33, 0xc8, 0xcc, 0x72,
+    0xf6, 0x2a, 0xe8, 0x33, 0xc4, 0x0b, 0xf2, 0x58,
+    0x42, 0xe9, 0x84, 0xbb, 0x78, 0xbd, 0xbf, 0x97,
+    0xc0, 0x10, 0x7d, 0x55, 0xbd, 0xb6, 0x62, 0xf5,
+    0xc4, 0xe0, 0xfa, 0xb9, 0x84, 0x5c, 0xb5, 0x14,
+    0x8e, 0xf7, 0x39, 0x2d, 0xd3, 0xaa, 0xff, 0x93,
+    0xae, 0x1e, 0x6b, 0x66, 0x7b, 0xb3, 0xd4, 0x24,
+    0x76, 0x16, 0xd4, 0xf5, 0xba, 0x10, 0xd4, 0xcf,
+    0xd2, 0x26, 0xde, 0x88, 0xd3, 0x9f, 0x16, 0xfb
+};
+
+
+static const unsigned char rsaModulusN_2048[] = {
+    0xae, 0x45, 0xed, 0x56, 0x01, 0xce, 0xc6, 0xb8,
+    0xcc, 0x05, 0xf8, 0x03, 0x93, 0x5c, 0x67, 0x4d,
+    0xdb, 0xe0, 0xd7, 0x5c, 0x4c, 0x09, 0xfd, 0x79,
+    0x51, 0xfc, 0x6b, 0x0c, 0xae, 0xc3, 0x13, 0xa8,
+    0xdf, 0x39, 0x97, 0x0c, 0x51, 0x8b, 0xff, 0xba,
+    0x5e, 0xd6, 0x8f, 0x3f, 0x0d, 0x7f, 0x22, 0xa4,
+    0x02, 0x9d, 0x41, 0x3f, 0x1a, 0xe0, 0x7e, 0x4e,
+    0xbe, 0x9e, 0x41, 0x77, 0xce, 0x23, 0xe7, 0xf5,
+    0x40, 0x4b, 0x56, 0x9e, 0x4e, 0xe1, 0xbd, 0xcf,
+    0x3c, 0x1f, 0xb0, 0x3e, 0xf1, 0x13, 0x80, 0x2d,
+    0x4f, 0x85, 0x5e, 0xb9, 0xb5, 0x13, 0x4b, 0x5a,
+    0x7c, 0x80, 0x85, 0xad, 0xca, 0xe6, 0xfa, 0x2f,
+    0xa1, 0x41, 0x7e, 0xc3, 0x76, 0x3b, 0xe1, 0x71,
+    0xb0, 0xc6, 0x2b, 0x76, 0x0e, 0xde, 0x23, 0xc1,
+    0x2a, 0xd9, 0x2b, 0x98, 0x08, 0x84, 0xc6, 0x41,
+    0xf5, 0xa8, 0xfa, 0xc2, 0x6b, 0xda, 0xd4, 0xa0,
+    0x33, 0x81, 0xa2, 0x2f, 0xe1, 0xb7, 0x54, 0x88,
+    0x50, 0x94, 0xc8, 0x25, 0x06, 0xd4, 0x01, 0x9a,
+    0x53, 0x5a, 0x28, 0x6a, 0xfe, 0xb2, 0x71, 0xbb,
+    0x9b, 0xa5, 0x92, 0xde, 0x18, 0xdc, 0xf6, 0x00,
+    0xc2, 0xae, 0xea, 0xe5, 0x6e, 0x02, 0xf7, 0xcf,
+    0x79, 0xfc, 0x14, 0xcf, 0x3b, 0xdc, 0x7c, 0xd8,
+    0x4f, 0xeb, 0xbb, 0xf9, 0x50, 0xca, 0x90, 0x30,
+    0x4b, 0x22, 0x19, 0xa7, 0xaa, 0x06, 0x3a, 0xef,
+    0xa2, 0xc3, 0xc1, 0x98, 0x0e, 0x56, 0x0c, 0xd6,
+    0x4a, 0xfe, 0x77, 0x95, 0x85, 0xb6, 0x10, 0x76,
+    0x57, 0xb9, 0x57, 0x85, 0x7e, 0xfd, 0xe6, 0x01,
+    0x09, 0x88, 0xab, 0x7d, 0xe4, 0x17, 0xfc, 0x88,
+    0xd8, 0xf3, 0x84, 0xc4, 0xe6, 0xe7, 0x2c, 0x3f,
+    0x94, 0x3e, 0x0c, 0x31, 0xc0, 0xc4, 0xa5, 0xcc,
+    0x36, 0xf8, 0x79, 0xd8, 0xa3, 0xac, 0x9d, 0x7d,
+    0x59, 0x86, 0x0e, 0xaa, 0xda, 0x6b, 0x83, 0xbb};
+
+static const unsigned char rsaModulusN_4096[] = {	
+        0xB1, 0x11, 0x3F, 0x37, 0xE3, 0x57, 0x7A, 0x0E, 
+        0xFE, 0xC4, 0xEF, 0x49, 0x3C, 0x31, 0x5C, 0x49, 
+        0x1E, 0xF0, 0x7E, 0x45, 0x01, 0x12, 0x85, 0xE1, 
+        0xB3, 0xD3, 0xC0, 0xD8, 0x7E, 0xF5, 0x0E, 0xF8, 
+        0x24, 0x52, 0x74, 0x58, 0x1C, 0x84, 0x7E, 0xE9, 
+        0xD9, 0xA4, 0xE2, 0x0B, 0xDA, 0x95, 0x15, 0x45, 
+        0x0B, 0x3A, 0xA2, 0x84, 0x40, 0x58, 0x1D, 0x33, 
+        0x04, 0xBA, 0x68, 0xA3, 0x4C, 0x67, 0x6A, 0x96, 
+        0x94, 0xF6, 0xA7, 0x30, 0xCB, 0xD3, 0x90, 0x6F, 
+        0xA9, 0x6B, 0x70, 0x8A, 0xB1, 0xC0, 0xC8, 0x15, 
+        0x84, 0xE1, 0x49, 0xEC, 0xC3, 0xA8, 0x56, 0x70, 
+        0xD6, 0xCA, 0xE4, 0x5A, 0x32, 0x1F, 0x7B, 0x74, 
+        0x67, 0xFB, 0x78, 0x0B, 0x7D, 0x65, 0x3E, 0xAD, 
+        0x74, 0xCF, 0x4D, 0x47, 0x4D, 0xAE, 0x97, 0x31, 
+        0x64, 0xC4, 0x9D, 0x64, 0x4C, 0x31, 0xB8, 0x8D, 
+        0xED, 0xFB, 0x02, 0x93, 0x67, 0xC6, 0xEC, 0xDF, 
+        0x28, 0xD9, 0x38, 0xAB, 0x39, 0xC2, 0xF6, 0x82, 
+        0x8F, 0x70, 0xF6, 0x1F, 0x2D, 0x75, 0x8D, 0x3D, 
+        0x57, 0xC8, 0xF1, 0xA1, 0xAE, 0x9E, 0x52, 0xF0, 
+        0x1C, 0x20, 0x66, 0x71, 0xC5, 0x12, 0x64, 0x0F, 
+        0x45, 0x67, 0x06, 0x40, 0xD3, 0x06, 0xF0, 0x4D, 
+        0xFF, 0x91, 0x8C, 0x5E, 0x41, 0x65, 0x66, 0xA4, 
+        0xC7, 0xFC, 0x3E, 0x65, 0x3C, 0xC3, 0x75, 0x7B, 
+        0xF1, 0x2C, 0xF4, 0x08, 0xA8, 0x10, 0x83, 0x7B, 
+        0xFB, 0xDC, 0x2B, 0xF2, 0x36, 0xCE, 0x2C, 0x6D, 
+        0x69, 0xAF, 0x72, 0xB8, 0xF6, 0x79, 0x04, 0x2B, 
+        0x6A, 0xA0, 0x58, 0x6F, 0xD4, 0xF6, 0x3E, 0xF4, 
+        0x8E, 0xEE, 0xB1, 0x01, 0x51, 0x9D, 0xC2, 0x31, 
+        0x80, 0x26, 0xB8, 0xBE, 0xC0, 0x02, 0xD9, 0xAB, 
+        0x46, 0x0F, 0x63, 0x8D, 0xBB, 0x2A, 0x79, 0xE3, 
+        0x34, 0xF9, 0x9C, 0xF8, 0xC4, 0x22, 0x6B, 0xD5, 
+        0x0C, 0x2E, 0x65, 0x13, 0x5A, 0x8D, 0xBE, 0x84, 
+        0xAB, 0x29, 0x88, 0xE2, 0xD5, 0x5C, 0x4C, 0x04, 
+        0xCF, 0x27, 0x39, 0x51, 0x04, 0x02, 0x8C, 0x2C, 
+        0xE3, 0x1F, 0x03, 0x53, 0x62, 0x94, 0x1F, 0xD9, 
+        0x2A, 0x1B, 0xB5, 0x09, 0x2C, 0x3A, 0x14, 0xD2, 
+        0xC3, 0xFD, 0x04, 0x2E, 0x47, 0xEC, 0x98, 0x49, 
+        0x31, 0xD8, 0x35, 0x8E, 0x78, 0x14, 0x67, 0x73, 
+        0xD9, 0x3F, 0xBC, 0xF3, 0xE3, 0x66, 0x74, 0x8D, 
+        0xE5, 0x31, 0x9A, 0x27, 0x23, 0x72, 0x2C, 0xF5, 
+        0x48, 0xDC, 0x56, 0x16, 0x22, 0x8F, 0xE6, 0x78, 
+        0xE3, 0x7B, 0x22, 0xDD, 0x2A, 0xCC, 0x0A, 0xDC, 
+        0xC0, 0xF4, 0x00, 0x67, 0x8F, 0xBD, 0x95, 0x90, 
+        0x6A, 0x1D, 0xC7, 0x90, 0x12, 0x08, 0xAB, 0xF2, 
+        0x51, 0x41, 0xEA, 0xF6, 0xAE, 0x04, 0x5F, 0x47, 
+        0x05, 0xA5, 0xFC, 0x5B, 0x81, 0x58, 0x02, 0x8C, 
+        0xF6, 0xDC, 0x06, 0x35, 0xDB, 0x2D, 0x3B, 0xFA, 
+        0xAF, 0xF5, 0x3B, 0x29, 0x7D, 0xCF, 0x64, 0x03, 
+        0x37, 0x15, 0xDB, 0xC3, 0xC1, 0x2E, 0x84, 0x90, 
+        0x7E, 0x9F, 0x51, 0xC1, 0x47, 0x9E, 0x14, 0x43, 
+        0x70, 0xC6, 0xE7, 0xD2, 0xFB, 0x91, 0x7E, 0x16, 
+        0xD2, 0x82, 0xE0, 0x05, 0x1A, 0xAC, 0x2F, 0xF8, 
+        0xF6, 0xFB, 0x00, 0xDA, 0xB0, 0x9E, 0x99, 0xB4, 
+        0x68, 0x70, 0xAF, 0x90, 0x3F, 0xC6, 0x84, 0x44, 
+        0xDB, 0x6D, 0x0F, 0x9C, 0xE5, 0x54, 0x1B, 0x41, 
+        0x4E, 0x32, 0xB0, 0xE2, 0xCE, 0x68, 0x8E, 0x39, 
+        0x88, 0x01, 0x43, 0x4F, 0x21, 0xE3, 0xC7, 0xB0, 
+        0xEF, 0x52, 0x67, 0x54, 0x0F, 0x00, 0x80, 0x40, 
+        0xBF, 0x0F, 0xFF, 0xFC, 0x93, 0xCF, 0x36, 0x2D, 
+        0x3E, 0x3F, 0xFC, 0x2D, 0xBC, 0x53, 0x50, 0x60, 
+        0x4A, 0xC9, 0x3A, 0x78, 0x6A, 0x5E, 0xA7, 0x39, 
+        0x91, 0xB3, 0x0E, 0x5F, 0x9D, 0x44, 0xBA, 0x47, 
+        0x00, 0x5E, 0x5F, 0x85, 0x48, 0x82, 0xC3, 0x26, 
+        0x1C, 0x6E, 0x9A, 0xB8, 0x55, 0x53, 0xBD, 0x3D};	
+
+static unsigned char expectedPtext[] = "\x54\x85\x9b\x34\x2c\x49\xea\x2a\x12\xab\x12\x5c\xa2\x12\xbb\xaf";
+	
+	
+/******************************************************************************
+* function:
+*   run_rsa (int count,
+*               ENGINE *e
+*               int print_output, 
+*               int verify, 
+*               int len,
+*               int sign_only, 
+*               int verify_only)
+*
+* @param count [IN] - number of iteration count
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex out flag
+* @param verfiy [IN] - verify flag
+* @param Len [IN] - rsa mod size
+* @param sign_only [IN] - RSA signature only flag
+* @param verify_only [IN] - RSA verify only flag
+*
+* description:
+*   the test application for RSA sign and verify using QAT engine.
+*   The OpenSSL corresponding RSA_private_encrypt() and RSA_public_decrypt() functions are used
+*   in this application.
+*   The values of RSA key structures are passed from Intel API RSA test vector.
+******************************************************************************/
+void run_rsa(int count, ENGINE * e, int print_output, int verify, int len,
+             int sign_only, int verify_only, int encrypt_only, int decrypt_only)
+{
+
+    int i = 0;
+    int sigLen = 0;
+    int verLen = 0;
+
+    RSA *key = NULL;
+    unsigned char *sig = OPENSSL_malloc(RSA_SIZE);
+    unsigned char verMsg[RSA_SIZE];
+    unsigned char *HashData = OPENSSL_malloc(HASH_DATA_SIZE);
+	unsigned char *ctext = NULL ;
+	unsigned char *ptext = NULL ;
+	int plen = 0;
+	int expectedPlen = 0;
+	int clen = 0;
+
+	expectedPlen = sizeof(expectedPtext) - 1;
+
+    if (HashData == NULL)
+    {
+        printf("HashData Initial malloc failed ! \n");
+        exit(EXIT_FAILURE);
+    }
+
+    /* setup input hash message */
+    for (i = 0; i < HASH_DATA_SIZE; i++)
+        HashData[i] = i % 16;
+	
+    /* setup new RSA key */
+    key = RSA_new();
+
+    /* initialise RSA key compoents by copy intel testing vector to RSA key
+       structure */
+    /* pass input len to support RSA module size */ 	
+    if (len <= 1024)
+    {
+    /* bignumber format needed for RSA sturcture */
+        DEBUG("\n RSA module size 1024 \n");
+    	key->n = BN_bin2bn(rsaModulusN_1024, sizeof(rsaModulusN_1024), key->n);
+    	key->e = BN_bin2bn(rsaPublicExponentE_1024, sizeof(rsaPublicExponentE_1024),
+                  key->e);
+    	key->d = BN_bin2bn(rsaPrivateExponentD_1024, sizeof(rsaPrivateExponentD_1024),
+                  key->d);
+    	key->p = BN_bin2bn(rsaPrimeP_1024_KeyPair, sizeof(rsaPrimeP_1024_KeyPair),
+                  key->p);
+    	key->q = BN_bin2bn(rsaPrimeQ_1024_KeyPair, sizeof(rsaPrimeQ_1024_KeyPair),
+                  key->q);
+    	key->dmp1 = BN_bin2bn(rsaCrtExpDp_1024_KeyPair, sizeof(rsaCrtExpDp_1024_KeyPair),
+                  key->dmp1);
+    	key->dmq1 = BN_bin2bn(rsaCrtExpDq_1024_KeyPair, sizeof(rsaCrtExpDq_1024_KeyPair),
+                  key->dmq1);
+    	key->iqmp = BN_bin2bn(rsaCrtCoefQInv_1024_KeyPair,
+                  sizeof(rsaCrtCoefQInv_1024_KeyPair), key->iqmp);
+    }
+
+    if (len > 1024 && len <= 2048)
+    {
+
+    /* bignumber format needed for RSA sturcture */
+        DEBUG("\n RSA module size 2048 \n");
+    	key->n = BN_bin2bn(rsaModulusN_2048, sizeof(rsaModulusN_2048), key->n);
+    	key->e = BN_bin2bn(rsaPublicExponentE_2048, sizeof(rsaPublicExponentE_2048),
+                  key->e);
+    	key->d = BN_bin2bn(rsaPrivateExponentD_2048, sizeof(rsaPrivateExponentD_2048),
+                  key->d);
+    	key->p = BN_bin2bn(rsaPrimeP_2048_KeyPair, sizeof(rsaPrimeP_2048_KeyPair),
+                  key->p);
+    	key->q = BN_bin2bn(rsaPrimeQ_2048_KeyPair, sizeof(rsaPrimeQ_2048_KeyPair),
+                  key->q);
+    	key->dmp1 = BN_bin2bn(rsaCrtExpDp_2048_KeyPair, sizeof(rsaCrtExpDp_2048_KeyPair),
+                  key->dmp1);
+    	key->dmq1 = BN_bin2bn(rsaCrtExpDq_2048_KeyPair, sizeof(rsaCrtExpDq_2048_KeyPair),
+                  key->dmq1);
+    	key->iqmp = BN_bin2bn(rsaCrtCoefQInv_2048_KeyPair,
+                  sizeof(rsaCrtCoefQInv_2048_KeyPair), key->iqmp);
+    }
+
+    if (len > 2048)
+    {
+    /* bignumber format needed for RSA sturcture */
+        DEBUG("\n RSA module size 4096 \n");
+    	key->n = BN_bin2bn(rsaModulusN_4096, sizeof(rsaModulusN_4096), key->n);
+    	key->e = BN_bin2bn(rsaPublicExponentE_4096, sizeof(rsaPublicExponentE_4096),
+                  key->e);
+    	key->d = BN_bin2bn(rsaPrivateExponentD_4096, sizeof(rsaPrivateExponentD_4096),
+                  key->d);
+    	key->p = BN_bin2bn(rsaPrimeP_4096_KeyPair, sizeof(rsaPrimeP_4096_KeyPair),
+                  key->p);
+    	key->q = BN_bin2bn(rsaPrimeQ_4096_KeyPair, sizeof(rsaPrimeQ_4096_KeyPair),
+                  key->q);
+    	key->dmp1 = BN_bin2bn(rsaCrtExpDp_4096_KeyPair, sizeof(rsaCrtExpDp_4096_KeyPair),
+                  key->dmp1);
+    	key->dmq1 = BN_bin2bn(rsaCrtExpDq_4096_KeyPair, sizeof(rsaCrtExpDq_4096_KeyPair),
+                  key->dmq1);
+    	key->iqmp = BN_bin2bn(rsaCrtCoefQInv_4096_KeyPair,
+                  sizeof(rsaCrtCoefQInv_4096_KeyPair), key->iqmp);
+    }
+	
+	/* the op buffer for pub enc needs to be the pub key size*/
+	ctext = OPENSSL_malloc(RSA_size(key));
+	ptext = OPENSSL_malloc(RSA_size(key));
+
+    for (i = 0; i < count; i++)
+    {
+
+		/*For functional tests we need to run verify anyway*/
+        if (!i || sign_only)
+        {
+            DEBUG("\n----- RSA Sign   ----- \n\n");
+
+            if (print_output)
+            {
+                tests_hexdump("Hashdata:", HashData, HASH_DATA_SIZE);
+            }
+
+            /* the RSA_private_encrypt() function return the length of
+               signature */
+            /* a signature file contains all 0xFF will be returned if
+               RSA_private_encrypt() failed */
+            sigLen = RSA_private_encrypt(HASH_DATA_SIZE,   /* length in bytes of input file */
+                                         HashData,  /* input data pointer */
+                                         sig,   /* output signature pointer */
+                                         key,   /* RSA key structure */
+                                         RSA_PKCS1_PADDING  /* padding format */
+                );
+            if (print_output)
+            {
+                tests_hexdump("Signature:", sig, sigLen);
+            }
+        }
+
+		/*Sign*/
+        if (verify_only)
+        {
+            DEBUG("\n----- RSA Verify   ----- \n\n");
+
+            if (print_output)
+            {
+                tests_hexdump("Signature:", sig, sigLen);
+            }
+
+            /* RSA_public_decryt() returns the length of verified message */
+            /* a verified file contains all 0xFF will be returned if
+               RSA_private_encrypt() failed */
+            verLen = RSA_public_decrypt(sigLen, /* length in bytes of input signature */
+                                        sig,    /* input signature */
+                                        verMsg, /* output verify message pointer */
+                                        key,    /* RSA key structure */
+                                        RSA_PKCS1_PADDING   /* padding format */
+                );
+            if (print_output)
+            {
+                tests_hexdump("Verify:", verMsg, verLen);
+            }
+
+			/* Compare and verify the signed and verified message */
+			if (verify)
+			{
+				if (memcmp(verMsg, HashData, verLen))
+				{
+					printf("# FAIL verify for RSA.\n");
+					tests_hexdump("Verified actual:", verMsg, verLen);
+					tests_hexdump("Signed expected:", HashData, HASH_DATA_SIZE);
+
+				}
+				else
+				{
+					printf("# PASS verify for RSA.\n");
+				}
+
+			}
+        }
+
+		/*For functional tests we need to run encrypt anyway*/
+        if (!i || encrypt_only)
+        {
+            DEBUG("\n----- RSA Encrypt   ----- \n\n");
+
+            if (print_output)
+            {
+                tests_hexdump("Plain text:", expectedPtext, expectedPlen);
+            }
+			clen = RSA_public_encrypt(expectedPlen,   /* length in bytes of input file */
+										 expectedPtext,  /* input data pointer */
+										 ctext,   /* output ciphertext pointer */
+										 key,   /* RSA key structure */
+										 RSA_PKCS1_PADDING  /* padding format */
+				);
+            if (print_output)
+            {
+                tests_hexdump("Cipher text:", ctext, clen);
+            }
+
+		}
+
+        if (decrypt_only)
+        {
+            DEBUG("\n----- RSA Decrypt   ----- \n\n");
+
+            if (print_output)
+            {
+                tests_hexdump("Cipher text:", ctext, clen);
+            }
+			plen = RSA_private_decrypt(clen,   /* length in bytes of input file */
+										 ctext,  /* input data pointer */
+										 ptext,   /* output ciphertext pointer */
+										 key,   /* RSA key structure */
+										 RSA_PKCS1_PADDING  /* padding format */
+				);
+            if (print_output)
+            {
+                tests_hexdump("Plain text:", ptext, plen);
+            }
+
+			/* Compare and verify the encrypted and decrypted message */
+			if (verify)
+			{
+				//printf("plen:%d, clen:%d, expectedPlen:%d \n", plen,clen,expectedPlen);
+
+				if (memcmp(ptext, expectedPtext, plen))
+				{
+					printf("# FAIL decrypt for RSA.\n");
+					tests_hexdump("Actual plain text:", expectedPtext, expectedPlen);
+					tests_hexdump("Decrypted plain text:", ptext, plen);
+
+				}
+				else
+				{
+					printf("# PASS decrypt for RSA.\n");
+				}
+			}
+		}
+
+    }
+
+    OPENSSL_free(sig);
+    OPENSSL_free(HashData);
+    RSA_free(key);
+
+}
+
+/******************************************************************************
+* function:
+*      tests_run_rsa (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_rsa_sign(int count, int size, ENGINE * e, int print_output,
+                   int verify)
+{
+							/*sign, verify, encrypt, decrypt*/
+    run_rsa(count, e, print_output, verify, size, 1, 0, 0, 0);
+}
+
+void
+tests_run_rsa_verify(int count, int size, ENGINE * e, int print_output,
+                     int verify)
+{
+							/*sign, verify, encrypt, decrypt*/
+    run_rsa(count, e, print_output, verify, size, 0, 1, 0, 0);
+}
+
+void
+tests_run_rsa_encrypt(int count, int size, ENGINE * e, int print_output,
+                     int verify)
+{
+							/*sign, verify, encrypt, decrypt*/
+    run_rsa(count, e, print_output, verify, size, 0, 0, 1, 0);
+}
+
+void
+tests_run_rsa_decrypt(int count, int size, ENGINE * e, int print_output,
+                     int verify)
+{
+							/*sign, verify, encrypt, decrypt*/
+    run_rsa(count, e, print_output, verify, size, 0, 0, 0, 1);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_rc4.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_rc4.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,331 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/rc4.h>
+#include <openssl/engine.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+/******************************************************************************
+* function:
+*         run_rc4 (int count,
+*                  ENGINE *e
+*                  int print_output
+*                  int verify
+*                  int len)
+*
+* @param count        [IN] - number of iterations
+* @param e            [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify       [IN] - verify flag
+* @param len          [IN] - the length of input message
+*
+* description:
+*   This function is designed to test the RC4 cipher during encryption and
+*   decryption using the QAT engine.
+*
+*   The higher level EVP interface wrapper functions EVP_EncryptInit_ex(),
+*   EVP_EncryptUpdate() and EVP_EncryptFinal_ex() are used for the cipher
+*   routines inside of test application.
+*
+******************************************************************************/
+static void
+run_rc4(int count, ENGINE * e, int print_output, int verify, int len)
+{
+    int i = 0;
+    int ret = 0;
+    int cipherLen = 0;
+    int update_len = 0;
+    int DoutLen = 0;
+    int DinLen = 0;
+    EVP_CIPHER_CTX *ctx = NULL;
+    EVP_CIPHER_CTX *dctx = NULL;
+
+    unsigned char *input = OPENSSL_malloc(len);
+    unsigned char *outcipher = OPENSSL_malloc(len);
+    unsigned char *Doutput = OPENSSL_malloc(len);
+    unsigned char *incipher = outcipher;
+
+    /* 16 bytes/128bit key. */
+    const unsigned char key[] = {
+        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x70, 0x71,
+        0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+    };
+
+    if (outcipher == NULL || Doutput == NULL)
+    {
+        printf("[%s] --- Initial malloc failed ! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* Setup input plaintext */
+    for (i = 0; i < len; i++)
+        input[i] = i % 16;
+
+    /* initialise ctx for encryption */
+    ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for ctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(ctx);
+
+    DEBUG("\n----- Encrypt RC4 cipher ----- \n\n");
+
+    if (print_output)
+        tests_hexdump("RC4 input msg:", input, len);
+
+    ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_rc4(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             NULL   /* IV not used for RC4 */
+        );
+
+    if (ret != 1)
+    {
+        printf("[%s] --- EVP_EncryptInit_ex(, ret = %d!\n", __func__, ret);
+        goto err;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_EncryptUpdate(ctx,    /* EVP_CIPHER_CTX */
+                                outcipher,  /* Output cipher pointer */
+                                &cipherLen, /* Output cipher length pointer */
+                                input,  /* Input text */
+                                len /* Input text length */
+            );
+
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_EncryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    DEBUG("Textlen   is %d \n", len);
+    DEBUG("cipherLen is %d \n", cipherLen);
+    DEBUG("Calling EVP_CipherFinal! \n");
+
+    ret = EVP_EncryptFinal_ex(ctx,  /* EVP_CIPHER_CTX */
+                              outcipher,    /* Output buffer */
+                              &update_len   /* Number of bytes of output */
+        );
+
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in evp_EncryptFinal, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    if (print_output)
+    {
+        tests_hexdump("RC4 Ciphertext:", outcipher, cipherLen);
+        tests_hexdump("RC4 Key:", key, sizeof(key));
+    }
+
+    EVP_CIPHER_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+    ctx = NULL;
+
+        /*---------- Decryption ----------*/
+
+    /* Initialise ctx for decryption */
+    dctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (dctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for dctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(dctx);
+
+    /* REset the update_len value for decryption */
+    update_len = 0;
+
+    /* Input length should same as output cipher length from encryption */
+    DinLen = cipherLen;
+
+    ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_rc4(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             NULL   /* IV not used for RC4 */
+        );
+
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_DecryptUpdate(dctx,   /* EVP_CIPHER_CTX */
+                                Doutput,    /* Output text pointer */
+                                &DoutLen,   /* Output text length pointer */
+                                incipher,   /* Input cipher for decryption */
+                                DinLen  /* Input cipher length */
+            );
+
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_DecryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    DEBUG("DoutLen is %d \n", DoutLen);
+
+    ret = EVP_DecryptFinal_ex(dctx, /* EVP_CIPHER_CTX */
+                              Doutput,  /* Output buffer */
+                              &update_len   /* Number of bytes of output */
+        );
+
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptFinal, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    if (print_output)
+        tests_hexdump("RC4 Decrypted msg:", Doutput, DoutLen);
+
+    /* Compare and verify the decrypt and encrypt message */
+    if (verify)
+    {
+        if (memcmp(Doutput, input, len))
+        {
+            printf("# FAIL verify for RC4.\n");
+            tests_hexdump("RC4 actual  :", Doutput, DoutLen);
+            tests_hexdump("RC4 expected:", input, len);
+        }
+        else
+        {
+            printf("# PASS verify for RC4.\n");
+        }
+    }
+
+    EVP_CIPHER_CTX_cleanup(dctx);
+    OPENSSL_free(dctx);
+    dctx = NULL;
+
+    if (input)
+        OPENSSL_free(input);
+    if (outcipher)
+        OPENSSL_free(outcipher);
+    if (Doutput)
+        OPENSSL_free(Doutput);
+    return;
+
+  err:
+    if (ctx != NULL)
+    {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        OPENSSL_free(ctx);
+    }
+    if (dctx != NULL) ;
+    {
+        EVP_CIPHER_CTX_cleanup(dctx);
+        OPENSSL_free(dctx);
+    }
+    exit(EXIT_FAILURE);
+}
+
+/******************************************************************************
+* function:
+*      tests_run_rc4 (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_rc4(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_rc4(count, e, print_output, verify, size);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_sha512.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_sha512.c	2022-05-09 13:48:33.648535544 -0700
@@ -0,0 +1,166 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+/******************************************************************************
+* function:
+*   tests_run_sha512_msg (int count,
+*                         int size, 
+*                         ENGINE *e
+*                         int print_output,
+*                         int verify)
+*
+* @param count        [IN] - number of iterations
+* @param size         [IN] - input data size 
+* @param e            [IN] - OpenSSL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify       [IN] - verify flag
+*
+* Description:
+*   This function is designed to test the QAT engine with variable message sizes
+*   using the SHA512 algorithm. The higher level EVP interface function EVP_Digest()
+*   is used inside of test application.
+*   This is a boundary test, the application should return the expected digest hash value.
+*   In verify mode an input size of 1024 bytes is used to generate a comparison digest.
+******************************************************************************/
+void tests_run_sha512_msg(int count, int size, ENGINE * e, int print_output,
+                          int verify)
+{
+    int i = 0;
+    int inLen = size;
+    int ret = 0;
+
+    /* Use default input size in verify mode. */
+    if (verify)
+        inLen = 1024;
+
+    unsigned char md[SHA512_DIGEST_LENGTH];
+    unsigned char *inData = OPENSSL_malloc(inLen);
+
+    unsigned char expected[] = {
+        0xDC, 0x71, 0xA7, 0xA5, 0x44, 0x38, 0xA3, 0xAF,
+        0x5D, 0x2C, 0x6A, 0x56, 0xD8, 0xB1, 0x22, 0xD5,
+        0xD5, 0xC5, 0xF8, 0xC5, 0x8F, 0x0D, 0x9C, 0x1D,
+        0x7D, 0x31, 0xCF, 0x11, 0x9A, 0x70, 0x22, 0x77,
+        0xCD, 0xEE, 0x88, 0xE8, 0xB8, 0xFF, 0xBD, 0x7E,
+        0xCA, 0xBE, 0x44, 0x73, 0x90, 0xF1, 0xDA, 0x1E,
+        0xBC, 0x22, 0xEA, 0x22, 0xF8, 0x01, 0x08, 0xB7,
+        0xB5, 0x22, 0xF8, 0x01, 0x55, 0xF1, 0xDD, 0xE6,
+    };
+
+    if (inData == NULL)
+    {
+        printf("*** [%s] --- inData malloc failed! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* Setup the input and output data. */
+    memset(inData, 0xaa, inLen);
+    memset(md, 0x00, SHA512_DIGEST_LENGTH);
+
+    for (i = 0; i < count; i++)
+    {
+        DEBUG("\n----- SHA512 digest msg ----- \n\n");
+
+        ret = EVP_Digest(inData,    /* Input data pointer.  */
+                         inLen, /* Input data length.  */
+                         md,    /* Output hash pointer.  */
+                         NULL, EVP_sha512(),    /* Hash algorithm indicator. */
+                         e      /* Engine indicator.  */
+            );
+
+        if (ret != 1 || verify)
+        {
+            /* Compare the digest results with the expected results. */
+            if (memcmp(md, expected, SHA512_DIGEST_LENGTH))
+            {
+                printf("# FAIL verify for SHA512.\n");
+
+                tests_hexdump("SHA512 actual  :", md, SHA512_DIGEST_LENGTH);
+                tests_hexdump("SHA512 expected:", expected,
+                              SHA512_DIGEST_LENGTH);
+            }
+            else
+            {
+                printf("# PASS verify for SHA512.\n");
+            }
+        }
+
+        if (print_output)
+            tests_hexdump("SHA512 digest text:", md, SHA512_DIGEST_LENGTH);
+    }
+
+    if (inData)
+        OPENSSL_free(inData);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_des.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_des.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,336 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+#define DES_BLOCKSIZE 8
+
+/******************************************************************************
+* function:
+*   run_des (int count,
+*                  ENGINE *e
+*                  int print_output
+*                  int verify
+*                  int len)
+*
+* @param count [IN] - number of iterations
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+* @param len [IN] - the length of input message
+*
+* description:
+*   The function is design to test  DES_CBC cipher encryption and decryption using QAT engine.
+*   The higher level EVP interface function EVP_EncryptInit_ex(), EVP_EncryptUpdate()
+*   and EVP_EncryptFinal_ex() are called for encryption  routines inside of test application.
+*   EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
+*   corresponding EVP decryption routines.
+*
+******************************************************************************/
+
+void run_des(int count, ENGINE * e, int print_output, int verify, int len)
+{
+    int i = 0;
+    int ret = 0;
+
+    unsigned char *input = OPENSSL_malloc(len);
+
+    /* extra one black size memory space needed for padding */
+    unsigned char *outcipher = OPENSSL_malloc(len + DES_BLOCKSIZE*4);
+    unsigned char *Doutput = OPENSSL_malloc(len + DES_BLOCKSIZE*4);
+    unsigned char *incipher = outcipher;
+    int cipherLen = 0;
+    int update_len = 0;
+    int DoutLen = 0;
+    int DinLen = 0;
+    EVP_CIPHER_CTX *ctx = NULL;
+    EVP_CIPHER_CTX *dctx = NULL;
+
+    /* 7 bytes key */
+    const unsigned char key[] = {
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99
+    };
+
+    /* 8 bytes initial vector */
+    const unsigned char ivec[] = {
+        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
+    };
+
+    if (input == NULL || outcipher == NULL || Doutput == NULL)
+    {
+        printf("[%s] --- Initial parameters malloc failed ! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* setup input message values */
+    for (i = 0; i < len; i++)
+        input[i] = i % 16;
+
+    /* initialise ctx for encryption */
+    ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for ctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(ctx);
+
+    DEBUG("\n----- Encrypt DES_CBC cipher ----- \n\n");
+
+    if (print_output)
+        tests_hexdump("DES input msg:", input, len);
+
+    ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_des_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex(), ret = %d!\n", __func__,
+               ret);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        exit(EXIT_FAILURE);
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+	ret = EVP_EncryptUpdate(ctx,    /* EVP_CIPHER_CTX */
+				outcipher,  /* output cipher pointer */
+				&cipherLen, /* output cipher length pointer */
+				input,  /* input text */
+				len /* input text length */
+	    );
+
+	if (ret != 1)
+	{
+	    printf("[%s] --- Error in EVP_EncryptUpdate!, ret = %d\n", __func__,
+		   ret);
+	    goto err;
+	}
+    }
+
+    ret = EVP_EncryptFinal_ex(ctx,  /* EVP_CIPHER_CTX */
+                              outcipher + cipherLen,    /* output buffer,
+                                                           update from the last 
+                                                           padding block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in evp_EncryptFinal, ret = %d\n", __func__, ret);
+        goto err;
+    }
+
+    /* update the outLen of output */
+    cipherLen += update_len;
+
+    if (print_output)
+        tests_hexdump("DES Cipher:", outcipher, cipherLen);
+
+    EVP_CIPHER_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+    ctx = NULL;
+
+        /*------------ Decrypt ----------*/
+
+    dctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (dctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for dctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(dctx);
+
+    /* set back the update_len value for decryption */
+    update_len = 0;
+    /* input length should same as output cipher length from encryption */
+    DinLen = cipherLen;
+
+    ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_des_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_DecryptUpdate(dctx,   /* EVP_CIPHER_CTX */
+                                Doutput,    /* output text pointer */
+                                &DoutLen,   /* output text length pointer */
+                                incipher,   /* input cipher for decryption */
+                                DinLen  /* input cipher length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_DecryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    ret = EVP_DecryptFinal_ex(dctx, /* EVP_CIPHER_CTX */
+                              Doutput + DoutLen,    /* output buffer, update
+                                                       from the last padding
+                                                       block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptFinal, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    /* decrypt outlen update */
+    DoutLen += update_len;
+
+    if (print_output)
+        tests_hexdump("DES Decrypted msg:", Doutput, DoutLen);
+
+    /* Compare and verify the decrypt and encrypt message. */
+    if (verify)
+    {
+        if (memcmp(Doutput, input, len))
+        {
+            printf("# FAIL verify for DES.\n");
+
+            tests_hexdump("DES actual  :", Doutput, DoutLen);
+            tests_hexdump("DES expected:", input, len);
+
+        }
+        else
+        {
+            printf("# PASS verify for DES.\n");
+        }
+    }
+
+    EVP_CIPHER_CTX_cleanup(dctx);
+    OPENSSL_free(dctx);
+    dctx = NULL;
+
+    if (input)
+        OPENSSL_free(input);
+    if (outcipher)
+        OPENSSL_free(outcipher);
+    if (Doutput)
+        OPENSSL_free(Doutput);
+    return;
+
+  err:
+    if (ctx != NULL)
+    {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        OPENSSL_free(ctx);
+    }
+    if (dctx != NULL) ;
+    {
+        EVP_CIPHER_CTX_cleanup(dctx);
+        OPENSSL_free(dctx);
+    }
+    exit(EXIT_FAILURE);
+}
+
+/******************************************************************************
+* function:
+*      tests_run_des (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_des(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_des(count, e, print_output, verify, size);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,359 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#define _GNU_SOURCE
+#define __USE_GNU
+
+#include <pthread.h>
+
+#include "tests.h"
+
+
+static __inline__ unsigned long long rdtsc(void)
+{
+    unsigned long a, d;
+
+    asm volatile ("rdtsc":"=a" (a), "=d"(d));
+
+    return (((unsigned long long)a) | (((unsigned long long)d) << 32));
+}
+
+
+/******************************************************************************
+* function:
+*   tests_initialise_engine (void)
+*
+* description:
+*   QAT engine initialise functions, load up the QAT engine and set as the default engine in OpenSSL.
+******************************************************************************/
+
+ENGINE *tests_initialise_engine(void)
+{
+    /* loading qat engine */
+    ENGINE *e;
+
+    DEBUG("Loading Qat Engine ! \n");
+    e = ENGINE_by_id("qat");
+
+    if (!e)
+    {
+        printf("Engine load failed, using default engine !\n");
+        return NULL;
+    }
+
+    if (!ENGINE_init(e))
+    {
+
+        ENGINE_free(e);
+        printf("Engine initialise failed ! using default engine\n");
+        return NULL;
+    }
+
+    /* Set QAT engine as the default engine */
+    ENGINE_set_default(e, ENGINE_METHOD_ALL);
+
+    return e;
+}
+
+/******************************************************************************
+* function:
+*   tests_cleanup_engine (ENGINE *e)
+*
+* @param e [IN] - OpenSSL engine pointer
+*
+* description:
+*   QAT engine clean up function.
+******************************************************************************/
+void tests_cleanup_engine(ENGINE * e)
+{
+    if (e)
+    {
+        /* Release the functional reference from ENGINE_init() */
+        ENGINE_finish(e);
+        /* Release the structural reference from ENGINE_by_id() */
+        ENGINE_free(e);
+    }
+    DEBUG("QAT Engine Freed ! \n");
+}
+
+/******************************************************************************
+* function:
+*   tests_hexdump (const char *title,
+          const unsigned char *s,
+                          int l)
+*
+* @param title [IN] - hex dump title
+* @param s [IN] - input pointer
+* @param l [IN] - length of input
+*
+* description:
+*   hex dump function.
+******************************************************************************/
+void tests_hexdump(const char *title, const unsigned char *s, int l)
+{
+    int i = 0;
+
+    printf("%s", title);
+
+    for (i = 0; i < l; i++)
+    {
+        if ((i % 8) == 0)
+            printf("\n        ");
+
+        printf("0x%02X, ", s[i]);
+    }
+
+    printf("\n\n");
+}
+
+/******************************************************************************
+* function:
+*   tests_run (int count,
+*              int type
+*              ENGINE *e
+*              int id
+*              int print_output
+*              int verify
+*              int performance)
+*
+* @param count        [IN] - Number of iteration count
+* @param type         [IN] - Testing type
+* @param size         [IN] - testing data size
+* @param e            [IN] - OpenSSL engine pointer
+* @param id           [IN] - Thread ID
+* @param print_output [IN] - Print hex out flag
+* @param verfiy       [IN] - Verify output flag
+* @param performance  [IN] - performance output flag
+*
+* description:
+*   select which application to run based on user input
+******************************************************************************/
+
+void tests_run(int *count, int type, int size, ENGINE * e, int id,
+               int print_output, int verify, int performance)
+{
+
+    if (performance)
+    {
+        printf("\n|-----------------------------------------------------|\n");
+        printf("|----------Thread ID %d, running in progress-----------|\n",
+               id);
+        printf("|-----------------------------------------------------|\n");
+    }
+
+    switch (type)
+    {
+
+        case TEST_HMAC:
+
+/* HMAC test application */
+            tests_run_hmac_sha256(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_MD5:
+
+/* MD5 test application */
+            tests_run_md5_msg(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_SHA1:
+
+/* SHA1 test application */
+            tests_run_sha1_msg(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_SHA256:
+
+/* SHA256 hash test application */
+            tests_run_sha256_msg(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_SHA512:
+
+/* SHA512 hash test application */
+            tests_run_sha512_msg(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_DES3:
+
+/* DES3 cipher test application, input message length 14 bytes */
+            tests_run_des3(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_DES3_ENCRYPT:
+
+/* DES3 cipher test application, input message length 14 bytes */
+            tests_run_des3_encrypt(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_DES3_DECRYPT:
+
+/* DES3 cipher test application, input message length 14 bytes */
+            tests_run_des3_decrypt(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_DES:
+
+/* DES cipher test application, input message length 14 bytes */
+            tests_run_des(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_AES256:
+
+/* AES256 cipher test application, input message length 14 bytes */
+            tests_run_aes256(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_AES192:
+
+/* AES192 cipher test application, input message length 14 bytes */
+            tests_run_aes192(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_AES128:
+
+/* AES128 cipher test application, input message len bytes */
+            tests_run_aes128(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_AES128_CBC_HMAC_SHA1:
+      	    tests_run_aes_cbc_hmac_sha1(*count, size, e, print_output, verify, TEST_AES128_CBC_HMAC_SHA1);
+	    break;
+
+        case TEST_AES256_CBC_HMAC_SHA1:
+	    tests_run_aes_cbc_hmac_sha1(*count, size, e, print_output, verify, TEST_AES256_CBC_HMAC_SHA1);
+	    break;
+
+	case TEST_RC4:
+
+/* RC4 cipher test application, input message length 14 bytes */
+            tests_run_rc4(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_DSA_SIGN:
+
+/* DSA sign & verify test application, input message length 124 bytes */
+            tests_run_dsa_sign_only(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_DSA_VERIFY:
+
+/* DSA sign & verify test application, input message length 124 bytes */
+            tests_run_dsa_sign_verify(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_RSA_SIGN:
+
+/* RSA sign & verify test application, input message length 124 bytes */
+            tests_run_rsa_sign(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_RSA_VERIFY:
+
+/* RSA sign & verify test application, input message length 124 bytes */
+            tests_run_rsa_verify(*count, size, e, print_output, verify);
+            break;
+       
+        case TEST_RSA_ENCRYPT:
+
+/* RSA encrypt test application*/
+            tests_run_rsa_encrypt(*count, size, e, print_output, verify);
+            break;
+
+        case TEST_RSA_DECRYPT:
+
+/* RSA decrypt test application */
+            tests_run_rsa_decrypt(*count, size, e, print_output, verify);
+            break;
+       
+	case TEST_DH:
+
+/* DH test application, input message length 124 bytes */
+            tests_run_dh(*count, size, e, print_output, verify);
+            break;
+
+        default:
+            fprintf(stderr, "Unknown test type %d\n", type);
+            exit(EXIT_FAILURE);
+            break;
+    }
+
+    if (performance)
+    {
+        printf("\n|-----------------------------------------------------|\n");
+        printf("|----------Thread ID %3d finished---------------------|\n",
+               id);
+        printf("|-----------------------------------------------------|\n");
+    }
+
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_hmac.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_hmac.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,155 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/hmac.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+static unsigned char key[] = 
+{
+	0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
+	0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 
+	0x0b, 0x0b, 0x0b, 0x0b, 
+};
+        
+		
+static unsigned char data[]= 
+{ 
+	0x48, 0x69, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65,
+};
+
+static unsigned char expected[] = 
+{
+	0x49, 0x2c, 0xe0, 0x20, 0xfe, 0x25, 0x34, 0xa5, 
+	0x78, 0x9d, 0xc3, 0x84, 0x88, 0x06, 0xc7, 0x8f, 
+	0x4f, 0x67, 0x11, 0x39, 0x7f, 0x08, 0xe7, 0xe7, 
+	0xa1, 0x2c, 0xa5, 0xa4, 0x48, 0x3c, 0x8a, 0xa6,
+};
+
+
+/******************************************************************************
+* function:
+*   tests_run_hmac_sha256 (int count,
+*                      int size,
+*                      ENGINE *e
+*                      int print_output,
+*                      int verify)
+*
+* @param count        [IN] - number of iterations
+* @param size         [IN] - input data size
+* @param e            [IN] - OpenSSL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify       [IN] - verify flag
+*
+* Description:
+*   This function is design to verify HMAC-SHA256 using QAT engine. 
+******************************************************************************/
+void tests_run_hmac_sha256(int count, int size, ENGINE * e, int print_output,
+                       int verify)
+{
+        unsigned char* result;
+        unsigned int result_len = 32;
+	int ret = 1;
+        int i = 0;
+        HMAC_CTX *ctx = NULL ;
+
+    	ctx = (HMAC_CTX *) OPENSSL_malloc(sizeof(HMAC_CTX));
+        result = OPENSSL_malloc(result_len);
+
+        HMAC_CTX_init(ctx);
+        HMAC_Init_ex(ctx, key, 16, EVP_sha256(), e);
+        HMAC_Update(ctx, data, 8);
+        HMAC_Final(ctx, result, &result_len);
+	HMAC_CTX_cleanup(ctx);
+
+	if(verify)
+	{
+
+        	for (i=0; i!=result_len; i++)
+        	{
+                	if (expected[i]!=result[i])
+                	{
+                        	printf("Got %02X instead of %02X at byte %d!\n", result[i], expected[i], i);
+       				ret = 0; 
+                        	break;
+                	}
+        	}
+	}
+
+	if (ret)
+                printf("# PASS verify for HMAC.\n");
+
+	
+	if(ctx)
+	    OPENSSL_free(ctx);
+	if(result)
+	    OPENSSL_free(result);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes192.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/test/tests_aes192.c	2022-05-09 13:48:33.644535706 -0700
@@ -0,0 +1,342 @@
+
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/engine.h>
+#include <openssl/des.h>
+#include <openssl/rand.h>
+
+#include "tests.h"
+
+#define AES192_BLOCKSIZE 16
+
+/******************************************************************************
+* function:
+*         run_aes192 (int count,
+*                     ENGINE *e
+*                     int print_output
+*                     int verify
+*                     int len)
+*
+* @param count [IN] - number of iterations
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+* @param len [IN] - the length of input message
+*
+* description:
+*   The function is design to test AES_192 cipher encryption and decryption using QAT engine.
+*   The higher level EVP interface function EVP_EncryptInit_ex(), EVP_EncryptUpdate()
+*   and EVP_EncryptFinal_ex() are called for encryption routines inside of test application.
+*   EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
+*   corresponding EVP decryption routines.
+*
+******************************************************************************/
+static void
+run_aes192(int count, ENGINE * e, int print_output, int verify, int len)
+{
+    int i = 0;
+    int ret = 0;
+
+    unsigned char *input = OPENSSL_malloc(len);
+
+    /* extra one black size memory space needed for padding */
+    unsigned char *outcipher = OPENSSL_malloc(len + AES192_BLOCKSIZE*4);
+    unsigned char *Doutput = OPENSSL_malloc(len + AES192_BLOCKSIZE*4);
+    unsigned char *incipher = outcipher;
+    int cipherLen = 0;
+    int update_len = 0;
+    int DoutLen = 0;
+    int DinLen = 0;
+    EVP_CIPHER_CTX *ctx = NULL;
+    EVP_CIPHER_CTX *dctx = NULL;
+
+    /* 24 bytes key */
+    const unsigned char key[] = {
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
+        0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00,
+        0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88
+    };
+
+    /* 16 bytes initial vector */
+    const unsigned char ivec[] = {
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
+        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42
+    };
+
+    if (input == NULL || outcipher == NULL || Doutput == NULL)
+    {
+        printf("[%s] --- Initial parameters malloc failed ! \n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    /* setup input message values */
+    for (i = 0; i < len; i++)
+        input[i] = i % 16;
+
+    /* initialise ctx for encryption */
+    ctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for ctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(ctx);
+
+    DEBUG("\n----- Encrypt AES_192_cbc cipher ----- \n\n");
+
+    if (print_output)
+        tests_hexdump("AES192 input msg", input, len);
+
+    ret = EVP_EncryptInit_ex(ctx,   /* EVP_CIPHER_CTX */
+                             EVP_aes_192_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- EVP_EncryptInit_ex() ret = %d!\n", __func__, ret);
+        EVP_CIPHER_CTX_cleanup(ctx);
+        exit(EXIT_FAILURE);
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_EncryptUpdate(ctx,    /* EVP_CIPHER_CTX */
+                                outcipher,  /* output cipher pointer */
+                                &cipherLen, /* output cipher length pointer */
+                                input,  /* input text */
+                                len /* input text length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_EncryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    DEBUG("outLen now is %d \n", cipherLen);
+
+    DEBUG("Calling EVP_CipherFinal! \n");
+
+    ret = EVP_EncryptFinal_ex(ctx,  /* EVP_CIPHER_CTX */
+                              outcipher + cipherLen,    /* output buffer,
+                                                           update from the last 
+                                                           padding block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in evp_EncryptFinal, ret = %d\n", __func__, ret);
+        goto err;
+    }
+
+    /* update the outLen of output */
+    cipherLen += update_len;
+
+    if (print_output)
+        tests_hexdump("AES192 Cipher", outcipher, cipherLen);
+
+    EVP_CIPHER_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+    ctx = NULL;
+
+        /*---------- Decryption ----------*/
+
+    /* initialise ctx for decryption */
+    dctx = OPENSSL_malloc(sizeof(EVP_CIPHER_CTX));
+    if (dctx == NULL)
+    {
+        printf("[%s] --- OPENSSL_malloc() failed for dctx\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+    EVP_CIPHER_CTX_init(dctx);
+
+    /* set back the update_len value for decryption */
+    update_len = 0;
+    /* input length should same as output cipher length from encryption */
+    DinLen = cipherLen;
+
+    ret = EVP_DecryptInit_ex(dctx,  /* EVP_CIPHER_CTX */
+                             EVP_aes_192_cbc(), /* EVP_CIPHER type */
+                             e, /* Engine indicator */
+                             key,   /* Key */
+                             ivec   /* initial vector */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptInit_ex, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+
+        ret = EVP_DecryptUpdate(dctx,   /* EVP_CIPHER_CTX */
+                                Doutput,    /* output text pointer */
+                                &DoutLen,   /* output text length pointer */
+                                incipher,   /* input cipher for decryption */
+                                DinLen  /* input cipher length */
+            );
+        if (ret != 1)
+        {
+            printf("[%s] --- Error in EVP_DecryptUpdate, ret = %d!\n", __func__,
+                   ret);
+            goto err;
+        }
+    }
+
+    ret = EVP_DecryptFinal_ex(dctx, /* EVP_CIPHER_CTX */
+                              Doutput + DoutLen,    /* output buffer, update
+                                                       from the last padding
+                                                       block */
+                              &update_len   /* number of bytes of output */
+        );
+    if (ret != 1)
+    {
+        printf("[%s] --- Error in EVP_DecryptFinal, ret = %d!\n", __func__,
+               ret);
+        goto err;
+    }
+
+    /* decrypt outlen update */
+    DoutLen += update_len;
+
+    if (print_output)
+        tests_hexdump("AES192 Decrypted msg", Doutput, DoutLen);
+
+    /* Compare and verify the decrypt and encrypt message. */
+    if (verify)
+    {
+        if (memcmp(Doutput, input, len))
+        {
+            printf("# FAIL verify for AES192.\n");
+
+            tests_hexdump("AES192 actual  :", Doutput, DoutLen);
+            tests_hexdump("AES192 expected:", input, len);
+
+        }
+        else
+        {
+            printf("# PASS verify for AES192.\n");
+        }
+    }
+
+    EVP_CIPHER_CTX_cleanup(dctx);
+    OPENSSL_free(dctx);
+    dctx = NULL;
+
+    if (input)
+        OPENSSL_free(input);
+    if (outcipher)
+        OPENSSL_free(outcipher);
+    if (Doutput)
+        OPENSSL_free(Doutput);
+    return;
+
+  err:
+    if (ctx != NULL)
+    {
+        EVP_CIPHER_CTX_cleanup(ctx);
+        OPENSSL_free(ctx);
+    }
+    if (dctx != NULL) ;
+    {
+        EVP_CIPHER_CTX_cleanup(dctx);
+        OPENSSL_free(dctx);
+    }
+    exit(EXIT_FAILURE);
+}
+
+/******************************************************************************
+* function:
+*   tests_run_aes192 (int count,
+*                     int size,
+*		   engine *e	
+*                     int print_output
+*                     int verify)
+*
+* @param count [IN] - number of iterations
+* @param size [IN] - the length of input message
+* @param e [IN] - OpenSLL engine pointer
+* @param print_output [IN] - print hex output flag
+* @param verify [IN] - verify flag
+*
+* description:
+*	specify a test case
+*
+******************************************************************************/
+void
+tests_run_aes192(int count, int size, ENGINE * e, int print_output, int verify)
+{
+    run_aes192(count, e, print_output, verify, size);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/Makefile.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/Makefile	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,10 @@
+
+obj-m	:= qat_mem.o
+
+
+default: clean
+	make -C $(KERNEL_SOURCE_ROOT) M=$(PWD) modules
+
+
+clean:
+	/bin/rm -rf *.ko *.o
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/qat_mem.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/qat_mem.c	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,378 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#ifdef	CONFIG_WG_KERNEL_4_14
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <linux/cdev.h>
+
+#include "qat_mem.h"
+
+#define PAGE_ORDER 5
+#define MAX_MEM_ALLOC (PAGE_SIZE * (2 << PAGE_ORDER) - sizeof(qat_mem_config))
+
+static int major;
+static unsigned long bytesToPageOrder(long int memSize);
+
+module_param(major, int, S_IRUGO);
+
+/******************************************************************************
+* function:
+*         qat_mem_read(struct file *filp, char __user *buffer, size_t length,
+*         	       loff_t *offset)
+*
+* @param filp   [IN] - unused
+* @param buffer [IN] - unused
+* @param length [IN] - unused
+* @param offset [IN] - unused
+*
+* description:
+*   Callback for read operations on the device node. We don't support them.
+*
+******************************************************************************/
+static ssize_t qat_mem_read(struct file *filp, char __user * buffer,
+                            size_t length, loff_t * offset)
+{
+    return -EIO;
+}
+
+/******************************************************************************
+* function:
+*         qat_mem_write(struct file *filp, char __user *buffer, size_t length,
+*         	       loff_t *offset)
+*
+* @param filp [IN] - unused
+* @param buff [IN] - unused
+* @param leng [IN] - unused
+* @param off  [IN] - unused
+*
+* description:
+*   Callback for write operations on the device node. We don't support them.
+*
+******************************************************************************/
+static ssize_t qat_mem_write(struct file *filp, const char __user * buff,
+                             size_t len, loff_t * off)
+{
+    return -EIO;
+}
+
+/******************************************************************************
+* function:
+*         do_ioctl(qat_mem_config *mem, unsigned int cmd, unsigned long arg)
+*
+* @param mem [IN] - pointer to mem structure
+* @param cmd [IN] - ioctl number requested 
+* @param arg [IN] - any arg needed by ioctl implementaion 
+*
+* description:
+*   Callback for ioctl operations on the device node. This is our control path.
+*   We support two ioctls, QAT_MEM_MALLOC and QAT_MEM_FREE.
+*
+******************************************************************************/
+static int do_ioctl(qat_mem_config * mem, unsigned int cmd, unsigned long arg)
+{
+
+    switch (cmd)
+    {
+        case QAT_MEM_MALLOC:
+            if (mem->length <= 0)
+            {
+                printk
+                    ("%s: invalid inputs in qat_mem_config structure!\n",
+                     __func__);
+                return -EINVAL;
+            }
+
+            if (mem->length > MAX_MEM_ALLOC)
+            {
+                printk
+                    ("%s: memory requested (%d) greater than max allocation (%ld)\n",
+                     __func__, mem->length, MAX_MEM_ALLOC);
+                return -EINVAL;
+            }
+            mem->virtualAddress =
+                (uintptr_t) __get_free_pages(GFP_KERNEL,
+                                             bytesToPageOrder(mem->length));
+            if (mem->virtualAddress == (uintptr_t) 0)
+            {
+                printk("%s: __get_free_pages() failed\n", __func__);
+                return -EINVAL;
+            }
+
+            mem->physicalAddress =
+                (uintptr_t) virt_to_phys((void *)(mem->virtualAddress));
+            mem->signature = 0xDEADBEEF;
+            memcpy((unsigned char *)mem->virtualAddress, mem, sizeof(*mem));
+
+            if (copy_to_user((void *)arg, mem, sizeof(*mem)))
+            {
+                printk("%s: copy_to_user failed\n", __func__);
+                return -EFAULT;
+            }
+            break;
+
+        case QAT_MEM_FREE:
+            if ((void *)mem->virtualAddress == NULL)
+            {
+                printk
+                    ("%s: invalid inputs in qat_mem_config structure !\n",
+                     __func__);
+                return -EINVAL;
+            }
+
+            free_pages((unsigned long)mem->virtualAddress,
+                       bytesToPageOrder(mem->length));
+            break;
+
+        default:
+            printk("%s: unknown request\n", __func__);
+            return -ENOTTY;
+    }
+
+    return 0;
+
+}
+
+/******************************************************************************
+* function:
+*         qat_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+*
+* @param file [IN] - unused
+* @param cmd  [IN] - ioctl number requested
+* @param arg  [IN] - any arg needed by the ioctl implementation
+*
+* description:
+*   Parameter-check the ioctl call before calling do_ioctl() to do the actual
+*   work.
+*
+* @see do_ioctl()
+*
+******************************************************************************/
+static long
+qat_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    qat_mem_config mem;
+
+    if (_IOC_SIZE(cmd) != sizeof(mem))
+    {
+        printk("%s: invalid parameter length\n", __func__);
+        return -EINVAL;
+    }
+    if (copy_from_user(&mem, (unsigned char *)arg, sizeof(mem)))
+    {
+        printk("%s: copy_from_user failed\n", __func__);
+        return -EFAULT;
+    }
+
+    return do_ioctl(&mem, cmd, arg);
+}
+
+/******************************************************************************
+* function:
+*         qat_mem_mmap(struct file *filp, struct vm_area_struct *vma)
+*
+* @param filp [IN]    - unused
+* @param vma  [INOUT] - struct containing details of the requested mmap, and
+*                       also the resulting offset
+*
+* description:
+*   Callback for mmap operations on the device node. This is identical to the
+*   /dev/kmem device on some Linux distros, but others have removed this for
+*   security reasons so we have to re-implement it.
+*
+******************************************************************************/
+static int qat_mem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    unsigned long pfn;
+    int ret;
+
+    /* Convert the vm_pgoff page frame number to an address, then a physical
+       address, then convert it back to a page frame number. The final result
+       of this is to ensure that pfn is a _physical_ page frame number */
+    pfn = __pa((u64) vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;
+    if (!pfn_valid(pfn))
+    {
+        printk("%s: invalid pfn\n", __func__);
+        return -EIO;
+    }
+    vma->vm_pgoff = pfn;
+
+    if ((ret = remap_pfn_range(vma, vma->vm_start,
+                               vma->vm_pgoff,
+                               vma->vm_end - vma->vm_start,
+                               vma->vm_page_prot)) < 0)
+    {
+        printk("%s: remap_pfn_range failed, returned %d\n", __func__, ret);
+        return ret;
+    }
+
+    return 0;
+}
+
+static struct file_operations fops = {
+    .read = qat_mem_read,
+    .write = qat_mem_write,
+    .unlocked_ioctl = qat_mem_ioctl,
+    .mmap = qat_mem_mmap,
+};
+
+/******************************************************************************
+* function:
+*         qat_mem_module_init(void)
+*
+* description:
+*   Initialise the QAT memory allocator kernel module.
+*
+******************************************************************************/
+static int __init qat_mem_module_init(void)
+{
+    int results;
+    int count = 10;
+    int cdev_minor = 0;
+    struct cdev *qat_mem_cdev;
+    dev_t dev;
+
+    dev = MKDEV(major, cdev_minor);
+
+    results = alloc_chrdev_region(&dev, cdev_minor, count, "qat_mem");
+    if (results < 0)
+    {
+        printk(KERN_WARNING "%s: can't get dynamic major number.\n", __func__);
+        goto next;
+    }
+
+    major = MAJOR(dev);
+    printk(KERN_ERR "%s: get dynamic major %d\n", __func__, major);
+
+    qat_mem_cdev = cdev_alloc();
+    kobject_set_name(&qat_mem_cdev->kobj, "qat_mem %d", major);
+    cdev_init(qat_mem_cdev, &fops);
+
+    results = cdev_add(qat_mem_cdev, dev, major);
+
+    if (results)
+        printk(KERN_WARNING "%s: qat_mem cdev add failed : %d. \n", __func__,
+               results);
+
+    return results;
+
+next:
+    results = register_chrdev(0, "qat_mem", &fops);
+    if (results < 0)
+    {
+        printk("Can't get major: %d\n", results);
+        return results;
+    }
+    printk("Assign major: %d\n", results);
+    return 0;
+}
+
+/******************************************************************************
+* function:
+*         qat_mem_module_exit(void)
+*
+* description:
+*   Cleanup before unloading the kernel module.
+*
+******************************************************************************/
+static void __exit qat_mem_module_exit(void)
+{
+    unregister_chrdev(major, "qat_mem");
+}
+
+/******************************************************************************
+* function:
+*         bytesToPageOrder(long int memSize)
+*
+* @param memSize [IN] - number of bytes requested
+*
+* description:
+*   Return the ln2 of the number of pages needed to store memSize bytes.
+*
+******************************************************************************/
+static unsigned long bytesToPageOrder(long int memSize)
+{
+    if (memSize <= PAGE_SIZE)
+        return 0;
+    else if (memSize <= PAGE_SIZE * 1 << 1)
+        return 1;
+    else if (memSize <= PAGE_SIZE * 1 << 2)
+        return 2;
+    else if (memSize <= PAGE_SIZE * 1 << 3)
+        return 3;
+    else if (memSize <= PAGE_SIZE * 1 << 4)
+        return 4;
+    else if (memSize <= PAGE_SIZE * 1 << 5)
+        return 5;
+    else
+        return -1;
+}
+
+module_init(qat_mem_module_init);
+module_exit(qat_mem_module_exit);
+MODULE_LICENSE("GPL");
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/qat_mem.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/qat_mem.h	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,82 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#ifndef __QAT_MEM_H
+#define __QAT_MEM_H
+
+#include <asm/ioctl.h>
+
+#ifndef __KERNEL__
+#include <stdint.h>
+#endif
+
+typedef struct _qat_mem_config {
+	uint32_t signature;
+	uintptr_t virtualAddress;
+	int length;
+	uintptr_t physicalAddress;
+} qat_mem_config;
+
+#define QAT_MEM_MAGIC    0x95
+#define QAT_MEM_MALLOC  _IOWR(QAT_MEM_MAGIC, 0, qat_mem_config)
+#define QAT_MEM_FREE    _IOW(QAT_MEM_MAGIC, 2, qat_mem_config)
+
+#endif
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/qat_mem_test.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qat_mem/qat_mem_test.c	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,126 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009, 2010,2011 Intel Corporation. All rights reserved.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#define _XOPEN_SOURCE 600
+
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* Linux doesn't conform to the POSIX standard here:
+ * #include <stropts.h> */
+#include <sys/ioctl.h>
+
+#include <sys/mman.h>
+#include <unistd.h>
+#include <string.h>
+#include "qat_mem.h"
+
+#define SEG_LEN 64
+
+/******************************************************************************
+* function:
+*         main(void)
+*
+* description:
+*   Entry point.
+*
+******************************************************************************/
+int main(void)
+{
+	int qat_memfd = -1;
+	qat_mem_config qmcfg;
+	void *addr = MAP_FAILED;
+	qat_mem_config *mem_to_free;
+
+	if ((qat_memfd = open("/dev/qat_mem", O_RDWR)) == -1) {
+		perror("open qat_mem");
+		goto cleanup;
+	}
+	qmcfg.length = SEG_LEN;
+	if (ioctl(qat_memfd, QAT_MEM_MALLOC, &qmcfg) == -1) {
+		perror("ioctl QAT_MEM_MALLOC");
+		goto cleanup;
+	}
+	printf("virtualAddress after ioctl %lx\n", qmcfg.virtualAddress);
+
+	if ((addr =
+	     mmap(NULL, SEG_LEN, PROT_READ | PROT_WRITE, MAP_PRIVATE, qat_memfd,
+		  qmcfg.virtualAddress)) == MAP_FAILED) {
+		perror("mmap");
+		goto cleanup;
+	}
+	mem_to_free = addr;
+	printf("seg mapped to %p, virtualAddress in seg %lx, length %d\n", addr,
+	       mem_to_free->virtualAddress, mem_to_free->length);
+	strcpy(addr + sizeof(qat_mem_config), "Hello World!");
+	puts(addr + sizeof(qat_mem_config));
+ cleanup:
+	if (qat_memfd != -1
+	    && ioctl(qat_memfd, QAT_MEM_FREE, mem_to_free) == -1)
+		perror("ioctl QAT_MEM_FREE");
+	if (addr != MAP_FAILED && munmap(addr, SEG_LEN) == -1)
+		perror("munmap");
+	if (qat_memfd != -1 && close(qat_memfd) == -1)
+		perror("close qat_mem");
+	exit(EXIT_SUCCESS);
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qae_mem_utils.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/qae_mem_utils.c	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,613 @@
+
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qae_mem_utils.c
+ *
+ * This file provides linux kernel memory allocation for quick assist API
+ *
+ *****************************************************************************/
+
+#include "qae_mem_utils.h"
+#include "qat_mem/qat_mem.h"
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <assert.h>
+#include <string.h>
+#include <limits.h>
+#include <pthread.h>
+
+#define DEBUG(...)
+//#define DEBUG(...) printf(__VA_ARGS__)
+#define ERROR(...) printf(__VA_ARGS__)
+
+/* flag for mutex lock */
+static int inited = 0;
+
+/* qat_mem ioctl open file descriptor */
+static int qat_memfd = -1;
+
+/* Big Slab Allocator Lock */
+static pthread_mutex_t bsal = PTHREAD_MUTEX_INITIALIZER;   
+
+/*  We allocate memory in slabs consisting of a number of slots
+ *  to avoid fragmentation and also to reduce cost of allocation
+ *
+ *  There are six predefined slot sizes, 128 byte, 4096 byte,
+ *  128KB, 256KB, 4096KB and 8192KB  Slabs are 128KB in size.  
+ *  This implies the most slots that a slab can hold is 128KB/256 = 512.  
+ *  The first slot is used for meta info, so actual is 511.
+ */
+#define SLAB_SIZE 	(0x20000 - sizeof(qat_mem_config))
+
+/* slot free signature */
+#define SIG_FREE        0xF1F2F3F4
+
+/* slot allocate signatture */
+#define SIG_ALLOC       0xA1A2A3A4
+
+/* maxmium slot size */
+#define MAX_ALLOC	(SLAB_SIZE - sizeof (qae_slab))
+
+static int slot_sizes_available[] =
+{
+    0x0100,
+    0x0400,
+    0x1000,
+    0x2000,
+    0x4000,
+    0x8000
+};
+
+typedef struct _qae_slot
+{
+    struct _qae_slot *next;
+    int sig;
+    char *file;
+    int line;
+}
+qae_slot;
+
+typedef struct _qae_slab
+{
+    qat_mem_config memCfg;
+    int slot_size;
+    int sig;
+    struct _qae_slab *next_slab;
+    struct _qae_slot *next_slot;
+}
+qae_slab;
+
+qae_slab *slab_list;
+
+static void init(void);
+
+/*****************************************************************************
+ * function:
+ *         find_slab_slot(void *ptr)
+ *
+ * @param[in] ptr, pointer to a slot in a slab
+ *
+ * @description
+ * 	find the slab that contains the slot of memory ptr
+ *	retval pointer to the slab
+ *
+ *****************************************************************************/
+static qae_slab *find_slab_slot(void *ptr)
+{
+    qae_slab *slb;
+    qae_slab *result = NULL;
+
+    /* We don't need to lock around access to the list for read purposes
+       because we know new entries are always added to the head of the list,
+       and entries are only ever removed when shutting down */
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    for (slb = slab_list; slb != NULL; slb = slb->next_slab)
+    {
+        unsigned char *end = (unsigned char *)slb + SLAB_SIZE;
+
+        if (ptr >= (void *)slb && ptr < (void *)end)
+        {
+            result = slb;
+            goto exit;
+        }
+    }
+
+  exit:
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         create_slab(int size)
+ *
+ * @param[in] size, the size of the slots within the slab. Note that this is
+ *                  not the size of the slab itself
+ *
+ * @description
+ * 	create a new slab and add it to the global linked list
+ * 	retval pointer to the new slab
+ *
+ *****************************************************************************/
+static qae_slab *create_slab(int size)
+{
+    int i = 0;
+    int nslot = 0;
+    qat_mem_config qmcfg;
+    qae_slab *result = NULL;
+    qae_slab *slb = NULL;
+
+    qmcfg.length = SLAB_SIZE;
+    if (ioctl(qat_memfd, QAT_MEM_MALLOC, &qmcfg) == -1)
+    {
+        static char errmsg[LINE_MAX];
+
+        snprintf(errmsg, LINE_MAX, "ioctl QAT_MEM_MALLOC(%d)", qmcfg.length);
+        perror(errmsg);
+        goto exit;
+    }
+
+    if ((slb =
+         mmap(NULL, qmcfg.length, PROT_READ | PROT_WRITE,
+              MAP_SHARED | MAP_LOCKED, qat_memfd,
+              qmcfg.virtualAddress)) == MAP_FAILED)
+    {
+        perror("mmap");
+        goto exit;
+    }
+
+    DEBUG("%s slot size %d\n", __func__, size);
+    slb->slot_size = size;
+    slb->next_slab = slab_list;
+    slb->next_slot = NULL;
+    slb->sig = SIG_ALLOC;
+    /* Make sure update of the slab list is the last thing to be done.  This
+       means it is not necessary to lock against anyone iterating the list from 
+       the head */
+    slab_list = slb;
+
+    qae_slot *slt = NULL;
+
+    for (i = sizeof(qae_slab); SLAB_SIZE - i >= size; i += size)
+    {
+        slt = (qae_slot *) ((unsigned char *)slb + i);
+        slt->next = slb->next_slot;
+        slt->sig = SIG_FREE;
+        slt->file = NULL;
+        slt->line = 0;
+        slb->next_slot = slt;
+        nslot++;
+    }
+    result = slb;
+    DEBUG("%s slab %p last slot is %p, count is %d\n", __func__, slb, slt,
+          nslot);
+  exit:
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         alloc_from_slab(int size, const char *file, int line)
+ *
+ * @param[in] size, the size of the memory block required
+ * @param[in] file, the C source filename of the call site
+ * @param[in] line, the line number withing the C source file of the call site
+ *
+ * @description
+ *      allocate a slot of memory from some slab
+ * 	retval pointer to the allocated block
+ *
+ *****************************************************************************/
+static void *alloc_from_slab(int size, const char *file, int line)
+{
+    qae_slab *slb;
+    qae_slot *slt;
+    int slot_size;
+    void *result = NULL;
+    int rc;
+    int i;
+
+    if ((rc = pthread_mutex_lock(&bsal)) != 0)
+    {
+        fprintf(stderr, "pthread_mutex_lock: %s\n", strerror(rc));
+        return result;
+    }
+
+    if (!inited)
+        init();
+
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    size += sizeof(qae_slot);
+
+    slot_size = -1;
+    
+    for (i = 0; i < sizeof (slot_sizes_available) / sizeof (int); i++)
+    {
+        if (size < slot_sizes_available[i])
+        {
+            slot_size = slot_sizes_available[i];
+            break;
+        }
+    }
+
+    if (slot_size == -1)
+    {
+        if (size <= MAX_ALLOC)
+            slot_size = MAX_ALLOC;
+        else
+        {
+            DEBUG("%s too big %d\n", __func__, size);
+            goto exit;
+        }
+    }
+
+    for (slb = slab_list; slb != NULL; slb = slb->next_slab)
+    {
+        if (slb->slot_size == slot_size && slb->next_slot != NULL)
+            break;
+    }
+
+    if (!slb)
+        slb = create_slab(slot_size);
+
+    if (slb == NULL)
+    {
+        printf("%s error, create_slab failed\n", __func__);
+        goto exit;
+    }
+
+    if (slb->next_slot == NULL)
+    {
+        DEBUG("%s error, no slots\n", __func__);
+        goto exit;
+    }
+
+    slt = slb->next_slot;
+
+    if (slt->sig != SIG_FREE)
+    {
+        ERROR("%s error alloc slot that isn't free %p\n", __func__, slt);
+        exit(1);
+    }
+
+    slb->next_slot = slt->next;
+    memset(slt, 0xAA, slot_size);
+    slt->sig = SIG_ALLOC;
+    slt->file = strdup(file);
+    slt->line = line;
+    result = (void *)((unsigned char *)slt + sizeof(qae_slot));
+
+  exit:
+    if ((rc = pthread_mutex_unlock(&bsal)) != 0)
+        fprintf(stderr, "pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         free_to_slab(void *ptr)
+ *
+ * @param[in] ptr, pointer to the memory to be freed
+ *
+ * @description
+ *      free a slot of memory back to its slab
+ *
+ *****************************************************************************/
+static void free_to_slab(void *ptr)
+{
+    qae_slab *slb;
+    qae_slot *slt = (void *)((unsigned char *)ptr - sizeof(qae_slot));
+    int rc;
+
+    if ((rc = pthread_mutex_lock(&bsal)) != 0)
+    {
+        fprintf(stderr, "pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if (slt->sig != SIG_ALLOC)
+    {
+        ERROR("%s error free slot that isn't alloc %p\n", __func__, slt);
+        exit(1);
+    }
+
+    slb = find_slab_slot(ptr);
+
+    if (slb)
+    {
+        free(slt->file);
+        memset(slt, 0xFF, slb->slot_size);
+        slt->sig = SIG_FREE;
+        slt->file = NULL;
+        slt->line = 0;
+        slt->next = slb->next_slot;
+        slb->next_slot = slt;
+        goto exit;
+    }
+
+    ERROR ("%s error can't free %p\n", __func__, ptr);
+
+  exit:
+    if ((rc = pthread_mutex_unlock(&bsal)) != 0)
+        fprintf(stderr, "pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+/*****************************************************************************
+ * function:
+ *         slot_get_size(void *ptr)
+ *
+ * @param[in] ptr, pointer to the slot memory 
+ *
+ * @description
+ *      get the slot memory size in bytes
+ *
+ *****************************************************************************/
+static int slot_get_size(void *ptr)
+{
+    int rc;
+    int result = 0;
+
+    if ((rc = pthread_mutex_lock(&bsal)) != 0)
+    {
+        fprintf(stderr, "pthread_mutex_lock: %s\n", strerror(rc));
+        return result;
+    }
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    qae_slab *slb = find_slab_slot(ptr);
+
+    if (!slb)
+    {
+        ERROR("%s error can't find %p\n", __func__, ptr);
+        goto exit;
+    }
+    result = slb->slot_size - sizeof(qae_slot);
+
+  exit:
+    if ((rc = pthread_mutex_unlock(&bsal)) != 0)
+        fprintf(stderr, "pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         cleanup_slabs(void)
+ *
+ * @description
+ *      Free all memory managed by the slab allocator. This function is
+ *      intended to be registered as an atexit() handler.
+ *
+ *****************************************************************************/
+static void cleanup_slabs(void)
+{
+    qae_slab *slb, *s_next_slab;
+    qat_mem_config qmcfg;
+    int rc;
+
+    if ((rc = pthread_mutex_lock(&bsal)) != 0)
+    {
+        fprintf(stderr, "pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    for (slb = slab_list; slb != NULL; slb = s_next_slab)
+    {
+        qae_slot *slt = NULL;
+        int i;
+
+        for (i = sizeof(qae_slab); SLAB_SIZE - i >= slb->slot_size;
+             i += slb->slot_size)
+        {
+            slt = (qae_slot *) ((unsigned char *)slb + i);
+
+            if (slt->sig == SIG_ALLOC && slt->file != NULL && slt->line != 0)
+                DEBUG("Leak : %p %s:%d\n", slt, slt->file, slt->line);
+        }
+
+        DEBUG("%s do munmap  of %p\n", __func__, slb);
+        qmcfg = *((qat_mem_config *) slb);
+
+        /* Have to save this off before unmapping. This is why we can't have
+           slb = slb->next_slab in the for loop above. */
+        s_next_slab = slb->next_slab;
+
+        if (munmap(slb, SLAB_SIZE) == -1)
+        {
+            perror("munmap");
+            exit(EXIT_FAILURE);
+        }
+        DEBUG("%s ioctl free of %p\n", __func__, slb);
+        if (ioctl(qat_memfd, QAT_MEM_FREE, &qmcfg) == -1)
+        {
+            perror("ioctl QAT_MEM_FREE");
+            exit(EXIT_FAILURE);
+        }
+    }
+    DEBUG("%s done\n", __func__);
+
+    if ((rc = pthread_mutex_unlock(&bsal)) != 0)
+        fprintf(stderr, "pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+/******************************************************************************
+* function:
+*         init(void)
+*
+* description:
+*   Initialise the user-space part of the QAT memory allocator.
+*
+******************************************************************************/
+static void init(void)
+{
+    if ((qat_memfd = open("/dev/qat_mem", O_RDWR)) == -1)
+    {
+        perror("open qat_mem");
+        exit(EXIT_FAILURE);
+    }
+    atexit(cleanup_slabs);
+    inited = 1;
+}
+
+/******************************************************************************
+* function:
+*         qaeMemV2P(void *v)
+*
+* @param[in] v, virtual memory address pointer 
+*
+* description:
+* 	map vritual memory address to physic memory address
+*
+******************************************************************************/
+CpaPhysicalAddr qaeMemV2P(void *v)
+{
+    qae_slab *slb;
+
+    slb = find_slab_slot(v);
+
+    if (!slb)
+    {
+        printf("%s error can't find slab for %p\n", __func__, v);
+        return 0;
+    }
+
+    qat_mem_config *memCfg = (qat_mem_config *) slb;
+    ptrdiff_t offset = ((unsigned char *)v - (unsigned char *)slb);
+
+    /* Exit if the allocator signature isn't found. */
+    if (memCfg->signature != 0xDEADBEEF)
+    {
+        DEBUG
+            ("%s: virtualAddr %p pageStart %p signature %x physicalAddress %x\n",
+             __func__, v, slb, memCfg->signature,
+             (unsigned int)memCfg->physicalAddress);
+
+        ERROR("%s: Exiting due to invalid signature\n", __func__);
+        exit(EXIT_FAILURE);
+    }
+
+    if (offset >= memCfg->length)
+        DEBUG("%s: offset %d memCfg->length %d\n", __func__, (int)offset,
+              memCfg->length);
+
+    if (offset > memCfg->length)
+        exit(EXIT_FAILURE);
+
+    return (memCfg->physicalAddress) + offset;
+}
+
+/**************************************
+ * Memory functions
+ *************************************/
+
+/******************************************************************************
+* function:
+*         qaeMemAlloc(size_t memsize, , const char *file, int line)
+*
+* @param[in] memsize,  size of usable memory requested
+* @param[in] file,     the C source filename of the call site
+* @param[in] line,     the line number withing the C source file of the call site
+*
+* description:
+*   Allocate a block of pinned memory.
+*
+******************************************************************************/
+void *qaeMemAlloc(size_t memsize, const char *file, int line)
+{
+    return alloc_from_slab(memsize, file, line);
+}
+
+/******************************************************************************
+* function:
+*         qaeMemFree(void *ptr)
+*
+* @param[in] ptr, address of start of usable memory
+*
+* description:
+*   Free a block of memory previously allocated by this allocator.
+*
+******************************************************************************/
+void qaeMemFree(void *ptr)
+{
+    if(NULL != ptr) 
+        free_to_slab(ptr);
+}
+
+/******************************************************************************
+* function:
+*         qaeMemRealloc(void *ptr, size_t memsize, const char *file, int line)
+*
+* @param[in] ptr,     address of start of usable memory for old allocation
+* @param[in] memsize, size of new block required
+* @param[in] file,    the C source filename of the call site
+* @param[in] line,    the line number withing the C source file of the call site
+*
+* description:
+*   Change the size of usable memory in an allocated block. This may allocate
+*   a new block and copy the data to it.
+*
+******************************************************************************/
+void *qaeMemRealloc(void *ptr, size_t memsize, const char *file, int line)
+{
+    int copy = slot_get_size(ptr);
+    void *n = alloc_from_slab(memsize, file, line);
+
+    if (memsize < copy)
+        copy = memsize;
+    memcpy(n, ptr, copy);
+    free_to_slab(ptr);
+    return n;
+}
--- cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/e_qat.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ cavecreek-1.13.0-19/quickassist/shims/openssl/engines/qat_engine/e_qat.c	2022-05-09 13:48:33.640535868 -0700
@@ -0,0 +1,5748 @@
+
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file e_qat.c
+ *
+ * This file provides a OpenSSL engine for the  quick assist API
+ *
+ *****************************************************************************/
+
+/* macros defined to allow use of the cpu get and set affinity functions */
+#define _GNU_SOURCE
+#define __USE_GNU
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/engine.h>
+#include <openssl/obj_mac.h>
+#include <openssl/aes.h>
+#include <openssl/rc4.h>
+#include <openssl/x509.h>
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/dsa.h>
+#include <openssl/md5.h>
+#include <openssl/sha.h>
+#include <openssl/tls1.h>
+#include <pthread.h>
+#include <assert.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sched.h>
+
+#include "qae_mem_utils.h"
+#include "cpa.h"
+#include "cpa_cy_im.h"
+#include "cpa_types.h"
+#include "cpa_cy_sym.h"
+#include "cpa_cy_rsa.h"
+#include "cpa_cy_dsa.h"
+#include "cpa_cy_dh.h"
+#include "cpa_cy_ln.h"
+#include "cpa_cy_common.h"
+#include "cpa_cy_im.h"
+#include "qat_mem.h"
+#include "icp_sal_user.h"
+#include "icp_sal_poll.h"
+#include "e_qat.h"
+
+#define AES_BLOCK_SIZE      16
+#define AES_IV_LEN          16
+#define AES_KEY_SIZE_256    32
+#define AES_KEY_SIZE_192    24
+#define AES_KEY_SIZE_128    16
+#define AES_FLAGS           0
+
+#define RC4_BLOCK_SIZE      1
+#define RC4_IV_LEN          0
+#define RC4_KEY_SIZE        16
+#define RC4_FLAGS           0
+
+#define DES3_BLOCK_SIZE     8
+#define DES3_IV_LEN         8
+#define DES3_KEY_SIZE_192   24
+#define DES3_FLAGS          0
+
+#define DES_BLOCK_SIZE      8
+#define DES_IV_LEN          8
+#define DES_KEY_SIZE_56     8
+#define DES_FLAGS           0
+
+#define SHA1_SIZE           20
+#define SHA1_BLOCK_SIZE     8
+#define SHA1_FLAGS          0
+
+#define SHA256_SIZE         32
+#define SHA256_BLOCK_SIZE   32
+#define SHA256_FLAGS        0
+
+#define SHA512_SIZE         64
+#define SHA512_BLOCK_SIZE   64
+#define SHA512_FLAGS        0
+
+#define MD5_SIZE            16
+#define MD5_BLOCK_SIZE      64
+#define MD5_FLAGS           0
+
+#define CTX_NOT_CLEAN       255
+
+typedef enum _CipherType
+{
+    AES128 = 1,
+    AES192,
+    AES256,
+    RC_4,
+    DES,
+    DES3
+
+}CipherType;
+
+typedef enum _DigestType
+{
+    SHA_1 = 1,
+    SHA_256,
+    SHA_512,
+    MD_5
+
+}DigestType;
+
+#ifndef QAT_MAX_DIGEST_CHAIN_LENGTH
+#define QAT_MAX_DIGEST_CHAIN_LENGTH 1000000000
+#endif
+
+#define QAT_POLL_CORE_AFFINITY
+#define QAT_WARN
+
+//#define QAT_DEBUG
+
+#ifdef QAT_DEBUG
+#define DEBUG(...) printf(__VA_ARGS__)
+#define DUMPL(var,p,l) hexDump(__func__,var,p,l);
+#define DUMPREQ(inst, cb, opD, sess, src, dst) dumpRequest(inst, cb, opD, sess, src, dst);
+#else
+#define DEBUG(...)
+#define DUMPL(...)
+#define DUMPREQ(...)
+#endif
+
+/* warning message for qat engine and cpa function */
+#ifdef QAT_WARN
+#define WARN(...) printf (__VA_ARGS__)
+#else
+#define WARN(...)
+#endif
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE 4096
+#endif
+
+#define QAT_DEV "/dev/qat_mem"
+#define POLL_PERIOD_IN_NS 10000
+
+CpaInstanceHandle *qatInstanceHandles = NULL;
+static pthread_key_t qatInstanceForThread;
+pthread_t *icp_polling_threads;
+static int keep_polling = 1;
+Cpa16U numInstances = 0;
+int qatPerformOpRetries = 0;
+static int currInst = 0;
+
+char *ICPConfigSectionName_start = "SSL";
+
+/* Use the nanosleep version of sendpoll */
+/*#define USE_NS_SENDPOLL*/
+
+#define SAL_STOP_DELAY 1
+
+/******************************************************************************
+* function:
+*         incr_curr_inst(void)
+*
+* description:
+*   Increment the logical Cy instance number to use for the next operation.
+*
+******************************************************************************/
+static inline void incr_curr_inst(void)
+{
+    currInst = (currInst + 1) % numInstances;
+}
+
+/******************************************************************************
+* function:
+*         get_next_inst(void)
+*
+* description:
+*   Return the next instance handle to use for an operation.
+*
+******************************************************************************/
+static CpaInstanceHandle get_next_inst(void)
+{
+    CpaInstanceHandle instanceHandle;
+
+    if ((instanceHandle = pthread_getspecific(qatInstanceForThread)) == NULL)
+    {
+        instanceHandle = qatInstanceHandles[currInst];
+        incr_curr_inst();
+    }
+    return instanceHandle;
+}
+
+/******************************************************************************
+* function:
+*         qat_set_instance_for_gthread(ENGINE *e)
+*
+* @param instanceNum [IN] - logical instance number
+*
+* description:
+*   Bind the current thread to a particular logical Cy instance. Note that if
+*   instanceNum is greater than the number of configured instances, the
+*   modulus operation is used.
+*
+******************************************************************************/
+void qat_set_instance_for_thread(int instanceNum)
+{
+    int rc;
+
+    if ((rc =
+         pthread_setspecific(qatInstanceForThread,
+                             qatInstanceHandles[instanceNum %
+                                                numInstances])) != 0)
+    {
+        fprintf(stderr, "pthread_setspecific: %s\n", strerror(rc));
+        return;
+    }
+}
+
+/* Struct for tracking threaded QAT operation completion. */
+struct op_done
+{
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    int flag;
+    CpaBoolean verifyResult;
+};
+
+/* Callback to indicate QAT completion. */
+static void qat_callbackFn(void *callbackTag,
+                           CpaStatus status,
+                           const CpaCySymOp operationType,
+                           void *pOpData,
+                           CpaBufferList * pDstBuffer, CpaBoolean verifyResult);
+
+/* Callback to indicate QAT completion of RSA. */
+void qat_rsaCallbackFn(void *pCallbackTag,
+                       CpaStatus status, void *pOpData, CpaFlatBuffer * pOut);
+
+/* Qat engine id declaration */
+static const char *engine_qat_id = "qat";
+static const char *engine_qat_name =
+    "Reference implementation of QAT crypto engine";
+
+/* Common Qat engine cipher function declarations */
+static int cipher_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                     const unsigned char *iv, int enc, CipherType cipherType);
+
+static int common_cipher_cleanup(EVP_CIPHER_CTX * ctx);
+
+/* Common Qat engine digest function declarations */
+static int digest_init(EVP_MD_CTX * ctx);
+
+static int digest_update(EVP_MD_CTX * ctx, const void *data, size_t count);
+
+static int digest_final(EVP_MD_CTX * ctx, unsigned char *md);
+
+static int digest_cleanup(EVP_MD_CTX * ctx);
+
+/* Qat engine AES256 Cipher function declarations */
+static int qat_aes_256_cbc_init(EVP_CIPHER_CTX * ctx,
+                                const unsigned char *key,
+                                const unsigned char *iv, int enc);
+
+static int qat_aes_256_cbc_do_cipher(EVP_CIPHER_CTX * ctx,
+                                     unsigned char *out,
+                                     const unsigned char *in, size_t inl);
+
+/* Qat engine AES192 Cipher function declarations */
+static int qat_aes_192_cbc_init(EVP_CIPHER_CTX * ctx,
+                                const unsigned char *key,
+                                const unsigned char *iv, int enc);
+
+static int qat_aes_192_cbc_do_cipher(EVP_CIPHER_CTX * ctx,
+                                     unsigned char *out,
+                                     const unsigned char *in, size_t inl);
+
+/* Qat engine AES128 Cipher function declarations */
+static int qat_aes_128_cbc_init(EVP_CIPHER_CTX * ctx,
+                                const unsigned char *key,
+                                const unsigned char *iv, int enc);
+
+static int qat_aes_128_cbc_do_cipher(EVP_CIPHER_CTX * ctx,
+                                     unsigned char *out,
+                                     const unsigned char *in, size_t inl);
+
+/* Qat engine RC4 Cipher function declarations */
+static int qat_rc4_init(EVP_CIPHER_CTX * ctx,
+                        const unsigned char *key,
+                        const unsigned char *iv, int enc);
+
+static int qat_rc4_do_cipher(EVP_CIPHER_CTX * ctx,
+                             unsigned char *out,
+                             const unsigned char *in, size_t inl);
+
+/* Qat engine 3DES Cipher function declarations */
+static int qat_des_ede3_cbc_init(EVP_CIPHER_CTX * ctx,
+                                 const unsigned char *key,
+                                 const unsigned char *iv, int enc);
+
+static int qat_des_ede3_cbc_do_cipher(EVP_CIPHER_CTX * ctx,
+                                      unsigned char *out,
+                                      const unsigned char *in, size_t inl);
+
+/* Qat engine DES Cipher function declarations */
+static int qat_des_cbc_init(EVP_CIPHER_CTX * ctx,
+                            const unsigned char *key,
+                            const unsigned char *iv, int enc);
+
+static int qat_des_cbc_do_cipher(EVP_CIPHER_CTX * ctx,
+                                 unsigned char *out,
+                                 const unsigned char *in, size_t inl);
+
+/* Qat engine AES-SHA1 function declaration */
+static int qat_aes_cbc_hmac_sha1_init(EVP_CIPHER_CTX *ctx,
+            			      const unsigned char *inkey,
+            			      const unsigned char *iv, int enc);
+static int qat_aes_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+              				const unsigned char *in, size_t len);
+static int qat_aes_cbc_hmac_sha1_cleanup(EVP_CIPHER_CTX *ctx);
+static int qat_aes_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
+
+/* Qat engine SHA1 digest function declaration */
+static int qat_sha1_init(EVP_MD_CTX * ctx);
+static int qat_sha1_update(EVP_MD_CTX * ctx, const void *data, size_t count);
+static int qat_sha1_copy(EVP_MD_CTX * ctx_out, const EVP_MD_CTX *ctx_in);
+static int qat_sha1_final(EVP_MD_CTX * ctx, unsigned char *md);
+
+/* Qat engine SHA256 digest function declaration */
+static int qat_sha256_init(EVP_MD_CTX * ctx);
+static int qat_sha256_update(EVP_MD_CTX * ctx, const void *data, size_t count);
+static int qat_sha256_copy(EVP_MD_CTX * ctx_out, const EVP_MD_CTX *ctx_in);
+static int qat_sha256_final(EVP_MD_CTX * ctx, unsigned char *md);
+
+/* Qat engine SHA512 digest function declaration */
+static int qat_sha512_init(EVP_MD_CTX * ctx);
+static int qat_sha512_update(EVP_MD_CTX * ctx, const void *data, size_t count);
+static int qat_sha512_copy(EVP_MD_CTX * ctx_out, const EVP_MD_CTX *ctx_in);
+static int qat_sha512_final(EVP_MD_CTX * ctx, unsigned char *md);
+
+/* Qat engine MD5 digest function declaration */
+static int qat_md5_init(EVP_MD_CTX * ctx);
+static int qat_md5_update(EVP_MD_CTX * ctx, const void *data, size_t count);
+static int qat_md5_copy(EVP_MD_CTX * ctx_out, const EVP_MD_CTX *ctx_in);
+static int qat_md5_final(EVP_MD_CTX * ctx, unsigned char *md);
+/* Qat engine RSA methods declaration */
+static int qat_rsa_priv_enc(int flen, const unsigned char *from,
+                            unsigned char *to, RSA * rsa, int padding);
+static int qat_rsa_pub_dec(int flen, const unsigned char *from,
+                           unsigned char *to, RSA * rsa, int padding);
+static int qat_rsa_priv_dec(int flen, const unsigned char *from,
+                            unsigned char *to, RSA * rsa, int padding);
+static int qat_rsa_mod_exp(BIGNUM * r0, const BIGNUM * I, RSA * rsa,
+                           BN_CTX * ctx);
+static int qat_bn_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+                          const BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx);
+static int qat_rsa_pub_enc(int flen, const unsigned char *from,
+                           unsigned char *to, RSA * rsa, int padding);
+
+/* Qat engine DSA methods declaration */
+DSA_SIG *qat_dsa_do_sign(const unsigned char *dgst, int dlen, DSA * dsa);
+int qat_dsa_sign_setup(DSA * dsa, BN_CTX * ctx_in, BIGNUM ** kinvp,
+                       BIGNUM ** rp);
+static int qat_dsa_do_verify(const unsigned char *dgst, int dgst_len,
+                             DSA_SIG * sig, DSA * dsa);
+
+#if OPENSSL_VERSION_NUMBER < 0x01000000
+static int qat_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,
+		           BIGNUM *a2, BIGNUM *p2, BIGNUM *m, BN_CTX *ctx,
+                           BN_MONT_CTX *in_mont);
+#endif
+static int qat_mod_exp_dsa(DSA * dsa, BIGNUM * r, BIGNUM * a, const BIGNUM * p,
+                           const BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx);
+
+/* Qat engine DH methods declaration */
+static int qat_mod_exp_dh(const DH * dh, BIGNUM * r, const BIGNUM * a,
+                          const BIGNUM * p, const BIGNUM * m, BN_CTX * ctx,
+                          BN_MONT_CTX * m_ctx);
+int qat_dh_generate_params(DH * dh, int prime_len, int generator,
+                           BN_GENCB * cb);
+int qat_dh_generate_key(DH * dh);
+int qat_dh_compute_key(unsigned char *key, const BIGNUM * pub_key, DH * dh);
+
+static CpaPhysicalAddr realVirtualToPhysical(void *virtualAddr);
+
+#ifdef USE_NS_SENDPOLL
+int ns_handler(struct timespec* reqTime);
+#endif
+
+/* qat_buffer structure for partial hash */
+typedef struct qat_buffer_t
+{
+    struct qat_buffer_t *next;  /* next buffer in the list */
+    void *data;                 /* point to data buffer    */
+    int len;                    /* lenght of data          */
+} qat_buffer;
+
+/* Qat ctx structure declaration */
+typedef struct qat_ctx_t
+{
+    int paramNID;               /* algorithm nid */
+    CpaCySymSessionCtx ctx;     /* session context */
+    unsigned char hashResult[SHA512_SIZE];
+    				/* hash digest result */
+    int enc;                    /* encryption flag */
+    int init;			/* has been initialised */
+    CpaInstanceHandle instanceHandle;
+
+    /* the memory for the private meta data must be allocated as contiguous
+     * memory. The cpaCyBufferListGetMetaSize() will return the size (in
+     * bytes) for memory allocation routine to allocate the private meta data
+     * memory 
+     */
+    void *srcPrivateMetaData;   /* meta data pointer */
+    void *dstPrivateMetaData;   /* meta data pointer */
+
+    /*  For partial operations, we maintain a linked list of buffers
+     *  to be processed in the final function.
+     */
+
+    qat_buffer *first;          /* first buffer pointer for partial op */
+    qat_buffer *last;           /* last buffer pointe for partial op */
+    int buff_count;		/* buffer count */
+    int buff_total;		/* total number of buffer */
+
+} qat_ctx;
+
+/* Qat cipher AES256 function structure declaration */
+EVP_CIPHER qat_aes_256_cbc = {
+    NID_aes_256_cbc,            /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_256,           /* key_size in Bytes - defined above */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined above */
+    EVP_CIPH_CBC_MODE,           /* flags defined above */
+    qat_aes_256_cbc_init,
+    qat_aes_256_cbc_do_cipher,
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* qat_aes_256_cbc_set_asn1_parameters */
+    NULL,                       /* qat_aes_256_cbc_get_asn1_parameters */
+    NULL,                       /* qat_aes_256_cbc_ctrl */
+    NULL                        /* qat_aes_256_cbc_app_data */
+};
+
+/* Qat cipher AES192 function structure declaration */
+EVP_CIPHER qat_aes_192_cbc = {
+    NID_aes_192_cbc,            /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_192,           /* key_size in Bytes - defined above */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined above */
+    EVP_CIPH_CBC_MODE,          /* flags defined above */
+    qat_aes_192_cbc_init,
+    qat_aes_192_cbc_do_cipher,
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* qat_aes_192_cbc_set_asn1_parameters */
+    NULL,                       /* qat_aes_192_cbc_get_asn1_parameters */
+    NULL,                       /* qat_aes_192_cbc_ctrl */
+    NULL                        /* qat_aes_192_cbc_app_data */
+};
+
+/* Qat cipher AES128 function structure declaration */
+EVP_CIPHER qat_aes_128_cbc = {
+    NID_aes_128_cbc,            /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_128,           /* key_size in Bytes - defined above */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined above */
+    EVP_CIPH_CBC_MODE,          /* flags defined above */
+    qat_aes_128_cbc_init,
+    qat_aes_128_cbc_do_cipher,
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* qat_aes_128_cbc_set_asn1_parameters */
+    NULL,                       /* qat_aes_128_cbc_get_asn1_parameters */
+    NULL,                       /* qat_aes_128_cbc_ctrl */
+    NULL                        /* qat_aes_128_cbc_app_data */
+};
+
+#ifdef NID_aes_128_cbc_hmac_sha1
+/* Qat cipher AES128-SHA1 function structure declaration */
+EVP_CIPHER qat_aes_128_cbc_hmac_sha1 = {
+    NID_aes_128_cbc_hmac_sha1,  /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_128,           /* key_size in Bytes - defined above */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined above */
+    EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_FLAG_AEAD_CIPHER,
+    qat_aes_cbc_hmac_sha1_init,
+    qat_aes_cbc_hmac_sha1_cipher,
+    qat_aes_cbc_hmac_sha1_cleanup,
+    sizeof(qat_chained_ctx),  /* ctx_size */
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_set_asn1_iv,
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_get_asn1_iv,
+    qat_aes_cbc_hmac_sha1_ctrl,
+    NULL 
+};
+#endif
+
+#ifdef NID_aes_256_cbc_hmac_sha1
+/* Qat cipher AES256-SHA1 function structure declaration */
+EVP_CIPHER qat_aes_256_cbc_hmac_sha1 = {
+    NID_aes_256_cbc_hmac_sha1,  /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_256,           /* key_size in Bytes - defined above */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined above */
+    EVP_CIPH_CBC_MODE|EVP_CIPH_FLAG_DEFAULT_ASN1|EVP_CIPH_FLAG_AEAD_CIPHER, 
+    qat_aes_cbc_hmac_sha1_init,
+    qat_aes_cbc_hmac_sha1_cipher,
+    qat_aes_cbc_hmac_sha1_cleanup,
+    sizeof(qat_chained_ctx),  /* ctx_size */
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_set_asn1_iv,
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_get_asn1_iv,
+    qat_aes_cbc_hmac_sha1_ctrl,
+    NULL
+};
+#endif
+
+/* Qat cipher RC4 function structure declaration */
+EVP_CIPHER qat_rc4 = {
+    NID_rc4,                    /* nid */
+    RC4_BLOCK_SIZE,             /* block_size */
+    RC4_KEY_SIZE,               /* key_size in Bytes - defined above */
+    RC4_IV_LEN,                 /* iv_len in Bytes - defined above */
+    RC4_FLAGS,                  /* flags defined above */
+    qat_rc4_init,
+    qat_rc4_do_cipher,
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* qat_rc4_set_asn1_parameters */
+    NULL,                       /* qat_rc4_get_asn1_parameters */
+    NULL,                       /* qat_rc4_ctrl */
+    NULL                        /* qat_rc4_app_data */
+};
+
+/* Qat cipher 3DES function structure declaration */
+EVP_CIPHER qat_des_ede3_cbc = {
+    NID_des_ede3_cbc,           /* nid */
+    DES3_BLOCK_SIZE,            /* block_size */
+    DES3_KEY_SIZE_192,          /* key_size in Bytes - defined above */
+    DES3_IV_LEN,                /* iv_len in Bytes - defined above */
+    EVP_CIPH_CBC_MODE,           /* flags defined above */
+    qat_des_ede3_cbc_init,
+    qat_des_ede3_cbc_do_cipher,
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* qat_des_ede3_cbc_set_asn1_parameters */
+    NULL,                       /* qat_des_ede3_cbc_get_asn1_parameters */
+    NULL,                       /* qat_des_ede3_cbc_ctrl */
+    NULL                        /* qat_des_ede3_cbc_app_data */
+};
+
+/* Qat cipher DES function structure declaration */
+EVP_CIPHER qat_des_cbc = {
+    NID_des_cbc,                /* nid */
+    DES_BLOCK_SIZE,             /* block_size */
+    DES_KEY_SIZE_56,            /* key_size in Bytes - defined above */
+    DES_IV_LEN,                 /* iv_len in Bytes - defined above */
+    EVP_CIPH_CBC_MODE,          /* flags defined above */
+    qat_des_cbc_init,
+    qat_des_cbc_do_cipher,
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* qat_des_cbc_set_asn1_parameters */
+    NULL,                       /* qat_des_cbc_get_asn1_parameters */
+    NULL,                       /* qat_des_cbc_ctrl */
+    NULL                        /* qat_des_cbc_app_data */
+};
+
+/* Qat digest SHA1 function structure declaration */
+EVP_MD qat_sha1 = {
+    NID_sha1,                   /* nid */
+    NID_undef,
+    SHA1_SIZE,                  /* output size */
+    SHA1_FLAGS,                 /* flags defined above */
+    qat_sha1_init,
+    qat_sha1_update,
+    qat_sha1_final,
+    qat_sha1_copy,
+    digest_cleanup,
+    NULL,                       /* qat_sha1_sign */
+    NULL,                       /* qat_sha1_verify */
+   {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA1_BLOCK_SIZE,            /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+#if OPENSSL_VERSION_NUMBER > 0x01000000
+    NULL                        /* qat_sha1_ctrl */
+#endif
+};
+
+/* Qat digest SHA256 function structure declaration */
+EVP_MD qat_sha256 = {
+    NID_sha256,                 /* nid */
+    NID_undef,
+    SHA256_SIZE,                /* output size */
+    SHA256_FLAGS,               /* flags defined above */
+    qat_sha256_init,
+    qat_sha256_update,
+    qat_sha256_final,
+    qat_sha256_copy,
+    digest_cleanup,
+    NULL,                       /* qat_sha256_sign */
+    NULL,                       /* qat_sha256_verify */
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA256_BLOCK_SIZE,          /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+#if OPENSSL_VERSION_NUMBER > 0x01000000
+    NULL                        /* qat_sha256_ctrl */
+#endif
+};
+
+/* Qat digest SHA512 function structure declaration */
+EVP_MD qat_sha512 = {
+    NID_sha512,                 /* nid */
+    NID_undef,
+    SHA512_SIZE,                /* output size */
+#if OPENSSL_VERSION_NUMBER > 0x01000000
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE|EVP_MD_FLAG_DIGALGID_ABSENT, 
+#else
+    SHA512_FLAGS,
+#endif
+    qat_sha512_init,
+    qat_sha512_update,
+    qat_sha512_final,
+    qat_sha512_copy,
+    digest_cleanup,
+    NULL,                       /* qat_sha512_sign */
+    NULL,                       /* qat_sha512_verify */
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA512_BLOCK_SIZE,          /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+#if OPENSSL_VERSION_NUMBER > 0x01000000
+    NULL                        /* qat_sha512_ctrl */
+#endif
+};
+
+/* Qat digest MD5 function structure declaration */
+EVP_MD qat_md5 = {
+    NID_md5,                    /* nid */
+    NID_undef,
+    MD5_SIZE,                   /* output size */
+    MD5_FLAGS,                  /* flags defined above */
+    qat_md5_init,
+    qat_md5_update,
+    qat_md5_final,
+    qat_md5_copy,
+    digest_cleanup,
+    NULL,                       /* qat_md5_sign */
+    NULL,                       /* qat_md5_verify */
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    MD5_BLOCK_SIZE,             /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+#if OPENSSL_VERSION_NUMBER > 0x01000000
+    NULL                        /* qat_md5_ctrl */
+#endif
+};
+
+/* Qat Symmetric cipher function register */
+static int qat_cipher_nids[] = {
+#ifndef QAT_ZERO_COPY_MODE
+    NID_aes_256_cbc,
+    NID_aes_192_cbc,
+    NID_aes_128_cbc,
+    NID_rc4,
+    NID_des_ede3_cbc,
+    NID_des_cbc,
+#endif
+#ifdef NID_aes_128_cbc_hmac_sha1
+    NID_aes_128_cbc_hmac_sha1,
+#endif
+#ifdef NID_aes_256_cbc_hmac_sha1
+    NID_aes_256_cbc_hmac_sha1,
+#endif
+};
+
+/* Qat digest function register */
+static int qat_digest_nids[] = {
+    NID_sha1,
+    NID_sha256,
+    NID_sha512,
+    NID_md5,
+};
+
+/* Qat RSA method structure declaration. */
+static RSA_METHOD qat_rsa_method = {
+    "QAT RSA method",           /* name */
+    qat_rsa_pub_enc,            /* rsa_pub_enc */
+    qat_rsa_pub_dec,            /* rsa_pub_dec */
+    qat_rsa_priv_enc,           /* rsa_priv_enc */
+    qat_rsa_priv_dec,           /* rsa_priv_dec */
+    qat_rsa_mod_exp,            /* rsa_mod_exp */
+    qat_bn_mod_exp,             /* bn_mod_exp */
+    NULL,                       /* init */
+    NULL,                       /* finish */
+    0,                          /* flags */
+    NULL,                       /* app_data */
+    NULL,                       /* rsa_sign */
+    NULL                        /* rsa_verify */
+};
+
+/* Qat DSA method structure declaration. */
+static DSA_METHOD qat_dsa_method = {
+    "QAT DSA method",           /* name */
+    qat_dsa_do_sign,            /* do_sign */
+    qat_dsa_sign_setup,         /* sign_setup */
+    qat_dsa_do_verify,          /* do_verify */
+#if OPENSSL_VERSION_NUMBER < 0x01000000
+    /*
+     * openssl-0.9.8w will segfault without this as dsa_do_verify doesnt
+     * check to see if this is null.  This is fixed in openssl-1.0.1c
+    */
+    qat_dsa_mod_exp,            /* mod_exp */
+#else
+    NULL,                       /* mod_exp */
+#endif
+    qat_mod_exp_dsa,            /* bn_mod_exp */
+    NULL,                       /* init */
+    NULL,                       /* finish */
+    0,                          /* flags */
+    NULL                        /* app_data */
+};
+
+/* Qat DH method structure declaration. */
+static DH_METHOD qat_dh_method = {
+    "QAT DH method",            /* name */
+    qat_dh_generate_key,        /* generate_key */
+    qat_dh_compute_key,         /* compute_key */
+    qat_mod_exp_dh,             /* bn_mod_exp */
+    NULL,                       /* init */
+    NULL,                       /* finish */
+    0,                          /* flags */
+    NULL,                       /* app_data */
+    NULL                        /* generate_params */
+};
+
+/* OpenSSL  structs for default function pointers. */
+static const DSA_METHOD *openssl_dsa_method;
+static const DH_METHOD *openssl_dh_method;
+static const RSA_METHOD *openssl_rsa_method;
+
+static CpaVirtualToPhysical myVirtualToPhysical = realVirtualToPhysical;
+static int qat_inited = 0;
+static int zero_copy_memory_mode = 0;
+
+/* Qat engine function declarations */
+static int qat_ciphers(ENGINE * e,
+                       const EVP_CIPHER ** cipher, const int **nids, int nid);
+
+static int qat_digests(ENGINE * e,
+                       const EVP_MD ** digests, const int **nids, int nid);
+
+static void hexDump(const char *func, const char *var, const unsigned char p[],
+                    int l)
+{
+    int i;
+
+    printf("%s: %s", func, var);
+    for (i = 0; i < l; i++)
+    {
+        if (i % 16 == 0)
+            putchar('\n');
+        else if (i % 8 == 0)
+            fputs("- ", stdout);
+        printf("%02x ", p[i]);
+    }
+    putchar('\n');
+}
+
+#ifdef QAT_DEBUG
+static void dumpRequest(const CpaInstanceHandle instanceHandle,
+                        void *pCallbackTag,
+                        const CpaCySymOpData * pOpData,
+                        const CpaCySymSessionSetupData * sessionData,
+                        const CpaBufferList * pSrcBuffer,
+                        CpaBufferList * pDstBuffer)
+{
+    unsigned int index = 0;
+    struct op_done *opDoneCB = (struct op_done*)pCallbackTag;
+ 
+    printf("\nInstance Handle:    %p\n", instanceHandle);
+    printf("Callback Ptr:       %p\n", opDoneCB);
+    printf("OpData->packetType:        %u\n", pOpData->packetType);
+    hexDump(__func__, "Cipher Key:      ",
+            sessionData->cipherSetupData.pCipherKey,
+            sessionData->cipherSetupData.cipherKeyLenInBytes);
+    printf("Cipher Key Len:     %u\n",
+            sessionData->cipherSetupData.cipherKeyLenInBytes);
+    hexDump(__func__, "Cipher IV:               ",
+            pOpData->pIv, pOpData->ivLenInBytes);
+    hexDump(__func__, "MAC Key:                 ",
+            sessionData->hashSetupData.authModeSetupData.authKey,
+            sessionData->hashSetupData.authModeSetupData.authKeyLenInBytes);
+    for(index = 0; index < pSrcBuffer->numBuffers; index++)
+    {
+        printf("pSrcBuffer->pBuffers[%u].pData:                   %p\n", index, pSrcBuffer->pBuffers[index].pData);
+        hexDump(__func__, " ",
+            pSrcBuffer->pBuffers[index].pData,
+            pSrcBuffer->pBuffers[index].dataLenInBytes);
+        printf("pSrcBuffer->pBuffers[%u].dataLenInBytes:          %u\n\n",
+           index, pSrcBuffer->pBuffers[index].dataLenInBytes);
+    }
+ 
+    for(index = 0; index < pDstBuffer->numBuffers; index++)
+    {
+        printf("pDstBuffer->pBuffers[%u].pData:                  %p\n", index, pDstBuffer->pBuffers[index].pData);
+        hexDump(__func__, " ",
+            pDstBuffer->pBuffers[index].pData,  
+            pDstBuffer->pBuffers[index].dataLenInBytes);
+        printf("pDstBuffer->pBuffers[%u].dataLenInBytes:         %u\n\n",
+            index, pDstBuffer->pBuffers[index].dataLenInBytes);
+    }
+ 
+    printf("sessionData->cipherSetupData.cipherAlgorithm:	%u\n", sessionData->cipherSetupData.cipherAlgorithm);
+    printf("sessionData->cipherSetupData.cipherDirection:	%u\n", sessionData->cipherSetupData.cipherDirection);
+    printf("sessionData->algChainOrder:            		%u\n", sessionData->algChainOrder);
+    printf("pOpData->cryptoStartSrcOffsetInBytes:		%u\n", pOpData->cryptoStartSrcOffsetInBytes);
+    printf("pOpData->messageLenToCipherInBytes:  		%u\n", pOpData->messageLenToCipherInBytes);
+    printf("sessionData->hashSetupData.hashAlgorithm:		%u\n", sessionData->hashSetupData.hashAlgorithm);
+    printf("sessionData->hashSetupData.hashMode:	        %u\n", sessionData->hashSetupData.hashMode);
+    printf("pOpData->hashStartSrcOffsetInBytes:         	%u\n", pOpData->hashStartSrcOffsetInBytes);
+    printf("sessionData->hashSetupData.digestResultLenInBytes:	%u\n", sessionData->hashSetupData.digestResultLenInBytes);
+    printf("pOpData->messageLenToHashInBytes:			%u\n", pOpData->messageLenToHashInBytes);
+    printf("pOpData->pDigestResult:				%p\n", pOpData->pDigestResult);
+    printf("sessionData->verifyDigest:				%u\n", sessionData->verifyDigest);
+    printf("opDoneCB->verifyResult:				%u\n", opDoneCB->verifyResult);
+}
+#endif
+
+
+
+/******************************************************************************
+* function:
+*         initOpDone(struct op_done *opDone)
+*
+* @param opDone [IN] - pointer to op done callback structure
+*
+* description:
+*   Initialise the QAT operation "done" callback structure.
+*
+******************************************************************************/
+static void initOpDone(struct op_done *opDone)
+{
+    pthread_mutex_init(&(opDone->mutex), NULL);
+    pthread_cond_init(&(opDone->cond), NULL);
+    opDone->flag = 0;
+    opDone->verifyResult = CPA_FALSE;
+}
+
+/******************************************************************************
+* function:
+*         cleanupOpDone(struct op_done *opDone)
+*
+* @param opDone [IN] - pointer to op done callback structure
+*
+* description:
+*   Cleanup the thread and mutex used in the QAT operation "done" callback.
+*
+******************************************************************************/
+static void cleanupOpDone(struct op_done *opDone)
+{
+    pthread_mutex_destroy(&(opDone->mutex));
+    pthread_cond_destroy(&(opDone->cond));
+}
+
+/******************************************************************************
+* function:
+*         waitForOpToComplete(struct op_done *opDone)
+*
+* @param opdone [IN] - pointer to op done callback structure
+*
+* description:
+*   Wait on a mutex lock with a timeout for cpaCySymPerformOp to complete.
+*
+******************************************************************************/
+static void waitForOpToComplete(struct op_done *opDone)
+{
+    struct timespec ts;
+    int rc;
+
+    pthread_mutex_lock(&(opDone->mutex));
+
+    while (!opDone->flag)
+    {
+        clock_gettime(CLOCK_REALTIME, &ts);
+        ts.tv_sec += 1;
+        rc = pthread_cond_timedwait(&(opDone->cond), &(opDone->mutex), &ts);
+        if (rc != 0)
+            WARN("pthread_cond_timedwait: %s\n", strerror(rc));
+    }
+    pthread_mutex_unlock(&(opDone->mutex));
+}
+
+/******************************************************************************
+* function:
+*         qat_callbackFn(void *callbackTag, CpaStatus status,
+*                        const CpaCySymOp operationType, void *pOpData,
+*                        CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+*
+
+* @param pCallbackTag  [IN] -  Opaque value provided by user while making
+*                              individual function call. Cast to op_done.
+* @param status        [IN] -  Status of the operation.
+* @param operationType [IN] -  Identifies the operation type requested.
+* @param pOpData       [IN] -  Pointer to structure with input parameters.
+* @param pDstBuffer    [IN] -  Destination buffer to hold the data output.
+* @param verifyResult  [IN] -  Used to verify digest result.
+*
+* description:
+*   Callback function used by cpaCySymPerformOp to indicate completion.
+*
+******************************************************************************/
+static void qat_callbackFn(void *callbackTag, CpaStatus status,
+                           const CpaCySymOp operationType, void *pOpData,
+                           CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+{
+    struct op_done *opDone = (struct op_done *)callbackTag;
+
+    DEBUG("e_qat.%s: status %d verifyResult %d\n", __func__, status,
+          verifyResult);
+    pthread_mutex_lock(&(opDone->mutex));
+    opDone->flag = 1;
+    opDone->verifyResult = verifyResult;
+    pthread_cond_signal(&(opDone->cond));
+    pthread_mutex_unlock(&(opDone->mutex));
+}
+
+/******************************************************************************
+* function:
+*         qat_rsaCallbackFn(void *pCallbackTag, CpaStatus status,
+*                           void *pOpData, CpaFlatBuffer * pOut)
+*
+* @param instanceHandle [IN]  - Instance handle.
+* @param pRsaEncryptCb  [IN]  - Pointer to callback function to be invoked
+*                               when the operation is complete.
+* @param pCallbackTag   [IN]  - Opaque User Data for this specific call. Will
+*                               be returned unchanged in the callback.
+* @param pEncryptOpData [IN]  - Structure containing all the data needed to
+*                               perform the RSA encryption operation.
+* @param pOutputData    [Out] - Pointer to structure into which the result of
+*                               the RSA encryption primitive is written.
+* description:
+*   Callback function used by cpaCyRsaEncrypt to indicate completion.
+*   Calls back to qat_callbackFn().
+*
+******************************************************************************/
+void qat_rsaCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+                       CpaFlatBuffer * pOut)
+{
+    qat_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+                   NULL, CPA_FALSE);
+}
+
+/******************************************************************************
+* function:
+*         realVirtualToPhysical(void *virtualAddr)
+*
+* @param virtualAddr [IN] - Virtual address.
+*
+* description:
+*   Translates virtual address to hardware physical address. See the qae_mem
+*   module for more details. The virtual to physical translator is required
+*   by the QAT hardware to map from virtual addresses to physical locations
+*   in pinned memory.
+*
+*   This function is designed to work with the allocator defined in
+*   qae_mem_utils.c and qat_mem/qat_mem.c
+*
+******************************************************************************/
+static CpaPhysicalAddr realVirtualToPhysical(void *virtualAddr)
+{
+    return qaeMemV2P(virtualAddr);
+}
+
+/******************************************************************************
+* function:
+*         setMyVirtualToPhysical(CpaVirtualToPhysical fp)
+*
+* @param CpaVirtualToPhysical [IN] - Function pointer to translation function
+*
+* description:
+*   External API to allow users to specify their own virtual to physical
+*   address translation function.
+*
+******************************************************************************/
+void setMyVirtualToPhysical(CpaVirtualToPhysical fp)
+{
+    /*  If user specifies a V2P function then 
+     *  the user is taking responsibility for 
+     *  allocating and freeing pinned memory
+     *  so we switch to zero_copy_memory mode
+     */
+    if (!qat_inited)
+    {
+        myVirtualToPhysical = fp;
+        zero_copy_memory_mode = 1;
+    }
+    else
+        WARN("%s: can't set virtual to physical translation function after initialisation\n", __func__);
+}
+
+/******************************************************************************
+* function:
+*         copyAllocPinnedMemory(void *ptr, int size)
+*
+* @param ptr [IN]  - Pointer to data to be copied
+* @param size [IN] - Size of data to be copied
+*
+* description:
+*   Internal API to allocate a pinned memory
+*   buffer and copy data to it.  
+*
+* @retval NULL      failed to allocate memory
+* @retval non-NULL  pointer to allocated memory
+******************************************************************************/
+static void *copyAllocPinnedMemory(void *ptr, size_t size)
+{
+    void *nptr;
+    
+    if ((nptr = qaePinnedMemAlloc (size)) == NULL)
+    {
+        WARN("%s: pinned memory allocation failure\n", __func__);
+        return NULL;
+    }
+
+    memcpy (nptr, ptr, size);
+    return nptr;
+}
+
+/******************************************************************************
+* function:
+*         copyFreePinnedMemory(void *kptr, void *uptr, int size)
+*
+* @param uptr [IN] - Pointer to user data
+* @param kptr [IN] - Pointer to pinned memory to be copied
+* @param size [IN] - Size of data to be copied
+*
+* description:
+*   Internal API to allocate a pinned memory
+*   buffer and copy data to it.
+*
+******************************************************************************/
+static void copyFreePinnedMemory(void *uptr, void *kptr, int size)
+{
+    memcpy (uptr, kptr, size);
+    qaeMemFree (kptr);
+}
+
+/******************************************************************************
+* function:
+*         CpaStatus myPerformOp(const CpaInstanceHandle  instanceHandle,
+*                     void *                     pCallbackTag,
+*                     const CpaCySymOpData      *pOpData,
+*                     const CpaBufferList       *pSrcBuffer,
+*                     CpaBufferList             *pDstBuffer,
+*                     CpaBoolean                *pVerifyResult)
+*
+* @param ih [IN] - Instance handle
+* @param instanceHandle [IN]  - Instance handle
+* @param pCallbackTag   [IN]  - Pointer to op_done struct
+* @param pOpData        [IN]  - Operation parameters
+* @param pSrcBuffer     [IN]  - Source buffer list
+* @param pDstBuffer     [OUT] - Destination buffer list
+* @param pVerifyResult  [OUT] - Whether hash verified or not
+*
+* description:
+*   Wrapper around cpaCySymPerformOp which handles retries for us.
+*
+******************************************************************************/
+CpaStatus myPerformOp(const CpaInstanceHandle instanceHandle,
+                      void *pCallbackTag,
+                      const CpaCySymOpData * pOpData,
+                      const CpaBufferList * pSrcBuffer,
+                      CpaBufferList * pDstBuffer, CpaBoolean * pVerifyResult)
+{
+    CpaStatus status;
+
+    do
+    {
+        status = cpaCySymPerformOp(instanceHandle,
+                                   pCallbackTag,
+                                   pOpData,
+                                   pSrcBuffer, pDstBuffer, pVerifyResult);
+        if (status == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+            pthread_yield();
+        }
+    }
+    while (status == CPA_STATUS_RETRY);
+    return status;
+}
+
+#ifndef USE_NS_SENDPOLL
+/******************************************************************************
+* function:
+*         void *sendPoll(void *ih)
+*
+* @param ih [IN] - Instance handle
+*
+* description:
+*   Poll the QAT instances every 2 microseconds.
+*
+******************************************************************************/
+static void *sendPoll(void *ih)
+{
+
+    CpaStatus status = 0;
+    CpaInstanceHandle instanceHandle;
+
+    instanceHandle = (CpaInstanceHandle) ih;
+    
+    while (keep_polling)
+    {
+        /* Poll for 0 means process all packets on the ET ring */
+        status = icp_sal_CyPollInstance(instanceHandle, 0);
+
+        if (CPA_STATUS_SUCCESS == status)
+        {
+            /* Do nothing */
+        }
+        else if (CPA_STATUS_RETRY == status)
+        {
+            pthread_yield();
+        }
+        else
+        {
+            WARN("WARNING icp_sal_CyPollInstance returned status %d\n", status);
+        }
+    }
+
+    return NULL;
+}
+#else
+/******************************************************************************
+* function:
+*         void *sendPoll_ns(void *ih)
+*
+* @param ih [IN] - Instance handle
+*
+* description:
+*   Poll the QAT instances (nanosleep version)
+*       NB: Delay in this function is set by default at runtime by pulling a value
+*       in nsecs from /etc/send_poll_interval. If no such file is available,
+*       default falls through to POLL_PERIOD_IN_NS.
+*
+******************************************************************************/
+static void *sendPoll_ns(void *ih)
+{
+    CpaStatus status = 0;
+    CpaInstanceHandle instanceHandle;
+    struct timespec reqTime;
+    struct timespec interUpdate;
+    FILE *fp;
+    char interBuf[32] = {'0'};
+    size_t bytesRead = 0;
+    long int lastUpdate = 0;
+    int pollFilePres = 1;
+
+    instanceHandle = (CpaInstanceHandle) ih;
+    reqTime.tv_sec = 0;
+    reqTime.tv_nsec = POLL_PERIOD_IN_NS;
+ 
+    fp = fopen("/etc/send_poll_interval", "r");
+    if(fp == NULL)
+    {
+        pollFilePres = 0;
+    }
+ 
+    if(1 == pollFilePres)
+    {
+        bytesRead = fread(interBuf, 1, sizeof(interBuf), fp);
+ 
+        if(bytesRead > 0)
+        {
+            reqTime.tv_nsec = atoi(interBuf);
+            DEBUG("sendPoll: Interval is set to %i", reqTime.tv_nsec);
+            fseek(fp, 0L, SEEK_SET);
+        }
+        clock_gettime(CLOCK_MONOTONIC, &interUpdate);
+        lastUpdate = interUpdate.tv_sec;
+    }
+ 
+    while (keep_polling)
+    {
+        /* Poll for 0 means process all packets on the ET ring */
+        status = icp_sal_CyPollInstance(instanceHandle, 0);
+ 
+        if (CPA_STATUS_SUCCESS == status || CPA_STATUS_RETRY == status)
+        {
+            /* Do nothing */
+        }
+        else
+        {
+            WARN("WARNING icp_sal_CyPollInstance returned status %d\n", status);
+        }
+ 
+        ns_handler(&reqTime);
+               
+        if(1 == pollFilePres)
+        {
+            clock_gettime(CLOCK_MONOTONIC, &interUpdate);
+            if(interUpdate.tv_sec > (lastUpdate + 300))//use 300 (5 minutes)
+            {
+                bytesRead = fread(interBuf, 1, sizeof(interBuf), fp);
+                if(bytesRead > 0)
+                {
+                    reqTime.tv_nsec = atoi(interBuf);
+                    DEBUG("sendPoll: Interval is set dynamically to %li\n", reqTime.tv_nsec);
+                    fseek(fp, 0L, SEEK_SET);
+                }
+                lastUpdate = interUpdate.tv_sec;
+            }
+        }
+    }
+    if(fp != NULL)
+    { 
+        fclose(fp);
+    }
+
+    return NULL;
+}
+
+/******************************************************************************
+* function:
+*         int ns_handler(struct timespec* reqTime)         
+*
+* @param reqTime [IN] - timespec structure
+*
+* description:
+*            Handle the call to nanosleep.   
+******************************************************************************/
+int ns_handler(struct timespec* reqTime)
+{
+    static unsigned int recDepth = 0; //to prevent too much time drift
+    struct timespec remTime;
+    int retVal = 1;
+
+    recDepth++;
+    if(recDepth >= 5)
+    {
+        retVal = 0; //break out of the recursion and start a new nanosleep seq
+    }
+    else
+    {
+        if(nanosleep(reqTime, &remTime) < 0)
+        {
+            if(EINTR == errno)
+            {
+                retVal = ns_handler(&remTime);
+            }
+            else
+            {
+                WARN("WARNING nanosleep system call failed: errno %i\n", errno);
+                retVal = 0;
+            }
+        }
+    }
+
+    recDepth--;
+    return retVal;
+}
+
+
+#endif
+
+/******************************************************************************
+* function:
+*         qat_engine_init(ENGINE *e)
+*
+* @param e [IN] - OpenSSL engine pointer
+*
+* description:
+*   Qat engine init function, associated with Crypto memory setup
+*   and cpaStartInstance setups.
+******************************************************************************/
+static int qat_engine_init(ENGINE * e)
+{
+        int instNum;
+    CpaStatus status = CPA_STATUS_SUCCESS;
+
+    DEBUG("[%s] ---- Engine Initing\n\n", __func__);
+
+   /* Initialise the QAT hardware */
+    /*
+     * The second argument of icp_sal_userStartMultiProcess needs to match
+     * the value of LimitDevAccess in the SSL section of the icp device
+     * configuration file (ie /etc/dh89xxcc_qa_dev0.conf).
+     * If LimitDevAccess = 0, then use CPA_FALSE, otherwise CPA_TRUE.
+     */
+    if (CPA_STATUS_SUCCESS != icp_sal_userStartMultiProcess("SSL",CPA_FALSE))
+    {
+       WARN("icp_sal_userStart failed\n");
+        exit(EXIT_FAILURE);
+    }   
+
+ 
+   /* Get the number of available instances */
+    status = cpaCyGetNumInstances(&numInstances);
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("cpaCyGetNumInstances failed, status=%d\n", status);
+        return 0;
+    }
+    if (!numInstances)
+    {
+        WARN("No crypto instances found\n"
+             "make sure the icp device configuration file has "
+	     "LimitDevAccess = 0\n");
+        return 0;
+    }
+
+    DEBUG("%s: %d Cy instances got\n", __func__, numInstances);
+
+    /* Allocate memory for the instance handle array */
+    qatInstanceHandles =
+        (CpaInstanceHandle *) OPENSSL_malloc(numInstances *
+                                             sizeof(CpaInstanceHandle));
+    if (qatInstanceHandles == NULL)
+    {
+        WARN("OPENSSL_malloc() failed for instance handles.\n");
+        return 0;
+    }
+
+    /* Allocate memory for the polling threads */
+    icp_polling_threads =
+        (pthread_t *) OPENSSL_malloc(numInstances * sizeof(pthread_t));
+    if (icp_polling_threads == NULL)
+    {
+        DEBUG("malloc() failed for icp_polling_threads.\n");
+        return 0;
+    }
+
+    /* Get the Cy instances */
+    status = cpaCyGetInstances(numInstances, qatInstanceHandles);
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("cpaCyGetInstances failed, status=%d\n", status);
+        return 0;
+    }
+
+    /* Set translation function and start each instance */
+    for (instNum = 0; instNum < numInstances; instNum++)
+    {
+        /* Set the address translation function */
+        status = cpaCySetAddressTranslation(qatInstanceHandles[instNum],
+                                            myVirtualToPhysical);
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("cpaCySetAddressTranslation failed, status=%d\n", status);
+            return 0;
+        }
+
+        /* Start the instances */
+        status = cpaCyStartInstance(qatInstanceHandles[instNum]);
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("cpaCyStartInstance failed, status=%d\n", status);
+            return 0;
+        }
+
+        /* Create the polling threads */
+#ifdef USE_NS_SENDPOLL
+        pthread_create(&icp_polling_threads[instNum], NULL, sendPoll_ns,
+                       qatInstanceHandles[instNum]);
+#else
+        pthread_create(&icp_polling_threads[instNum], NULL, sendPoll,
+                       qatInstanceHandles[instNum]);
+#endif
+#ifdef QAT_POLL_CORE_AFFINITY
+        {
+            int coreID = 0;
+            int sts = 1;
+            cpu_set_t cpuset;
+
+            CPU_ZERO(&cpuset);
+
+            coreID = 0;
+            CPU_SET(coreID, &cpuset);
+
+            sts =
+                pthread_setaffinity_np(icp_polling_threads[instNum],
+                                       sizeof(cpu_set_t), &cpuset);
+            if (sts != 0)
+            {
+                DEBUG("pthread_setaffinity_np error, status = %d \n", sts);
+                exit(EXIT_FAILURE);
+            }
+            sts =
+                pthread_getaffinity_np(icp_polling_threads[instNum],
+                                       sizeof(cpu_set_t), &cpuset);
+            if (sts != 0)
+            {
+                DEBUG("pthread_getaffinity_np error, status = %d \n", sts);
+                exit(EXIT_FAILURE);
+            }
+
+            if (CPU_ISSET(coreID, &cpuset))
+                DEBUG("Polling thread assigned on CPU core %d\n", coreID);
+        }
+#endif
+    }
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_engine_finish(ENGINE *e)
+*
+* @param e [IN] - OpenSSL engine pointer
+*
+* description:
+*   Qat engine finish function.
+******************************************************************************/
+static int qat_engine_finish(ENGINE * e)
+{
+    
+    int i; 
+    CpaStatus status = CPA_STATUS_SUCCESS;
+
+    DEBUG("[%s] ---- Engine Finishing...\n\n", __func__);
+
+    keep_polling = 0;
+
+    for ( i = 0; i < numInstances; i++)
+    {
+        status = cpaCyStopInstance(qatInstanceHandles[i]);
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("cpaCyStopInstance failed, status=%d\n", status);
+            return 0;
+        }
+
+        pthread_join(icp_polling_threads[i], NULL);
+
+    }
+
+    //DEBUG(" [%s] release  element: %p with engine id: %p\n",__FUNCTION__,gConfigEntry,e);
+
+    OPENSSL_free(qatInstanceHandles);
+    OPENSSL_free(icp_polling_threads);
+
+    icp_sal_userStop();
+#ifdef SAL_STOP_DELAY
+    sleep(SAL_STOP_DELAY);
+#endif
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_engine_destroy(ENGINE *e)
+*
+* @param e [IN] - OpenSSL engine pointer
+*
+* description:
+*   Qat engine destroy function, required by Openssl engine API.
+*   all the clean up are implemented in qat_engine_finish(), thus we just do 
+*   nothing here but return 1.  
+*
+******************************************************************************/
+static int qat_engine_destroy(ENGINE * e)
+{
+    DEBUG("[%s] ---- Destroying Engine...\n\n", __func__);
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         cipher_init( EVP_CIPHER_CTX *ctx,
+*                          const unsigned char *key,
+*                          const unsigned char *iv,
+*                          int enc, CipherType cipherType )
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value
+* @param iv  [IN] - pointer to initial vector
+* @param enc [IN] - encryption indicator
+*
+* description:
+*   This function is rewrite of aes_xxx_cbc_init() function in OpenSSL.
+*   All the inputs are passed form the above OpenSSL layer to the
+*   corresponding API cpaCySymInitSession() function.
+*   It is the first function called in AES cipher routine sequences,
+*   in order to initialize the cipher ctx structure and CpaCySymSession.
+*   The function will return 1 if successful.
+******************************************************************************/
+static int cipher_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                     const unsigned char *iv, int enc, CipherType cipherType)
+{
+
+    CpaCySymSessionSetupData sessionSetupData = {0};
+    Cpa32U sessionCtxSize = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    CpaInstanceHandle instanceHandle;
+    void *srcPrivateMetaData = NULL;
+    void *dstPrivateMetaData = NULL;
+    Cpa32U metaSize = 0;
+
+    DEBUG("[%s] ---- AES init %p, enc %d...\n\n", __func__, ctx, enc);
+
+    if(cipherType != RC_4)
+    { 
+        if ((!key) || (!iv) || (!ctx))
+        {
+            WARN("[%s] --- key, iv or ctx is NULL.\n", __func__);
+            return 0;
+        }
+#ifdef QAT_DEBUG
+        {
+            int i;
+
+            printf("%s: dumping iv\n", __func__);
+            for (i = 0; i < 16; i++)
+                printf("%2x ", iv[i]);
+            putchar('\n');
+        }
+#endif
+    }
+    else
+    {
+        if ((!key) || (!ctx))
+        {
+            WARN("[%s] --- key, iv or ctx is NULL.\n", __func__);
+            return 0;
+        }
+    }
+
+
+    /* Priority of this session */
+    sessionSetupData.sessionPriority = CPA_CY_PRIORITY_HIGH;
+    sessionSetupData.symOperation = CPA_CY_SYM_OP_CIPHER;
+    /* Cipher algorithm and mode */
+    if(cipherType != RC_4 && cipherType != DES3 && cipherType != DES) 
+    sessionSetupData.cipherSetupData.cipherAlgorithm =
+        CPA_CY_SYM_CIPHER_AES_CBC;
+
+    switch (cipherType)
+    {
+        case AES128:
+            sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                (Cpa32U) qat_aes_128_cbc.key_len;
+          break;
+        case AES192:
+            sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                (Cpa32U) qat_aes_192_cbc.key_len;
+          break;
+        case AES256:
+            sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                (Cpa32U) qat_aes_256_cbc.key_len;
+          break;
+        case RC_4:
+            sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                (Cpa32U)qat_rc4.key_len;
+            sessionSetupData.cipherSetupData.cipherAlgorithm =
+                CPA_CY_SYM_CIPHER_ARC4;
+          break;
+        case DES3:
+            sessionSetupData.cipherSetupData.cipherAlgorithm =
+                CPA_CY_SYM_CIPHER_3DES_CBC;
+            sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                (Cpa32U) qat_des_ede3_cbc.key_len;
+          break;
+        case DES:
+            sessionSetupData.cipherSetupData.cipherAlgorithm =
+                CPA_CY_SYM_CIPHER_DES_CBC;
+            sessionSetupData.cipherSetupData.cipherKeyLenInBytes =
+                (Cpa32U) qat_des_cbc.key_len;
+          break;
+        default:
+          break;
+}
+
+    
+    /* Cipher key */
+    sessionSetupData.cipherSetupData.pCipherKey = (Cpa8U *) key;
+
+    sessionSetupData.verifyDigest = CPA_FALSE;
+
+    /* Operation to perform */
+    if (enc)
+    {
+        sessionSetupData.cipherSetupData.cipherDirection =
+            CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+    }
+    else
+    {
+        sessionSetupData.cipherSetupData.cipherDirection =
+            CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+    }
+
+    instanceHandle = get_next_inst();
+    if ((sts = cpaCySymSessionCtxGetSize
+         (instanceHandle, &sessionSetupData,
+          &sessionCtxSize)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymSessionCtxGetSize failed, sts = %d.\n",
+             __func__, sts);
+        return 0;
+    }
+
+    pSessionCtx = (CpaCySymSessionCtx) qaePinnedMemAlloc (sessionCtxSize);
+    DEBUG("session %p size %d alloc\n", pSessionCtx, sessionCtxSize);
+
+    if (pSessionCtx == NULL)
+    {
+        WARN("[%s] --- pSessionCtx malloc failed !\n", __func__);
+        return 0;
+    }
+    if ((sts = cpaCySymInitSession
+         (instanceHandle, qat_callbackFn, &sessionSetupData,
+          pSessionCtx)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymInitSession failed, sts = %d \n", __func__, sts);
+        qaeMemFree (pSessionCtx);
+        return 0;
+    }
+
+    if ((sts = cpaCyBufferListGetMetaSize(instanceHandle,
+                                          1, &metaSize)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed sts=%d.\n",
+             __func__, sts);
+        qaeMemFree (pSessionCtx);
+        return 0;
+    }
+
+    if (metaSize)
+    {
+        srcPrivateMetaData = qaePinnedMemAlloc (metaSize);
+        if (!srcPrivateMetaData)
+        {
+            WARN("[%s] --- srcBufferList.pPrivateMetaData is NULL.\n",
+                 __func__);
+            qaeMemFree (pSessionCtx);
+            return 0;
+        }
+        dstPrivateMetaData = qaePinnedMemAlloc (metaSize);
+        if (!dstPrivateMetaData)
+        {
+            WARN("[%s] --- dstBufferList.pPrivateMetaData is NULL.\n",
+                 __func__);
+            qaeMemFree (pSessionCtx);
+            qaeMemFree (srcPrivateMetaData);
+            return 0;
+        }
+    }
+    else
+    {
+        srcPrivateMetaData = NULL;
+        dstPrivateMetaData = NULL;
+    }
+
+    /* pinned memory is not required for qat_context */
+    qat_context = (qat_ctx *) OPENSSL_malloc(sizeof(qat_ctx));
+
+    if (qat_context == NULL)
+    {
+        WARN("[%s] --- qat_context not allocated.\n", __func__);
+        qaeMemFree (pSessionCtx);
+        qaeMemFree (srcPrivateMetaData);
+        qaeMemFree (dstPrivateMetaData);
+        return 0;
+    }
+
+    switch (cipherType)
+    {
+        case AES128:
+            qat_context->paramNID = qat_aes_128_cbc.nid;
+          break;
+        case AES192:
+            qat_context->paramNID = qat_aes_192_cbc.nid;
+          break;
+        case AES256:
+            qat_context->paramNID = qat_aes_256_cbc.nid;
+          break;
+        case RC_4:
+            qat_context->paramNID = qat_rc4.nid;
+          break;
+        case DES3:
+            qat_context->paramNID = qat_des_ede3_cbc.nid;
+          break;
+        case DES:
+            qat_context->paramNID = qat_des_cbc.nid;
+          break;    
+        default:
+             WARN("[%s] --- Unsupported Cipher Type.\n", __func__);
+             qaeMemFree (pSessionCtx);
+             qaeMemFree (srcPrivateMetaData);
+             qaeMemFree (dstPrivateMetaData);
+             return 0;
+          break;
+    }
+
+    qat_context->ctx = pSessionCtx;
+    qat_context->srcPrivateMetaData = srcPrivateMetaData;
+    qat_context->dstPrivateMetaData = dstPrivateMetaData;
+
+    /* set app_data pointer in ctx to qat_context pointer */
+    ctx->app_data = (void *)qat_context;
+
+    qat_context->enc = enc;
+    qat_context->instanceHandle = instanceHandle;
+
+    if(cipherType != RC_4)
+    {
+
+        /* copy iv value to ctx */
+        memcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
+        memcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));
+        DEBUG("%s: ctx %p\n", __func__, ctx);
+        DEBUG ("%s iv len is %d\n", __func__, EVP_CIPHER_CTX_iv_length(ctx));
+        DUMPL("ctx->iv", ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+        DUMPL("CIPHER INTI KEY", key , 32);   
+ }
+    return 1;
+
+
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_256_cbc_init( EVP_CIPHER_CTX *ctx,
+*                          const unsigned char *key,
+*                          const unsigned char *iv,
+*                                          int enc)
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value
+* @param iv  [IN] - pointer to initial vector
+* @param enc [IN] - encryption indicator
+*
+* description:
+*   This function is rewrite of aes_256_cbc_init() function in OpenSSL.
+*   All the inputs are passed form the above OpenSSL layer to the
+*   corresponding API cpaCySymInitSession() function.
+*   It is the first function called in AES cipher routine sequences,
+*   in order to initialize the cipher ctx structure and CpaCySymSession.
+*   The function will return 1 if successful.
+******************************************************************************/
+static int
+qat_aes_256_cbc_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                     const unsigned char *iv, int enc)
+{
+   DEBUG("[%s] --- called.\n", __func__);
+
+   return cipher_init(ctx, key,iv,enc,AES256);
+}
+
+
+/******************************************************************************
+* function:
+*         do_cipher(EVP_CIPHER_CTX *ctx,
+*                                   unsigned char *out,
+*                                   const unsigned char *in,
+*                                   size_t inl,
+                                    CipherType cipherType)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN]  - pointer to input data
+* @param inl [IN]  - Message length to cipher in bytes
+* @param cipherType [in] - Enum cipher type
+*
+* description:
+*    This function is rewrite of aes_xxx_cbc_do_cipher() in OpenSSL.
+*    All the inputs are passed form the above OpenSSL layer to the
+*    corresponding API cpaCySymPerformOp() function.
+*    The function encrypt inl bytes from the buffer pointer in and writes
+*    the encrypted version to the output pointer.
+*    It is the second function called in AES cipher routine sequences
+*    and return 1 if successful
+******************************************************************************/
+static int do_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                          const unsigned char *in, size_t inl, CipherType cipherType)
+{
+
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    CpaCySymOpData OpData = { 0, };
+    CpaBufferList srcBufferList = { 0, };
+    CpaFlatBuffer srcFlatBuffer = { 0, };
+    CpaBufferList dstBufferList = { 0, };
+    CpaFlatBuffer dstFlatBuffer = { 0, };
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    struct op_done opDone;
+
+    DEBUG("\n[%s] --- do_cipher %p BEGIN, inl %d\n", __func__, ctx, (int) inl);
+
+    if ((!in) || (!out) || (!ctx))
+    {
+        WARN("[%s] --- in, out or ctx is NULL.\n", __func__);
+        return 0;
+    }
+    
+#ifdef QAT_DEBUG
+    {
+        int i;
+
+        printf("%s: inl %d\n", __func__, (int) inl);
+        for (i = 0; i < inl; i++)
+            printf("%2x ", in[i]);
+        putchar('\n');
+    }
+#endif
+
+    qat_context = (qat_ctx *) (ctx->app_data);
+    pSessionCtx = qat_context->ctx;
+
+    OpData.sessionCtx = pSessionCtx;
+    OpData.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+    /* Initialization Vector or Counter. */
+
+    DEBUG ("%s iv len is %d\n", __func__, EVP_CIPHER_CTX_iv_length(ctx));
+    DUMPL("ctx->iv", ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+
+    if (zero_copy_memory_mode)
+    {
+        OpData.pIv = (Cpa8U *) ctx->iv;
+        srcFlatBuffer.pData = (Cpa8U *) in;
+        dstFlatBuffer.pData = (Cpa8U *) out;
+    }
+    else
+    {
+        OpData.pIv = (Cpa8U *) copyAllocPinnedMemory (ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+        srcFlatBuffer.pData = (Cpa8U *) copyAllocPinnedMemory ((void*)in, inl);
+        dstFlatBuffer.pData = (Cpa8U *) qaePinnedMemAlloc (inl);
+    }
+
+
+    /* Starting point for cipher processing - given as number of bytes from
+       start of data in the source buffer. The result of the cipher operation
+
+
+    will be written back into the output buffer starting at this location. */
+    OpData.cryptoStartSrcOffsetInBytes = 0;
+    /* Starting point for hash processing - given as number of bytes from start
+       of packet in source buffer. */
+    OpData.hashStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the hash will be
+       computed on.  */
+    OpData.messageLenToHashInBytes = 0;
+    /* Pointer to the location where the digest result either exists or will be
+       inserted. */
+    OpData.pDigestResult = NULL;
+    /* Pointer to Additional Authenticated Data (AAD) needed for authenticated
+       cipher mechanisms - CCM and GCM. For other authentication mechanisms
+       this pointer is ignored. */
+    OpData.pAdditionalAuthData = NULL;
+    /* The message length, in bytes, of the source buffer that the crypto
+       operation will be computed on. This must be a multiple to the block size
+       if a block cipher is being used. */
+    OpData.messageLenToCipherInBytes = inl;
+
+    /* Cipher IV length in bytes.  Determines the amount of valid IV data
+       pointed to by the pIv parameter. */
+    OpData.ivLenInBytes = (Cpa32U) EVP_CIPHER_CTX_iv_length(ctx);
+
+
+
+    srcFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    srcBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    srcBufferList.pBuffers = &srcFlatBuffer;
+    srcBufferList.pUserData = NULL;
+
+    srcBufferList.pPrivateMetaData = qat_context->srcPrivateMetaData;
+
+    dstFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    dstBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    dstBufferList.pBuffers = &dstFlatBuffer;
+    /* This is an opaque field that is not read or modified internally. */
+    dstBufferList.pUserData = NULL;
+
+    dstBufferList.pPrivateMetaData = qat_context->dstPrivateMetaData;
+
+    DEBUG("[%s] performing with %d bytes (iv-len=%d)\n", __func__, (int)inl,
+          EVP_CIPHER_CTX_iv_length(ctx));
+
+    initOpDone(&opDone);
+
+    if ((sts = myPerformOp(qat_context->instanceHandle,
+                           &opDone,
+                           &OpData,
+                           &srcBufferList,
+                           &dstBufferList,
+                           CPA_FALSE)) != CPA_STATUS_SUCCESS)
+
+{
+        WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        qaeMemFree (srcBufferList.pPrivateMetaData);
+        qaeMemFree (dstBufferList.pPrivateMetaData);
+        return 0;
+    }
+
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+
+    /*  If encrypting, the IV is the last block of the destination (ciphertext)
+     *  buffer.  If decrypting, the source buffer is the ciphertext.
+     */
+    if (qat_context->enc)
+    {
+        memcpy(ctx->iv,
+               dstBufferList.pBuffers[0].pData + inl - AES_BLOCK_SIZE,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+    else
+    {
+        memcpy(ctx->iv,
+               srcBufferList.pBuffers[0].pData + inl - AES_BLOCK_SIZE,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+
+    DUMPL("src buffer - END", srcBufferList.pBuffers[0].pData, inl);
+
+    DUMPL("dest buffer - END", dstBufferList.pBuffers[0].pData, inl);
+    DUMPL("ctx->iv- END", ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+
+    if (!zero_copy_memory_mode)
+    {
+        qaeMemFree (OpData.pIv);
+        qaeMemFree (srcFlatBuffer.pData);
+        copyFreePinnedMemory (out, dstFlatBuffer.pData, inl);
+    }
+
+
+
+    DEBUG("[%s] --- do_cipher END\n\n", __func__);
+
+    return 1;
+}
+
+
+/******************************************************************************
+* function:
+*         qat_aes_256_cbc_do_cipher(EVP_CIPHER_CTX *ctx,
+*                                   unsigned char *out,
+*                                   const unsigned char *in,
+*                                   size_t inl)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN]  - pointer to input data
+* @param inl [IN]  - Message length to cipher in bytes
+*
+* description:
+*    This function is rewrite of aes_256_cbc_do_cipher() in OpenSSL.
+*    All the inputs are passed form the above OpenSSL layer to the
+*    corresponding API cpaCySymPerformOp() function.
+*    The function encrypt inl bytes from the buffer pointer in and writes
+*    the encrypted version to the output pointer.
+*    It is the second function called in AES cipher routine sequences
+*    and return 1 if successful
+******************************************************************************/
+static int
+qat_aes_256_cbc_do_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                          const unsigned char *in, size_t inl)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return do_cipher(ctx, out, in, inl, AES256);
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_192_cbc_init(EVP_CIPHER_CTX *ctx,
+*                              const unsigned char *key,
+*                              const unsigned char *iv,
+*                              int enc)
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value
+* @param iv  [IN] - pointer to initial vector
+* @param enc [IN] - encryption indicator
+*
+* description:
+*   This function is rewrite of aes_192_cbc_init() function in OpenSSL.
+*   All the inputs are passed form the above OpenSSL layer to the
+*   corresponding API cpaCySymInitSession() function.
+*   It is the first function called in AES cipher routine sequences,
+*   in order to initialize the cipher ctx structure and CpaCySymSession.
+*   The function will return 1 if successful.
+******************************************************************************/
+static int
+qat_aes_192_cbc_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                     const unsigned char *iv, int enc)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return cipher_init(ctx, key, iv, enc, AES192);
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_192_cbc_do_cipher(EVP_CIPHER_CTX *ctx,
+*                                   unsigned char *out,
+*                                   const unsigned char *in,
+*                                   size_t inl)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN] - pointer to input data
+* @param inl [IN] - Message length to cipher in bytes
+*
+* description:
+*    This function is rewrite of aes_192_cbc_do_cipher() in OpenSSL.
+*    All the inputs are passed form the above OpenSSL layer to the
+*    corresponding API cpaCySymPerformOp() function.
+*    The function encrypt inl bytes from the buffer pointer in and writes
+*    the encrypted version to the output pointer.
+*    It is the second function called in AES cipher routine sequences
+*    and return 1 if successful
+******************************************************************************/
+static int
+qat_aes_192_cbc_do_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                          const unsigned char *in, size_t inl)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return do_cipher(ctx, out, in, inl, AES192);
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_128_cbc_init(EVP_CIPHER_CTX *ctx,
+*                              const unsigned char *key,
+*                              const unsigned char *iv,
+*                              int enc)
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value
+* @param iv  [IN] - pointer to initial vector
+* @param enc [IN] - encryption indicator
+*
+* description:
+*   This function is rewrite of aes_128_cbc_init() function in OpenSSL.
+*   All the inputs are passed form the above OpenSSL layer to the
+*   corresponding API cpaCySymInitSession() function.
+*   It is the first function called in AES cipher routine sequences,
+*   in order to initialize the cipher ctx structure and CpaCySymSession.
+*   The function will return 1 if successful.
+******************************************************************************/
+static int
+qat_aes_128_cbc_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                     const unsigned char *iv, int enc)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return cipher_init(ctx, key, iv, enc, AES128);
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_128_cbc_do_cipher(EVP_CIPHER_CTX *ctx,
+*                                   unsigned char *out,
+*                                   const unsigned char *in,
+*                                   size_t inl)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN] - pointer to input data
+* @param inl [IN] - Message length to cipher in bytes
+*
+* description:
+*    This function is rewrite of aes_128_cbc_do_cipher() in OpenSSL.
+*    All the inputs are passed form the above OpenSSL layer to the
+*    corresponding API cpaCySymPerformOp() function.
+*    The function encrypt inl bytes from the buffer pointer in and writes
+*    the encrypted version to the output pointer.
+*    It is the second function called in AES cipher routine sequences
+*    and return 1 if successful
+******************************************************************************/
+static int
+qat_aes_128_cbc_do_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                          const unsigned char *in, size_t inl)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return do_cipher(ctx, out, in, inl, AES128);
+}
+
+/******************************************************************************
+* function:
+*         common_cipher_cleanup(EVP_CIPHER_CTX *ctx)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+*
+* description:
+*    This function is rewrite of aes_xxx_cbc_cleanup() in OpenSSL. The function is design
+*    to clears all information form a cipher context and free up any allocated memory
+*    associate it. It is the last function called in AES cipher routine sequences
+*    in order to make sure the sensitive information does not remain in memory.
+*    The function will return 1 if successful
+******************************************************************************/
+static int common_cipher_cleanup(EVP_CIPHER_CTX      *ctx)
+{
+    CpaStatus sts = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    qat_ctx *qat_context = NULL;
+
+    DEBUG("[%s] --- cleaning\n\n", __func__);
+
+    if (!ctx)
+    {
+        WARN("[%s] --- ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (!ctx->app_data)
+    {
+        WARN("[%s] --- ctx->app_data is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->app_data);
+
+    pSessionCtx = qat_context->ctx;
+
+    if ((sts =
+         cpaCySymRemoveSession(qat_context->instanceHandle,
+                               pSessionCtx)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymRemoveSession failed, sts = %d.\n",
+             __func__, sts);
+        return 0;
+    }
+
+    if (pSessionCtx)
+        qaeMemFree (pSessionCtx);
+    if (qat_context->srcPrivateMetaData)
+        qaeMemFree (qat_context->srcPrivateMetaData);
+    if (qat_context->dstPrivateMetaData)
+        qaeMemFree (qat_context->dstPrivateMetaData);
+
+    if (qat_context)
+    {
+        OPENSSL_free(qat_context);
+        ctx->app_data = NULL;
+    }
+
+    return 1;
+
+}
+
+/******************************************************************************
+* function:
+*         qat_rc4_init(EVP_CIPHER_CTX      *ctx,
+*                      const unsigned char *key,
+*                      const unsigned char *iv,
+*                      int                  enc)
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value
+* @param iv  [IN] - pointer to initial vector (not used for RC4.)
+* @param enc [IN] - encryption indicator
+*
+* description:
+*   This function is a rewrite of rc4_init() function in OpenSSL.
+*   All the inputs are passed form the above OpenSSL layer to the
+*   corresponding API cpaCySymInitSession() function.
+*   It is the first function called in RC4 cipher routine sequences,
+*   in order to initialize the cipher ctx structure and CpaCySymSession.
+*   The function will return 1 if successful.
+******************************************************************************/
+static int
+qat_rc4_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+             const unsigned char *iv, int enc)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return cipher_init(ctx, key, iv, enc, RC_4);
+}
+
+/******************************************************************************
+* function:
+*         qat_rc4_do_cipher(EVP_CIPHER_CTX      *ctx,
+*                           unsigned char       *out,
+*                           const unsigned char *in,
+*                           size_t              inl)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN]  - pointer to input data
+* @param inl [IN]  - Message length to cipher in bytes
+*
+* description:
+*    This function is rewrite of rc4_do_cipher() in OpenSSL.
+*    All the inputs are passed form the above OpenSSL layer to the
+*    corresponding API cpaCySymPerformOp() function.
+*    The function encrypts inl bytes from the buffer pointer in and writes
+*    the encrypted version to the output pointer.
+*    It is the second function called in RC4 cipher routine sequences
+*    and return 1 if successful
+******************************************************************************/
+static int
+qat_rc4_do_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                  const unsigned char *in, size_t inl)
+{
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    CpaCySymOpData OpData = { 0, };
+    CpaBufferList srcBufferList = { 0, };
+    CpaFlatBuffer srcFlatBuffer = { 0, };
+    CpaBufferList dstBufferList = { 0, };
+    CpaFlatBuffer dstFlatBuffer = { 0, };
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    struct op_done opDone;
+    int in_place = 0;
+
+    DEBUG("\n[%s] --- do_cipher BEGIN\n", __func__);
+
+    if ((!in) || (!out) || (!ctx))
+    {
+        WARN("[%s] --- in, out or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->app_data);
+    pSessionCtx = qat_context->ctx;
+
+    OpData.sessionCtx = pSessionCtx;
+    OpData.packetType = CPA_CY_SYM_PACKET_TYPE_PARTIAL;
+
+    /* Note, IV parameters not set for RC4 */
+    if (zero_copy_memory_mode)
+    {
+        srcFlatBuffer.pData = (Cpa8U *) in;
+        dstFlatBuffer.pData = (Cpa8U *) out;
+    }
+    else
+    {
+        srcFlatBuffer.pData = (Cpa8U *) copyAllocPinnedMemory ((void*)in, inl);
+        in_place = 1;
+    }
+    /* Starting point for cipher processing - given as number of bytes from
+       start of data in the source buffer. The result of the cipher operation
+       will be written back into the output buffer starting at this location. */
+    OpData.cryptoStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the crypto
+       operation will be computed on. This must be a multiple to the block size 
+       if a block cipher is being used. This is also the same as the result
+       length. */
+    OpData.messageLenToCipherInBytes = inl;
+    /* Starting point for hash processing - given as number of bytes from start 
+       of packet in source buffer. */
+    OpData.hashStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the hash will be 
+       computed on. */
+    OpData.messageLenToHashInBytes = 0;
+    /* Pointer to the location where the digest result either exists or will be 
+       inserted. */
+    OpData.pDigestResult = NULL;
+    /* Pointer to Additional Authenticated Data (AAD) needed for authenticated
+       cipher mechanisms - CCM and GCM. */
+    OpData.pAdditionalAuthData = NULL;
+    /* Compute the digest and compare it to the digest contained at the
+       location pointed to by pDigestResult. */
+
+    srcFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    srcBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    srcBufferList.pBuffers = &srcFlatBuffer;
+    srcBufferList.pUserData = NULL;
+
+    srcBufferList.pPrivateMetaData = qat_context->srcPrivateMetaData;
+
+    dstFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    dstBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    dstBufferList.pBuffers = &dstFlatBuffer;
+    /* This is an opaque field that is not read or modified internally. */
+    dstBufferList.pUserData = NULL;
+
+    dstBufferList.pPrivateMetaData = qat_context->dstPrivateMetaData;
+
+    initOpDone(&opDone);
+
+    /*  Note that RC4 partial packet processing must be done in
+     *  place.  i.e. source and dest buffer must be the same.  If
+     *  in user memory mode we allocate the buffers to be the same
+     *  ourselves.  For zero copy mode responsibity is with the 
+     *  caller to ensure buffers are the same.  We do not copy
+     *  src to dst since the caller has explicitly set zero-copy
+     *  mode to avoid copies.
+     */
+
+    if ((sts = myPerformOp(qat_context->instanceHandle,
+                           &opDone,
+                           &OpData,
+                           &srcBufferList,
+                           in_place ? &srcBufferList : &dstBufferList,
+                           CPA_FALSE )) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        qaeMemFree (srcBufferList.pPrivateMetaData);
+        qaeMemFree (dstBufferList.pPrivateMetaData);
+        return 0;
+    }
+
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+
+    if (!zero_copy_memory_mode)
+    {
+        copyFreePinnedMemory (out, srcFlatBuffer.pData, inl);
+    }
+	
+    DEBUG("[%s] --- do_cipher END\n\n", __func__);
+
+    return 1;
+}
+/******************************************************************************
+* function:
+*         qat_des_ede3_cbc_init(EVP_CIPHER_CTX *ctx,
+*                               const unsigned char *key,
+*                               const unsigned char *iv,
+*                               int enc)
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value
+* @param iv  [IN] - pointer to initial vector
+* @param enc [IN] - encryption indicator
+*
+* description:
+*    This function is rewrite of des_ede3_cbc_init() function in OpenSSL.
+*    All the inputs are pass from OpenSSL above layer down to the corresponding API
+*    cpaCySymInitSession() function. It is the first function called in DES3 cipher routine
+*    sequences, in order to initialize the cipher ctx structure and CpaCySymSession.
+*    The function will return 1 if successful
+******************************************************************************/
+static int
+qat_des_ede3_cbc_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                      const unsigned char *iv, int enc)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return cipher_init(ctx, key, iv, enc, DES3);
+}
+
+/******************************************************************************
+* function:
+*         qat_des_ede3_cbc_do_cipher(EVP_CIPHER_CTX *ctx,
+*                                    unsigned char *out,
+*                                    const unsigned char *in,
+*                                    size_t inl)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN] - pointer to input data
+* @param inl [IN] - Message length to cipher in bytes
+*
+* description:
+*   This function is rewrite of des_ede3_cbc_do_cipher() in OpenSSL.
+*   All the inputs are pass form the above OpenSSL layer to the
+*   corresponding API cpaCySymPerformOp() function.
+*   The function encrypt inl bytes from the buffer pointer "in"
+*   and writes the encrypted version to output pointer.
+*   It is the second function called in DES3 cipher routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int
+qat_des_ede3_cbc_do_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                           const unsigned char *in, size_t inl)
+{
+
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    CpaCySymOpData OpData = { 0, };
+    CpaBufferList srcBufferList = { 0, };
+    CpaFlatBuffer srcFlatBuffer = { 0, };
+    CpaBufferList dstBufferList = { 0, };
+    CpaFlatBuffer dstFlatBuffer = { 0, };
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    struct op_done opDone;
+
+    DEBUG("\n[%s] --- do_cipher BEGIN\n", __func__);
+
+    if ((!in) || (!out) || (!ctx))
+    {
+        WARN("[%s] --- in, out or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if ((!ctx->app_data))
+    {
+        WARN("[%s] --- app_data is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->app_data);
+    pSessionCtx = qat_context->ctx;
+
+    OpData.sessionCtx = pSessionCtx;
+    OpData.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+    /* Initialization Vector or Counter. */
+
+    if (zero_copy_memory_mode)
+    {
+        OpData.pIv = (Cpa8U *) ctx->iv;
+        srcFlatBuffer.pData = (Cpa8U *) in;
+        dstFlatBuffer.pData = (Cpa8U *) out;
+    }
+    else
+    {
+        OpData.pIv = (Cpa8U *) copyAllocPinnedMemory (ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+        srcFlatBuffer.pData = (Cpa8U *) copyAllocPinnedMemory ((void*)in, inl);
+        dstFlatBuffer.pData = (Cpa8U *) qaePinnedMemAlloc (inl);
+    }
+    /* Cipher IV length in bytes.  Determines the amount of valid IV data
+       pointed to by the pIv parameter. */
+    OpData.ivLenInBytes = (Cpa32U) EVP_CIPHER_CTX_iv_length(ctx);
+    /* Starting point for cipher processing - given as number of bytes from
+       start of data in the source buffer. The result of the cipher operation
+       will be written back into the output buffer starting at this location. */
+    OpData.cryptoStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the crypto
+       operation will be computed on. This must be a multiple to the block size 
+       if a block cipher is being used. This is also the same as the result
+       length. */
+    OpData.messageLenToCipherInBytes = inl;
+    /* Starting point for hash processing - given as number of bytes from start 
+       of packet in source buffer. */
+    OpData.hashStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the hash will be 
+       computed on. */
+    OpData.messageLenToHashInBytes = 0;
+    /* Pointer to the location where the digest result either exists or will be 
+       inserted. */
+    OpData.pDigestResult = NULL;
+    /* Pointer to Additional Authenticated Data (AAD) needed for authenticated
+       cipher mechanisms - CCM and GCM. */
+    OpData.pAdditionalAuthData = NULL;
+
+
+    srcFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    srcBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    srcBufferList.pBuffers = &srcFlatBuffer;
+    srcBufferList.pUserData = NULL;
+
+    srcBufferList.pPrivateMetaData = qat_context->srcPrivateMetaData;
+
+    dstFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    dstBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    dstBufferList.pBuffers = &dstFlatBuffer;
+    dstBufferList.pUserData = NULL;
+
+    dstBufferList.pPrivateMetaData = qat_context->dstPrivateMetaData;
+
+    initOpDone(&opDone);
+
+    if ((sts = myPerformOp(qat_context->instanceHandle,
+                           &opDone,
+                           &OpData,
+                           &srcBufferList,
+                           &dstBufferList,
+                           CPA_FALSE )) != CPA_STATUS_SUCCESS)                         
+    {
+        WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        qaeMemFree (srcBufferList.pPrivateMetaData);
+        qaeMemFree (dstBufferList.pPrivateMetaData);
+        return 0;
+    }
+
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+
+    /*  If encrypting, the IV is the last block of the destination (ciphertext)
+     *  buffer.  If decrypting, the source buffer is the ciphertext.
+     */
+    if (qat_context->enc)
+    {
+        memcpy(ctx->iv,
+               dstBufferList.pBuffers[0].pData + inl - DES_BLOCK_SIZE,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+    else
+    {
+        memcpy(ctx->iv,
+               srcBufferList.pBuffers[0].pData + inl - DES_BLOCK_SIZE,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+
+    if (!zero_copy_memory_mode)
+    {
+        qaeMemFree (OpData.pIv);
+        qaeMemFree (srcFlatBuffer.pData);
+        copyFreePinnedMemory (out, dstFlatBuffer.pData, inl);
+    }
+
+    DEBUG ("%s inl=%d\n", __func__, (int) inl);
+    DEBUG("[%s] --- do_cipher END\n\n", __func__);
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_des_cbc_init(EVP_CIPHER_CTX *ctx,
+*                          const unsigned char *key,
+*                          const unsigned char *iv,
+*                          int enc)
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value
+* @param iv  [IN] - pointer to initial vector
+* @param enc [IN] - encryption indicator
+*
+* description:
+*    This function is rewrite of des_cbc_init() function in OpenSSL.
+*    All the inputs are pass from OpenSSL above layer down to the corresponding API
+*    cpaCySymInitSession() function. It is the first function called in DES3 cipher routine
+*    sequences, in order to initialize the cipher ctx structure and CpaCySymSession.
+*    The function will return 1 if successful
+******************************************************************************/
+static int
+qat_des_cbc_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                 const unsigned char *iv, int enc)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return cipher_init(ctx, key, iv, enc, DES);
+}
+
+/******************************************************************************
+* function:
+*         qat_des_cbc_do_cipher(EVP_CIPHER_CTX *ctx,
+*                               unsigned char *out,
+*                               const unsigned char *in,
+*                               size_t inl)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN] - pointer to input data
+* @param inl [IN] - Message length to cipher in bytes
+*
+* description:
+*   This function is rewrite of des_cbc_do_cipher() in OpenSSL.
+*   All the inputs are pass form the above OpenSSL layer to the
+*   corresponding API cpaCySymPerformOp() function.
+*   The function encrypt inl bytes from the buffer pointer "in"
+*   and writes the encrypted version to output pointer.
+*   It is the second function called in DES3 cipher routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int
+qat_des_cbc_do_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                      const unsigned char *in, size_t inl)
+{
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    CpaCySymOpData OpData = { 0, };
+    CpaBufferList srcBufferList = { 0, };
+    CpaFlatBuffer srcFlatBuffer = { 0, };
+    CpaBufferList dstBufferList = { 0, };
+    CpaFlatBuffer dstFlatBuffer = { 0, };
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    struct op_done opDone;
+
+    DEBUG("\n[%s] --- do_cipher BEGIN\n", __func__);
+
+    if ((!in) || (!out) || (!ctx))
+    {
+        WARN("[%s] --- in, out or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->app_data);
+    pSessionCtx = qat_context->ctx;
+
+    OpData.sessionCtx = pSessionCtx;
+    OpData.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+
+    /* Initialization Vector or Counter. */
+    if (zero_copy_memory_mode)
+    {
+        OpData.pIv = (Cpa8U *) ctx->iv;
+        srcFlatBuffer.pData = (Cpa8U *) in;
+        dstFlatBuffer.pData = (Cpa8U *) out;
+    }
+    else
+    {
+        OpData.pIv = (Cpa8U *) copyAllocPinnedMemory (ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+        srcFlatBuffer.pData = (Cpa8U *) copyAllocPinnedMemory ((void*)in, inl);
+        dstFlatBuffer.pData = (Cpa8U *) qaePinnedMemAlloc (inl);
+    }
+		
+    /* Cipher IV length in bytes.  Determines the amount of valid IV data
+       pointed to by the pIv parameter. */
+    OpData.ivLenInBytes = (Cpa32U) EVP_CIPHER_CTX_iv_length(ctx);
+    /* Starting point for cipher processing - given as number of bytes from
+       start of data in the source buffer. The result of the cipher operation
+       will be written back into the output buffer starting at this location. */
+    OpData.cryptoStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the crypto
+       operation will be computed on. This must be a multiple to the block size 
+       if a block cipher is being used. This is also the same as the result
+       length. */
+    OpData.messageLenToCipherInBytes = inl;
+    /* Starting point for hash processing - given as number of bytes from start 
+       of packet in source buffer. */
+    OpData.hashStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the hash will be 
+       computed on. */
+    OpData.messageLenToHashInBytes = 0;
+    /* Pointer to the location where the digest result either exists or will be 
+       inserted. */
+    OpData.pDigestResult = NULL;
+    /* Pointer to Additional Authenticated Data (AAD) needed for authenticated
+       cipher mechanisms - CCM and GCM. */
+    OpData.pAdditionalAuthData = NULL;
+
+
+    srcFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    srcBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    srcBufferList.pBuffers = &srcFlatBuffer;
+    srcBufferList.pUserData = NULL;
+
+    srcBufferList.pPrivateMetaData = qat_context->srcPrivateMetaData;
+
+    dstFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    dstBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    dstBufferList.pBuffers = &dstFlatBuffer;
+    dstBufferList.pUserData = NULL;
+
+    dstBufferList.pPrivateMetaData = qat_context->dstPrivateMetaData;
+
+    initOpDone(&opDone);
+
+    if ((sts = myPerformOp(qat_context->instanceHandle,
+                           &opDone,
+                           &OpData,
+                           &srcBufferList,
+                           &dstBufferList,
+                           CPA_FALSE)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        qaeMemFree (srcBufferList.pPrivateMetaData);
+        qaeMemFree (dstBufferList.pPrivateMetaData);
+        return 0;
+    }
+
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+
+    /*  If encrypting, the IV is the last block of the destination (ciphertext)
+     *  buffer.  If decrypting, the source buffer is the ciphertext.
+     */
+    if (qat_context->enc)
+    {
+        memcpy(ctx->iv,
+               dstBufferList.pBuffers[0].pData + inl - DES_BLOCK_SIZE,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+    else
+    {
+        memcpy(ctx->iv,
+               srcBufferList.pBuffers[0].pData + inl - DES_BLOCK_SIZE,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+
+    if (!zero_copy_memory_mode)
+    {
+        if(OpData.pIv)
+		qaeMemFree (OpData.pIv);
+        if(srcFlatBuffer.pData)
+        	qaeMemFree (srcFlatBuffer.pData);
+        
+        copyFreePinnedMemory (out, dstFlatBuffer.pData, inl);
+    }
+
+    DEBUG("[%s] --- do_cipher END\n\n", __func__);
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_sha1_session_init(EVP_MD_CTX *ctx_out,
+*                          const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* @retval 0      function succeeded
+* @retval 1      function failed
+*
+* description:
+*    This function synchronises the initialisation of the QAT session and
+*  pre-allocates the necessary buffers for the session.
+******************************************************************************/
+#define data(ctx) ((qat_chained_ctx *)(ctx)->cipher_data)
+#define HMAC_KEY_SIZE 64
+#define TLS_VIRT_HDR_SIZE 13
+
+static int qat_aes_sha1_session_init(EVP_CIPHER_CTX *ctx)
+{
+    qat_chained_ctx* evp_ctx = data(ctx);
+    CpaCySymSessionSetupData *sessionSetupData = NULL;
+    Cpa32U sessionCtxSize = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    Cpa32U metaSize = 0;
+ 
+    /* All parameters have not been set yet. */
+    if(evp_ctx->initParamsSet != 1)
+        return 0;
+ 
+    sessionSetupData = evp_ctx->session_data;
+ 
+    evp_ctx->instanceHandle = get_next_inst();
+    if (cpaCySymSessionCtxGetSize(evp_ctx->instanceHandle, sessionSetupData,
+                        &sessionCtxSize) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymSessionCtxGetSize failed.\n", __func__);
+        return 0;
+    }
+ 
+    pSessionCtx = (CpaCySymSessionCtx) qaePinnedMemAlloc(sessionCtxSize);
+ 
+    if (pSessionCtx == NULL)
+    {
+        WARN("[%s] --- pSessionCtx malloc failed !\n", __func__);
+        return 0;
+    }
+    
+   if(ctx->encrypt)
+       sessionSetupData->verifyDigest = CPA_FALSE;
+   else
+       sessionSetupData->verifyDigest = CPA_TRUE;
+
+   sessionSetupData->digestIsAppended =  CPA_TRUE;
+   
+
+    if (cpaCySymInitSession(evp_ctx->instanceHandle, qat_callbackFn, sessionSetupData,
+              pSessionCtx) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymInitSession failed.\n", __func__);
+        qaeMemFree(pSessionCtx);
+        return 0;
+    }
+ 
+    evp_ctx->qat_ctx = pSessionCtx;
+ 
+    evp_ctx->srcBufferList.numBuffers = 2;
+    evp_ctx->srcBufferList.pBuffers = (evp_ctx->srcFlatBuffer);
+    evp_ctx->srcBufferList.pUserData = NULL;
+ 
+    evp_ctx->dstBufferList.numBuffers = 2;
+    evp_ctx->dstBufferList.pBuffers = (evp_ctx->dstFlatBuffer);
+    evp_ctx->dstBufferList.pUserData = NULL;
+
+    /* setup meta data for buffer lists */
+    if (cpaCyBufferListGetMetaSize(evp_ctx->instanceHandle,
+                                   evp_ctx->srcBufferList.numBuffers,
+                                   &metaSize) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed.\n",__func__);
+        return 0;
+    }
+ 
+    if (metaSize)
+    {
+        evp_ctx->srcBufferList.pPrivateMetaData = qaePinnedMemAlloc(metaSize);
+        if (!(evp_ctx->srcBufferList.pPrivateMetaData))
+        {
+            WARN("[%s] --- srcBufferList.pPrivateMetaData is NULL.\n", __func__);
+            return 0;
+        }
+    } else
+    {
+        evp_ctx->srcBufferList.pPrivateMetaData = NULL;
+    }
+    metaSize = 0;
+
+    if (cpaCyBufferListGetMetaSize(evp_ctx->instanceHandle,
+                                   evp_ctx->dstBufferList.numBuffers,
+                                   &metaSize) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed.\n",__func__);
+        return 0;
+    }
+ 
+    if (metaSize)
+    {
+        evp_ctx->dstBufferList.pPrivateMetaData = qaePinnedMemAlloc(metaSize);
+        if (!(evp_ctx->dstBufferList.pPrivateMetaData))
+        {
+            WARN("[%s] --- dstBufferList.pPrivateMetaData is NULL.\n", __func__);
+            return 0;
+        }
+    } else
+    {
+        evp_ctx->dstBufferList.pPrivateMetaData = NULL;
+    }
+
+    /* Create the OpData structure to remove this processing from the data path */
+    evp_ctx->OpData.sessionCtx = evp_ctx->qat_ctx;
+    evp_ctx->OpData.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+ 
+    evp_ctx->OpData.pIv = evp_ctx->pIv;
+    evp_ctx->OpData.ivLenInBytes = (Cpa32U)EVP_CIPHER_CTX_iv_length(ctx);
+ 
+    evp_ctx->OpData.cryptoStartSrcOffsetInBytes = TLS_VIRT_HDR_SIZE;
+ 
+    evp_ctx->OpData.hashStartSrcOffsetInBytes = 0;
+    evp_ctx->OpData.pAdditionalAuthData = NULL;
+    
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_cbc_hmac_sha1_init(EVP_CIPHER_CTX *ctx,
+*                                    const unsigned char *inkey,
+*                                    const unsigned char *iv, int enc)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param inKey  [IN]  - input cipher key
+* @param iv     [IN]  - initialisation vector
+* @param enc    [IN]  - 1 encrypt 0 decrypt
+*
+* @retval 0      function succeeded
+* @retval 1      function failed
+*
+* description:
+*    This function initialises the cipher and hash algorithm parameters for this
+*  EVP context.
+*
+******************************************************************************/
+static int qat_aes_cbc_hmac_sha1_init(EVP_CIPHER_CTX *ctx,
+                        const unsigned char *inkey,
+                        const unsigned char *iv, int enc)
+{
+    /* Initialise a QAT session  and set the cipher keys*/
+    qat_chained_ctx* evp_ctx = data(ctx);
+    CpaCySymSessionSetupData *sessionSetupData = NULL;
+
+    evp_ctx->session_data = OPENSSL_malloc(sizeof(CpaCySymSessionSetupData));
+    if(NULL == evp_ctx->session_data)
+    {
+        WARN("qaePinnedMemAlloc() failed for session setup data allocation.\n");
+        return 0;
+    }
+ 
+    sessionSetupData = evp_ctx->session_data;
+ 
+    if ((!inkey) || (!iv) || (!ctx))
+    {
+        WARN("[%s] --- key, iv or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    DUMPL("iv", iv, EVP_CIPHER_CTX_iv_length(ctx));
+    DUMPL("key", inkey, EVP_CIPHER_CTX_key_length(ctx));
+ 
+    /* Priority of this session */
+    sessionSetupData->sessionPriority = CPA_CY_PRIORITY_HIGH;
+    sessionSetupData->symOperation = CPA_CY_SYM_OP_ALGORITHM_CHAINING;
+ 
+    /* Cipher algorithm and mode */
+    sessionSetupData->cipherSetupData.cipherAlgorithm = CPA_CY_SYM_CIPHER_AES_CBC;
+    /* Cipher key length 256 bits (32 bytes) */
+    sessionSetupData->cipherSetupData.cipherKeyLenInBytes = (Cpa32U)EVP_CIPHER_CTX_key_length(ctx);
+    /* Cipher key */
+    if(NULL == (sessionSetupData->cipherSetupData.pCipherKey = OPENSSL_malloc(EVP_CIPHER_CTX_key_length(ctx))))
+    {
+        WARN("[%s] --- unable to allocate memory for Cipher key.\n", __func__);
+	return 0;
+    }
+	
+    memcpy(sessionSetupData->cipherSetupData.pCipherKey, inkey, EVP_CIPHER_CTX_key_length(ctx));
+ 
+    /* Operation to perform */
+    if(enc)
+    {
+        sessionSetupData->cipherSetupData.cipherDirection = CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+        sessionSetupData->algChainOrder = CPA_CY_SYM_ALG_CHAIN_ORDER_HASH_THEN_CIPHER;
+    } else
+    {
+        sessionSetupData->cipherSetupData.cipherDirection = CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+        sessionSetupData->algChainOrder = CPA_CY_SYM_ALG_CHAIN_ORDER_CIPHER_THEN_HASH;
+    }
+
+    /* Hash Configuration */
+    sessionSetupData->hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA1;
+    sessionSetupData->hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+    sessionSetupData->hashSetupData.digestResultLenInBytes = SHA1_SIZE;
+    sessionSetupData->hashSetupData.authModeSetupData.aadLenInBytes = 0;
+ 
+    /* copy iv value to ctx */
+    memcpy(ctx->iv, iv, EVP_CIPHER_CTX_iv_length(ctx));
+ 
+    /* Pre-allocate necessary memory */
+    evp_ctx->tls_virt_hdr = qaePinnedMemAlloc(TLS_VIRT_HDR_SIZE);
+    if(NULL == evp_ctx->tls_virt_hdr)
+    {
+        WARN("[%s] Unable to allcoate memory for MAC preamble\n", __func__);
+        return 0;
+    }
+    memset(evp_ctx->tls_virt_hdr, 0, TLS_VIRT_HDR_SIZE);
+    evp_ctx->srcFlatBuffer[0].pData = evp_ctx->tls_virt_hdr;
+    evp_ctx->srcFlatBuffer[0].dataLenInBytes = TLS_VIRT_HDR_SIZE;
+    evp_ctx->dstFlatBuffer[0].pData = evp_ctx->srcFlatBuffer[0].pData;
+    evp_ctx->dstFlatBuffer[0].dataLenInBytes = TLS_VIRT_HDR_SIZE;
+
+    evp_ctx->hmac_key = qaePinnedMemAlloc(HMAC_KEY_SIZE);
+    if(NULL == evp_ctx->hmac_key)
+    {
+        WARN("[%s] Unable to allocate memory or HMAC Key\n", __func__);
+        return 0;
+    }
+    memset(evp_ctx->hmac_key, 0, HMAC_KEY_SIZE);
+    sessionSetupData->hashSetupData.authModeSetupData.authKey = evp_ctx->hmac_key;
+    sessionSetupData->hashSetupData.authModeSetupData.authKeyLenInBytes = HMAC_KEY_SIZE; 
+
+    evp_ctx->pIv = qaePinnedMemAlloc(EVP_CIPHER_CTX_iv_length(ctx));
+    if(!evp_ctx->pIv)
+    {
+        WARN("[%s] --- pIv is NULL.\n", __func__);
+        return 0;
+    }
+ 
+    evp_ctx->initParamsSet = 1;
+    qat_aes_sha1_session_init(ctx);
+    evp_ctx->payload_length = 0;
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+*                                 const unsigned char *in, size_t len)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param out   [OUT]  - output buffer for transform result
+* @param in     [IN]  - input buffer
+* @param len    [IN]  - length of input buffer
+*
+* @retval 0      function succeeded
+* @retval 1      function failed
+*
+* description:
+*    This function perfrom the cryptographic transfornm according to the
+*  parameters setup during initialisation.
+*
+******************************************************************************/
+static int qat_aes_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                        const unsigned char *in, size_t len)
+{
+    CpaStatus sts = 0;
+    unsigned int pad_len = 0;
+    struct op_done opDone;
+    qat_chained_ctx *evp_ctx = data(ctx);
+    int retVal = 0;
+    size_t plen = evp_ctx->payload_length,
+           iv   = 0; /* explicit IV in TLS 1.1 and later */
+
+    if (len%AES_BLOCK_SIZE) return 0;
+ 
+    if (plen==0)
+        plen = len;
+    else if (ctx->encrypt && len!=((plen+SHA_DIGEST_LENGTH+AES_BLOCK_SIZE)&-AES_BLOCK_SIZE))
+        return 0;
+#ifdef TLS1_1_VERSION
+    else if (evp_ctx->tls_version >= TLS1_1_VERSION)
+    {
+        iv = AES_BLOCK_SIZE;
+	memcpy(evp_ctx->OpData.pIv, in, EVP_CIPHER_CTX_iv_length(ctx));
+	/* Note: The OpenSSL framework assumes that the IV field will be part of the 
+         * encrypted data, yet never looks at the output of the encryptio/decryption
+         * process for this field. In order to chain HASH and CIPHER we need to present
+         * contiguous SGL to QAT, thus we need to copy the IV from input to output in
+         * in order to skip this field in encryption */ 
+        if(in != out)
+            memcpy(out, in, EVP_CIPHER_CTX_iv_length(ctx));
+	in += iv;
+        out += iv;	
+	len -= iv;
+	evp_ctx->payload_length -= iv;
+	plen -= iv;
+    }
+#endif
+    else    
+	memcpy(evp_ctx->OpData.pIv, ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+ 
+    /* Build request/response buffers */
+    if (zero_copy_memory_mode)
+    {
+        evp_ctx->srcFlatBuffer[1].pData = (Cpa8U*)in;
+        evp_ctx->dstFlatBuffer[1].pData = (Cpa8U*)out;
+    } else
+    {
+        evp_ctx->srcFlatBuffer[1].pData = qaePinnedMemAlloc(len);
+        if(!(evp_ctx->srcFlatBuffer[1].pData))
+        {
+            WARN("[%s] --- src/dst buffer allocation.\n", __func__);
+            return 0;
+        }
+        evp_ctx->dstFlatBuffer[1].pData = evp_ctx->srcFlatBuffer[1].pData;
+        memcpy(evp_ctx->dstFlatBuffer[1].pData, in, len);
+    }
+    evp_ctx->srcFlatBuffer[1].dataLenInBytes = len;
+    evp_ctx->srcBufferList.pUserData = NULL;
+    evp_ctx->dstFlatBuffer[1].dataLenInBytes = len;
+    evp_ctx->dstBufferList.pUserData = NULL;
+	
+    evp_ctx->OpData.messageLenToCipherInBytes = len;
+
+    if(!(ctx->encrypt))
+    {
+        AES_KEY aes_key;
+        unsigned char in_blk[AES_BLOCK_SIZE] = {0x0};
+        unsigned char *key = evp_ctx->session_data->cipherSetupData.pCipherKey;
+        unsigned int  key_len = EVP_CIPHER_CTX_key_length(ctx);
+        unsigned char ivec[AES_BLOCK_SIZE] = {0x0};
+        unsigned char out_blk[AES_BLOCK_SIZE] = {0x0};
+
+        key_len = key_len * 8; //convert to bits
+        memcpy(in_blk, (in + (len - AES_BLOCK_SIZE)), AES_BLOCK_SIZE);
+        memcpy(ivec, (in + (len - (AES_BLOCK_SIZE + AES_BLOCK_SIZE))), AES_BLOCK_SIZE);
+
+        /* Dump input parameters */
+        DUMPL("Key :", key, EVP_CIPHER_CTX_key_length(ctx));
+        DUMPL("IV :", ivec, AES_BLOCK_SIZE);
+        DUMPL("Input Blk :", in_blk, AES_BLOCK_SIZE);
+ 
+        AES_set_decrypt_key(key, key_len, &aes_key);
+        AES_cbc_encrypt(in_blk, out_blk, AES_BLOCK_SIZE, &aes_key, ivec, 0);
+
+        DUMPL("Output Blk :", out_blk, AES_BLOCK_SIZE);
+
+        /* Extract pad length */
+        pad_len = out_blk[AES_BLOCK_SIZE - 1];
+ 
+        /* Calculate and update length */
+        evp_ctx->payload_length = len - (pad_len + 1 + SHA_DIGEST_LENGTH);
+       
+        evp_ctx->tls_virt_hdr[TLS_VIRT_HDR_SIZE-2] = evp_ctx->payload_length>>8;
+        evp_ctx->tls_virt_hdr[TLS_VIRT_HDR_SIZE-1] = evp_ctx->payload_length;
+ 
+        /* HMAC Length */
+        evp_ctx->OpData.messageLenToHashInBytes = TLS_VIRT_HDR_SIZE + evp_ctx->payload_length;
+
+        memcpy(evp_ctx->dstFlatBuffer[0].pData, evp_ctx->tls_virt_hdr, TLS_VIRT_HDR_SIZE);
+    }else
+    {
+        evp_ctx->OpData.messageLenToHashInBytes = TLS_VIRT_HDR_SIZE + evp_ctx->payload_length;
+    }
+
+    /* Add record padding */
+    if(ctx->encrypt)
+    {
+        plen += SHA_DIGEST_LENGTH;
+        for (pad_len=len-plen-1;plen<len;plen++) evp_ctx->dstFlatBuffer[1].pData[plen]=pad_len;
+    }
+
+    initOpDone(&opDone);
+    
+#ifdef TLS1_1_VERSION
+    if(!(ctx->encrypt) && ((evp_ctx->tls_version) < TLS1_1_VERSION)) 
+#else
+    if(!(ctx->encrypt)) 
+#endif
+        memcpy(ctx->iv, in + len - AES_BLOCK_SIZE, EVP_CIPHER_CTX_iv_length(ctx));
+
+    DEBUG("Pre Perform Op\n"); 
+    DUMPREQ(evp_ctx->instanceHandle, &opDone, &(evp_ctx->OpData), 
+   	    evp_ctx->session_data, &(evp_ctx->srcBufferList), 
+	    &(evp_ctx->dstBufferList));
+
+    if ((sts = myPerformOp(evp_ctx->instanceHandle,
+                           &opDone,
+                           &(evp_ctx->OpData),
+                           &(evp_ctx->srcBufferList),
+                           &(evp_ctx->dstBufferList),
+                           &(evp_ctx->session_data->verifyDigest))) != CPA_STATUS_SUCCESS)
+    {
+
+        WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__,
+              sts);
+        return 0;
+    }
+
+    waitForOpToComplete(&opDone);
+    
+    if(ctx->encrypt)
+        retVal = 1;
+    else if(CPA_TRUE == opDone.verifyResult)
+	retVal = 1;
+   
+    DEBUG("Post Perform Op\n"); 
+    DUMPREQ(evp_ctx->instanceHandle, &opDone, &(evp_ctx->OpData), 
+   	    evp_ctx->session_data, &(evp_ctx->srcBufferList), 
+	    &(evp_ctx->dstBufferList));
+    
+    cleanupOpDone(&opDone);
+ 
+#ifdef TLS1_1_VERSION
+    if((ctx->encrypt) && ((evp_ctx->tls_version) < TLS1_1_VERSION)) 
+#else
+    if(ctx->encrypt) 
+#endif
+        memcpy(ctx->iv, 
+	    evp_ctx->dstBufferList.pBuffers[1].pData + len - AES_BLOCK_SIZE, 
+	    EVP_CIPHER_CTX_iv_length(ctx));
+       
+    if (!zero_copy_memory_mode)
+    {
+        memcpy(out, evp_ctx->dstFlatBuffer[1].pData, len);
+	if(NULL != evp_ctx->srcFlatBuffer[1].pData)
+	{
+
+	    qaeMemFree(evp_ctx->srcFlatBuffer[1].pData);
+	    evp_ctx->srcFlatBuffer[1].pData = NULL;
+	    evp_ctx->dstFlatBuffer[1].pData = NULL;
+	}
+    } 
+
+    return retVal;
+}
+
+#if defined(NID_aes_128_cbc_hmac_sha1)
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, 
+*				int type, int arg, void *ptr)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param type   [IN]  - type of request either 
+*			EVP_CTRL_AEAD_SET_MAC_KEY or EVP_CTRL_AEAD_TLS1_AAD
+* @param arg    [IN]  - size of the pointed to by ptr
+* @param ptr    [IN]  - input buffer contain the necessary parameters
+*
+* @retval x      The return value is dependent on the type of request being made
+*	EVP_CTRL_AEAD_SET_MAC_KEY return of 1 is success
+*	EVP_CTRL_AEAD_TLS1_AAD return value indicates the amount fo padding to 
+*		be applied to the SSL/TLS record
+* @retval -1     function failed
+*
+* description:
+*    This function is a generic control interface provided by the EVP API. For 
+*  chained requests this interface is used fro setting the hmac key value for 
+*  authentication of the SSL/TLS record. The second type is used to specify the
+*  TLS virtual header which is used in the authentication calculationa nd to 
+*  identify record payload size.
+*
+******************************************************************************/
+static int qat_aes_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
+{
+
+    qat_chained_ctx *evp_ctx = data(ctx);
+    int retVal = 0;
+    CpaCySymSessionSetupData* sessionSetupData = evp_ctx->session_data;
+
+    switch (type)
+    {
+        case EVP_CTRL_AEAD_SET_MAC_KEY:
+        {
+            unsigned char *hmac_key = evp_ctx->hmac_key;
+ 
+            if(NULL == hmac_key)
+            {
+                WARN("HMAC Key is NULL");
+                return -1;
+            } 
+ 
+            memset (hmac_key,0,HMAC_KEY_SIZE);
+ 
+            if (arg > HMAC_KEY_SIZE) 
+	     {
+	        SHA1_Init(&(evp_ctx->key_wrap));
+                SHA1_Update(&(evp_ctx->key_wrap),ptr,arg);
+                SHA1_Final(hmac_key,&(evp_ctx->key_wrap));
+                sessionSetupData->hashSetupData.authModeSetupData.authKeyLenInBytes = HMAC_KEY_SIZE;
+            } else 
+	    {
+                memcpy(hmac_key,ptr,arg);
+                sessionSetupData->hashSetupData.authModeSetupData.authKeyLenInBytes = arg;
+            }
+ 
+            DUMPL("hmac_key", hmac_key, arg);
+ 
+            qat_aes_sha1_session_init(ctx);
+            retVal = 1;
+            break;
+        }
+        case EVP_CTRL_AEAD_TLS1_AAD:
+        {
+            /* Values to include in the record MAC calculation are included in this type
+               This returns the amount of padding required for the send/encrypt direction */
+            unsigned char *p=ptr;
+            unsigned int   len=p[arg-2]<<8|p[arg-1];
+
+	    evp_ctx->tls_version = (p[arg-4]<<8|p[arg-3]);
+            if (ctx->encrypt)
+            {
+                evp_ctx->payload_length = len;
+                if (evp_ctx->tls_version >= TLS1_1_VERSION)
+		{
+                    len -= AES_BLOCK_SIZE;
+		    //BWILL: Why does this code reduce the len in the TLS header by the IV for the framework?
+                    p[arg-2] = len>>8;
+                    p[arg-1] = len;
+                }
+
+                if(NULL == evp_ctx->tls_virt_hdr)
+                {
+                    WARN("Unable to allocate memory for mac preamble in qat/n");
+                    return -1;
+                }
+                memcpy(evp_ctx->tls_virt_hdr, p, TLS_VIRT_HDR_SIZE);
+                DUMPL("tls_virt_hdr", evp_ctx->tls_virt_hdr, arg);
+ 
+                retVal = (int)(((len+SHA_DIGEST_LENGTH+AES_BLOCK_SIZE)&-AES_BLOCK_SIZE) - len);
+                break;
+            } else
+            {
+                if (arg>13) arg = 13;
+                memcpy(evp_ctx->tls_virt_hdr,ptr,arg);
+                evp_ctx->payload_length = arg;
+ 
+                retVal = SHA_DIGEST_LENGTH;
+                break;
+            }
+        }
+        default:
+        return -1;
+    }
+    return retVal;
+}
+#endif
+
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_cleanup(EVP_CIPHER_CTX *ctx)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function will cleanup all allocated resources required to perfrom the 
+*  cryptographic transform.
+*
+******************************************************************************/
+static int qat_aes_cbc_hmac_sha1_cleanup(EVP_CIPHER_CTX *ctx)
+{
+    qat_chained_ctx* evp_ctx = data(ctx);
+    CpaStatus sts = 0;
+    CpaCySymSessionSetupData* sessSetup = evp_ctx->session_data;
+
+    if((sts = cpaCySymRemoveSession(evp_ctx->instanceHandle, evp_ctx->qat_ctx))
+           != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] cpaCySymRemoveSession FAILED, sts = %d.!\n", __func__, sts);
+        return 0;
+    }
+ 
+    if(sessSetup)
+    {
+        if(evp_ctx->qat_ctx)
+        {
+            qaeMemFree(evp_ctx->qat_ctx);
+	    evp_ctx->qat_ctx = NULL;
+	}
+        if(sessSetup->hashSetupData.authModeSetupData.authKey)
+	{
+            qaeMemFree(sessSetup->hashSetupData.authModeSetupData.authKey);
+	    sessSetup->hashSetupData.authModeSetupData.authKey = NULL;
+	}
+	if(evp_ctx->tls_virt_hdr)
+	{
+	    qaeMemFree(evp_ctx->tls_virt_hdr);
+	    evp_ctx->tls_virt_hdr = NULL;
+	}
+        if(evp_ctx->srcBufferList.pPrivateMetaData)
+        {
+            qaeMemFree(evp_ctx->srcBufferList.pPrivateMetaData);
+            evp_ctx->srcBufferList.pPrivateMetaData = NULL;
+        }
+        if(evp_ctx->dstBufferList.pPrivateMetaData)
+        { 
+            qaeMemFree(evp_ctx->dstBufferList.pPrivateMetaData);
+            evp_ctx->dstBufferList.pPrivateMetaData = NULL;
+        }
+        if(evp_ctx->pIv)
+        {
+            qaeMemFree(evp_ctx->pIv);
+            evp_ctx->pIv = NULL;
+        
+        }
+
+	if(sessSetup->cipherSetupData.pCipherKey)
+	{
+	    OPENSSL_free(sessSetup->cipherSetupData.pCipherKey);
+	    sessSetup->cipherSetupData.pCipherKey = NULL;
+        }
+      OPENSSL_free(sessSetup);
+
+    }
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_digest_context_copy(EVP_MD_CTX *ctx_out,
+*                                 const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* @retval 0      function succeeded
+* @retval 1      function failed
+*
+* description:
+*    This function copies a context.  All buffers are also
+*    copied.
+******************************************************************************/
+static int qat_digest_context_copy (EVP_MD_CTX *ctx_out,  
+                                    const EVP_MD_CTX *ctx_in)
+{
+    qat_ctx *qat_out = NULL;
+    qat_ctx *qat_in = NULL;
+    qat_buffer *buff_in = NULL;
+    qat_buffer *buff_out = NULL;
+    int i = 0;
+
+    if ((!ctx_in) || (!ctx_out))
+    {
+        WARN("[%s] --- ctx_in or ctx_out is NULL.\n", __func__);
+        return 0;
+    }
+
+    DEBUG ("[%s] %p->%p\n", __func__, ctx_in->md_data, ctx_out->md_data);
+
+    qat_out = (qat_ctx *) (ctx_out->md_data);
+    qat_in = (qat_ctx *) (ctx_in->md_data);
+
+    /*  If source context has not yet been initialised, there is nothing
+     *  we can do except return success.
+     */
+    if (!qat_in)
+    {
+        return 1;
+    }
+
+    /*  If dest context has not been initialised, but source has, then
+     *  consider this an error since we have nowhere to copy the context
+     *  info into.  Return failure.
+     */
+    if (!qat_out)
+    {
+        WARN("[%s] --- qat_out or qat_in is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (qat_out->buff_count != 0)
+    {
+        WARN("[%s] --- ctx_out has buffers.\n", __func__);
+    }
+
+    buff_in = qat_in->first;
+    qat_out->first = NULL;
+
+    for (i = 0; i < qat_in->buff_count; i++)
+   { 
+      
+        buff_out = OPENSSL_malloc (sizeof (qat_buffer));
+        buff_out->data = copyAllocPinnedMemory ((void*) buff_in->data, buff_in->len);
+        buff_out->len = buff_in->len;
+        buff_out->next = NULL;
+
+        if (qat_out->first)
+        {
+            qat_out->last->next = buff_out;
+            qat_out->last = buff_out;
+        }
+        else
+        {
+            qat_out->first = 
+            qat_out->last = buff_out;
+        }
+
+        buff_in = buff_in->next;
+    }
+
+    qat_out->buff_count = qat_in->buff_count;
+    qat_out->buff_total = qat_in->buff_total;
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*   qat_sha1_init(EVP_MD_CTX *ctx)
+*
+*
+* @param ctx [IN] - pointer to sha ctx
+*
+* description:
+*    This function is rewrite of sha1_init() function in OpenSSL
+*    The function is design to initialize the sha ctx structure and CpaCySymSession.
+*    It is the first function called in SHA1 digest routine sequence
+*    Function will return 1 if successful
+******************************************************************************/
+static int qat_sha1_init(EVP_MD_CTX * ctx)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_init(ctx);
+}
+
+/******************************************************************************
+* function:
+*   digest_init(EVP_MD_CTX *ctx)
+*
+*
+* @param ctx [IN] - pointer to sha ctx
+* @param digestType [in] - Enum digest type
+*
+* description:
+*    This function is rewrite of sha/MD5_init() function in OpenSSL
+*    The function is design to initialize the sha ctx structure and CpaCySymSession.
+*    It is the first function called in SHA/MD5 digest routine sequence
+*    Function will return 1 if successful
+******************************************************************************/
+static int digest_init(EVP_MD_CTX * ctx)
+{
+
+    DEBUG("[%s] ---- Digest init...\n\n", __func__);
+
+    qat_ctx    *qat_context = NULL;
+    qat_buffer *buff        = NULL;
+    qat_buffer *buff_next   = NULL;
+   
+    /*  It does sometimes happen that we are asked to initialise a
+     *  context before md_data has been allocated.  We politely refuse
+     *  since we have nowhere to store our data but return success anyway.
+     *  It will be initialised later on.
+     */
+    if (ctx->md_data == NULL)
+    {
+        DEBUG ("[%s] --- qat_context not allocated.\n", __func__);
+        return 1;
+    }
+    
+    qat_context = (qat_ctx *) ctx->md_data;  
+
+    /* If this ctx has called Init before and  been updated 
+     * with out a clean or final call we must free up the buffers
+     * That were created in the update
+     */ 
+    if (qat_context->init == CTX_NOT_CLEAN)
+    {
+        DEBUG("[%s] ---- Init with unclean ctx\n", __func__);    
+
+        buff = qat_context->first;
+        
+        int i;
+        for (i = 0; i < qat_context->buff_count; i++)
+        {
+            qaeMemFree (buff->data);
+            buff_next = buff->next;
+            OPENSSL_free (buff);
+            buff = buff_next;
+        }
+
+        qat_context->first = NULL;
+        qat_context->last = NULL;
+        qat_context->buff_count = 0;
+        qat_context->buff_total = 0;
+    }
+
+    memset(ctx->md_data ,0x00, sizeof(qat_ctx));
+
+    qat_context->init = 1;
+
+    DEBUG("%s: ctx %p\n", __func__, qat_context->ctx);
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_sha1_update(EVP_MD_CTX *ctx,
+*                         const void *data,
+*                         size_t count)
+*
+* @param ctx   [IN] - pointer to sha ctx
+* @param data  [IN] - pointer to chunks of inputdata
+* @param count [IN] - message Length To Hash In Bytes
+*
+* description:
+*   This function is rewrite of sha1_update() in OpenSSL,
+*   It will be called repeatedly with chunks of target message to be
+*   ddhashed before it pass to cpaCyRsaDecrypt() function.
+*   The second function called in SHA1 digest routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int qat_sha1_update(EVP_MD_CTX * ctx, const void *data, size_t count)
+{ 
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_update(ctx,data,count);
+}
+
+/******************************************************************************
+* function:
+*         digest_update(EVP_MD_CTX *ctx,
+*                         const void *data,
+*                         size_t count)
+*
+* @param ctx   [IN] - pointer to sha ctx
+* @param data  [IN] - pointer to chunks of inputdata
+* @param count [IN] - message Length To Hash In Bytes
+*
+* description:
+*   This function is rewrite of sha/MD5_update() in OpenSSL,
+*   It will be called repeatedly with chunks of target message to be
+*   hashed before it pass to cpaCyRsaDecrypt() function.
+*   The second function called in SHA/MD5 digest routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int digest_update(EVP_MD_CTX * ctx, const void *data, size_t count)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+   
+    qat_ctx *qat_context = NULL;
+    qat_buffer *buff;
+
+    if (count == 0)
+        return 1;
+
+    if (zero_copy_memory_mode)
+    {
+        WARN("[%s] --- digest acceleration does not support zero copy.\n", __func__);
+        return 0;
+    }
+
+    if ((!ctx) || (!data))
+    {
+        WARN("[%s] --- ctx or data is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (ctx->md_data == NULL)
+    {
+        WARN("[%s] --- qat_context not allocated.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->md_data);
+   
+    if (qat_context->init == 0)
+    {
+        WARN("[%s] --- update called before init\n", __func__);
+        return 0;
+    }
+
+    if (qat_context->buff_total + count > QAT_MAX_DIGEST_CHAIN_LENGTH)
+    {
+        WARN("[%s] --- Maximum digest chain length exceeded.\n", __func__);
+        return 0;
+    }
+    
+    buff = OPENSSL_malloc (sizeof (qat_buffer));
+    if (!buff)
+    {
+        WARN("[%s] --- alloc failure.\n", __func__);
+        return 0;
+    }
+
+    buff->data = copyAllocPinnedMemory ((void*) data, count);
+    buff->len = count;
+    buff->next = NULL;
+
+    if (!buff->data)
+    {    
+        WARN("[%s] --- alloc failure.\n", __func__);
+	OPENSSL_free (buff);
+        return 0;
+    }
+
+    if (qat_context->first == NULL)
+    {
+        qat_context->first = buff;
+        qat_context->last = buff;
+    }
+    else
+    {
+        qat_context->last->next = buff;
+        qat_context->last = buff;
+    }
+
+    qat_context->buff_count++;
+    qat_context->buff_total += count;
+    qat_context->init = CTX_NOT_CLEAN;
+
+    DEBUG("%s: added buffer len %d to chain, count now %d len %d\n", 
+          __func__, (int) count, qat_context->buff_count,
+          (int) qat_context->buff_total);
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_sha1_copy(EVP_MD_CTX *ctx_out,
+*                        const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* description:
+*    This function copies a context and creates a new session
+*    to be associated with this context.  All buffers are also
+*    copied.
+******************************************************************************/
+static int qat_sha1_copy (EVP_MD_CTX *ctx_out, const EVP_MD_CTX *ctx_in)
+{
+    int sts = 1;
+
+    if(ctx_in->md_data != NULL)
+    {
+        memset(ctx_out->md_data,0x00, sizeof(qat_ctx));
+    }
+
+    sts = qat_sha1_init (ctx_out);
+
+    if (sts != 1)
+        return sts;
+
+    sts = qat_digest_context_copy (ctx_out, ctx_in);
+
+    return sts;
+}
+
+/******************************************************************************
+* function:
+*   qat_sha1_final(EVP_MD_CTX *ctx,
+*                  unsigned char *md)
+*
+* @param ctx [IN]  - pointer to sha ctx
+* @param md  [OUT] - digest message output
+*
+* description:
+*   This function is the rewrite of OpenSSL sha1_final() function.
+*   It places the digested message in md.
+*   The third function called in SHA1 digest routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int qat_sha1_final(EVP_MD_CTX * ctx, unsigned char *md)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_final(ctx,md);
+}
+
+/******************************************************************************
+* function:
+*   digest_final(EVP_MD_CTX *ctx,
+*                unsigned char *md,
+*                int digestSize  )
+*
+* @param ctx [IN]  - pointer to sha ctx
+* @param md  [OUT] - digest message output
+*
+* description:
+*   This function is the rewrite of OpenSSL sha/MD5_final() function.
+*   It places the digested message in md.
+*   The third function called in SHA/MD5 digest routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int digest_final(EVP_MD_CTX * ctx, unsigned char *md )
+{
+
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    CpaCySymOpData OpData = { 0, };
+    CpaBufferList srcBufferList = { 0, };
+    CpaFlatBuffer *srcFlatBuffer;
+    CpaStatus sts = 0;
+    Cpa32U metaSize = 0;
+    void *srcPrivateMetaData = NULL;
+    struct op_done opDone;
+    qat_ctx *qat_context = NULL;
+    qat_buffer *buff = NULL;
+    qat_buffer *buff_next = NULL;
+    int i;
+    int success = 1;
+    
+    CpaCySymSessionSetupData sessionSetupData = { 0 };
+    Cpa32U sessionCtxSize = 0;
+    CpaInstanceHandle instanceHandle;
+
+    DEBUG("[%s] --- called.\n", __func__);
+
+    if ((!ctx) || (!md))
+    {
+        WARN("[%s] --- ctx or md is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (ctx->md_data == NULL)
+    {
+        WARN("[%s] --- qat_context not allocated.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->md_data);
+
+    sessionSetupData.sessionPriority = CPA_CY_PRIORITY_HIGH;
+    sessionSetupData.symOperation = CPA_CY_SYM_OP_HASH;
+    sessionSetupData.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_PLAIN;
+    sessionSetupData.verifyDigest = CPA_FALSE;
+
+    sessionSetupData.hashSetupData.digestResultLenInBytes = ctx->digest->md_size;  
+
+ 
+    switch(ctx->digest->md_size)
+
+    {
+        case SHA1_SIZE:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA1;
+           break;
+        case SHA256_SIZE:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA256;
+           break;
+        case SHA512_SIZE:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA512;
+           break;
+        case MD5_SIZE:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_MD5;
+          break;
+        default:
+          break;
+    }
+
+    /* Operation to perform */
+    instanceHandle = get_next_inst();
+    if ((sts = cpaCySymSessionCtxGetSize(instanceHandle,
+                                         &sessionSetupData,
+                                         &sessionCtxSize)) !=
+        CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymSessionCtxGetSize failed, sts = %d.\n",
+             __func__, sts);
+        return 0;
+    }
+
+    pSessionCtx = (CpaCySymSessionCtx) qaePinnedMemAlloc (sessionCtxSize);
+    if (pSessionCtx == NULL)
+    {
+        WARN("[%s] --- pSessionCtx malloc failed.\n", __func__);
+
+        return 0;
+    }
+
+    if ((sts = cpaCySymInitSession
+         (instanceHandle, qat_callbackFn, &sessionSetupData,
+          pSessionCtx)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymInitSession failed, sts = %d.\n", __func__, sts);
+        qaeMemFree (pSessionCtx);
+        return 0;
+    }
+
+    qat_context->ctx = pSessionCtx;
+    qat_context->instanceHandle = instanceHandle;
+
+    pSessionCtx = qat_context->ctx;
+
+    /* OpData structure setup */
+    OpData.pDigestResult = qaePinnedMemAlloc (ctx->digest->md_size);
+
+    if (!OpData.pDigestResult)
+    {
+        WARN("[%s] --- alloc failure.\n", __func__);
+        return 0;
+    }
+
+    OpData.sessionCtx = pSessionCtx;
+    OpData.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+    OpData.hashStartSrcOffsetInBytes = 0;
+    OpData.messageLenToHashInBytes = qat_context->buff_total;
+    OpData.pAdditionalAuthData = NULL;
+
+    /*  Allocate meta data and flat buffer array for as many buffers
+     *  as we are holding in our context linked list.
+     */
+    if ((sts = cpaCyBufferListGetMetaSize(qat_context->instanceHandle,
+                                          qat_context->buff_count, &metaSize)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed sts=%d.\n",
+             __func__, sts);
+        return 0;
+    }
+
+    if (metaSize)
+    {
+        srcPrivateMetaData = qaePinnedMemAlloc (metaSize);
+
+        if (!srcPrivateMetaData)
+        {
+            WARN("[%s] --- srcBufferList.pPrivateMetaData is NULL.\n",
+                 __func__);
+    	    qaeMemFree (OpData.pDigestResult);
+            return 0;
+        }
+    }
+    else
+    {
+        srcPrivateMetaData = NULL;
+    }
+
+    srcFlatBuffer = qaePinnedMemAlloc (qat_context->buff_count * sizeof (CpaFlatBuffer));
+    if (srcFlatBuffer == NULL)
+    {
+        WARN("[%s] --- FlatBuffer malloc failed.\n", __func__);
+        qaeMemFree (srcPrivateMetaData);
+    	qaeMemFree (OpData.pDigestResult);
+        return 0;
+    }
+
+    /*  Populate the pData and length elements of the flat buffer array
+     *  from the context linked list of qat_buffers
+     */
+    buff = qat_context->first;
+
+    for (i = 0; i < qat_context->buff_count; i++)
+    {
+        srcFlatBuffer[i].pData = buff->data;
+        srcFlatBuffer[i].dataLenInBytes = (Cpa32U) buff->len;
+        buff = buff->next;
+    }
+
+    /* Number of pointers */
+    srcBufferList.numBuffers = qat_context->buff_count;
+    ;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    srcBufferList.pBuffers = srcFlatBuffer;
+    /* This is an opaque field that is not read or modified internally. */
+    srcBufferList.pUserData = NULL;
+
+    srcBufferList.pPrivateMetaData = srcPrivateMetaData;
+
+    initOpDone(&opDone);
+
+    if ((sts = myPerformOp(qat_context->instanceHandle,
+                           &opDone,
+                           &OpData,
+                           &srcBufferList,
+                           &srcBufferList,
+                           CPA_FALSE )) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        success = 0;
+    }
+    else
+    {
+        waitForOpToComplete(&opDone);
+        cleanupOpDone(&opDone);
+
+        memcpy(md, OpData.pDigestResult, ctx->digest->md_size);
+    }
+
+    qaeMemFree (srcPrivateMetaData);
+    qaeMemFree (srcFlatBuffer);
+    qaeMemFree (OpData.pDigestResult);
+
+    /*  Free the list of chained buffers
+     */
+    buff = qat_context->first;
+
+    for (i = 0; i < qat_context->buff_count; i++)
+    {        
+        qaeMemFree (buff->data);
+        buff_next = buff->next;
+        OPENSSL_free (buff);
+        buff = buff_next;
+    }
+
+
+    qat_context->first = NULL;
+    qat_context->last = NULL;
+    qat_context->buff_count = 0;
+    qat_context->buff_total = 0;
+
+    if ((sts =
+         cpaCySymRemoveSession(qat_context->instanceHandle,
+                               qat_context->ctx)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymRemoveSession failed, sts = %d.\n",
+             __func__, sts);
+       return 0;
+    }
+
+    qat_context->instanceHandle = NULL;
+
+    if (pSessionCtx)
+        qaeMemFree (pSessionCtx);
+
+    qat_context->ctx = NULL;
+    qat_context->init = 0;
+
+    return success;
+}
+
+/******************************************************************************
+* function:
+*   qat_sha256_init(EVP_MD_CTX *ctx)
+*
+* @param ctx [IN] - pointer to sha ctx
+*
+* description:
+*    This function is rewrite of sha256()_init in OpenSSL.
+*    The function is design to initialize the sha ctx structure and
+*    CpaCySymSession. It is the first function called in SHA256
+*    digest routine sequence and return 1 if successful
+******************************************************************************/
+static int qat_sha256_init(EVP_MD_CTX * ctx)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_init(ctx);
+}
+
+/******************************************************************************
+* function:
+*         qat_sha256_update(EVP_MD_CTX *ctx,
+*                           const void *data,
+*                           size_t count)
+*
+* @param ctx   [IN] - pointer to sha ctx
+* @param data  [IN] - pointer to chunks of inputdata
+* @param count [IN] - message Length To Hash In Bytes
+*
+* description:
+*    This function is rewrite of sha256_update() in OpenSSL
+*    The function will be called repeatedly with chunks of target message to
+*    be hashed before it pass to cpaCyRsaDecrypt() function.
+*    It is the second function called in SHA256 digest routine sequence
+*    and return 1 if successful
+******************************************************************************/
+static int qat_sha256_update(EVP_MD_CTX * ctx, const void *data, size_t count)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_update(ctx,data,count);
+}
+
+/******************************************************************************
+* function:
+*         qat_sha256_copy(EVP_MD_CTX *ctx_out,
+*                        const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* description:
+*    This function copies a context and creates a new session
+*    to be associated with this context.  All buffers are also
+*    copied.
+******************************************************************************/
+static int qat_sha256_copy (EVP_MD_CTX *ctx_out, const EVP_MD_CTX *ctx_in)
+{
+    int sts = 1;
+
+    if(ctx_in->md_data != NULL)
+    {
+        memset(ctx_out->md_data,0x00, sizeof(qat_ctx));
+    }
+
+    sts = qat_sha256_init (ctx_out);
+
+    if (sts != 1)
+        return sts;
+
+    sts = qat_digest_context_copy (ctx_out, ctx_in);
+
+    return sts;
+}
+
+/******************************************************************************
+* function:
+*         qat_sha256_final(EVP_MD_CTX *ctx,
+*                          unsigned char *md)
+*
+* @param ctx [IN]  - pointer to sha ctx
+* @param md  [OUT] - digest message output
+*
+* description:
+*    This function is the rewrite of OpenSSL sha256_final() function.
+*    It places the digested message in md.
+*    The third function called in SHA256 digest routine sequence
+*    and return 1 if successful
+******************************************************************************/
+static int qat_sha256_final(EVP_MD_CTX * ctx, unsigned char *md)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_final(ctx,md);
+}
+
+/******************************************************************************
+* function:
+*   qat_sha512_init(EVP_MD_CTX *ctx)
+*
+* @param ctx [IN] - pointer to sha ctx
+*
+* description:
+*    This function is rewrite of sha512()_init in OpenSSL.
+*    The function is design to initialize the sha ctx structure and
+*    CpaCySymSession. It is the first function called in SHA512
+*    digest routine sequence and return 1 if successful
+******************************************************************************/
+static int qat_sha512_init(EVP_MD_CTX * ctx)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_init(ctx);
+}
+
+/******************************************************************************
+* function:
+*         qat_sha512_update(EVP_MD_CTX *ctx,
+*                           const void *data,
+*                           size_t count)
+*
+* @param ctx   [IN] - pointer to sha ctx
+* @param data  [IN] - pointer to chunks of inputdata
+* @param count [IN] - message Length To Hash In Bytes
+*
+* description:
+*    This function is rewrite of sha512_update() in OpenSSL
+*    The function will be called repeatedly with chunks of target message to
+*    be hashed before it pass to cpaCyRsaDecrypt() function.
+*    It is the second function called in SHA512 digest routine sequence
+*    and return 1 if successful
+******************************************************************************/
+static int qat_sha512_update(EVP_MD_CTX * ctx, const void *data, size_t count)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_update(ctx,data,count);
+}
+
+/******************************************************************************
+* function:
+*         qat_sha512_copy(EVP_MD_CTX *ctx_out,
+*                        const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* description:
+*    This function copies a context and creates a new session
+*    to be associated with this context.  All buffers are also
+*    copied.
+******************************************************************************/
+static int qat_sha512_copy (EVP_MD_CTX *ctx_out, const EVP_MD_CTX *ctx_in)
+{
+    int sts = 1;
+
+    if(ctx_in->md_data != NULL)
+    {
+        memset(ctx_out->md_data,0x00, sizeof(qat_ctx));
+    }
+
+    sts = qat_sha512_init (ctx_out);
+
+    if (sts != 1)
+        return sts;
+
+    sts = qat_digest_context_copy (ctx_out, ctx_in);
+
+    return sts;
+}
+
+/******************************************************************************
+* function:
+*         qat_sha512_final(EVP_MD_CTX *ctx,
+*                          unsigned char *md)
+*
+* @param ctx [IN] - pointer to sha ctx
+* @param md [OUT] - digest message output
+*
+* description:
+*    This function is the rewrite of OpenSSL sha512_final() function.
+*    It places the digested message in md.
+*    The third function called in SHA512 digest routine sequence
+*    and return 1 if successful
+******************************************************************************/
+static int qat_sha512_final(EVP_MD_CTX * ctx, unsigned char *md)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_final(ctx,md);
+}
+
+/******************************************************************************
+* function:
+*          qat_md5_init(EVP_MD_CTX *ctx)
+*
+* @param ctx [IN] - pointer to sha ctx
+*
+* description:
+*    This function is rewrite of md5_init() in OpenSSL.
+*    The function is design to initialize the sha ctx structure and
+*    CpaCySymSession. It is the first function called in MD5
+*    digest routine sequence and return 1 if successful
+******************************************************************************/
+static int qat_md5_init(EVP_MD_CTX * ctx)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_init(ctx);    
+}
+
+/******************************************************************************
+* function:
+*         qat_md5_update(EVP_MD_CTX *ctx,
+*                        const void *data,
+*                        size_t count)
+*
+* @param ctx   [IN] - pointer to sha ctx
+* @param data  [IN] - pointer to chunks of inputdata
+* @param count [IN] - message Length To Hash In Bytes
+*
+* description:
+*    This function is rewrite of md5_update() in OpenSSL
+*    The function will be called repeatedly with chunks of target message to
+*    be hashed before it pass to cpaCyRsaDecrypt() function.
+*    It is the second function called in MD5 digest routine sequence
+*    and return 1 if successful
+******************************************************************************/
+static int qat_md5_update(EVP_MD_CTX * ctx, const void *data, size_t count)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_update(ctx,data,count); 
+}
+
+/******************************************************************************
+* function:
+*         qat_md5_copy(EVP_MD_CTX *ctx_out,
+*                        const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* description:
+*    This function copies a context and creates a new session
+*    to be associated with this context.  All buffers are also
+*    copied.
+******************************************************************************/
+static int qat_md5_copy (EVP_MD_CTX *ctx_out, const EVP_MD_CTX *ctx_in)
+{
+    int sts = 1;
+   
+    if(ctx_in->md_data != NULL)
+    {    
+        memset(ctx_out->md_data,0x00, sizeof(qat_ctx));
+    }    
+    
+    sts = qat_md5_init (ctx_out);
+
+    if (sts != 1)
+        return sts;
+
+    sts = qat_digest_context_copy (ctx_out, ctx_in);
+  
+    return sts;
+}
+
+/******************************************************************************
+* function:
+*          qat_md5_final(EVP_MD_CTX *ctx,
+*                        unsigned char *md)
+*
+* @param ctx [IN] - pointer to sha ctx
+* @param md [OUT] - digest message output
+*
+* description:
+*    This function is the rewrite of OpenSSL md5_final() function.
+*    It places the digested message in md.
+*    The third function called in MD5 digest routine sequence
+*    and return 1 if successful
+******************************************************************************/
+static int qat_md5_final(EVP_MD_CTX * ctx, unsigned char *md)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return digest_final(ctx,md);
+}
+
+/******************************************************************************
+* function:
+*   int digest_cleanup(EVP_MD_CTX *ctx)
+*
+* @param ctx [IN] - pointer to sha ctx
+*
+* description:
+*     This function is the rewrite of OpenSSL digest xxx_cleanup() function.
+*     It design to set digested message in ctx to zeros if there is still values in it.
+*     The last function called in the digest routine sequence
+*     and return 1 if successful
+******************************************************************************/
+static int digest_cleanup(EVP_MD_CTX * ctx)
+{
+    qat_ctx *qat_context = NULL;
+
+    qat_buffer *buff = NULL;
+    qat_buffer *buff_next = NULL;
+
+    if (!ctx)
+    {
+        WARN("[%s] --- ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    DEBUG("%s: been called !\n", __func__);
+
+    if (ctx->md_data == NULL)
+    {
+        DEBUG ("[%s] --- qat_context not allocated.\n", __func__);
+        return 1;
+    }
+
+    qat_context = (qat_ctx *) (ctx->md_data);
+
+    /*
+     * After a ctx has been copied the old context may not call final, but
+     * just clean. So we must check that the buffer count is 0. If not we 
+     * must have buffers to free.       
+    */    
+   if(qat_context->buff_count != 0)
+    {
+        int i;
+    
+        buff = qat_context->first;
+   
+        for (i = 0; i < qat_context->buff_count; i++)
+        {
+            qaeMemFree (buff->data);
+            buff_next = buff->next;
+            OPENSSL_free (buff);
+            buff = buff_next;
+        }
+    }
+ 
+    qat_context->first = NULL;
+    qat_context->last = NULL;
+    qat_context->buff_count = 0;
+    qat_context->buff_total = 0;
+    qat_context->init =0;   
+ 
+    return 1;
+
+}
+
+/******************************************************************************
+* function:
+*         qat_alloc_pad(unsigned char *in,
+*                       int len,
+*                       int rLen,
+*                       int sign)
+*
+* @param in   [IN] - pointer to Flat Buffer
+* @param len  [IN] - length of input data (hash)
+* @param rLen [IN] - length of RSA
+* @param sign [IN] - 1 for sign operation and 0 for decryption
+*
+* description:
+*   This function is used to add PKCS#1 padding into input data buffer
+*   before it pass to cpaCyRsaDecrypt() function.
+*   The function returns a pointer to unsigned char buffer
+******************************************************************************/
+static unsigned char *qat_alloc_pad(unsigned char *in, int len,
+                                    int rLen, int sign)
+{
+    int i = 0;
+ 
+    /* out data buffer should have fix length */
+    unsigned char *out = qaeMemAlloc(rLen, __FILE__, __LINE__);
+ 
+    if (out == NULL)
+    {
+        WARN("[%s] --- out buffer malloc failed.\n", __func__);
+        return NULL;
+    }
+ 
+    /* First two char are 0x00, 0x01 */
+    out[0] = 0;
+ 
+    if(sign)
+    {
+        out[1] = 1;
+    }
+    else
+    {
+        out[1] = 2;
+    }
+ 
+    /* Fill 0xff and end up with 0x00 in out buffer until the length of
+       actual data space left */
+    for (i = 2; i < (rLen - len - 1); i++)
+    {
+        out[i] = 0xff;
+        out[i + 1] = 0x00;
+    }
+ 
+    /* shift actual data to the end of out buffer */
+    memcpy((out + rLen - len), in, len);
+ 
+    return out;
+}
+
+/******************************************************************************
+* function:
+*         qat_remove_pad(unsigned char *in,
+*                        int len,
+*                        int rLen,
+*                        int sign)
+*
+* @param in   [IN] - pointer to Flat Buffer
+* @param len  [IN] - length of output buffer
+* @param rLen [IN] - length of RSA
+* @param sign [IN] - 1 for sign operation and 0 for decryption
+*
+* description:
+*   This function is used to remove PKCS#1 padding from outputBuffer
+*   after cpaCyRsaEncrypt() function during RSA verify.
+*   The function returns a unsigned char buffer pointer.
+******************************************************************************/
+static int qat_remove_pad(unsigned char *out, unsigned char *in, int len,
+                          int rLen, int sign)
+{
+    int i = 0;
+    int dLen = 0;
+    int pLen = 0;
+ 
+    if (sign)
+    {
+        /* First two char of padding should be 0x00, 0x01 for signing*/
+        if(in[0] != 0x00 || in[1] != 0x01)
+        {
+            WARN("[%s] --- Padding format unknown!", __func__);
+            return 1; // 1 is error condition
+        }
+    }
+    else
+    {
+        /* First two char of padding should be 0x00, 0x02 for decryption */
+        if(in[0] != 0x00 || in[1] != 0x02)
+        {
+            WARN("[%s] --- Padding format unknown!", __func__);
+            return 1;
+        }
+    }
+ 
+    /* While loop is design to reach the 0x00 value and count all the 0xFF
+       value where filled by PKCS#1 padding */
+    while (in[i + 2] != 0x00 && i < rLen)
+           i++;
+ 
+    /* padding length = 0x00 + 0x01 + length of 0xFF + 0x00 */
+    pLen = 2 + i + 1;
+    /* Actual data length = 128 - padding length */
+    dLen = rLen - pLen;
+ 
+    /* shift actual data to the beginning of out buffer */
+    memcpy(out, in + pLen, len);
+ 
+    return 0;
+}
+
+/******************************************************************************
+* function:
+*         qat_data_len(unsigned char *in
+*                      int  rLen, int sign)
+*
+* @param in   [IN] - pointer to Flat Buffer
+* @param rLen [IN] - length of RSA
+* @param sign [IN] - 1 for sign operation and 0 for decryption
+*
+* description:
+*   This function is used to calculate the length of actual data
+*   and padding size inside of outputBuffer returned from cpaCyRsaEncrypt() function.
+*   The function counts the padding length (i) and return the length
+*   of actual data (dLen) contained in the outputBuffer
+******************************************************************************/
+static int qat_data_len(unsigned char *in, int rLen, int sign)
+{
+    /* first two bytes are 0x00, 0x01 */
+    int i = 0;
+    int dLen = 0;
+    int pLen = 0;
+ 
+    /* First two char of padding should be 0x00, 0x01 */
+    if(sign)
+    {
+        /* First two char of padding should be 0x00, 0x01 */
+        if(in[0] != 0x00 || in[1] != 0x01)
+        {
+            WARN("[%s] --- Padding format unknow!\n", __func__);
+            return 0;
+        }
+    }
+    else
+    {
+        /* First two char of padding should be 0x00, 0x02 for decryption */
+        if(in[0] != 0x00 || in[1] != 0x02)
+        {
+            WARN("[%s] --- Pading format unknown!", __func__);
+            return 0;
+        }
+    }
+ 
+    /* while loop is design to reach the 0x00 value and count all the 0xFF
+       value where filled by PKCS#1 padding */
+    while (in[i + 2] != 0x00 && i < rLen)
+           i++;
+ 
+    /* padding length = 2 + length of 0xFF + 0x00 */
+    pLen = 2 + i + 1;
+    /* data length = 128 - padding length */
+    dLen = rLen - pLen;
+ 
+    return dLen;
+}
+
+/******************************************************************************
+* function:
+*         qat_BN_to_FB(CpaFlatBuffer *fb,
+*                      BIGNUM *bn)
+*
+* @param fb [IN] - API flatbuffer structure pointer
+* @param bn [IN] - Big Number pointer
+*
+* description:
+*   This function is used to transform the big number format to the flat buffer
+*   format. The function is used to deliver the RSA Public/Private key structure
+*   from OpenSSL layer to API layer.
+******************************************************************************/
+static void qat_BN_to_FB(CpaFlatBuffer * fb, BIGNUM * bn)
+{
+
+    /* Memory allocate for flat buffer */
+    fb->dataLenInBytes = (Cpa32U) BN_num_bytes(bn);
+    fb->pData = qaePinnedMemAlloc (fb->dataLenInBytes);
+    if (fb->pData == NULL)
+    {
+        WARN("[%s] --- FlatBuffer pData malloc failed.\n", __func__);
+        return;
+    }
+    /* BN_bn2in() converts the absolute value of big number into big-endian
+       form and stores it at output buffer. the output buffer must point to
+       BN_num_bytes of memory */
+    BN_bn2bin(bn, fb->pData);
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_priv_enc (int flen,
+*                           const unsigned char *from,
+*                           unsigned char *to,
+*                           RSA *rsa,
+*                           int padding)
+*
+* @param flen    [IN]  - length in bytes of input file (hash value)
+* @param from    [IN]  - pointer to the input file
+* @param to      [OUT] - pointer to output signature
+* @param rsa     [IN]  - pointer to private key structure
+* @param padding [IN]  - Padding scheme
+*
+* description:
+*   This function is rewrite of OpenSSL RSA_priv_enc() function for RSA sign process.
+*   All the inputs are pass form the above OpenSSL layer to the corresponding API
+*   RSA sign function cpaCyRsaDecrypt().
+*   The function returns the RSA signature output.
+******************************************************************************/
+static int
+qat_rsa_priv_enc(int flen, const unsigned char *from, unsigned char *to,
+                 RSA * rsa, int padding)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    int outputLen = 0;
+    int rsaLen = 0;
+    CpaCyRsaPrivateKey cpaPrvKey;
+    CpaCyRsaDecryptOpData *DecOpData = NULL;
+    CpaFlatBuffer *outputBuffer = NULL;
+    CpaStatus sts = 1;
+    struct op_done opDone;
+    CpaInstanceHandle instanceHandle;
+
+    memset(&cpaPrvKey, 0, sizeof(CpaCyRsaPrivateKey));
+
+    DEBUG("[%s] --- flen =%d, padding = %d \n", __func__, flen, padding);
+    rsaLen = RSA_size(rsa);
+    /* output signature should have same length as RSA(128) */
+    outputLen = rsaLen;
+
+    /* Padding check */
+    if (padding != RSA_PKCS1_PADDING)
+    {
+        DEBUG("[%s] --- Unknown Padding!", __func__);
+        goto exit;
+    }
+
+    /* Input data length check */
+    /* The input message length should less than RSA size(128) and also have
+       minimum space of PKCS1 padding(4 bytes) */
+    if (flen > (rsaLen - 4) || flen == 0)
+    {
+        DEBUG("[%s] --- The input file length error !\n", __func__);
+        goto exit;
+    }
+
+    /* output and input data MUST allocate memory for sign process */
+
+    /* memory allocation for DecOpdata[IN] */
+    DecOpData =
+        (CpaCyRsaDecryptOpData *) qaePinnedMemAlloc (sizeof(CpaCyRsaDecryptOpData));
+    if (DecOpData == NULL)
+    {
+        WARN("[%s] --- OpData malloc failed!\n", __func__);
+        goto exit;
+    }
+    memset(DecOpData, 0, sizeof(CpaCyRsaDecryptOpData));
+
+    cpaPrvKey.version = CPA_CY_RSA_VERSION_TWO_PRIME;
+
+    /* Setup the private key rep type 2 structure */
+    cpaPrvKey.privateKeyRepType = CPA_CY_RSA_PRIVATE_KEY_REP_TYPE_2;
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.prime1P, rsa->p);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.prime2Q, rsa->q);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.exponent1Dp, rsa->dmp1);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.exponent2Dq, rsa->dmq1);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.coefficientQInv, rsa->iqmp);
+
+    /* Setup the DecOpData structure */
+    DecOpData->pRecipientPrivateKey = &cpaPrvKey;
+    DecOpData->inputData.dataLenInBytes = rsaLen;
+    DecOpData->inputData.pData = qat_alloc_pad((Cpa8U *) from, flen, rsaLen, 1);
+    if (DecOpData->inputData.pData == NULL)
+    {
+        WARN("[%s] --- InputData malloc failed!\n", __func__);
+        goto exit;
+    }
+
+    /* Memory allocation for DecOpdata[IN] the size of outputBuffer should big
+       enough to contain RSA_size */
+    outputBuffer = (CpaFlatBuffer *) qaePinnedMemAlloc (rsaLen);
+    if (outputBuffer == NULL)
+    {
+        WARN("[%s] --- OutputBuffer malloc failed!\n", __func__);
+        goto exit;
+    }
+
+    if (zero_copy_memory_mode)
+    {
+        /* Assign outputBuffer to output pointer */
+        outputBuffer->pData = (Cpa8U *) to;
+        outputBuffer->dataLenInBytes = rsaLen;
+    }
+    else
+    {
+        outputBuffer->pData = (Cpa8U *) qaePinnedMemAlloc (rsaLen);
+        outputBuffer->dataLenInBytes = rsaLen;
+    }
+
+    initOpDone(&opDone);
+
+    instanceHandle = get_next_inst();
+
+    /* cpaCyRsaDecrypt() is the function called for RSA verify in API, the
+       DecOpData [IN] contains both private key value and input file (hash)
+       value, the outputBuffer [OUT] stores the signature as the output
+       message, the sts value return 0 if successful */
+    do
+    {
+        sts = cpaCyRsaDecrypt(instanceHandle, qat_rsaCallbackFn, &opDone,
+                              DecOpData, outputBuffer);
+        if (sts == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+            pthread_yield();
+        }
+    }
+    while (sts == CPA_STATUS_RETRY);
+    if (sts != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaDecrypt failed, sts=%d.\n", __func__, sts);
+        goto exit;
+    }
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+
+  exit:
+
+    /* Free all the memory allocated in this function */
+    if (DecOpData->inputData.pData)
+        qaeMemFree (DecOpData->inputData.pData);
+
+    if (cpaPrvKey.privateKeyRep2.prime1P.pData)
+        qaeMemFree (cpaPrvKey.privateKeyRep2.prime1P.pData);
+
+    if (cpaPrvKey.privateKeyRep2.prime2Q.pData)
+        qaeMemFree (cpaPrvKey.privateKeyRep2.prime2Q.pData);
+
+    if (cpaPrvKey.privateKeyRep2.exponent1Dp.pData)
+        qaeMemFree (cpaPrvKey.privateKeyRep2.exponent1Dp.pData);
+
+    if (cpaPrvKey.privateKeyRep2.exponent2Dq.pData)
+        qaeMemFree (cpaPrvKey.privateKeyRep2.exponent2Dq.pData);
+
+    if (cpaPrvKey.privateKeyRep2.coefficientQInv.pData)
+        qaeMemFree (cpaPrvKey.privateKeyRep2.coefficientQInv.pData);
+
+    if (DecOpData)
+        qaeMemFree (DecOpData);
+
+    if (!zero_copy_memory_mode)
+        copyFreePinnedMemory (to, outputBuffer->pData, rsaLen);
+
+    if (outputBuffer)
+        qaeMemFree (outputBuffer);
+
+    if (sts)
+    {
+        /* set output all 0xff if failed */
+        DEBUG("[%s] --- cpaCyRsaDecrypt failed! \n", __func__);
+        memset(to, 0xff, rsaLen);
+    }
+    else
+        DEBUG("[%s] --- cpaCyRsaDecrypt finished! \n", __func__);
+
+    /* Return 128 bytes message buffer */
+    return outputLen;
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_priv_dec(int flen, const unsigned char *from,
+*                          unsigned char *to, RSA * rsa, int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA rsa_priv_dec() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+static int qat_rsa_priv_dec(int flen, const unsigned char *from,
+                            unsigned char *to, RSA * rsa, int padding)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    int dataLen = 0;
+    int rsaLen = 0;
+    CpaCyRsaPrivateKey cpaPrvKey;
+    CpaCyRsaDecryptOpData *DecOpData = NULL;
+    CpaFlatBuffer *outputBuffer = NULL;
+    CpaStatus sts = 1;
+    struct op_done opDone;
+    CpaInstanceHandle instanceHandle;
+ 
+    memset(&cpaPrvKey, 0, sizeof(CpaCyRsaPrivateKey));
+ 
+    DEBUG("[%s] --- flen =%d, padding = %d \n", __func__, flen, padding);
+    rsaLen = RSA_size(rsa);
+ 
+    /* Padding check */
+    if (padding != 1)
+    {
+        DEBUG("[%s] --- Unknown Padding!", __func__);
+        goto exit;
+    }
+ 
+    /* output and input data MUST allocate memory for decryption process */
+ 
+    /* memory allocation for DecOpdata[IN] */
+    DecOpData =
+        (CpaCyRsaDecryptOpData *)
+            qaeMemAlloc(sizeof(CpaCyRsaDecryptOpData), __FILE__, __LINE__);
+    if (DecOpData == NULL)
+    {
+        WARN("[%s] --- OpData malloc failed!\n", __func__);
+        goto exit;
+    }
+    memset(DecOpData, 0, sizeof(CpaCyRsaDecryptOpData));
+ 
+    cpaPrvKey.version = CPA_CY_RSA_VERSION_TWO_PRIME;
+ 
+    /* Setup the private key rep type 2 structure */
+    cpaPrvKey.privateKeyRepType = CPA_CY_RSA_PRIVATE_KEY_REP_TYPE_2;
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.prime1P, rsa->p);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.prime2Q, rsa->q);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.exponent1Dp, rsa->dmp1);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.exponent2Dq, rsa->dmq1);
+    qat_BN_to_FB(&cpaPrvKey.privateKeyRep2.coefficientQInv, rsa->iqmp);
+
+    /* Setup the DecOpData structure */
+    DecOpData->pRecipientPrivateKey = &cpaPrvKey;
+    DecOpData->inputData.dataLenInBytes = flen;
+    DecOpData->inputData.pData =
+        (Cpa8U *)qaeMemAlloc(flen, __FILE__, __LINE__);
+    if (DecOpData->inputData.pData == NULL)
+    {
+        WARN("[%s] --- InputData malloc failed!\n", __func__);
+        goto exit;
+    }
+    memcpy(DecOpData->inputData.pData, from, flen);
+ 
+    /* Memory allocation for DecOpdata[IN] the size of outputBuffer should
+       big enough to contain RSA_size */
+    outputBuffer = (CpaFlatBuffer *) qaeMemAlloc(sizeof(CpaFlatBuffer), __FILE__, __LINE__);
+    if (outputBuffer == NULL)
+    {
+        WARN("[%s] --- OutputBuffer malloc failed!\n", __func__);
+        goto exit;
+    }
+ 
+    /* Assign outputBuffer to output pointer */
+    //outputBuffer->pData = (Cpa8U *) to;
+    outputBuffer->pData = qaeMemAlloc(rsaLen, __FILE__, __LINE__);
+    if(outputBuffer->pData == NULL)
+    {
+        WARN("[%s] ---Output buffer allocation failed!\n", __func__);
+        goto exit;
+    }
+ 
+    outputBuffer->dataLenInBytes = rsaLen;
+ 
+    initOpDone(&opDone);
+ 
+    instanceHandle = get_next_inst();
+ 
+    /* cpaCyRsaDecrypt() is the function called for RSA verify in API, the
+       DecOpData [IN] contains both private key value and input file (hash)
+       value, the outputBuffer [OUT] stores the signature as the output
+       message, the sts value return 0 if successful */
+    if ((sts =
+         cpaCyRsaDecrypt(instanceHandle, qat_rsaCallbackFn, &opDone,
+                         DecOpData, outputBuffer)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaDecrypt failed, sts=%d.\n", __func__,
+              sts);
+        goto exit;
+    } 
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+ 
+    //Copy output to output buffer
+    dataLen = qat_data_len(outputBuffer->pData, rsaLen, 0);
+    if(qat_remove_pad(to, outputBuffer->pData, dataLen, rsaLen, 0) != 0)
+    {
+        WARN("[%s] --- pData remove padding detected, go to exit!\n",
+              __func__);
+        sts = 0;
+        goto exit;
+    }
+      
+    exit:
+    /* Free all the memory allocated in this function */
+    if (DecOpData->inputData.pData)
+        qaeMemFree(DecOpData->inputData.pData);
+ 
+    if (outputBuffer->pData)
+        qaeMemFree(outputBuffer->pData);
+ 
+    if (cpaPrvKey.privateKeyRep2.prime1P.pData)
+        qaeMemFree(cpaPrvKey.privateKeyRep2.prime1P.pData);
+ 
+    if (cpaPrvKey.privateKeyRep2.prime2Q.pData)
+        qaeMemFree(cpaPrvKey.privateKeyRep2.prime2Q.pData);
+ 
+    if (cpaPrvKey.privateKeyRep2.exponent1Dp.pData)
+        qaeMemFree(cpaPrvKey.privateKeyRep2.exponent1Dp.pData);
+ 
+    if (cpaPrvKey.privateKeyRep2.exponent2Dq.pData)
+        qaeMemFree(cpaPrvKey.privateKeyRep2.exponent2Dq.pData);
+ 
+    if (cpaPrvKey.privateKeyRep2.coefficientQInv.pData)
+        qaeMemFree(cpaPrvKey.privateKeyRep2.coefficientQInv.pData);
+ 
+    if (DecOpData)
+        qaeMemFree(DecOpData);
+ 
+    if (outputBuffer)
+        qaeMemFree(outputBuffer);
+ 
+    if (sts)
+    {
+        /* set output all 0xff if failed */
+        DEBUG("[%s] --- cpaCyRsaDecrypt failed! \n", __func__);
+        memset(to, 0xff, rsaLen);
+    }
+    else
+        DEBUG("[%s] --- cpaCyRsaDecrypt finished! \n", __func__);
+ 
+    return dataLen;
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_mod_exp(BIGNUM * r0, const BIGNUM * I, RSA * rsa,
+*                         BN_CTX * ctx)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA rsa_mod_exp() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+static int qat_rsa_mod_exp(BIGNUM * r0, const BIGNUM * I, RSA * rsa,
+                           BN_CTX * ctx)
+{
+    openssl_rsa_method = RSA_get_default_method();
+
+    return openssl_rsa_method->rsa_mod_exp(r0, I, rsa, ctx);
+}
+
+/******************************************************************************
+* function:
+*         qat_bn_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+*                        const BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA rsa_bn_mod_exp() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+static int qat_bn_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+                          const BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx)
+{
+    openssl_rsa_method = RSA_get_default_method();
+
+    return openssl_rsa_method->bn_mod_exp(r, a, p, m, ctx, m_ctx);
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_pub_enc(int flen,const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA qat_rsa_pub_enc() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+static int qat_rsa_pub_enc(int flen, const unsigned char *from,
+                           unsigned char *to, RSA * rsa, int padding)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+    int rsaLen = 0;
+ 
+    CpaCyRsaPublicKey cpaPubKey;
+    CpaCyRsaEncryptOpData *EncOpData = NULL;
+    CpaFlatBuffer *outputBuffer = NULL;
+    CpaStatus sts = 1;
+    struct op_done opDone;
+    unsigned char *pad_removed = NULL;
+    CpaInstanceHandle instanceHandle;
+
+    memset(&cpaPubKey, 0, sizeof(CpaCyRsaPublicKey));
+ 
+    rsaLen = RSA_size(rsa);
+ 
+    if (padding != 1)
+    {
+        WARN("[%s] --- Unknown Padding!", __func__);
+        goto exit;
+    }
+ 
+    DEBUG("[%s] --- flen=%d padding=%d\n", __func__, flen, padding);
+ 
+    /* Output and input data MUST allocate memory for RSA verify process */
+    /* Memory allocation for EncOpData[IN] */
+    EncOpData =
+        (CpaCyRsaEncryptOpData *)
+            qaeMemAlloc(sizeof(CpaCyRsaEncryptOpData), __FILE__, __LINE__);
+    if (EncOpData == NULL)
+    {
+        WARN("[%s] --- OpData malloc failed!\n", __func__);
+        goto exit;
+    }
+    /* Passing Public key from big number format to big endian order binary */
+    qat_BN_to_FB(&cpaPubKey.modulusN, rsa->n);
+    qat_BN_to_FB(&cpaPubKey.publicExponentE, rsa->e);
+ 
+    /* Setup the Encrypt operation Data structure */
+    EncOpData->pPublicKey = &cpaPubKey;
+    if(flen > rsaLen - 11)
+    {
+        WARN("[%s] --- Message Invalid!", __func__);
+        goto exit;
+    }
+ 
+    EncOpData->inputData.dataLenInBytes = rsaLen;
+    EncOpData->inputData.pData = qat_alloc_pad((Cpa8U *) from, flen, rsaLen, 0);
+    if(NULL == EncOpData->inputData.pData)
+    {
+        WARN("[%s] --- Padding failed!", __func__);
+        goto exit;
+    }     
+ 
+    /* Memory allocation for outputBuffer[OUT] OutputBuffer size initialize
+       as the size of rsa size */
+    outputBuffer = (CpaFlatBuffer *) qaeMemAlloc(RSA_size(rsa), __FILE__, __LINE__);
+    if (NULL == outputBuffer)
+    {
+        WARN("[%s] --- OutputBuffer malloc failed!\n", __func__);
+        goto exit;
+    }
+ 
+    /* outputBuffer size should large enough to hold the Hash value but
+       smaller than (RSA_size(rsa)-11) */
+    outputBuffer->dataLenInBytes = rsaLen;
+    outputBuffer->pData = qaeMemAlloc(rsaLen, __FILE__, __LINE__);
+    if (NULL == outputBuffer->pData)
+    {
+        WARN("[%s] --- OutputBuffer pData malloc failed!\n", __func__);
+        goto exit;
+    }
+ 
+    initOpDone(&opDone);
+ 
+    instanceHandle = get_next_inst();
+ 
+    /* The cpaCyRsaEncrypt() is the function called for RSA verify in API,
+       the EnOpData [IN] contains both public key values and input
+       signature values, the outputBuffer [OUT] stores the recovered digest
+       as the output message, sts value return 0 if successful */
+    if ((sts =
+         cpaCyRsaEncrypt(instanceHandle, qat_rsaCallbackFn, &opDone,
+                         EncOpData, outputBuffer)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaEncrypt failed sts=%d.\n", __func__,
+              sts);
+        goto exit;
+    }
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+ 
+    /* memory copy outputBuffer to to pointer where used for OpenSSL output
+     */
+    memcpy(to, outputBuffer->pData, outputBuffer->dataLenInBytes);
+ 
+    exit:
+    /* Free all the memory allocated in this function */
+    if (EncOpData)
+        qaeMemFree(EncOpData);
+    if (outputBuffer->pData)
+        qaeMemFree(outputBuffer->pData);
+    if (pad_removed)
+        qaeMemFree(pad_removed);
+    if (outputBuffer)
+        qaeMemFree(outputBuffer);
+    if (cpaPubKey.modulusN.pData)
+        qaeMemFree(cpaPubKey.modulusN.pData);
+    if (cpaPubKey.modulusN.pData)
+        qaeMemFree(cpaPubKey.publicExponentE.pData);
+ 
+    /* setup output buffer if failed */
+    if (sts)
+    {
+        /* set output all 0xff if failed */
+        DEBUG("[%s] --- cpaCyRsaEncrypt failed! \n", __func__);
+        memset(to, 0xff, rsaLen);
+        return rsaLen;
+    }
+    else
+    {
+        DEBUG("[%s] --- cpaCyRsaEncrypt finished! \n", __func__);
+ 
+        /* return outputLen bytes message buffer */
+        return rsaLen;
+    }
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_pub_dec(int flen,
+*                         const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,
+*                         int padding)
+*
+* @param flen    [IN]  - size in bytes of input signature
+* @param from    [IN]  - pointer to the signature file
+* @param to      [OUT] - pointer to output data
+* @param rsa     [IN]  - pointer to public key structure
+* @param padding [IN]  - Padding scheme
+*
+* description:
+*   This function is rewrite of OpenSSL RSA_pub_dec() function for RSA verify process.
+*   All the inputs are pass form the above OpenSSL layer to the corresponding API
+*   RSA verify function cpaCyRsaEncrypt().
+*   The function returns the RSA recovered message output.
+******************************************************************************/
+static int
+qat_rsa_pub_dec(int flen, const unsigned char *from, unsigned char *to,
+                RSA * rsa, int padding)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+    int outputLen = 0;
+    int rsaLen = 0;
+
+    CpaCyRsaPublicKey cpaPubKey;
+    CpaCyRsaEncryptOpData *EncOpData = NULL;
+    CpaFlatBuffer *outputBuffer = NULL;
+    CpaStatus sts = 1;
+    struct op_done opDone;
+    unsigned char *pad_removed = NULL;
+    CpaInstanceHandle instanceHandle;
+
+    memset(&cpaPubKey, 0, sizeof(CpaCyRsaPublicKey));
+
+    rsaLen = RSA_size(rsa);
+
+    if (padding != RSA_PKCS1_PADDING)
+    {
+        WARN("[%s] --- Unknown Padding!", __func__);
+        goto exit;
+    }
+
+    if (flen != rsaLen)
+    { 
+        WARN("[%s] --- The length of input signature incorrect! \n", __func__);
+        goto exit;
+    }
+
+    DEBUG("[%s] --- flen=%d padding=%d\n", __func__, flen, padding);
+
+    /* Output and input data MUST allocate memory for RSA verify process */
+    /* Memory allocation for EncOpData[IN] */
+    EncOpData =
+        (CpaCyRsaEncryptOpData *) qaePinnedMemAlloc (sizeof(CpaCyRsaEncryptOpData));
+    if (EncOpData == NULL)
+    {
+        WARN("[%s] --- OpData malloc failed!\n", __func__);
+        goto exit;
+    }
+    /* Passing Public key from big number format to big endian order binary */
+    qat_BN_to_FB(&cpaPubKey.modulusN, rsa->n);
+    qat_BN_to_FB(&cpaPubKey.publicExponentE, rsa->e);
+
+    /* Setup the Encrypt operation Data structure */
+    EncOpData->pPublicKey = &cpaPubKey;
+
+    if (zero_copy_memory_mode)
+    {
+        EncOpData->inputData.dataLenInBytes = flen;
+        EncOpData->inputData.pData = (Cpa8U *) from;
+    }
+    else
+    {
+        EncOpData->inputData.dataLenInBytes = flen;
+        EncOpData->inputData.pData = (Cpa8U *) copyAllocPinnedMemory ((void*) from, flen);
+    }
+
+    /* Memory allocation for outputBuffer[OUT] OutputBuffer size initialize as
+       the size of rsa size */
+    outputBuffer = (CpaFlatBuffer *) qaePinnedMemAlloc (RSA_size(rsa));
+    if (outputBuffer == NULL)
+    {
+        WARN("[%s] --- OutputBuffer malloc failed!\n", __func__);
+        goto exit;
+    }
+
+    /* outputBuffer size should large enough to hold the Hash value but smaller 
+       than (RSA_size(rsa)-11) */
+    outputBuffer->dataLenInBytes = rsaLen;
+    outputBuffer->pData = qaePinnedMemAlloc (rsaLen);
+    if (outputBuffer->pData == NULL)
+    {
+        WARN("[%s] --- OutputBuffer pData malloc failed!\n", __func__);
+        goto exit;
+    }
+
+    initOpDone(&opDone);
+
+    instanceHandle = get_next_inst();
+
+    /* The cpaCyRsaEncrypt() is the function called for RSA verify in API, the
+       EnOpData [IN] contains both public key values and input signature
+       values, the outputBuffer [OUT] stores the recovered digest as the output 
+       message, sts value return 0 if successful */
+    do
+    {
+        sts = cpaCyRsaEncrypt(instanceHandle, qat_rsaCallbackFn, &opDone,
+                              EncOpData, outputBuffer);
+        if (sts == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+            pthread_yield();
+        }
+    }
+    while (sts == CPA_STATUS_RETRY);
+    if (sts != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaEncrypt failed, sts=%d.\n", __func__, sts);
+        goto exit;
+    }
+    waitForOpToComplete(&opDone);
+    cleanupOpDone(&opDone);
+
+    outputLen = qat_data_len(outputBuffer->pData, rsaLen, 1);
+    if (outputLen == 0)
+    {
+        WARN("[%s] --- Unknown padding detected, go to exit!\n", __func__);
+        sts = 0;
+        goto exit;
+    }
+    /* remove the padding from outputBuffer */
+    /* only RSA_PKCS1_PADDING scheme supported by qat engine */
+    if (qat_remove_pad(to, outputBuffer->pData, outputBuffer->dataLenInBytes,
+                       rsaLen, 1) != 0)
+    {
+        WARN("[%s] --- pData remove padding detected, go to exit!\n", __func__);
+        sts = 0;
+        goto exit;
+    }
+
+    exit:
+
+    /* Free all the memory allocated in this function */
+    if (!zero_copy_memory_mode)
+        qaeMemFree (EncOpData->inputData.pData);
+    if (EncOpData)
+        qaeMemFree (EncOpData);
+    if (outputBuffer->pData)
+        qaeMemFree (outputBuffer->pData);
+    if (pad_removed)
+        qaeMemFree (pad_removed);
+
+    if (outputBuffer)
+        qaeMemFree (outputBuffer);
+    if (cpaPubKey.modulusN.pData)
+        qaeMemFree (cpaPubKey.modulusN.pData);
+    if (cpaPubKey.modulusN.pData)
+        qaeMemFree (cpaPubKey.publicExponentE.pData);
+
+    /* setup output buffer if failed */
+    if (sts)
+    {
+        /* set output all 0xff if failed */
+        DEBUG("[%s] --- cpaCyRsaEncrypt failed! \n", __func__);
+        memset(to, 0xff, rsaLen);
+        return rsaLen;
+    }
+    else
+    {
+        DEBUG("[%s] --- cpaCyRsaEncrypt finished! \n", __func__);
+
+        /* return outputLen bytes message buffer */
+        return outputLen;
+    }
+}
+
+/******************************************************************************
+* function:
+*         qat_dh_generate_key(DH * dh)
+*
+* description:
+*   Wrapper around the default OpenSSL DH dh_generate_key function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_dh_generate_key(DH * dh)
+{
+    DEBUG("%s been called \n", __func__);
+    openssl_dh_method = DH_OpenSSL();
+
+    return openssl_dh_method->generate_key(dh);
+}
+
+/******************************************************************************
+* function:
+*         qat_dh_compute_key(unsigned char *key,
+*                            const BIGNUM * pub_key, DH * dh)
+*
+* description:
+*   Wrapper around the default OpenSSL DH dh_compute_key function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_dh_compute_key(unsigned char *key, const BIGNUM * pub_key, DH * dh)
+{
+    DEBUG("%s been called \n", __func__);
+    openssl_dh_method = DH_OpenSSL();
+
+    return openssl_dh_method->compute_key(key, pub_key, dh);
+}
+
+/******************************************************************************
+* function:
+*         qat_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+                      const BIGNUM * m, BN_CTX * ctx)
+*
+* @param r   [IN] - Result bignum of mod_exp
+* @param a   [IN] - Base used for mod_exp
+* @param p   [IN] - Exponent used for mod_exp
+* @param m   [IN] - Modulus used for mod_exp
+* @param ctx [IN] - EVP context.
+*
+* description:
+*   Bignum modular exponentiation function used in DH and DSA.
+*
+******************************************************************************/
+static int qat_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+                       const BIGNUM * m, BN_CTX * ctx)
+{
+
+    CpaCyLnModExpOpData opData;
+    CpaFlatBuffer result = { 0, };
+    CpaStatus status = 0;
+    int retval = 1;
+    CpaInstanceHandle instanceHandle;
+
+    DEBUG("%s\n", __func__);
+    qat_BN_to_FB(&opData.base, (BIGNUM *) a);
+    qat_BN_to_FB(&opData.exponent, (BIGNUM *) p);
+    qat_BN_to_FB(&opData.modulus, (BIGNUM *) m);
+
+    result.dataLenInBytes = BN_num_bytes(m);
+    result.pData = qaePinnedMemAlloc (result.dataLenInBytes);
+    if (result.pData == NULL)
+    {
+        WARN("qaePinnedMemAlloc () failed for result.pData.\n");
+        retval = 0;
+        goto exit;
+    }
+
+    instanceHandle = get_next_inst();
+
+    do
+    {
+        status = cpaCyLnModExp(instanceHandle, NULL, NULL, &opData, &result);
+        if (status == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+            pthread_yield();
+        }
+    }
+    while (status == CPA_STATUS_RETRY);
+
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("cpaCyLnModExp failed, status=%d\n", status);
+        retval = 0;
+        goto exit;
+    }
+
+    /* Convert the flatbuffer results back to a BN */
+    BN_bin2bn(result.pData, result.dataLenInBytes, r);
+
+  exit:
+
+    if (opData.base.pData)
+        qaeMemFree (opData.base.pData);
+    if (opData.exponent.pData)
+        qaeMemFree (opData.exponent.pData);
+    if (opData.modulus.pData)
+        qaeMemFree (opData.modulus.pData);
+    if (result.pData)
+        qaeMemFree (result.pData);
+
+    return retval;
+}
+
+#if OPENSSL_VERSION_NUMBER < 0x01000000
+/*
+ * adapted from openssl-0.9.8w/fips/dsa/fips_dsa_ossl.c
+ *
+ * openssl-0.9.8w doesnt check if the engine provided DSA_METHOD doesn't
+ * have a function for dsa_mod_exp and automatically fall back to software
+ * (openssl-1.0.1c does) so we need to provide the software fall back.
+*/
+static int qat_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,
+		           BIGNUM *a2, BIGNUM *p2, BIGNUM *m, BN_CTX *ctx,
+                           BN_MONT_CTX *in_mont)
+{
+     return BN_mod_exp2_mont(rr, a1, p1, a2, p2, m, ctx, in_mont);
+}
+#endif
+/******************************************************************************
+* function:
+*         qat_mod_exp_dh(const DH * dh, BIGNUM * r, const BIGNUM * a,
+*                        const BIGNUM * p, const BIGNUM * m, BN_CTX * ctx,
+*                        BN_MONT_CTX * m_ctx)
+*
+* @param dh    [IN] - Pointer to a OpenSSL DH struct.
+* @param r     [IN] - Result bignum of mod_exp
+* @param a     [IN] - Base used for mod_exp
+* @param p     [IN] - Exponent used for mod_exp
+* @param m     [IN] - Modulus used for mod_exp
+* @param ctx   [IN] - EVP context.
+* @param m_ctx [IN] - EVP context for Montgomery multiplication.
+*
+* description:
+*   Overridden modular exponentiation function used in DH.
+*
+******************************************************************************/
+static int qat_mod_exp_dh(const DH * dh, BIGNUM * r, const BIGNUM * a,
+                          const BIGNUM * p, const BIGNUM * m, BN_CTX * ctx,
+                          BN_MONT_CTX * m_ctx)
+{
+    DEBUG("%s been called \n", __func__);
+    return qat_mod_exp(r, a, p, m, ctx);
+}
+
+/******************************************************************************
+* function:
+*         qat_mod_exp_dsa(DSA * dsa, BIGNUM * r, BIGNUM * a, const BIGNUM * p,
+                          const BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx)
+*
+* @param dsa   [IN] - Pointer to a OpenSSL DSA struct.
+* @param r     [IN] - Result bignum of mod_exp
+* @param a     [IN] - Base used for mod_exp
+* @param p     [IN] - Exponent used for mod_exp
+* @param m     [IN] - Modulus used for mod_exp
+* @param ctx   [IN] - EVP context.
+* @param m_ctx [IN] - EVP context for Montgomery multiplication.
+*
+* description:
+*   Overridden modular exponentiation function used in DSA.
+*
+******************************************************************************/
+static int qat_mod_exp_dsa(DSA * dsa, BIGNUM * r, BIGNUM * a, const BIGNUM * p,
+                           const BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx)
+{
+    DEBUG("%s been called \n", __func__);
+    return qat_mod_exp(r, a, p, m, ctx);
+
+}
+
+/******************************************************************************
+* function:
+*         qat_dsa_do_sign(const unsigned char *dgst, int dlen, DSA * dsa)
+*
+* description:
+*   Wrapper around the default OpenSSL DSA dsa_do_sign() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+DSA_SIG *qat_dsa_do_sign(const unsigned char *dgst, int dlen, DSA * dsa)
+{
+    DEBUG("%s been called \n", __func__);
+
+    openssl_dsa_method = DSA_OpenSSL();
+
+    return openssl_dsa_method->dsa_do_sign(dgst, dlen, dsa);
+}
+
+/******************************************************************************
+* function:
+*         qat_dsa_sign_setup(DSA * dsa, BN_CTX * ctx_in, BIGNUM ** kinvp,
+*                            BIGNUM ** rp)
+*
+* description:
+*   Wrapper around the default OpenSSL DSA dsa_sign_setup() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_dsa_sign_setup(DSA * dsa, BN_CTX * ctx_in, BIGNUM ** kinvp,
+                       BIGNUM ** rp)
+{
+    DEBUG("%s been called \n", __func__);
+    openssl_dsa_method = DSA_OpenSSL();
+
+    return openssl_dsa_method->dsa_sign_setup(dsa, ctx_in, kinvp, rp);
+}
+
+/******************************************************************************
+* function:
+*         qat_dsa_do_verify(const unsigned char *dgst, int dgst_len,
+*                           DSA_SIG * sig, DSA * dsa)
+*
+* description:
+*   Wrapper around the default OpenSSL DSA dsa_do_verify() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+static int qat_dsa_do_verify(const unsigned char *dgst, int dgst_len,
+                             DSA_SIG * sig, DSA * dsa)
+{
+    DEBUG("%s been called \n", __func__);
+    openssl_dsa_method = DSA_OpenSSL();
+
+    return openssl_dsa_method->dsa_do_verify(dgst, dgst_len, sig, dsa);
+}
+
+/******************************************************************************
+* function:
+*         bind_qat(ENGINE *e,
+*                  const char *id)
+*
+* @param e  [IN] - OpenSSL engine pointer
+* @param id [IN] - engine id
+*
+* description:
+*    Connect Qat engine to OpenSSL engine library
+******************************************************************************/
+static int bind_qat(ENGINE * e, const char *id)
+{
+    int ret = 0;
+
+    DEBUG("[%s] id=%s\n", __func__, id);
+
+    if (id && strcmp(id, engine_qat_id))
+    {
+        WARN("ENGINE_id defined already!\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_id(e, engine_qat_id))
+    {
+        WARN("ENGINE_set_id failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_name(e, engine_qat_name))
+    {
+        WARN("ENGINE_set_name failed\n");
+        goto end;
+    }
+
+    /* set all the algos we are going to use. */
+    if (!ENGINE_set_DSA(e, &qat_dsa_method))
+    {
+        WARN("ENGINE_set_DSA failed\n");
+        goto end;
+    }
+    if (!ENGINE_set_RSA(e, &qat_rsa_method))
+    {
+        WARN("ENGINE_set_RSA failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_DH(e, &qat_dh_method))
+    {
+        WARN("ENGINE_set_DH failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_ciphers(e, qat_ciphers))
+    {
+        WARN("ENGINE_set_ciphers failed\n");
+        goto end;
+    }
+
+#ifndef QAT_ZERO_COPY_MODE 
+    if (!ENGINE_set_digests(e, qat_digests))
+    {
+        WARN("ENGINE_set_digests failed\n");
+        goto end;
+    }
+#endif
+
+    if (!ENGINE_set_destroy_function(e, qat_engine_destroy)
+        || !ENGINE_set_init_function(e, qat_engine_init)
+        || !ENGINE_set_finish_function(e, qat_engine_finish))
+    {
+        WARN("[%s] failed reg destroy, init or finish\n", __func__);
+
+        goto end;
+    }
+
+    if ((ret = pthread_key_create(&qatInstanceForThread, NULL)) != 0)
+    {
+        fprintf(stderr, "pthread_key_create: %s\n", strerror(ret));
+        goto end;
+    }
+    ret = 1;
+
+  end:
+
+    return ret;
+
+}
+
+#ifndef OPENSSL_NO_DYNAMIC_ENGINE
+IMPLEMENT_DYNAMIC_BIND_FN(bind_qat) IMPLEMENT_DYNAMIC_CHECK_FN()
+#endif
+
+/******************************************************************************
+* function:
+*         qat_ciphers(ENGINE *e,
+*                     const EVP_CIPHER **cipher,
+*                     const int **nids,
+*                     int nid)
+*
+* @param e      [IN] - OpenSSL engine pointer
+* @param cipher [IN] - cipher structure pointer
+* @param nids   [IN] - cipher function nids
+* @param nid    [IN] - cipher operation id
+*
+* description:
+*   Qat engine cipher operations registrar
+******************************************************************************/
+static int
+qat_ciphers(ENGINE * e, const EVP_CIPHER ** cipher, const int **nids, int nid)
+{
+
+    int ok = 1;
+
+    /* No specific cipher => return a list of supported nids ... */
+    if (!cipher)
+    {
+        *nids = qat_cipher_nids;
+        /* num ciphers supported (array/numelements -1) */
+        return (sizeof(qat_cipher_nids) / sizeof(qat_cipher_nids[0]));
+    }
+
+    switch (nid)
+    {
+        case NID_aes_256_cbc:
+            *cipher = &qat_aes_256_cbc;
+            break;
+        case NID_aes_192_cbc:
+            *cipher = &qat_aes_192_cbc;
+            break;
+        case NID_aes_128_cbc:
+            *cipher = &qat_aes_128_cbc;
+            break;
+        case NID_rc4:
+            *cipher = &qat_rc4;
+            break;
+        case NID_des_ede3_cbc:
+            *cipher = &qat_des_ede3_cbc;
+            break;
+        case NID_des_cbc:
+            *cipher = &qat_des_cbc;
+            break;
+#ifdef NID_aes_128_cbc_hmac_sha1
+        case NID_aes_128_cbc_hmac_sha1:
+            *cipher = &qat_aes_128_cbc_hmac_sha1;
+            break;
+#endif
+#ifdef NID_aes_256_cbc_hmac_sha1
+        case NID_aes_256_cbc_hmac_sha1:
+            *cipher = &qat_aes_256_cbc_hmac_sha1;
+            break;
+#endif
+        default:
+            ok = 0;
+            *cipher = NULL;
+    }
+
+    return ok;
+}
+
+/******************************************************************************
+* function:
+*         qat_digests(ENGINE *e,
+*                     const EVP_MD **digest,
+*                     const int **nids,
+*                     int nid)
+*
+* @param e      [IN] - OpenSSL engine pointer
+* @param digest [IN] - digest structure pointer
+* @param nids   [IN] - digest functions nids
+* @param nid    [IN] - digest operation id
+*
+* description:
+*   Qat engine digest operations registrar
+******************************************************************************/
+static int
+qat_digests(ENGINE * e, const EVP_MD ** digest, const int **nids, int nid)
+{
+    int ok = 1;
+
+    /* No specific cipher => return a list of supported nids ... */
+    if (!digest)
+    {
+        *nids = qat_digest_nids;
+        /* num digests supported (array/numelements -1) */
+        return (sizeof(qat_digest_nids) / sizeof(qat_digest_nids[0]));
+    }
+
+    switch (nid)
+    {
+        case NID_sha1:
+            /* printf("%s: saying we can do sha1\n", __func__); */
+            *digest = &qat_sha1;
+            break;
+        case NID_sha256:
+           /* printf("%s: saying we can do sha256\n", __func__); */
+            *digest = &qat_sha256;
+            break;
+        case NID_sha512:
+            /* printf("%s: saying we can do sha512\n", __func__); */
+            *digest = &qat_sha512;
+            break;
+        case NID_md5:
+            /* printf("%s: saying we can do md5\n", __func__); */
+            *digest = &qat_md5;
+            break;
+        default:
+            ok = 0;
+            *digest = NULL;
+    }
+
+    return ok;
+}
+
+/* initialize Qat Engine if OPENSSL_NO_DYNAMIC_ENGINE*/
+#ifdef OPENSSL_NO_DYNAMIC_ENGINE
+static ENGINE *engine_qat(void)
+{
+    DEBUG("[%s] engine_qat\n", __func__);
+
+    DEBUG("%s: About to set mem functions\n", __func__);
+
+    if (access(QAT_DEV, F_OK) != 0)
+    {
+        perror("access");
+        return NULL;
+    }
+#ifdef QAT_ZERO_COPY_MODE
+    if (!CRYPTO_set_mem_ex_functions(qaeMemAlloc, qaeMemRealloc, qaeMemFree))
+    {
+        DEBUG("%s: CRYPTO_set_mem_functions failed\n", __func__);
+        /* Don't abort. This may be tried from a few places and will only
+           succeed the first time. */
+    }
+    else
+    {
+        DEBUG("%s: CRYPTO_set_mem_functions succeeded\n", __func__);
+    }
+
+    /*  If over-riding OPENSLL_malloc then buffers
+     *  passed will already be pinned memory
+     *  so we switch to zero copy mode
+     */
+    zero_copy_memory_mode = 1;
+#endif
+
+    ENGINE *ret = ENGINE_new();
+
+    if (!ret)
+        return NULL;
+
+    if (!bind_qat(ret, engine_qat_id))
+    {
+        WARN("qat engine bind failed!\n");
+        ENGINE_free(ret);
+        return NULL;
+    }
+
+    return ret;
+}
+
+void ENGINE_load_qat(void)
+{
+    ENGINE *toadd = engine_qat();
+    int err;
+
+    DEBUG("[%s] engine_load_qat\n", __func__);
+
+    if (!toadd)
+        return;
+
+    DEBUG("[%s] engine_load_qat adding\n", __func__);
+    ENGINE_add(toadd);
+    ENGINE_free(toadd);
+    ERR_clear_error();
+}
+
+#endif
+
